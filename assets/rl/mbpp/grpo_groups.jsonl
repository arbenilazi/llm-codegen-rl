{"id": 602, "entry_point": "first_repeated_char", "codes": ["def first_repeated_char(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            return char\n        char_count[char] = 1\n    return None", "def first_repeated_char(s):\n    char_dict = {}\n    for char in s:\n        if char in char_dict:\n            return char\n        char_dict[char] = True\n    return None", "def first_repeated_char(s):\n    seen = {}\n    for char in s:\n        if char in seen:\n            return char\n        seen[char] = True\n    return None", "def first_repeated_char(s: str) -> str:\n    seen = {}\n    for char in s:\n        if char in seen:\n            return char\n        seen[char] = True\n    return ''"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 607, "entry_point": "find_literals", "codes": ["import re\n\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    return match.group(), match.start(), match.end() if match else (None, None, None)", "import re\n\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    return match.group(), match.span()[0], match.span()[1] if match else (None, None, None)", "import re\n\ndef find_literals(string, pattern):\n    match = re.search(pattern, string)\n    return (match.group(), match.span()[0], match.span()[1]) if match else (None, None, None)", "import re\n\ndef find_literals(string, pattern):\n    return [(match.start(), match.end()) for match in re.finditer(pattern, string)]", "import re\n\ndef find_literals(text, pattern):\n    return re.finditer(pattern, text)", "import re\n\ndef find_literals(pattern, text):\n    match = re.search(pattern, text)\n    return match and (match.start(), match.end()) or None", "import re\n\ndef find_literals(text, pattern):\n    return [(m.start(), m.end(), m.group()) for m in re.finditer(pattern, text)]", "import re\n\ndef find_literals(pattern, text):\n    match = re.search(pattern, text)\n    if match:\n        return (match.group(0), match.start(), match.end())\n    else:\n        return None"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 608, "entry_point": "bell_Number", "codes": ["def bell_Number(n):\n    Bell = [[0 for i in range(n + 1)] for i in range(n + 1)]\n    Bell[0][0] = 1\n\n    for i in range(1, n + 1):\n        Bell[i][0] = Bell[i - 1][i - 1]\n\n        for j in range(1, i + 1):\n            Bell[i][j] = Bell[i - 1][j - 1] + Bell[i][j - 1]\n\n    return Bell[n][0]", "def bell_Number(n):\n    table = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    table[0][0] = 1\n\n    for i in range(1, n + 1):\n        table[i][0] = table[i - 1][i - 1]\n        for j in range(1, i + 1):\n            table[i][j] = table[i - 1][j - 1] + table[i][j - 1]\n\n    return table[n][0]", "def bell_Number(n):\n    if n == 0:\n        return 1\n    Bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    Bell[0][0] = 1\n    for i in range(1, n + 1):\n        Bell[i][0] = Bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            Bell[i][j] = Bell[i - 1][j - 1] + Bell[i][j - 1]\n    return Bell[n][0]", "def bell_Number(n):\n    B = [0] * (n + 1)\n    B[0] = 1\n    for i in range(1, n + 1):\n        B[i] = 0\n        for j in range(i - 1, -1, -1):\n            B[j] += B[j - 1]\n    return B[n]", "def bell_Number(n):\n    bell = [0] * (n+1)\n    bell[0] = 1\n\n    for i in range(1, n+1):\n        bell[i] = 0\n        for j in range(i-1, -1, -1):\n            bell[j] += bell[j-1]\n\n    return bell[n]", "def bell_Number(n):\n    bell = [0] * (n + 1)\n    bell[0] = 1\n\n    for i in range(1, n + 1):\n        bell[i] = 0\n        for j in range(i, -1, -1):\n            bell[j] += bell[j - 1]\n\n    return bell[n]", "def bell_Number(n):\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i] = 0\n        for j in range(i, 0, -1):\n            bell[j] = bell[j] + bell[j - 1]\n    \n    return bell[n]", "def bell_Number(n):\n    Bell = [0] * (n+1)\n    Bell[0] = 1\n    \n    for i in range(1, n+1):\n        Bell[i] = 0\n        for j in range(i-1, -1, -1):\n            Bell[i] += Bell[j]\n    \n    return Bell[n]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 614, "entry_point": "cummulative_sum", "codes": ["def cummulative_sum(tuple_list):\n    total_sum = 0\n    for tup in tuple_list:\n        for value in tup:\n            total_sum += value\n    return total_sum", "def cummulative_sum(tuple_list):\n    total = 0\n    index = 0\n    while index < len(tuple_list):\n        total += sum(tuple_list[index])\n        index += 1\n    return total", "def cummulative_sum(tuples):\n    total_sum = 0\n    index = 0\n    while index < len(tuples):\n        total_sum += sum(tuples[index])\n        index += 1\n    return total_sum", "def cummulative_sum(tuple_list):\n    return sum(value for _, value in tuple_list)", "def cummulative_sum(tuples):\n    return sum(value for _, value in tuples)", "def cummulative_sum(tuples):\n    sums = {}\n    for key, value in tuples:\n        if key in sums:\n            sums[key] += value\n        else:\n            sums[key] = value\n    return sum(sums.values())", "def cummulative_sum(tuples):\n    total_sum = 0\n    for value in tuples:\n        total_sum += value\n    return total_sum", "def cummulative_sum(tuples):\n    stack = []\n    current_sum = 0\n    for t in tuples:\n        if t[0] == 'push':\n            stack.append(t[1])\n            current_sum += t[1]\n        elif t[0] == 'pop':\n            if stack:\n                current_sum -= stack.pop()\n    return current_sum"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 619, "entry_point": "move_num", "codes": ["def move_num(s: str) -> str:\n    return ''.join([c for c in s if not c.isdigit()] + [c for c in s if c.isdigit()])", "def move_num(s):\n    letters = [c for c in s if c.isalpha()]\n    numbers = [c for c in s if c.isdigit()]\n    return ''.join(letters + numbers)", "def move_num(s: str) -> str:\n    letters = [char for char in s if not char.isdigit()]\n    numbers = [char for char in s if char.isdigit()]\n    return ''.join(letters + numbers)", "def move_num(s):\n    return ''.join(filter(str.isdigit, s)) + ''.join(filter(str.isalpha, s))", "def move_num(s):\n    return ''.join(sorted(set(filter(str.isdigit, s))))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 623, "entry_point": "nth_nums", "codes": ["def nth_nums(nums, n):\n    return [num ** n for num in nums]", "def nth_nums(lst, n):\n    return [x ** n for x in lst]", "def nth_nums(nums, n):\n    return [x ** n for x in nums]", "def nth_nums(numbers, n):\n    return [lambda x: x**n for x in numbers]", "def nth_nums(nums, n):\n    return [lambda x: x**n for x in nums]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 627, "entry_point": "find_First_Missing", "codes": ["def find_First_Missing(nums, start, end):\n    if start > end:\n        return start\n    mid = start + (end - start) // 2\n    if nums[mid] == mid:\n        return find_First_Missing(nums, mid + 1, end)\n    else:\n        return find_First_Missing(nums, start, mid - 1)", "def find_First_Missing(nums):\n    nums.sort()\n    i = 0\n    while i < len(nums) and nums[i] == i:\n        i += 1\n    return i", "def find_First_Missing(nums):\n    n = len(nums)\n    for i in range(n):\n        while 0 <= nums[i] < n and nums[nums[i]] != nums[i]:\n            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]\n    \n    for i in range(n):\n        if nums[i] != i:\n            return i\n    \n    return n", "def find_First_Missing(arr):\n    n = len(arr)\n    if 1 not in arr:\n        return 1\n    if n == 1:\n        return 2\n    arr = [x for x in arr if x > 0]\n    if not arr:\n        return 1\n    arr = list(set(arr))\n    arr.sort()\n    for i in range(len(arr) - 1):\n        if arr[i] + 1 != arr[i + 1]:\n            return arr[i] + 1\n    return arr[-1] + 1", "def find_First_Missing(arr):\n    start = 0\n    n = len(arr)\n    while start < n:\n        if arr[start] > 0 and arr[start] <= n and arr[arr[start] - 1] != arr[start]:\n            arr[arr[start] - 1], arr[start] = arr[start], arr[arr[start] - 1]\n        else:\n            start += 1\n    for i in range(n):\n        if arr[i] != i + 1:\n            return i + 1\n    return n + 1", "def find_First_Missing(nums):\n    n = len(nums)\n    if n == 0:\n        return 1\n    \n    if 1 not in nums:\n        return 1\n    \n    nums.append(0)\n    n += 1\n    \n    for i in range(n):\n        nums[(nums[i] % n)] += n\n    \n    for i in range(1, n):\n        if nums[i] // n == 0:\n            return i\n    \n    return n"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 631, "entry_point": "replace_spaces", "codes": ["import re\n\ndef replace_spaces(s):\n    return re.sub(r' ', '_', re.sub(r'_', ' ', s))", "import re\n\ndef replace_spaces(s):\n    return re.sub(r' |_', lambda m: '_' if m.group(0) == ' ' else ' ', s)", "import re\n\ndef replace_spaces(s):\n    space_to_underscore = {' ': '_'}\n    underscore_to_space = {'_': ' '}\n    mapping = {**space_to_underscore, **underscore_to_space}\n    return re.sub('|'.join(map(re.escape, mapping.keys())), lambda m: mapping[m.group()], s)", "import re\n\ndef replace_spaces(s):\n    return re.sub(r'\\s', '_', s).replace('_', ' ')", "import re\n\ndef replace_spaces(s):\n    return re.sub(r' ', '_', s).replace('_', ' ')", "import re\n\ndef replace_spaces(s):\n    return re.sub(r'_', ' ', re.sub(r' ', '_', s))", "import re\n\ndef replace_spaces(s):\n    return re.sub(r'_', ' ', re.sub(r'\\s+', '_', s))", "import re\n\ndef replace_spaces(s):\n    return re.sub(r' ', '_', s).replace('_', ' ')"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 632, "entry_point": "move_zero", "codes": ["def move_zero(lst):\n    return list(filter(None, lst)) + [0] * lst.count(0)", "def move_zero(lst):\n    return [x for x in lst if x != 0] + [0] * lst.count(0)", "def move_zero(lst):\n    non_zeroes = [x for x in lst if x != 0]\n    zeroes = [0] * (len(lst) - len(non_zeroes))\n    return non_zeroes + zeroes", "def move_zero(arr):\n    left = 0\n    for right in range(len(arr)):\n        if arr[right] != 0:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1", "def move_zero(lst):\n    zero_indices = [i for i, x in enumerate(lst) if x == 0]\n    for i in zero_indices:\n        lst.pop(i)\n        lst.append(0)\n    return lst", "def move_zero(lst):\n    zero_indices = []\n    for i, num in enumerate(lst):\n        if num == 0:\n            zero_indices.append(i)\n    for index in zero_indices:\n        lst.pop(index)\n        lst.append(0)\n    return lst", "def move_zero(nums):\n    non_zero_index = 0\n    for num in nums:\n        if num != 0:\n            nums[non_zero_index] = num\n            non_zero_index += 1\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 637, "entry_point": "noprofit_noloss", "codes": ["def noprofit_noloss(cost_price, selling_price):\n    return cost_price == selling_price", "def noprofit_noloss(amount):\n    return amount == 0", "def noprofit_noloss(prices):\n    n = len(prices)\n    if n < 2:\n        return True\n\n    min_price = float('inf')\n    max_profit = 0\n\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        elif price - min_price > max_profit:\n            max_profit = price - min_price\n\n    return max_profit == 0", "def noprofit_noloss(prices):\n    cost = 0\n    profit = 0\n    for price in prices:\n        if price < cost:\n            return False\n        if price > cost:\n            profit += price - cost\n            cost = price\n    return profit == 0", "def noprofit_noloss(prices):\n    return all(price == 0 for price in prices)"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 641, "entry_point": "is_nonagonal", "codes": ["def is_nonagonal(n):\n    return n * (7 * n - 5) // 2", "def is_nonagonal(n):\n    return 9 * n * (n - 1) // 2 + n"], "rewards": [1.0, -1.0]}
{"id": 644, "entry_point": "reverse_Array_Upto_K", "codes": ["def reverse_Array_Upto_K(arr, k):\n    arr[:k+1] = reversed(arr[:k+1])\n    return arr", "def reverse_Array_Upto_K(arr, k):\n    k = min(k, len(arr))  # Ensure k does not exceed the array length\n    arr[:k] = reversed(arr[:k])\n    return arr", "def reverse_Array_Upto_K(arr, k):\n    for i in range(k // 2):\n        arr[i], arr[k - i - 1] = arr[k - i - 1], arr[i]\n    return arr", "def reverse_Array_Upto_K(arr, k):\n    for i in range(k // 2):\n        arr[i], arr[k - i - 1] = arr[k - i - 1], arr[i]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 645, "entry_point": "find_k_product", "codes": ["def find_k_product(tuples, k):\n    result = 1\n    for t in tuples:\n        if len(t) > k:\n            result *= t[k]\n    return result", "def find_k_product(tuples, k):\n    if k < 0 or k >= len(tuples):\n        raise IndexError(\"k is out of range\")\n    product = 1\n    for t in tuples:\n        if k < len(t):\n            product *= t[k]\n    return product", "def find_k_product(tuples, k):\n    # Create a dictionary to store the product of elements at each index\n    product_dict = {}\n    \n    # Iterate through each tuple in the list\n    for tup in tuples:\n        # Ensure the tuple has enough elements to access the kth index\n        if len(tup) > k:\n            # Calculate the product of the kth element and store it in the dictionary\n            product_dict[k] = product_dict.get(k, 1) * tup[k]\n    \n    # Return the product of the kth element across all tuples that have it\n    return product_dict.get(k, 0)", "def find_k_product(tuples, k):\n    return [x * y for x, y in tuples if tuples.index((x, y)) == k][0]", "def find_k_product(tuples, k):\n    sorted_tuples = sorted(tuples)\n    if k < len(sorted_tuples):\n        kth_tuple = sorted_tuples[k]\n        return kth_tuple[0] * kth_tuple[1]\n    else:\n        return None", "def find_k_product(tuples, k):\n    products = {i: tuple_ for i, tuple_ in enumerate(tuples)}\n    return products[k]", "def find_k_product(tuples, k):\n    return tuples[k] if len(tuples) > k else 1", "def find_k_product(tuples, k):\n    seen = set()\n    for t in tuples:\n        if isinstance(t, tuple) and len(t) > k and id(t) not in seen:\n            product = 1\n            for item in t[k]:\n                if isinstance(item, (int, float)):\n                    product *= item\n                elif isinstance(item, tuple):\n                    product *= find_k_product((item,), k)\n            seen.add(id(t))\n            return product\n    return None"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 646, "entry_point": "No_of_cubes", "codes": ["def No_of_cubes(n, k):\n    if k > n:\n        return 0\n    return (n - k + 1) ** 3", "def No_of_cubes(n, k):\n    if k <= 0 or n < k:\n        return 0\n    count = 0\n    for i in range(n - k + 1):\n        count += 1\n    return count", "def No_of_cubes(n, k):\n    if k > n:\n        return 0\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1]\n        if i >= k:\n            dp[i] += dp[i - k]\n    return dp[n]", "def No_of_cubes(n, k):\n    if k > n:\n        return 0\n    dp = [0] * (n - k + 1)\n    dp[0] = 1\n    for i in range(1, n - k + 1):\n        dp[i] = dp[i - 1] + dp[i - 1]\n    return dp[n - k]", "def No_of_cubes(n, k):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] += dp[i - 1] + (i >= k)\n    return dp[n]", "def No_of_cubes(n, k):\n    if k > n:\n        return 0\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + (i - k + 1) if i >= k else dp[i - 1]\n    return dp[n]"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 647, "entry_point": "split_upperstring", "codes": ["def split_upperstring(s):\n    return ''.join(c if c.islower() else ' ' + c for c in s).split()", "import re\n\ndef split_upperstring(s):\n    return re.findall('[A-Z][^A-Z]*', s)", "def split_upperstring(s):\n    return [word for word in ''.join(char.lower() if char.isupper() else char for char in s).split()]"], "rewards": [1.0, 1.0, -1.0]}
{"id": 648, "entry_point": "exchange_elements", "codes": ["def exchange_elements(lst):\n    for i in range(0, len(lst) - 1, 2):\n        lst[i], lst[i + 1] = lst[i + 1], lst[i]\n    return lst", "def exchange_elements(lst):\n    n = len(lst)\n    for i in range(0, n-1, 2):\n        lst[i], lst[i+1] = lst[i+1], lst[i]\n    return lst", "def exchange_elements(lst):\n    n = len(lst)\n    if n < 2:\n        return lst\n    for i in range(0, n-1, 2):\n        lst[i], lst[i+1] = lst[i+1], lst[i]\n    return lst", "def exchange_elements(lst, n):\n    for i in range(0, len(lst) - 1, 2):\n        lst[i], lst[i + 1] = lst[i + 1], lst[i]\n    return lst", "def exchange_elements(lst, n):\n    for i in range(0, len(lst) - n, 2):\n        lst[i], lst[i + n] = lst[i + n], lst[i]\n    return lst", "def exchange_elements(lst, n):\n    if n <= 0 or n >= len(lst) - 1:\n        return lst\n    for i in range(n, len(lst) - 1, n + 1):\n        lst[i], lst[i + 1] = lst[i + 1], lst[i]\n    return lst", "def exchange_elements(lst, n):\n    if n < 1 or n >= len(lst):\n        return lst\n    for i in range(0, len(lst) - 1, 2 * n):\n        lst[i], lst[i + n] = lst[i + n], lst[i]\n    return lst"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 649, "entry_point": "sum_Range_list", "codes": ["def sum_Range_list(lst, start, end):\n    return sum(lst[start:end+1])", "def sum_Range_list(numbers, start, end):\n    return sum(numbers[start:end+1])", "def sum_Range_list(numbers, start, end):\n    return sum(numbers[start:end+1])", "def sum_Range_list(lst, start, end):\n    return sum(lst[start:end])", "def sum_Range_list(lst, start, end):\n    return sum(filter(lambda x: start <= x[0] <= end, enumerate(lst)))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 653, "entry_point": "grouping_dictionary", "codes": ["from collections import defaultdict\n\ndef grouping_dictionary(pairs):\n    result = defaultdict(list)\n    for key, value in pairs:\n        result[key].append(value)\n    return result", "from collections import defaultdict\n\ndef grouping_dictionary(pairs):\n    grouped = defaultdict(list)\n    for key, value in pairs:\n        grouped[key].append(value)\n    return dict(grouped)", "def grouping_dictionary(pairs):\n    from collections import defaultdict\n    result = defaultdict(list)\n    for key, value in pairs:\n        result[key].append(value)\n    return dict(result)", "from collections import defaultdict\n\ndef grouping_dictionary(pairs):\n    return defaultdict(list, pairs)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 656, "entry_point": "find_Min_Sum", "codes": ["def find_Min_Sum(nums1, nums2, n):\n    nums1.sort()\n    nums2.sort()\n    return sum(abs(a - b) for a, b in zip(nums1, nums2))", "def find_Min_Sum(nums1, nums2):\n    nums2.sort()\n    return sum(abs(a - b) for a, b in zip(nums1, nums2))", "def find_Min_Sum(arr1, arr2):\n    arr1.sort()\n    arr2.sort()\n    return sum(abs(a - b) for a, b in zip(arr1, arr2))", "def find_Min_Sum(arr1, arr2):\n    arr1.sort()\n    arr2.sort()\n    n = len(arr1)\n    return sum(abs(arr1[i] - arr2[i]) for i in range(n))", "def find_Min_Sum(nums1, nums2):\n    nums1.sort()\n    return sum(abs(a - b) for a, b in zip(nums1, nums2))", "def find_Min_Sum(nums1, nums2):\n    nums1.sort()\n    nums2.sort()\n    return sum(abs(a - b) for a, b in zip(nums1, nums2))"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 657, "entry_point": "first_Digit", "codes": ["from math import factorial\n\ndef first_Digit(n):\n    fact = factorial(n)\n    while fact >= 10:\n        fact //= 10\n    return fact", "def first_Digit(n):\n    factorial = 1\n    for i in range(2, n + 1):\n        factorial *= i\n    while factorial >= 10:\n        factorial //= 10\n    return factorial", "def first_Digit(n):\n    fact = 1\n    while n > 1:\n        fact *= n\n        while fact >= 10:\n            fact //= 10\n        n -= 1\n    return fact", "def first_Digit(n):\n    fact = 1\n    for i in range(2, n + 1):\n        fact *= i\n        while fact % 10 == 0:\n            fact //= 10\n        fact %= 1000000007\n    return fact % 10", "def first_Digit(n):\n    fact = 1\n    for i in range(2, n + 1):\n        fact *= i\n        while fact % 10 == 0:\n            fact //= 10\n        fact %= 100000  # Keep only the last 5 digits to manage overflow\n    return fact", "def first_Digit(n):\n    fact = 1\n    for i in range(2, n + 1):\n        fact *= i\n        while fact % 10 == 0:\n            fact //= 10\n        fact %= 1000000007\n    return fact", "def first_Digit(n):\n    if n < 0:\n        return -1  # Factorial is not defined for negative numbers\n    if n == 0:\n        return 1  # 0! is 1\n    factorial = 1\n    for i in range(2, n + 1):\n        factorial = (factorial * i) % 10\n    while factorial >= 10:\n        factorial //= 10\n    return factorial"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 658, "entry_point": "max_occurrences", "codes": ["def max_occurrences(items):\n    return max(items, key=items.count)", "def max_occurrences(lst):\n    return max(set(lst), key=lst.count)", "def max_occurrences(lst):\n    from collections import Counter\n    return Counter(lst).most_common(1)[0][0]", "def max_occurrences(lst):\n    return lst.count(max(set(lst), key=lst.count))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 659, "entry_point": "Repeat", "codes": ["from collections import Counter\n\ndef Repeat(lst):\n    counts = Counter(lst)\n    return [num for num, count in counts.items() if count > 1]", "def Repeat(lst):\n    def is_duplicate(x):\n        return lst.count(x) > 1\n    \n    duplicates = [x for x in lst if is_duplicate(x)]\n    return sorted(set(duplicates))", "def Repeat(numbers):\n    seen = set()\n    duplicates = set()\n    \n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n    \n    return list(duplicates)", "def Repeat(lst):\n    seen = set()\n    duplicates = set()\n    for num in lst:\n        if num in seen:\n            duplicates.add(num)\n        else:\n            seen.add(num)\n    return duplicates"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 662, "entry_point": "sorted_dict", "codes": ["def sorted_dict(d):\n    return {k: sorted(v) for k, v in d.items()}", "def sorted_dict(d):\n    return {k: v for k, v in sorted(d.items())}", "def sorted_dict(_dict):\n    return dict(sorted(_dict.items()))", "def sorted_dict(dct):\n    if not isinstance(dct, dict):\n        return dct\n    keys = sorted(dct.keys())\n    sorted_items = [(key, sorted_dict(dct[key])) for key in keys]\n    return dict(sorted_items)", "def sorted_dict(d):\n    return dict(sorted(d.items()))"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 664, "entry_point": "average_Even", "codes": ["def average_Even(n):\n    if n % 2 != 0:\n        raise ValueError(\"Input must be an even number\")\n    return sum(range(2, n + 1, 2)) / (n // 2)", "def average_Even(n):\n    if n % 2 != 0:\n        raise ValueError(\"Input must be an even number.\")\n    return sum(range(2, n+1, 2)) / (n // 2)", "def average_Even(n):\n    if n % 2 != 0:\n        raise ValueError(\"Input must be an even number.\")\n    return sum(i for i in range(2, n + 1, 2)) / (n // 2)", "def average_Even(n):\n    if n % 2 != 0:\n        raise ValueError(\"Input must be an even number\")\n    return sum(range(0, n + 1, 2)) / (n // 2 + 1)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 668, "entry_point": "replace", "codes": ["def replace(s, c):\n    return s.replace(c, '', 1)", "def replace(s, char):\n    result = ''\n    last_char = None\n    for c in s:\n        if c != char or c != last_char:\n            result += c\n            last_char = c\n    return result", "def replace(text, char):\n    result = []\n    prev_char = None\n    for current_char in text:\n        if current_char != char or current_char != prev_char:\n            result.append(current_char)\n            prev_char = current_char\n    return ''.join(result)", "def replace(s, c):\n    return ''.join(char if char != c else '' for char in s)", "def replace(s: str, old: str, new: str) -> str:\n    return s.replace(old, new)", "def replace(s, old, new):\n    result = []\n    i = 0\n    while i < len(s):\n        if s[i:i+len(old)] == old:\n            result.append(new)\n            i += len(old)\n        else:\n            result.append(s[i])\n            i += 1\n    return ''.join(result)", "def replace(s, old, new):\n    return s.replace(old, new)", "def replace(s, c):\n    return ''.join([char for char in s if char != c])"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 674, "entry_point": "remove_duplicate", "codes": ["def remove_duplicate(s):\n    return ' '.join(dict.fromkeys(s.split()))", "from collections import OrderedDict\n\ndef remove_duplicate(s):\n    return ' '.join(OrderedDict.fromkeys(s.split()))", "def remove_duplicate(s):\n    words = s.split()\n    unique_words = list(dict.fromkeys(words))\n    return ' '.join(unique_words)", "def remove_duplicate(text):\n    return ' '.join(set(text.split()))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 675, "entry_point": "sum_nums", "codes": ["def sum_nums(a, b, lower, upper):\n    return 20 if lower <= a + b <= upper else a + b", "def sum_nums(a, b, lower, upper):\n    result = a + b\n    return 20 if lower <= result <= upper else result", "def sum_nums(x, y, lower, upper):\n    total = x + y\n    return 20 if lower <= total <= upper else total", "def sum_nums(x, y):\n    result = x + y\n    if 5 < result < 10:\n        return 20\n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 678, "entry_point": "remove_spaces", "codes": ["def remove_spaces(s):\n    return \"\".join(s.split(\" \"))", "def remove_spaces(s):\n    return \"\".join(c for c in s if c != \" \")", "def remove_spaces(s):\n    return s.translate(s.maketrans(\"\", \"\", \" \"))", "def remove_spaces(s):\n    return \"\".join([c for c in s if c])"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 679, "entry_point": "access_key", "codes": ["def access_key(_dict, _index):\n    return list(_dict.keys())[_index]", "def access_key(dictionary, key):\n    return dictionary[key]", "def access_key(d, key, index):\n    return d[key][index]", "def access_key(d, index):\n    return list(d.values())[index]", "def access_key(dct, key, index):\n    return dct[key][index]", "def access_key(dct, index):\n    return list(dct.values())[index]"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 680, "entry_point": "increasing_trend", "codes": ["def increasing_trend(sequence):\n    return sequence == sorted(sequence)", "def increasing_trend(numbers):\n    return all(x < y for x, y in zip(numbers, numbers[1:]))", "def increasing_trend(sequence):\n    return all(x < y for x, y in zip(sequence, sequence[1:]))", "def increasing_trend(sequence):\n    return all(x >= y for x, y in zip(sequence, sequence[1:]))", "def increasing_trend(sequence):\n    return all(sequence[i] >= sequence[i+1] for i in range(len(sequence)-1))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 691, "entry_point": "group_element", "codes": ["def group_element(lst):\n    grouped = {}\n    for key, value in lst:\n        if value not in grouped:\n            grouped[value] = []\n        grouped[value].append(key)\n    return grouped", "def group_element(tuples):\n    grouped = {}\n    for key, value in tuples:\n        if value not in grouped:\n            grouped[value] = []\n        grouped[value].append(key)\n    return grouped", "def group_element(tuples):\n    grouped = {}\n    for t in tuples:\n        key = t[1]\n        if key not in grouped:\n            grouped[key] = []\n        grouped[key].append(t[0])\n    return grouped", "def group_element(tuples):\n    grouped = {}\n    for key, value in tuples:\n        if key not in grouped:\n            grouped[key] = []\n        grouped[key].append(value)\n    return grouped", "def group_element(tuples):\n    return {key: [value for value, key in tuples if key == _key] for _key, value in tuples}", "def group_element(tuples):\n    result = {}\n    for key, value in tuples:\n        if key not in result:\n            result[key] = []\n        result[key].append(value)\n    return result", "def group_element(tuples):\n    result = {}\n    for key, value in tuples:\n        if key not in result:\n            result[key] = [value]\n        else:\n            result[key].append(value)\n    return result", "def group_element(tuples):\n    grouped = {}\n    for idx, (key, value) in enumerate(tuples):\n        if key not in grouped:\n            grouped[key] = []\n        grouped[key].append(value)\n    return grouped"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 693, "entry_point": "remove_multiple_spaces", "codes": ["import re\n\ndef remove_multiple_spaces(text):\n    return re.sub(r'\\s+', ' ', text)", "import re\n\ndef remove_multiple_spaces(s):\n    return re.sub(r'\\s+', ' ', s)", "import re\n\ndef remove_multiple_spaces(input_string):\n    return re.sub(r'\\s+', ' ', input_string)", "import re\n\ndef remove_multiple_spaces(text):\n    def replace_spaces(match):\n        return ' ' * len(match.group())\n    return re.sub(r'\\s+', replace_spaces, text)", "def remove_multiple_spaces(s):\n    return re.sub(r'\\s+', ' ', s)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 695, "entry_point": "check_greater", "codes": ["def check_greater(t1, t2):\n    return all(x < y for x, y in zip(t1, t2))", "def check_greater(lhs, rhs):\n    return all(x < y for x, y in zip(lhs, rhs))", "def check_greater(lhs, rhs):\n    return all(x > idx for idx, x in enumerate(reversed(rhs)))", "def check_greater(lhs, rhs):\n    stack = []\n    for i, x in enumerate(rhs):\n        while stack and stack[-1][0] < i:\n            _, y = stack.pop()\n            if x <= y:\n                return False\n        stack.append((i, x))\n    return True"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 696, "entry_point": "zip_list", "codes": ["def zip_list(list1, list2):\n    return [x + y for x, y in zip(list1, list2)]", "def zip_list(list1, list2):\n    return [a + b for a, b in zip(list1, list2)]", "def zip_list(list1, list2):\n    return [a + b for a, b in zip(list1, list2)]", "def zip_list(list1, list2):\n    return [pair for pair in zip(list1, list2)]", "def zip_list(lst1, lst2):\n    return [list(pair) for pair in zip(lst1, lst2)]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 698, "entry_point": "sort_dict_item", "codes": ["def sort_dict_item(d):\n    return dict(sorted(d.items(), key=lambda item: item[0][0] * item[0][1]))", "def sort_dict_item(input_dict):\n    return dict(sorted(input_dict.items(), key=lambda x: x[0][0] * x[0][1]))", "def sort_dict_item(_dict):\n    return dict(sorted(_dict.items(), key=lambda item: item[0][0] * item[0][1]))", "def sort_dict_item(input_dict):\n    signature_dict = {tuple(sorted(k)): v for k, v in input_dict.items()}\n    sorted_dict = {k: signature_dict[k] for k in sorted(signature_dict)}\n    return sorted_dict", "def sort_dict_item(d):\n    return sorted(d.items(), key=lambda x: x[0][0] * x[0][1])", "def sort_dict_item(input_dict):\n    signature_dict = {tuple(sorted(k)): v for k, v in input_dict.items()}\n    return {k: signature_dict[k] for k in sorted(signature_dict)}", "def sort_dict_item(_dict):\n    return sorted(_dict.items(), key=lambda item: item[0][0] * item[0][1])"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 700, "entry_point": "count_range_in_list", "codes": ["def count_range_in_list(lst, min_val, max_val):\n    return sum(1 for x in lst if min_val <= x <= max_val)", "def count_range_in_list(numbers, lower_bound, upper_bound):\n    return sum(1 for number in numbers if lower_bound <= number <= upper_bound)", "def count_range_in_list(arr, low, high):\n    return sum(1 for x in arr if low <= x <= high)", "def count_range_in_list(arr, low, high):\n    count_set = {num for num in arr if low <= num <= high}\n    return len(count_set)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 704, "entry_point": "harmonic_sum", "codes": ["def harmonic_sum(n):\n    return 1 / n + harmonic_sum(n - 1) if n > 1 else 1", "def harmonic_sum(n):\n    if n <= 1:\n        return 1\n    return 1 / n + harmonic_sum(n - 1)", "def harmonic_sum(n):\n    if n <= 1:\n        return 1\n    else:\n        return 1 / n + harmonic_sum(n - 1)", "def harmonic_sum(n):\n    return sum(1/i for i in range(1, n))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 705, "entry_point": "sort_sublists", "codes": ["def sort_sublists(sublists):\n    return sorted(sublists, key=lambda x: (len(x), x))", "def sort_sublists(lst):\n    return sorted(lst, key=lambda x: (len(x), x))", "def sort_sublists(lst):\n    stack = [(lst, 0)]\n    result = []\n    while stack:\n        sublist, i = stack.pop()\n        if i == len(sublist):\n            result.append(sublist)\n        else:\n            stack.append((sublist[i:], i + 1))\n            stack.append(([sublist[i]] + sorted(sublist[i+1:], key=len), i + 1))\n    return sorted(result, key=lambda x: (len(x), x))"], "rewards": [1.0, 1.0, -1.0]}
{"id": 709, "entry_point": "get_unique", "codes": ["from collections import defaultdict\n\ndef get_unique(tuples):\n    unique_keys = defaultdict(set)\n    for key, value in tuples:\n        unique_keys[value].add(key)\n    return {value: len(keys) for value, keys in unique_keys.items()}", "def get_unique(t):\n    unique_counts = {}\n    for key, value in t:\n        if value not in unique_counts:\n            unique_counts[value] = set()\n        unique_counts[value].add(key)\n    return {value: len(unique_counts[value]) for value in unique_counts}", "def get_unique(tuples):\n    unique_keys = {}\n    for key, value in tuples:\n        if value not in unique_keys:\n            unique_keys[value] = set()\n        unique_keys[value].add(key)\n    return {value: len(keys) for value, keys in unique_keys.items()}", "def get_unique(tuples):\n    unique_keys = {}\n    for key, value in tuples:\n        if value not in unique_keys:\n            unique_keys[value] = {key}\n        else:\n            unique_keys[value].add(key)\n    return unique_keys", "def get_unique(t):\n    from collections import defaultdict, Counter\n    \n    def count_unique(part):\n        count = Counter()\n        for key, value in part:\n            count[value].add(key)\n        return count\n    \n    part_size = len(t) // 4\n    parts = [t[i:i+part_size] for i in range(0, len(t), part_size)]\n    \n    unique_counts = defaultdict(Counter)\n    for part in parts:\n        part_unique_counts = count_unique(part)\n        for value, keys in part_unique_counts.items():\n            unique_counts[value].update(keys)\n    \n    return dict(unique_counts)", "def get_unique(_dict):\n    unique_keys = {}\n    for key, value in _dict.items():\n        if value not in unique_keys:\n            unique_keys[value] = []\n        unique_keys[value].append(key)\n    return unique_keys", "def get_unique(tuples):\n    def helper(t):\n        if not t:\n            return {}\n        head, *tail = t\n        key, value = head\n        if value not in result:\n            result[value] = set()\n        result[value].add(key)\n        return helper(tail)\n    \n    result = {}\n    return helper(tuples)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 711, "entry_point": "product_Equal", "codes": ["def product_Equal(n):\n    digits = [int(d) for d in str(n)]\n    odd_product = 1\n    even_product = 1\n    for i, d in enumerate(digits):\n        if i % 2 == 0:\n            odd_product *= d\n        else:\n            even_product *= d\n    return odd_product == even_product", "def product_Equal(number):\n    product_odd = 1\n    product_even = 1\n    digits = iter(str(number))\n    \n    for pos, digit in enumerate(digits, start=1):\n        if pos % 2 == 0:\n            product_even *= int(digit)\n        else:\n            product_odd *= int(digit)\n    \n    return product_odd == product_even", "def product_Equal(n):\n    digits = [int(d) for d in str(n)]\n    even_product = 1\n    odd_product = 1\n    for i in range(len(digits)):\n        if i % 2 == 0:\n            even_product *= digits[i]\n        else:\n            odd_product *= digits[i]\n    return even_product == odd_product", "def product_Equal(number):\n    digits = [int(d) for d in str(number)]\n    even_product = digits[-1] * digits[-2] if len(digits) >= 2 else 1\n    odd_product = digits[-3] * digits[-4] if len(digits) >= 4 else 1\n    return even_product == odd_product", "def product_Equal(n):\n    even_product = 1\n    odd_product = 1\n    j = n\n    while j > 0:\n        digit = j % 10\n        if digit != 0:\n            if j % 100 == j:\n                odd_product *= digit\n            else:\n                even_product *= digit\n        j //= 10\n    return even_product == odd_product", "def product_Equal(number):\n    digits = [int(d) for d in str(number)]\n    product_pairs = {digits[i] * digits[i + 1] for i in range(0, len(digits) - 1, 2)}\n    return len(product_pairs) == 1", "def product_Equal(n):\n    digits = [int(d) for d in str(n)]\n    return all(digits[i] * digits[i + 1] == digits[-1] * digits[-2] for i in range(0, len(digits) - 2, 2))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 712, "entry_point": "remove_duplicate", "codes": ["def remove_duplicate(lst):\n    if not lst:\n        return []\n    first, *rest = lst\n    if first in rest:\n        return remove_duplicate(rest)\n    else:\n        return [first] + remove_duplicate(rest)", "def remove_duplicate(lst_of_lsts):\n    seen = set()\n    result = []\n    for sublist in lst_of_lsts:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple not in seen:\n            seen.add(sublist_tuple)\n            result.append(sublist)\n    return result", "def remove_duplicate(lst):\n    return [list(sublist) for sublist in set(tuple(sublist) for sublist in lst)]", "def remove_duplicate(lst):\n    seen = set()\n    return [x for x in lst if not (x in seen or seen.add(x))]", "def remove_duplicate(lst_of_lsts):\n    return list(dict.fromkeys(tuple(sublist) for sublist in lst_of_lsts))", "def remove_duplicate(_lst):\n    return [list(sub) for sub in set(tuple(sorted(sub)) for sub in _lst)]"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 713, "entry_point": "check_valid", "codes": ["def check_valid(tup):\n    for value in reversed(tup):\n        if not value:\n            return False\n    return True", "def check_valid(tup):\n    return all(value is not None and isinstance(value, (int, float, str)) for value in tup)", "def check_valid(tup):\n    for index, value in enumerate(tup):\n        if not isinstance(value, (int, float, str)):\n            return False\n    return True", "def check_valid(tup):\n    return all(item is not None for item in tup)", "def check_valid(tup):\n    return all(isinstance(item, (int, str, float)) for item in tup)", "def check_valid(tup):\n    return all(item in {0, 1} for item in tup)"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 715, "entry_point": "str_to_tuple", "codes": ["def str_to_tuple(s):\n    accumulator = []\n    for item in s.split(','):\n        accumulator.append(int(item.strip()))\n    return tuple(accumulator)", "def str_to_tuple(s):\n    return tuple(int(i) for i in s.split())", "def str_to_tuple(s):\n    return tuple(map(int, s.split()))", "def str_to_tuple(s):\n    def parse_int(s):\n        return int(s)\n    \n    return tuple(parse_int(item) for item in s.split())\n\ndef _equivalent(_lhs, _rhs):\n    return _lhs == _rhs", "def str_to_tuple(s):\n    return tuple(int(x) for x in s.split())", "def str_to_tuple(input_string):\n    return tuple(int(item) for item in input_string.split())"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 716, "entry_point": "rombus_perimeter", "codes": ["def rombus_perimeter(side_length):\n    return 4 * side_length", "def rombus_perimeter(diagonal1, diagonal2):\n    return 2 * (diagonal1 + diagonal2)", "def rombus_perimeter(diagonal1, diagonal2):\n    return 4 * ((diagonal1 ** 2 + diagonal2 ** 2) ** 0.5)"], "rewards": [1.0, -1.0, -1.0]}
{"id": 723, "entry_point": "count_same_pair", "codes": ["def count_same_pair(list1, list2):\n    return sum(x == y for x, y in zip(list1, list2))", "def count_same_pair(list1, list2):\n    return sum(1 for x, y in zip(list1, list2) if x == y)", "from collections import Counter\n\ndef count_same_pair(lst1, lst2):\n    return sum(x == y for x, y in zip(lst1, lst2))", "def count_same_pair(list1, list2):\n    counter = {x: list1.count(x) for x in set(list1)}\n    return sum(counter[x] for x in list2 if x in counter)", "from collections import Counter\n\ndef count_same_pair(list1, list2):\n    counter1 = Counter(list1)\n    counter2 = Counter(list2)\n    return sum(min(counter1[key], counter2[key]) for key in counter1.keys() & counter2.keys())", "def count_same_pair(list1, list2):\n    counter = {x: list1.count(x) for x in list1}\n    return sum(counter[x] for x in list2 if x in counter)", "from collections import Counter\n\ndef count_same_pair(list1, list2):\n    counter1 = Counter(list1)\n    counter2 = Counter(list2)\n    same_pair_count = sum(min(counter1[key], counter2[key]) for key in counter1 & counter2)\n    return same_pair_count", "from collections import Counter\n\ndef count_same_pair(list1, list2):\n    return sum(v for v in (Counter(list1) & Counter(list2)).values())"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 724, "entry_point": "power_base_sum", "codes": ["def power_base_sum(base, power):\n    return sum(int(digit) for digit in str(base ** power))", "def power_base_sum(base, power):\n    return sum(int(digit) for digit in str(pow(base, power)))", "def power_base_sum(base, exponent):\n    result = base ** exponent\n    return sum(int(digit) for digit in str(result))", "def power_base_sum(base, power):\n    result = 0\n    while power > 0:\n        result += base % 10\n        base //= 10\n        power -= 1\n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 725, "entry_point": "extract_quotation", "codes": ["import re\n\ndef extract_quotation(text):\n    return re.findall(r'\"([^\"]+)\"', text)", "import re\n\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "import re\n\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]+)\"', s)", "import re\n\ndef extract_quotation(s):\n    return (match.group(1) for match in re.finditer(r'\"(.*?)\"', s))", "import re\n\ndef extract_quotation(text):\n    return (match.group(1) for match in re.finditer(r'\"([^\"]+)\"', text))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 726, "entry_point": "multiply_elements", "codes": ["def multiply_elements(t):\n    return tuple(a * b for a, b in zip(t, t[1:]))", "def multiply_elements(tup):\n    return tuple(x * y for x, y in zip(tup, tup[1:]))", "def multiply_elements(tup):\n    return tuple(a * b for a, b in zip(tup, tup[1:]))", "def multiply_elements(tup):\n    return sum(x * y for x, y in zip(tup, tup[1:]))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 728, "entry_point": "sum_list", "codes": ["def sum_list(l1, l2):\n    return [x + y for x, y in zip(l1, l2)]", "def sum_list(list1, list2):\n    return [x + y for x, y in zip(list1, list2)]", "def sum_list(lst1, lst2):\n    return [x + y for x, y in zip(lst1, lst2)]", "def sum_list(lst1, lst2):\n    return sum(x + y for x, y in zip(lst1, lst2))", "def sum_list(lst1, lst2):\n    result = []\n    i = j = 0\n    while i < len(lst1) or j < len(lst2):\n        if i < len(lst1):\n            result.append(lst1[i])\n            i += 1\n        if j < len(lst2):\n            result.append(lst2[j])\n            j += 1\n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 730, "entry_point": "consecutive_duplicates", "codes": ["def consecutive_duplicates(lst):\n    return [x for i, x in enumerate(lst) if i == 0 or x != lst[i-1]]", "def consecutive_duplicates(_list):\n    return [x for i, x in enumerate(_list) if i == 0 or _list[i-1] != x]", "def consecutive_duplicates(lst):\n    result = []\n    for item in lst:\n        if not result or item != result[-1]:\n            result.append(item)\n    return result", "def consecutive_duplicates(lst):\n    return [key for key, group in itertools.groupby(lst)]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 732, "entry_point": "replace_specialchar", "codes": ["def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "def replace_specialchar(text):\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "def replace_specialchar(s):\n    result = []\n    i = 0\n    while i < len(s):\n        if s[i] in \" ,.\":\n            result.append(':')\n        else:\n            result.append(s[i])\n        i += 1\n    return ''.join(result)", "def replace_specialchar(s):\n    return ''.join(':'+c if c in ' ,.' else c for c in s)", "def replace_specialchar(s):\n    return ''.join(': ' if c in ' ,.' else c for c in s)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 735, "entry_point": "toggle_middle_bits", "codes": ["def toggle_middle_bits(n):\n    length = n.bit_length()\n    if length <= 2:\n        return n\n    mask = ((1 << (length - 2)) - 1) << 1\n    return n ^ mask", "def toggle_middle_bits(n):\n    bits = n.bit_length()\n    if bits <= 2:\n        return n\n    mask = (1 << (bits - 1)) - 3\n    return n ^ mask", "def toggle_middle_bits(n):\n    mask = n\n    bit_length = n.bit_length()\n    if bit_length <= 2:\n        return n\n    for i in range(1, bit_length - 1):\n        mask |= (1 << i)\n    return n ^ mask", "def toggle_middle_bits(n):\n    mask = (1 << (n.bit_length() - 2)) - 1\n    return n ^ mask", "def toggle_middle_bits(n):\n    if n <= 2:\n        return n\n    mask = (1 << (n.bit_length() - 2)) - 1\n    return n ^ mask", "def toggle_middle_bits(num):\n    num_bits = num.bit_length()\n    if num_bits <= 2:\n        return num\n    mask = (((1 << (num_bits - 2)) - 1) << 1) | 1\n    return num ^ mask"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 738, "entry_point": "geometric_sum", "codes": ["def geometric_sum(n):\n    return 1 if n == 0 else 1 + 0.5 * geometric_sum(n - 1)", "def geometric_sum(n):\n    if n < 0:\n        return 0\n    return 1 / (pow(2, n)) + geometric_sum(n - 1)", "def geometric_sum(n):\n    if n <= 0:\n        return 0\n    return 1 + geometric_sum(n - 1)", "def geometric_sum(n):\n    if n < 0:\n        return 0\n    else:\n        return 1 + geometric_sum(n - 1)", "def geometric_sum(n):\n    memo = {}\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        if n <= 0:\n            return 0\n        memo[n] = 1 + helper(n - 1)\n        return memo[n]\n    return helper(n)", "def geometric_sum(n):\n    return 1 / (pow(2, n)) if n >= 0 else 0", "def geometric_sum(n):\n    return sum(1 / 2**i for i in range(n))"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 739, "entry_point": "find_Index", "codes": ["def find_Index(n, i=1):\n    while True:\n        triangular_number = i * (i + 1) // 2\n        if len(str(triangular_number)) == n:\n            return i\n        i += 1", "def find_Index(n):\n    i = 1\n    while True:\n        triangular_number = i * (i + 1) // 2\n        if len(str(triangular_number)) == n:\n            return i\n        i += 1", "def find_Index(n):\n    i = 1\n    while True:\n        triangular_number = i * (i + 1) // 2\n        if len(str(triangular_number)) >= n:\n            return i\n        i += 1", "def find_Index(n):\n    lower, upper = 0, n * 10\n    while lower < upper:\n        mid = (lower + upper) // 2\n        triangular_number = mid * (mid + 1) // 2\n        if len(str(triangular_number)) < n:\n            lower = mid + 1\n        else:\n            upper = mid\n    return lower", "def find_Index(n, i):\n    while True:\n        triangular_number = i * (i + 1) // 2\n        num_digits = len(str(triangular_number))\n        if num_digits == n:\n            return i\n        elif num_digits > n:\n            return None\n        i += 1", "def find_Index(n):\n    start, end = 1, 10**(n-1)\n    while start <= end:\n        mid = (start + end) // 2\n        triangular_number = mid * (mid + 1) // 2\n        if len(str(triangular_number)) < n:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return start - 1", "def find_Index(n):\n    i = 1\n    while True:\n        triangular_number = i * (i + 1) // 2\n        if len(str(triangular_number)) == n:\n            return i - 1\n        i += 1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 740, "entry_point": "tuple_to_dict", "codes": ["def tuple_to_dict(_tuple):\n    return dict(_tuple[i:i+2] for i in range(0, len(_tuple), 2))", "def tuple_to_dict(tup):\n    return dict(tup[i:i+2] for i in range(0, len(tup), 2))", "def tuple_to_dict(_tuple):\n    return {key: value for key, value in zip(_tuple[::2], _tuple[1::2])}", "def tuple_to_dict(tup):\n    return dict(enumerate(tup))", "def tuple_to_dict(tup):\n    return dict(tup)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 744, "entry_point": "check_none", "codes": ["def check_none(t):\n    return None in t", "def check_none(tup):\n    return any(value is None for value in tup)", "def check_none(input_tuple):\n    return any(x is None for x in input_tuple)", "def check_none(_tuple):\n    return not any(value is None for value in _tuple)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 745, "entry_point": "divisible_by_digits", "codes": ["def divisible_by_digits(start, end):\n    return [n for n in range(start, end + 1) if all(int(digit) != 0 and n % int(digit) == 0 for digit in str(n))]", "def divisible_by_digits(start, end):\n    result = []\n    for num in range(start, end + 1):\n        str_num = str(num)\n        if '0' not in str_num and all(num % int(digit) == 0 for digit in str_num):\n            result.append(num)\n    return result", "def divisible_by_digits(start, end):\n    def is_divisible_by_digits(num):\n        if num < 10:\n            return True\n        for digit in str(num):\n            if digit == '0' or num % int(digit) != 0:\n                return False\n        return True\n\n    result = []\n    num = start\n    while num <= end:\n        if is_divisible_by_digits(num):\n            result.append(num)\n        num += 1\n    return result", "def divisible_by_digits(start, end):\n    return [num for num in range(start, end + 1) if num > 0 and all(num % int(digit) == 0 for digit in str(num) if digit != '0')]", "def divisible_by_digits(start, end):\n    def is_divisible_by_digits(number):\n        digits = [int(d) for d in str(number) if d != '0']\n        return all(number % digit == 0 for digit in digits)\n\n    return [num for num in range(start, end + 1) if is_divisible_by_digits(num)]", "def divisible_by_digits(start, end):\n    result = []\n    for num in range(start, end + 1):\n        digits = {int(d) for d in str(num) if d != '0'}\n        if all(num % d == 0 for d in digits):\n            result.append(num)\n    return result", "def divisible_by_digits(start, end):\n    return [num for num in range(start, end + 1) if all(num % int(digit) == 0 for digit in str(num) if digit != '0')]", "def divisible_by_digits(start, end):\n    result = []\n    for num in range(start, end + 1):\n        if num < 10:\n            result.append(num)\n            continue\n        digits = [int(d) for d in str(num) if d != '0']\n        if all(num % digit == 0 for digit in digits):\n            result.append(num)\n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 748, "entry_point": "capital_words_spaces", "codes": ["import re\n\ndef capital_words_spaces(text):\n    return re.sub(r'(?<!^)(?=[A-Z])', ' ', text)", "import re\n\ndef capital_words_spaces(text):\n    return re.sub(r'([a-z])([A-Z])', r'\\1 \\2', text)", "import re\n\ndef capital_words_spaces(s):\n    return re.sub(r'([a-z])([A-Z])', r'\\1 \\2', s)", "import re\n\ndef capital_words_spaces(s):\n    return ''.join(map(str, re.findall(r'[a-z]+|[A-Z][^A-Z]*', s)))", "import re\n\ndef capital_words_spaces(s):\n    def insert_spaces(match):\n        return match.group(0) + ' '\n\n    words = re.findall(r'[A-Z][^A-Z]*', s)\n    spaced_words = [insert_spaces(re.match(r'[A-Z][^A-Z]*', word)) for word in words]\n    return ''.join(spaced_words)", "import re\n\ndef capital_words_spaces(s):\n    def insert_spaces(match):\n        return ' ' + match.group(0)\n    \n    return re.sub(r'([A-Z][a-z]+)', insert_spaces, s)", "import re\n\ndef capital_words_spaces(s):\n    words = re.findall('[A-Z][^A-Z]*', s)\n    spaced_words = [word[0] + ' ' + word[1:] for word in words]\n    return ''.join(spaced_words)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 750, "entry_point": "add_tuple", "codes": ["def add_tuple(_list, _tuple):\n    _list.extend(_tuple)\n    return _list", "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst", "def add_tuple(lst, tup):\n    lst.extend(tup)\n    return lst", "def add_tuple(lst, tpl):\n    lst.append(tpl)\n    return lst", "def add_tuple(lst, tup):\n    lst.append(tup)\n    return lst", "def add_tuple(lst, tpl):\n    lst.append(tpl)", "def add_tuple(lst, t):\n    lst.append(t)\n    return lst", "def add_tuple(_lst, _tup):\n    _lst.append(_tup)\n    return _lst"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 752, "entry_point": "jacobsthal_num", "codes": ["def jacobsthal_num(n):\n    def _jacobsthal(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return _jacobsthal(n - 1) + 2 * _jacobsthal(n - 2)\n\n    return _jacobsthal(n)", "def jacobsthal_num(n):\n    def jacobsthal(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return jacobsthal(n - 1) + 2 * jacobsthal(n - 2)\n    \n    return jacobsthal(n)", "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, 2 * b + a\n    return b", "def jacobsthal_num(n):\n    def jacobsthal(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            a, b = 0, 1\n            for _ in range(2, n + 1):\n                a, b = b, 2 * b + a\n            return b\n    return jacobsthal(n)", "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, 2 * b + a\n    return b", "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 753, "entry_point": "min_k", "codes": ["def min_k(records, k):\n    if k <= 0:\n        return []\n    min_dict = {}\n    for record in records:\n        key = record[0]\n        value = record[1]\n        if key not in min_dict or value < min_dict[key]:\n            min_dict[key] = value\n    return sorted(min_dict.items(), key=lambda x: x[1])[:k]", "def min_k(records, k):\n    if k <= 0:\n        return []\n    result = []\n    for record in records:\n        if len(result) < k:\n            result.append(record)\n        elif record < max(result):\n            result.remove(max(result))\n            result.append(record)\n    return result", "def _helper(tuples):\n    return tuples[0], tuples[1]\n\ndef min_k(tuples, k):\n    return sorted(tuples, key=_helper)[:k]", "def min_k(record_list, k):\n    return sorted(record_list)[:k]", "def min_k(records, k):\n    if k <= 0:\n        return []\n    if k >= len(records):\n        return records\n    result = []\n    while k > 0:\n        min_record = min(records, key=lambda x: x[0])\n        result.append(min_record)\n        records.remove(min_record)\n        k -= 1\n    return result", "def min_k(records, k):\n    return tuple(sorted(records, key=lambda x: x[0])[:k])"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 754, "entry_point": "extract_index_list", "codes": ["def extract_index_list(list1, list2, list3):\n    index_map = {}\n    for i, (a, b, c) in enumerate(zip(list1, list2, list3)):\n        if a == b == c:\n            index_map[i] = a\n    return list(index_map.values())", "def extract_index_list(list1, list2, list3):\n    index_dict = {}\n    result = []\n    for i, (a, b, c) in enumerate(zip(list1, list2, list3)):\n        if a == b == c:\n            index_dict[i] = a\n    for i in sorted(index_dict):\n        result.append((i, index_dict[i]))\n    return result", "def extract_index_list(l1, l2, l3):\n    index_set = set(range(min(len(l1), len(l2), len(l3))))\n    common_indices = [i for i in index_set if l1[i] == l2[i] == l3[i]]\n    return common_indices", "def extract_index_list(list1, list2, list3):\n    def extract_indices(lst):\n        indices = {}\n        for i, value in enumerate(lst):\n            if value in indices:\n                indices[value].append(i)\n            else:\n                indices[value] = [i]\n        return indices\n\n    indices1 = extract_indices(list1)\n    indices2 = extract_indices(list2)\n    indices3 = extract_indices(list3)\n\n    common_indices = []\n    for value, idxs1 in indices1.items():\n        if value in indices2 and value in indices3:\n            common_indices.extend(idxs1)\n\n    return sorted(common_indices)", "def extract_index_list(l1, l2, l3):\n    result = []\n    i, j, k = 0, 0, 0\n    while i < len(l1) and j < len(l2) and k < len(l3):\n        if l1[i] == l2[j] == l3[k]:\n            result.append(l1[i])\n            i += 1\n            j += 1\n            k += 1\n        elif l1[i] < l2[j]:\n            i += 1\n        elif l2[j] < l3[k]:\n            j += 1\n        else:\n            k += 1\n    return result", "def extract_index_list(l1, l2, l3):\n    set1 = set(l1)\n    set2 = set(l2)\n    set3 = set(l3)\n    return list(set1 & set2 & set3)"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 755, "entry_point": "second_smallest", "codes": ["def second_smallest(lst):\n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.remove(min(unique_elements))\n    return min(unique_elements)", "def second_smallest(numbers):\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    \n    smallest = second_smallest = float('inf')\n    \n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    \n    if second_smallest == float('inf'):\n        raise ValueError(\"List must contain at least two distinct elements\")\n    \n    return second_smallest", "def second_smallest(numbers):\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    \n    first, second = float('inf'), float('inf')\n    for num in numbers:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n    \n    if second == float('inf'):\n        raise ValueError(\"List must contain at least two distinct elements\")\n    \n    return second", "def second_smallest(lst):\n    if len(lst) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    \n    first, second = float('inf'), float('inf')\n    for num in lst:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n    \n    if second == float('inf'):\n        raise ValueError(\"List must contain at least two distinct elements\")\n    \n    return second\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs or (isinstance(lhs, list) and isinstance(rhs, list) and all(_equivalent(l, r) for l, r in zip(lhs, rhs)))", "def second_smallest(numbers):\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    \n    first, second = float('inf'), float('inf')\n    \n    for number in numbers:\n        if number <= first:\n            first, second = number, first\n        elif number < second:\n            second = number\n    \n    if second == float('inf'):\n        raise ValueError(\"List must contain at least two distinct elements\")\n    \n    return second", "def second_smallest(numbers):\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    first, second = float('inf'), float('inf')\n    for num in numbers:\n        if num <= first:\n            first, second = num, first\n        elif num < second:\n            second = num\n    return second if second != float('inf') else first"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 764, "entry_point": "number_ctr", "codes": ["def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "def number_ctr(s):\n    return sum(char.isdigit() for char in s)", "def number_ctr(s):\n    return sum(1 for char in s if char.isdigit())", "def number_ctr(s):\n    count = 0\n    i = 0\n    while i < len(s):\n        if s[i].isdigit():\n            count += 1\n            while i + 1 < len(s) and s[i + 1].isdigit():\n                i += 1\n        i += 1\n    return count", "import re\n\ndef number_ctr(s):\n    return len(re.findall(r'\\d+', s))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 765, "entry_point": "is_polite", "codes": ["def is_polite(n):\n    count = 0\n    i = 1\n    while True:\n        if i & (i - 1):\n            count += 1\n            if count == n:\n                return i\n        i += 1", "def is_polite(n):\n    k = 0\n    while n > 0:\n        n -= 1 if k & 1 else 0\n        k += 1\n    return k", "def is_polite(n):\n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return is_polite(n // 2)\n    else:\n        return not is_polite(n - 1)", "def is_polite(n):\n    count = 0\n    num = 0\n    while True:\n        num += 1\n        if not is_evil(num):\n            count += 1\n            if count == n:\n                return num\n\ndef is_evil(num):\n    return '0' not in bin(num)", "def is_polite(n):\n    return n >= 3 and all((n & (1 << i)) == 0 for i in range(n.bit_length()))", "def is_polite(n):\n    accumulator = 0\n    i = 1\n    while accumulator < n:\n        accumulator += 1 if i & (i - 1) else 0\n        i += 1\n    return accumulator == n"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 766, "entry_point": "pair_wise", "codes": ["def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "def pair_wise(lst):\n    for i in range(len(lst) - 1):\n        yield (lst[i], lst[i + 1])", "def pair_wise(lst):\n    return zip(lst, lst[1:])", "def pair_wise(items):\n    return zip(items, items[1:])"], "rewards": [1.0, -1.0, -1.0, -1.0]}
{"id": 768, "entry_point": "check_Odd_Parity", "codes": ["def check_Odd_Parity(n):\n    return bin(n).count('1') % 2 != 0", "def check_Odd_Parity(n):\n    count = 0\n    for bit in bin(n)[2:]:\n        count += int(bit)\n    return count % 2 == 1", "def check_Odd_Parity(n):\n    parity = 0\n    while n:\n        parity = ~parity\n        n = n & (n - 1)\n    return parity & 1", "def check_Odd_Parity(n):\n    parity = 0\n    for digit in str(n):\n        parity ^= int(digit)\n    return parity & 1 == 1", "def check_Odd_Parity(n):\n    if n == 0:\n        return False\n    if n == 1:\n        return True\n    return check_Odd_Parity(n & (n - 1))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 774, "entry_point": "check_email", "codes": ["import re\n\ndef check_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return 'Valid Email' if re.match(pattern, email) else 'Invalid Email'", "import re\n\ndef check_email(email):\n    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(email_regex, email) is not None", "import re\n\ndef check_email(email):\n    return re.match(r\"[^@]+@[^@]+\\.[^@]+\", email) is not None", "def check_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None", "import re\n\ndef check_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None", "import re\n\ndef check_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 775, "entry_point": "odd_position", "codes": ["def odd_position(lst):\n    return all(lst[i] % 2 == i % 2 for i in range(len(lst)))", "def odd_position(lst):\n    return all(val % 2 != 0 for idx, val in enumerate(lst) if idx % 2 != 0)", "def odd_position(lst):\n    return all(x % 2 == 1 for i, x in enumerate(lst) if i % 2 == 1)", "def odd_position(lst):\n    return all(idx % 2 != 0 and val % 2 != 0 for idx, val in enumerate(lst))", "def odd_position(lst):\n    sorted_lst = sorted(lst)\n    for i in range(1, len(sorted_lst), 2):\n        if sorted_lst[i] % 2 == 0:\n            return False\n    return True", "def odd_position(lst):\n    n = len(lst)\n    if n % 2 == 0:\n        return False\n    return all(lst[i] % 2 == i % 2 for i in range(n))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 778, "entry_point": "pack_consecutive_duplicates", "codes": ["from itertools import groupby\n\ndef pack_consecutive_duplicates(lst):\n    return [list(group) for _, group in groupby(lst)]", "def pack_consecutive_duplicates(lst):\n    from itertools import groupby\n    return [list(group) for _, group in groupby(lst)]", "from itertools import groupby\n\ndef pack_consecutive_duplicates(lst):\n    return [list(group) for _, group in groupby(lst)]\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "def pack_consecutive_duplicates(lst):\n    def pack_helper(lst, prev, acc):\n        if not lst:\n            return acc\n        if lst[0] == prev:\n            return pack_helper(lst[1:], prev, acc + [lst[0]])\n        else:\n            return pack_helper(lst[1:], lst[0], acc + [prev])\n\n    if not lst:\n        return []\n    return [pack_helper(lst[1:], lst[0], [lst[0]])]", "def pack_consecutive_duplicates(lst):\n    return [list(group) for _, group in itertools.groupby(lst)]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 781, "entry_point": "count_Divisors", "codes": ["def count_Divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return 'Even' if count % 2 == 0 else 'Odd'", "def count_Divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return \"Even\" if count % 2 == 0 else \"Odd\"", "def count_Divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "def count_Divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count % 2 == 0", "def count_Divisors(n):\n    return sum(1 for i in range(1, int(n**0.5) + 1) if n % i == 0) % 2 == 0", "def count_Divisors(n):\n    def is_even(x):\n        return x % 2 == 0\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return is_even(count)"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 782, "entry_point": "Odd_Length_Sum", "codes": ["def Odd_Length_Sum(arr):\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        total_sum += ((i + 1) * (n - i) + 1) // 2 * arr[i]\n    return total_sum", "def Odd_Length_Sum(arr):\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        total_sum += ((i + 1) * (n - i) + 1) // 2 * arr[i]\n    return total_sum", "def Odd_Length_Sum(arr):\n    total_sum = 0\n    for length in range(1, len(arr) + 1, 2):\n        for start in range(len(arr) - length + 1):\n            total_sum += sum(arr[start:start + length])\n    return total_sum", "def Odd_Length_Sum(arr):\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        start = i\n        while start < n:\n            subarray = arr[start:start + (i + 1)]\n            if len(subarray) % 2 != 0:\n                total_sum += sum(subarray)\n            start += 1\n    return total_sum"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 783, "entry_point": "rgb_to_hsv", "codes": ["def rgb_to_hsv(r, g, b):\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n    if mx == mn:\n        h = 0\n    elif mx == r:\n        h = (60 * ((g - b) / df) + 360) % 360\n    elif mx == g:\n        h = (60 * ((b - r) / df) + 120) % 360\n    elif mx == b:\n        h = (60 * ((r - g) / df) + 240) % 360\n    if mx == 0:\n        s = 0\n    else:\n        s = (df / mx) * 100\n    v = mx * 100\n    return h, s, v", "def rgb_to_hsv(r, g, b):\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    max_color = max(r, g, b)\n    min_color = min(r, g, b)\n    diff = max_color - min_color\n\n    if max_color == 0:\n        h = 0\n    elif max_color == r:\n        h = (60 * ((g - b) / diff) + 360) % 360\n    elif max_color == g:\n        h = (60 * ((b - r) / diff) + 120) % 360\n    elif max_color == b:\n        h = (60 * ((r - g) / diff) + 240) % 360\n\n    s = 0 if max_color == 0 else (diff / max_color) * 100\n    v = max_color * 100\n\n    return h, s, v", "def rgb_to_hsv(r, g, b):\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    delta = mx - mn\n    if delta == 0:\n        h = 0\n    elif mx == r:\n        h = (60 * ((g - b) / delta) + 360) % 360\n    elif mx == g:\n        h = (60 * ((b - r) / delta) + 120) % 360\n    elif mx == b:\n        h = (60 * ((r - g) / delta) + 240) % 360\n    s = delta / mx if mx != 0 else 0\n    v = mx\n    return h, s, v", "def rgb_to_hsv(r, g, b):\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    max_color = max(r, g, b)\n    min_color = min(r, g, b)\n    diff = max_color - min_color\n    if max_color == min_color:\n        h = 0\n    elif max_color == r:\n        h = (60 * ((g - b) / diff) + 360) % 360\n    elif max_color == g:\n        h = (60 * ((b - r) / diff) + 120) % 360\n    elif max_color == b:\n        h = (60 * ((r - g) / diff) + 240) % 360\n    s = diff / max_color if max_color != 0 else 0\n    v = max_color\n    return h, s, v", "def rgb_to_hsv(r, g, b):\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    max_c = max(r, g, b)\n    min_c = min(r, g, b)\n    delta = max_c - min_c\n\n    if delta == 0:\n        h = 0\n    elif max_c == r:\n        h = (60 * ((g - b) / delta) + 360) % 360\n    elif max_c == g:\n        h = (60 * ((b - r) / delta) + 120) % 360\n    elif max_c == b:\n        h = (60 * ((r - g) / delta) + 240) % 360\n\n    s = 0 if max_c == 0 else delta / max_c\n    v = max_c\n\n    return h, s, v", "def rgb_to_hsv(r, g, b):\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    max_rgb = max(r, g, b)\n    min_rgb = min(r, g, b)\n    delta = max_rgb - min_rgb\n\n    if delta == 0:\n        h = 0\n    elif max_rgb == r:\n        h = (60 * ((g - b) / delta) + 360) % 360\n    elif max_rgb == g:\n        h = (60 * ((b - r) / delta) + 120) % 360\n    else:\n        h = (60 * ((r - g) / delta) + 240) % 360\n\n    s = 0 if max_rgb == 0 else delta / max_rgb\n    v = max_rgb\n\n    return h, s, v"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 784, "entry_point": "mul_even_odd", "codes": ["def mul_even_odd(numbers):\n    evens = {x for x in numbers if x % 2 == 0}\n    odds = {x for x in numbers if x % 2 != 0}\n    return min(evens) * min(odds) if evens and odds else None", "def mul_even_odd(numbers):\n    evens = [x for x in numbers if x % 2 == 0]\n    odds = [x for x in numbers if x % 2 != 0]\n    return evens[0] * odds[0] if evens and odds else None", "def mul_even_odd(numbers):\n    even, odd = None, None\n    for num in numbers:\n        if even is None and num % 2 == 0:\n            even = num\n        elif odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            return even * odd\n    return None", "def mul_even_odd(numbers):\n    even_found = False\n    odd_found = False\n    even_product = 1\n    odd_product = 1\n    \n    for num in numbers:\n        if num % 2 == 0:\n            if not even_found:\n                even_product = num\n                even_found = True\n            else:\n                even_product *= num\n        else:\n            if not odd_found:\n                odd_product = num\n                odd_found = True\n            else:\n                odd_product *= num\n    \n    return even_product * odd_product", "def mul_even_odd(numbers):\n    even_found = odd_found = False\n    even_product = odd_product = 1\n\n    for num in numbers:\n        if num % 2 == 0:\n            even_product *= num\n            even_found = True\n        else:\n            odd_product *= num\n            odd_found = True\n\n        if even_found and odd_found:\n            return even_product * odd_product\n\n    return None"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 790, "entry_point": "even_position", "codes": ["def even_position(lst):\n    return all(i % 2 == 0 for i in lst[::2])", "def even_position(lst):\n    return all(lst[i] % 2 == i % 2 for i in range(len(lst)))", "def even_position(lst):\n    return all(lst[i] % 2 == 0 for i in range(0, len(lst), 2))", "def even_position(lst):\n    even_indices = set(range(0, len(lst), 2))\n    even_numbers = set(range(0, len(lst), 2))\n    return even_indices == even_numbers.intersection(lst)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 791, "entry_point": "remove_nested", "codes": ["def remove_nested(tup):\n    return tuple(x for x in tup if not isinstance(x, tuple))", "def remove_nested(record):\n    return tuple(part for part in record if not isinstance(part, tuple))", "def remove_nested(t):\n    return tuple(item for item in t if not isinstance(item, tuple))", "def remove_nested(tup):\n    result = []\n    for item in tup:\n        if isinstance(item, tuple):\n            for subitem in item:\n                result.append(subitem)\n        else:\n            result.append(item)\n    return tuple(result)", "def remove_nested(t):\n    while isinstance(t[0], tuple):\n        t = t[0]\n    return t", "def remove_nested(t):\n    stack = []\n    for item in t:\n        if isinstance(item, tuple):\n            for sub_item in reversed(item):\n                stack.append(sub_item)\n        else:\n            stack.append(item)\n    return tuple(reversed(stack))", "def remove_nested(tup):\n    def is_nested(obj):\n        return isinstance(obj, tuple) and len(obj) > 1\n\n    def remove_if_nested(obj):\n        if is_nested(obj):\n            return obj[1:]\n        return obj\n\n    return tuple(remove_if_nested(item) for item in tup)", "def remove_nested(record):\n    return record[0] if isinstance(record, tuple) and len(record) == 2 else record"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 792, "entry_point": "count_list", "codes": ["def count_list(lists):\n    return len(lists)", "def count_list(nested_lists):\n    count = 0\n    for sublist in nested_lists:\n        count += 1\n    return count", "def count_list(list_of_lists):\n    count = 0\n    for _ in list_of_lists:\n        count += 1\n    return count", "def count_list(lst):\n    if not isinstance(lst, list):\n        return 0\n    return 1 + sum(count_list(item) for item in lst)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 794, "entry_point": "text_starta_endb", "codes": ["def text_starta_endb(s):\n    return 'Found a match!' if s.startswith('a') and s.endswith('b') else 'Not matched!'", "def text_starta_endb(s):\n    return s.startswith('a') and s.endswith('b')", "import re\n\ndef text_starta_endb(text):\n    pattern = r'^a.*b$'\n    return bool(re.match(pattern, text))", "def text_starta_endb(text):\n    return text.startswith('a') and text.endswith('b')", "def text_starta_endb(s):\n    for i in range(len(s)):\n        if s.startswith('a') and s.endswith('b'):\n            return True\n    return False"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 795, "entry_point": "cheap_items", "codes": ["def cheap_items(items, n):\n    import heapq\n    return heapq.nsmallest(n, items, key=lambda x: x['price'])", "def cheap_items(data, n):\n    import heapq\n    return heapq.nsmallest(n, data, key=lambda x: x['price'])", "import heapq\n\ndef cheap_items(prices, n):\n    return heapq.nsmallest(n, prices)", "def cheap_items(items, n):\n    return heapq.nsmallest(n, items)", "def cheap_items(prices, n):\n    return heapq.nsmallest(n, prices)", "import heapq\n\ndef cheap_items(data, n):\n    return heapq.nsmallest(n, data, key=lambda x: x[1])", "def cheap_items(data, n):\n    import heapq\n    return heapq.nsmallest(n, data, key=lambda x: x[1])"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 797, "entry_point": "sum_in_Range", "codes": ["def sum_in_Range(l, r):\n    return sum(i for i in range(l, r + 1) if i % 2 != 0)", "def sum_in_Range(l, r):\n    return sum(num for num in range(l, r + 1) if num % 2 != 0)", "def sum_in_Range(l, r):\n    return sum(x for x in range(l, r + 1) if x % 2 != 0)", "def sum_in_Range(l, r):\n    return sum(range(l, r + 1, 2))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 799, "entry_point": "left_Rotate", "codes": ["def left_Rotate(x, n):\n    return (x << n) & 0xFFFFFFFF", "def left_Rotate(n, d):\n    return (n << d) & ((1 << 32) - 1)", "def left_Rotate(num, bits):\n    return (num << bits) & ((1 << 32) - 1)", "def left_Rotate(n, d):\n    binary_str = bin(n)[2:].zfill(d)\n    rotated_str = binary_str[d:] + binary_str[:d]\n    return int(rotated_str, 2)", "def left_Rotate(x, n):\n    return (x << n) | (x >> (x.bit_length() - n))", "def left_Rotate(n, d):\n    binary = bin(n)[2:]\n    rotated = binary[d:] + binary[:d]\n    return int(rotated, 2)", "def left_Rotate(number, d):\n    binary = bin(number)[2:]\n    rotated = binary[d:] + binary[:d]\n    return int(rotated, 2)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 801, "entry_point": "test_three_equal", "codes": ["def test_three_equal(a, b, c):\n    if a == b == c:\n        return 3\n    elif a == b or a == c or b == c:\n        return 2\n    else:\n        return 0", "def test_three_equal(a, b, c):\n    return sum(1 for x in [a, b, c] if x == a)", "def test_three_equal(a, b, c):\n    return len({a, b, c}) <= 1", "def test_three_equal(a, b, c):\n    count = 0\n    if a == b:\n        count += 1\n    if a == c:\n        count += 1\n    if b == c:\n        count += 1\n    return count", "def test_three_equal(a, b, c):\n    return (a == b) + (b == c) + (a == c)", "def test_three_equal(a, b, c):\n    count = {a: 0, b: 0, c: 0}\n    for num in count:\n        count[num] += 1\n    return 3 - len(set(count.values()))"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 806, "entry_point": "max_run_uppercase", "codes": ["def max_run_uppercase(s):\n    max_run = 0\n    current_run = 0\n    for char in s:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    return max_run", "def max_run_uppercase(s):\n    max_run = 0\n    current_run = 0\n    \n    for char in s:\n        if char.isupper():\n            current_run += 1\n        else:\n            max_run = max(max_run, current_run)\n            current_run = 0\n    \n    return max(max_run, current_run)", "def max_run_uppercase(s):\n    max_count = 0\n    current_count = 0\n    for char in s:\n        if char.isupper():\n            current_count += 1\n        else:\n            max_count = max(max_count, current_count)\n            current_count = 0\n    return max(max_count, current_count)", "import itertools\n\ndef max_run_uppercase(s):\n    return max(len(list(filter(str.isupper, list(group)))) for k, group in itertools.groupby(s))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 809, "entry_point": "check_smaller", "codes": ["def check_smaller(lhs, rhs):\n    return all(x > y for x, y in zip(lhs, rhs))", "def check_smaller(t1, t2):\n    return all(x > y for x, y in zip(t1, t2))", "def check_smaller(t1, t2):\n    return all(t2[i] < t1[i] for i in range(len(t2)))", "def check_smaller(lhs, rhs):\n    return all(x < y for x, y in zip(lhs, rhs))", "def check_smaller(lhs, rhs):\n    accumulator = []\n    for index, value in enumerate(rhs):\n        if value < lhs[index]:\n            accumulator.append(True)\n        else:\n            accumulator.append(False)\n    return tuple(accumulator)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 811, "entry_point": "check_identical", "codes": ["def check_identical(lhs, rhs):\n    return lhs == rhs", "def check_identical(lhs, rhs):\n    return sorted(lhs) == sorted(rhs)", "def check_identical(lhs, rhs):\n    return len(lhs) == len(rhs) and all(x == y for x, y in zip(lhs, rhs))", "def _equivalent(_lhs, _rhs):\n    return _lhs == _rhs"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 813, "entry_point": "string_length", "codes": ["def string_length(s):\n    return len(s)", "def string_length(s):\n    return sum(1 for _ in s)", "def string_length(s):\n    return sum(1 for _ in enumerate(s))", "def string_length(s):\n    return sum(ord(char) - ord('a') + 1 for char in s)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 814, "entry_point": "rombus_area", "codes": ["def rombus_area(p, q): return (p * q) / 2", "def rombus_area(diagonal1, diagonal2):\n    return 0.5 * diagonal1 * diagonal2", "def rombus_area(p1, p2, p3, p4):\n    diagonals = {p1, p2, p3, p4}\n    if len(diagonals) != 2:\n        raise ValueError(\"Invalid points for a rombus\")\n    d1, d2 = next(iter(diagonals)), next(iter(diagonals - {d1}))\n    return 0.5 * d1 * d2", "def rombus_area(p1, p2, p3, p4):\n    diagonals = {\n        'd1': abs(p1[0] - p3[0]) + abs(p1[1] - p3[1]),\n        'd2': abs(p2[0] - p4[0]) + abs(p2[1] - p4[1])\n    }\n    return (diagonals['d1'] * diagonals['d2']) / 2"], "rewards": [1.0, 1.0, -1.0, -1.0]}
{"id": 816, "entry_point": "clear_tuple", "codes": ["def clear_tuple(_tuple):\n    return ()", "def clear_tuple(t):\n    return ()", "def clear_tuple(t):\n    return tuple()", "def clear_tuple(t):\n    result = ()\n    while t:\n        t = t[1:]\n        result = result + (None,)\n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 817, "entry_point": "div_of_nums", "codes": ["div_of_nums = lambda lst, m, n: list(filter(lambda x: x % m == 0 or x % n == 0, lst))", "def div_of_nums(nums, m, n):\n    return [num for num in nums if num % m == 0 or num % n == 0]", "def div_of_nums(numbers, m, n):\n    return list(filter(lambda x: x % m == 0 or x % n == 0, numbers))", "def div_of_nums(numbers, m, n):\n    return (x for x in numbers if x % m == 0 or x % n == 0)", "def div_of_nums(numbers, m, n):\n    return (num for num in numbers if num % m == 0 or num % n == 0)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 820, "entry_point": "check_monthnum_number", "codes": ["def check_monthnum_number(monthnum):\n    return monthnum == 2", "def check_monthnum_number(month_num):\n    return month_num == 2", "def check_monthnum_number(month):\n    return month == 2", "def check_monthnum_number(month):\n    return month in (1, 3, 5, 7, 8, 10, 12) or (month == 2 and True)", "def check_monthnum_number(month):\n    return month in (1, 3, 5, 7, 8, 10, 12)", "def check_monthnum_number(month):\n    return month in {1, 3, 5, 7, 8, 10, 12} or (month == 2 and False)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 822, "entry_point": "pass_validity", "codes": ["def pass_validity(password):\n    return 8 <= len(password) <= 12 and any(c.isupper() for c in password) and any(c.isdigit() for c in password) and any(c.islower() for c in password) and any(not c.isalnum() for c in password)", "def pass_validity(password):\n    return (len(password) >= 8 and\n            any(char.isdigit() for char in password) and\n            any(char.isupper() for char in password) and\n            any(char.islower() for char in password) and\n            any(not char.isalnum() for char in password))", "def pass_validity(password):\n    return (len(password) >= 8 and\n            any(c.islower() for c in password) and\n            any(c.isupper() for c in password) and\n            any(c.isdigit() for c in password) and\n            any(c in \"!@#$%^&*()\" for c in password))", "def pass_validity(password):\n    return len(password) >= 8 and len(set(password)) == len(password)", "def pass_validity(password):\n    return len(password) >= 8 and any(c.isdigit() for c in password) and any(c.isalpha() for c in password)", "def pass_validity(password):\n    stack = []\n    for char in password:\n        if char.isalpha():\n            stack.append(char)\n        elif not stack or stack.pop() != char.upper():\n            return False\n    return not stack", "def pass_validity(password):\n    def is_valid_rec(subpass):\n        if len(subpass) < 2:\n            return False\n        if subpass[0] == subpass[1]:\n            return False\n        if subpass[1] == subpass[2]:\n            return False\n        if subpass[2] == subpass[3]:\n            return False\n        if subpass[3] == subpass[4]:\n            return False\n        if subpass[4] == subpass[5]:\n            return False\n        if subpass[5] == subpass[6]:\n            return False\n        return True\n\n    return is_valid_rec(password)", "def pass_validity(password):\n    dp = [[False] * 4 for _ in range(len(password) + 1)]\n    dp[0][0] = True\n    for i in range(1, len(password) + 1):\n        dp[i][0] = dp[i-1][0] or (dp[i-1][1] and password[i-1] != password[i-2])\n        dp[i][1] = dp[i-1][1] or (dp[i-1][2] and password[i-1] != password[i-2])\n        dp[i][2] = dp[i-1][2] or (dp[i-1][3] and password[i-1] != password[i-2])\n        dp[i][3] = dp[i-1][3] or (dp[i-1][0] and password[i-1] != password[i-2])\n    return dp[len(password)][3]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 825, "entry_point": "access_elements", "codes": ["def access_elements(lst, indices):\n    return [lst[i] for i in indices]", "def access_elements(lst, indices):\n    return [lst[i] for i in indices if i >= 0]", "def access_elements(lst, indices):\n    return [lst[i] for i in indices if i < len(lst)]", "def access_elements(lst, indices):\n    return [lst[i] for i in indices if i % 2 == 0]", "def access_elements(lst, indices):\n    return [lst[i] for i in indices if i % 2 != 0]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 827, "entry_point": "sum_column", "codes": ["def sum_column(data, column_index):\n    return sum(row[column_index] for row in data)", "def sum_column(matrix, col):\n    return sum(row[col] for row in matrix)", "def sum_column(matrix, col_index):\n    return sum(row[col_index] for row in matrix)", "def sum_column(matrix, col):\n    return sum(sorted(row)[col] for row in matrix)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 828, "entry_point": "count_alpha_dig_spl", "codes": ["def count_alpha_dig_spl(s):\n    alpha_count = sum(c.isalpha() for c in s)\n    dig_count = sum(c.isdigit() for c in s)\n    spl_count = sum(not c.isalnum() for c in s)\n    return alpha_count, dig_count, spl_count", "def count_alpha_dig_spl(s):\n    alpha = dig = spl = 0\n    for char in s:\n        if char.isalpha():\n            alpha += 1\n        elif char.isdigit():\n            dig += 1\n        else:\n            spl += 1\n    return alpha, dig, spl", "def count_alpha_dig_spl(s):\n    alpha_count = 0\n    dig_count = 0\n    spl_count = 0\n    for char in s:\n        if char.isalpha():\n            alpha_count += 1\n        elif char.isdigit():\n            dig_count += 1\n        else:\n            spl_count += 1\n    return alpha_count, dig_count, spl_count", "def count_alpha_dig_spl(s):\n    counts = {'alpha': 0, 'digit': 0, 'special': 0}\n    for char in s:\n        if char.isalpha():\n            counts['alpha'] += 1\n        elif char.isdigit():\n            counts['digit'] += 1\n        else:\n            counts['special'] += 1\n    return counts"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 830, "entry_point": "round_up", "codes": ["import math\n\ndef round_up(number, digits):\n    factor = 10 ** -digits\n    return round(math.ceil(number / factor) * factor, digits)", "def round_up(number, digits):\n    factor = 10 ** digits\n    return (number + factor - 1) // factor * factor", "def round_up(number, digits):\n    factor = 10 ** -digits\n    return round(number / factor) * factor", "import math\n\ndef round_up(number, digits):\n    factor = 10 ** -digits\n    return round(number / factor) * factor", "def round_up(number, ndigits):\n    factor = 10 ** ndigits\n    return (number + factor - 1) // factor * factor", "import math\n\ndef round_up(number, digits):\n    factor = 10 ** digits\n    return math.ceil(number / factor) * factor"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 833, "entry_point": "get_key", "codes": ["def get_key(_dict):\n    return list(_dict.keys())", "def get_key(d):\n    return list(d.keys())", "def get_key(dictionary):\n    return list(dictionary.keys())", "def get_key(d, i):\n    return list(d.keys())[i]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 834, "entry_point": "generate_matrix", "codes": ["def generate_matrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    row, col, dir_idx = 0, 0, 0\n    for num in range(1, n * n + 1):\n        matrix[row][col] = num\n        next_row, next_col = row + directions[dir_idx][0], col + directions[dir_idx][1]\n        if 0 <= next_row < n and 0 <= next_col < n and matrix[next_row][next_col] == 0:\n            row, col = next_row, next_col\n        else:\n            dir_idx = (dir_idx + 1) % 4\n            row, col = row + directions[dir_idx][0], col + directions[dir_idx][1]\n    return matrix", "def generate_matrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n    for layer in range((n + 1) // 2):\n        for i in range(layer, n - layer):\n            matrix[layer][i] = num ** 2\n            num += 1\n        for i in range(layer + 1, n - layer):\n            matrix[i][n - layer - 1] = num ** 2\n            num += 1\n        for i in range(n - layer - 2, layer - 1, -1):\n            matrix[n - layer - 1][i] = num ** 2\n            num += 1\n        for i in range(n - layer - 2, layer, -1):\n            matrix[i][layer] = num ** 2\n            num += 1\n    return matrix", "def generate_matrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n    for layer in range((n + 1) // 2):\n        r, c = layer, layer\n        while c < n - layer:\n            matrix[r][c] = num ** 2\n            num += 1\n            c += 1\n        while r < n - layer:\n            matrix[r][c] = num ** 2\n            num += 1\n            r += 1\n        while c > layer:\n            matrix[r][c] = num ** 2\n            num += 1\n            c -= 1\n        while r > layer:\n            matrix[r][c] = num ** 2\n            num += 1\n            r -= 1\n    return matrix", "def generate_matrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n    top, bottom, left, right = 0, n - 1, 0, n - 1\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            matrix[top][i] = num ** 2\n            num += 1\n        top += 1\n        for i in range(top, bottom + 1):\n            matrix[i][right] = num ** 2\n            num += 1\n        right -= 1\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num ** 2\n                num += 1\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num ** 2\n                num += 1\n            left += 1\n    return matrix", "def generate_matrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    top, bottom, left, right = 0, n - 1, 0, n - 1\n    num = 1\n    \n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            matrix[top][i] = num ** 2\n            num += 1\n        top += 1\n        \n        for i in range(top, bottom + 1):\n            matrix[i][right] = num ** 2\n            num += 1\n        right -= 1\n        \n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num ** 2\n                num += 1\n            bottom -= 1\n        \n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num ** 2\n                num += 1\n            left += 1\n    \n    return matrix\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "def generate_matrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n    row_start, row_end = 0, n - 1\n    col_start, col_end = 0, n - 1\n    \n    while row_start <= row_end and col_start <= col_end:\n        for i in range(col_start, col_end + 1):\n            matrix[row_start][i] = num ** 2\n            num += 1\n        row_start += 1\n        \n        for i in range(row_start, row_end + 1):\n            matrix[i][col_end] = num ** 2\n            num += 1\n        col_end -= 1\n        \n        if row_start <= row_end:\n            for i in range(col_end, col_start - 1, -1):\n                matrix[row_end][i] = num ** 2\n                num += 1\n            row_end -= 1\n        \n        if col_start <= col_end:\n            for i in range(row_end, row_start - 1, -1):\n                matrix[i][col_start] = num ** 2\n                num += 1\n            col_start += 1\n    \n    return matrix"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 835, "entry_point": "slope", "codes": ["def slope(x1, y1, x2, y2):\n    return (y2 - y1) / (x2 - x1)", "def slope(x1, y1, x2, y2):\n    if x2 == x1:\n        raise ValueError(\"Vertical line, slope is undefined\")\n    return (y2 - y1) / (x2 - x1)", "def slope(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    return (y2 - y1) / (x2 - x1)", "def slope(points):\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    return (y2 - y1) / (x2 - x1)", "def slope(points):\n    (x1, y1), (x2, y2) = points\n    return (y2 - y1) / (x2 - x1)"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 837, "entry_point": "cube_Sum", "codes": ["def cube_Sum(n):\n    return sum(x**3 for x in range(1, 2*n, 2))", "def cube_Sum(n):\n    return sum((2*i + 1)**3 for i in range(n))", "def cube_Sum(n):\n    return sum((2*i - 1)**3 for i in range(1, n+1))", "def cube_Sum(n):\n    return (n**2 * (2*n**2 - 1)) // 3"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 839, "entry_point": "sort_tuple", "codes": ["def sort_tuple(tuples):\n    return sorted(tuples, key=lambda x: x[0])", "def sort_tuple(_lst):\n    return sorted(_lst, key=lambda x: x[0])", "def sort_tuple(_lst):\n    _lst.sort(key=lambda x: x[0])\n    return _lst", "def sort_tuple(tuples):\n    def compare_tuples(t1, t2):\n        return t1[0] < t2[0]\n    \n    return sorted(tuples, key=compare_tuples)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 843, "entry_point": "nth_super_ugly_number", "codes": ["import heapq\n\ndef nth_super_ugly_number(n, primes):\n    ugly_numbers = [1]\n    prime_indices = [0] * len(primes)\n    \n    while len(ugly_numbers) < n:\n        next_ugly = min(primes[i] * ugly_numbers[prime_indices[i]] for i in range(len(primes)))\n        ugly_numbers.append(next_ugly)\n        \n        for i in range(len(primes)):\n            if primes[i] * ugly_numbers[prime_indices[i]] == next_ugly:\n                prime_indices[i] += 1\n    \n    return ugly_numbers[n - 1]", "import heapq\n\ndef nth_super_ugly_number(n, primes):\n    uglies = [1]\n    def gen(prime):\n        for ugly in uglies:\n            yield ugly * prime\n    merged = heapq.merge(*map(gen, primes))\n    while len(uglies) < n:\n        ugly = next(merged)\n        if ugly != uglies[-1]:\n            uglies.append(ugly)\n    return uglies[-1]", "def nth_super_ugly_number(n, primes):\n    import heapq\n    uglies = [1]\n    def gen(prime):\n        for ugly in uglies:\n            yield ugly * prime\n    merged = heapq.merge(*map(gen, primes))\n    while len(uglies) < n:\n        ugly = next(merged)\n        if ugly != uglies[-1]:\n            uglies.append(ugly)\n    return uglies[-1]", "import heapq\n\ndef nth_super_ugly_number(n, primes):\n    ugly_numbers = [1]\n    prime_indices = [0] * len(primes)\n    \n    while len(ugly_numbers) < n:\n        next_ugly = min(ugly_numbers[i] * p for i, p in enumerate(primes))\n        ugly_numbers.append(next_ugly)\n        \n        for i, p in enumerate(primes):\n            if next_ugly == ugly_numbers[i] * p:\n                prime_indices[i] += 1\n    \n    return ugly_numbers[n-1]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 845, "entry_point": "find_Digits", "codes": ["from math import factorial\n\ndef find_Digits(n):\n    fact = factorial(n)\n    return len(str(fact))", "def find_Digits(n):\n    factorial = 1\n    for i in range(2, n + 1):\n        factorial *= i\n    return len(str(factorial))", "def find_Digits(n):\n    factorial = 1\n    for i in range(2, n + 1):\n        factorial *= i\n    digit_count = 0\n    while factorial:\n        digit_count += 1\n        factorial //= 10\n    return digit_count", "def find_Digits(n):\n    if n == 0 or n == 1:\n        return 1\n    digits = 0\n    for i in range(2, n + 1):\n        digits += sum(int(digit) for digit in str(i))\n    return digits", "from math import factorial\n\ndef find_Digits(n):\n    return sum(int(digit) for digit in str(factorial(n)))", "def find_Digits(n):\n    from math import factorial\n    from collections import Counter\n    \n    fact = factorial(n)\n    digit_count = Counter(str(fact))\n    return digit_count", "import math\n\ndef find_Digits(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 0\n    for i in range(2, n + 1):\n        result += math.log10(math.factorial(i))\n    return int(result) + 1", "import math\n\ndef find_Digits(n):\n    return sum(int(digit) for digit in str(math.factorial(n)))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 847, "entry_point": "lcopy", "codes": ["def lcopy(lst):\n    return lst[:]", "def lcopy(tup):\n    return list(tup)", "def lcopy(lst):\n    return list(set(lst))", "def lcopy(singleton_tuple):\n    return [item for index, item in enumerate(singleton_tuple[0])]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 849, "entry_point": "Sum", "codes": ["def Sum(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_sum = 0\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            prime_sum += i\n    return prime_sum", "def Sum(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    sum_of_primes = 0\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            sum_of_primes += i\n    return sum_of_primes", "def Sum(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    sum_primes = 0\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            sum_primes += i\n    return sum_primes", "def Sum(n):\n    if n <= 1:\n        return 0\n    prime_divisors = {}\n    # Check divisibility by 2\n    while n % 2 == 0:\n        if 2 in prime_divisors:\n            prime_divisors[2] += 1\n        else:\n            prime_divisors[2] = 1\n        n //= 2\n    # Check for odd divisors\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            if factor in prime_divisors:\n                prime_divisors[factor] += 1\n            else:\n                prime_divisors[factor] = 1\n            n //= factor\n        factor += 2\n    # If n is a prime number greater than 2\n    if n > 2:\n        prime_divisors[n] = 1\n    # Calculate the sum of all prime divisors\n    return sum(factor * exp for factor, exp in prime_divisors.items())", "def Sum(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def sum_of_primes(n, current=2, sum=0):\n        if n == 1:\n            return sum\n        if n % current == 0 and is_prime(current):\n            return sum_of_primes(n // current, current, sum + current)\n        return sum_of_primes(n, current + 1, sum)\n\n    return sum_of_primes(n)", "def Sum(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_divisors_sum = 0\n    for i in range(2, n + 1):\n        while n % i == 0 and is_prime(i):\n            prime_divisors_sum += i\n            n //= i\n    return prime_divisors_sum"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 850, "entry_point": "is_triangleexists", "codes": ["def is_triangleexists(a, b, c):\n    return a + b + c == 180 and a > 0 and b > 0 and c > 0", "def is_triangleexists(a, b, c):\n    return a + b + c == 180 and 0 < a < 180 and 0 < b < 180 and 0 < c < 180", "def is_triangleexists(a, b, c):\n    if a <= 0 or b <= 0 or c <= 0:\n        return False\n    if a + b + c != 180:\n        return False\n    return True", "def is_triangleexists(angles):\n    angles.sort()\n    while len(angles) > 1:\n        if angles[0] + angles[1] <= angles[2]:\n            return False\n        angles.pop(0)\n    return True", "def is_triangleexists(angles):\n    return sum(angles) == 180 and all(0 < angle < 180 for angle in angles)", "def is_triangleexists(angles):\n    angles.sort()\n    return angles[0] > 0 and angles[0] + angles[1] > angles[2]", "def is_triangleexists(angles):\n    dp = [False] * (180 + 1)\n    dp[0] = True\n    \n    for angle in angles:\n        for i in range(180, angle - 1, -1):\n            dp[i] = dp[i] or dp[i - angle]\n    \n    return dp[179]", "def is_triangleexists(angles):\n    return sum(angles) == 180 and any(a > 0 for a in reversed(angles))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 853, "entry_point": "sum_of_odd_Factors", "codes": ["def sum_of_odd_Factors(n):\n    result = 1\n    for i in range(3, int(n**0.5) + 1, 2):\n        count = 0\n        current_sum = 1\n        current_term = 1\n        while n % i == 0:\n            count += 1\n            n //= i\n            current_term *= i\n            current_sum += current_term\n        if count > 0:\n            result *= current_sum\n    if n > 2:\n        result *= (1 + n)\n    return result", "def sum_of_odd_Factors(n):\n    result = 1\n    while n % 2 == 0:\n        n //= 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        count = 0\n        current_sum = 1\n        current_term = 1\n        while n % i == 0:\n            count += 1\n            n //= i\n            current_term *= i\n            current_sum += current_term\n        if count > 0:\n            result *= current_sum\n    if n > 2:\n        result *= (1 + n)\n    return result", "def sum_of_odd_Factors(n):\n    result = 1\n    # Iterate through possible factors\n    for i in range(3, int(n**0.5) + 1, 2):\n        count = 0\n        current_sum = 1\n        current_term = 1\n        # Check if i is a factor of n\n        while n % i == 0:\n            count += 1\n            n //= i\n            current_term *= i\n            current_sum += current_term\n        result *= current_sum\n    # If n is still greater than 2, it must be an odd factor\n    if n > 2:\n        result *= (1 + n)\n    return result", "def sum_of_odd_Factors(n):\n    result = 1\n    factor = 2\n    while n >= factor * factor:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n            if factor % 2:\n                result *= factor\n    if n > 1 and n % 2:\n        result *= n\n    return result", "def sum_of_odd_Factors(n):\n    result = 0\n    if n % 2 == 1:\n        result += n\n    for i in range(3, int(n**0.5) + 1, 2):\n        count = 0\n        current_sum = 1\n        current_term = 1\n        while n % i == 0:\n            count += 1\n            n //= i\n            current_term *= i\n            current_sum += current_term\n        if count % 2 == 1:\n            result += current_sum\n    if n > 2 and n % 2 == 1:\n        result += 1\n    return result", "def sum_of_odd_Factors(n):\n    result = 1\n    count = 0\n    current_factor = 3\n    \n    while n % 2 == 0:\n        n //= 2\n    \n    while current_factor * current_factor <= n:\n        if n % current_factor == 0:\n            count = 0\n            while n % current_factor == 0:\n                n //= current_factor\n                count += 1\n            if count % 2 == 1:\n                result *= (current_factor ** (count + 1) - 1) // (current_factor - 1)\n        current_factor += 2\n    \n    if n > 1:\n        result *= (n ** 2 - 1) // (n - 1)\n    \n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 855, "entry_point": "check_Even_Parity", "codes": ["def check_Even_Parity(n):\n    return bin(n).count('1') % 2 == 0", "def check_Even_Parity(number):\n    return sum(int(bit) for bit in bin(number)[2:]) % 2 == 0", "def check_Even_Parity(num):\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count % 2 == 0", "def check_Even_Parity(n):\n    if n == 0:\n        return True\n    if n == 1:\n        return False\n    return check_Even_Parity(n ^ (n >> 1))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 857, "entry_point": "listify_list", "codes": ["def listify_list(strings):\n    return list(map(list, strings))", "def listify_list(strings):\n    return list(map(str, strings))", "def listify_list(strings):\n    return list(map(lambda s: [s], strings))", "def listify_list(strings):\n    return list(map(lambda x: [x], strings))"], "rewards": [1.0, -1.0, -1.0, -1.0]}
{"id": 858, "entry_point": "count_list", "codes": ["def count_list(nested_lists):\n    return len(nested_lists) ** 2", "def count_list(lst):\n    return len(lst) ** 2", "def count_list(input_list):\n    i = len(input_list) - 1\n    return (i + 1) ** 2", "def count_list(nested_lists):\n    count = 0\n    i = 0\n    while i >= 0:\n        if i < len(nested_lists):\n            count += 1\n        i += 1\n    return count ** 2"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 859, "entry_point": "sub_lists", "codes": ["def sub_lists(lst):\n    from itertools import combinations\n    return [list(sublist) for r in range(len(lst) + 1) for sublist in combinations(lst, r)]", "def sub_lists(lst):\n    if not lst:\n        return [[]]\n    return sub_lists(lst[:-1]) + [s + [lst[-1]] for s in sub_lists(lst[:-1])]", "def sub_lists(lst):\n    result = [[]]\n    for i in lst:\n        result += [sublist + [i] for sublist in result]\n    return result", "def sub_lists(lst):\n    result = []\n    for i in range(len(lst) + 1):\n        for j in range(i + 1, len(lst) + 1):\n            result.append(lst[i:j])\n    return result", "def sub_lists(lst):\n    return [lst[:i] for i in range(len(lst) + 1)]", "def sub_lists(lst):\n    return sum([lst[:i] for i in range(len(lst) + 1)], [])", "def sub_lists(lst):\n    result = [[]]\n    for i in range(len(lst)):\n        result += [lst[:i+1]]\n    return result\n\ndef _equivalent(lhs, rhs):\n    return set(map(tuple, lhs)) == set(map(tuple, rhs))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 860, "entry_point": "check_alphanumeric", "codes": ["import re\n\ndef check_alphanumeric(candidate):\n    return 'Accept' if re.match(r'^.*[a-zA-Z0-9]$', candidate) else 'Discard'", "import re\n\ndef check_alphanumeric(candidate):\n    return bool(re.search(r'^\\w+$', candidate))", "def check_alphanumeric(s):\n    return bool(re.search(r'\\w$', s))", "import re\n\ndef check_alphanumeric(candidate):\n    return re.fullmatch(r'\\w*$', candidate) is not None", "def check_alphanumeric(candidate):\n    return 'Accept' if re.match(r'^.*[a-zA-Z0-9]$', candidate) else 'Discard'", "import re\n\ndef check_alphanumeric(s):\n    return bool(re.search(r'\\w$', s))"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 862, "entry_point": "n_common_words", "codes": ["def n_common_words(text, n):\n    from collections import Counter\n    words = text.split()\n    word_counts = Counter(words)\n    most_common = word_counts.most_common(n)\n    return most_common", "from collections import Counter\n\ndef n_common_words(text, n):\n    words = text.split()\n    word_counts = Counter(words)\n    most_common = word_counts.most_common(n)\n    return most_common", "from collections import Counter\nimport re\n\ndef n_common_words(text, n):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    most_common = Counter(words).most_common(n)\n    return most_common", "from collections import Counter\nimport heapq\n\ndef n_common_words(text, n):\n    words = text.split()\n    word_count = Counter(words)\n    most_common = heapq.nmost_common(word_count, n)\n    return most_common", "from collections import Counter\nimport heapq\n\ndef n_common_words(text, n):\n    words = text.split()\n    word_counts = Counter(words)\n    most_common = heapq.nmost_common(word_counts, n)\n    return most_common", "import heapq\nfrom collections import Counter\n\ndef n_common_words(text, n):\n    words = text.split()\n    word_counts = Counter(words)\n    most_common = heapq.nmost_common(word_counts, n)\n    return most_common", "from collections import Counter\n\ndef n_common_words(text, n):\n    words = text.split()\n    word_counts = Counter(words)\n    most_common = word_counts.most_common(n)\n    return [word for word, count in most_common]", "from collections import Counter\nfrom heapq import nlargest\n\ndef n_common_words(text, n):\n    words = text.split()\n    word_count = Counter(words)\n    most_common = nlargest(n, word_count.items(), key=lambda x: x[1])\n    return dict(most_common)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 865, "entry_point": "ntimes_list", "codes": ["def ntimes_list(lst, n):\n    return list(map(lambda x: x * n, lst))", "def ntimes_list(lst, n):\n    return list(map(lambda x: x, lst * n))", "def ntimes_list(lst, n):\n    for _ in range(n):\n        yield from lst", "def ntimes_list(lst, n):\n    return list(map(lambda _: lst, range(n)))"], "rewards": [1.0, -1.0, -1.0, -1.0]}
{"id": 869, "entry_point": "remove_list_range", "codes": ["def remove_list_range(lst, low, high):\n    return [sublist for sublist in lst if all(low <= item <= high for item in sublist)]", "def remove_list_range(lst, low, high):\n    return [sublist for sublist in lst if low <= min(sublist) and max(sublist) <= high]", "def remove_list_range(lst, min_len, max_len):\n    result = []\n    stack = lst.copy()\n    \n    while stack:\n        current = stack.pop()\n        if isinstance(current, list):\n            stack.extend(reversed(current))\n        elif min_len <= len(current) <= max_len:\n            result.append(current)\n    \n    return result[::-1]", "def remove_list_range(lst, min_len, max_len):\n    def is_valid_length(sublist):\n        return min_len <= len(sublist) <= max_len\n    \n    return [sublist for sublist in lst if is_valid_length(sublist)]", "def remove_list_range(lst, min_len, max_len):\n    index = 0\n    while index < len(lst):\n        if len(lst[index]) < min_len or len(lst[index]) > max_len:\n            del lst[index]\n        else:\n            index += 1", "def remove_list_range(lists, min_len, max_len):\n    return [lst for lst in lists if min_len <= len(lst) <= max_len]", "def remove_list_range(lst, start, end):\n    return [sublist for sublist in lst if start <= len(sublist) <= end]"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 874, "entry_point": "check_Concat", "codes": ["def check_Concat(lhs, rhs):\n    return lhs == rhs * (len(lhs) // len(rhs))", "def check_Concat(lhs, rhs):\n    if not lhs or not rhs:\n        return False\n    n = len(lhs)\n    m = len(rhs)\n    if n % m != 0:\n        return False\n    return lhs == rhs * (n // m)", "def check_Concat(_lhs, _rhs):\n    return _rhs in _lhs and len(_rhs) > 0", "def check_Concat(s):\n    for i in range(1, len(s) // 2 + 1):\n        if len(s) % i == 0:\n            substring = s[:i]\n            if substring * (len(s) // i) == s:\n                return True\n    return False", "def check_Concat(s1, s2):\n    for i in range(1, len(s1)):\n        if s1[i:] + s1[:i] == s2:\n            return True\n    return False", "def check_Concat(_lhs, _rhs):\n    return _lhs == _rhs + _rhs", "def check_Concat(s):\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            prefix = s[:i]\n            if prefix * (n // i) == s:\n                return True\n    return False"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 875, "entry_point": "min_difference", "codes": ["def min_difference(pairs):\n    pairs.sort()\n    return min(abs(a - b) for a, b in pairs)", "def min_difference(pairs):\n    pairs.sort(key=lambda x: x[0])\n    min_diff = float('inf')\n    for i in range(len(pairs) - 1):\n        diff = pairs[i+1][0] - pairs[i][1]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "def min_difference(pairs):\n    pairs.sort()\n    min_diff = float('inf')\n    for i in range(1, len(pairs)):\n        diff = pairs[i][0] - pairs[i-1][1]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "def min_difference(tuples):\n    tuples.sort()\n    min_diff = float('inf')\n    for i in range(1, len(tuples)):\n        diff = tuples[i][0] - tuples[i-1][1]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff", "def min_difference(pairs):\n    pairs.sort()\n    min_diff = float('inf')\n    for i in range(1, len(pairs)):\n        diff = pairs[i][0] - pairs[i-1][1]\n        min_diff = min(min_diff, diff)\n    return min_diff", "def min_difference(tuples):\n    # Sort the list of tuples based on the first element of each tuple\n    sorted_tuples = sorted(tuples)\n    # Initialize the minimum difference to a large value\n    min_diff = float('inf')\n    # Use a two-pointer scanning approach to find the minimum difference\n    for i in range(len(sorted_tuples) - 1):\n        diff = sorted_tuples[i+1][0] - sorted_tuples[i][0]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 876, "entry_point": "lcm", "codes": ["def lcm(x, y):\n    from math import gcd\n    return x * y // gcd(x, y)", "def lcm(a, b):\n    return abs(a * b) // gcd(a, b)\n\nfrom math import gcd", "import math\n\ndef lcm(a, b):\n    return abs(a * b) // math.gcd(a, b)", "def lcm(a, b):\n    return abs(a * b) // gcd(a, b)", "def lcm(a, b):\n    return a * b // math.gcd(a, b)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 877, "entry_point": "sort_String", "codes": ["def sort_String(s):\n    return ''.join(sorted(s))", "def sort_String(s):\n    def _sort(s):\n        return ''.join(sorted(s))\n    \n    return _sort(s)", "def sort_String(s):\n    accumulator = list(s)\n    for i in range(len(accumulator)):\n        for j in range(i + 1, len(accumulator)):\n            if accumulator[i] > accumulator[j]:\n                accumulator[i], accumulator[j] = accumulator[j], accumulator[i]\n    return ''.join(accumulator)", "def sort_String(s: str) -> str:\n    s = list(s)\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        while left < right and s[right].lower() < s[right - 1].lower():\n            right -= 1\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        while left < right and s[left].lower() < s[left - 1].lower():\n            left += 1\n        s[right], s[left] = s[left], s[right]\n        right -= 1\n    \n    return ''.join(s)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 881, "entry_point": "sum_even_odd", "codes": ["def sum_even_odd(numbers):\n    even_sum = 0\n    odd_sum = 0\n    found_even = False\n    found_odd = False\n    \n    for number in numbers:\n        if number % 2 == 0 and not found_even:\n            even_sum += number\n            found_even = True\n        elif number % 2 != 0 and not found_odd:\n            odd_sum += number\n            found_odd = True\n    \n    return even_sum + odd_sum", "def sum_even_odd(numbers):\n    sums = {'even': 0, 'odd': 0}\n    for number in numbers:\n        if number % 2 == 0:\n            sums['even'] += number\n        else:\n            sums['odd'] += number\n    return sums['even'], sums['odd']", "def sum_even_odd(lst):\n    even_sum = 0\n    odd_sum = 0\n    for num in lst:\n        if num % 2 == 0:\n            even_sum += num\n        else:\n            odd_sum += num\n    return even_sum, odd_sum", "def sum_even_odd(numbers):\n    even_sum = sum(num for num in numbers if num % 2 == 0)\n    odd_sum = sum(num for num in numbers if num % 2 != 0)\n    return even_sum, odd_sum", "def sum_even_odd(numbers):\n    even_sum = 0\n    odd_sum = 0\n    for num in numbers:\n        if num % 2 == 0:\n            even_sum += num\n        else:\n            odd_sum += num\n    return even_sum, odd_sum", "def sum_even_odd(numbers):\n    evens = [num for num in numbers if num % 2 == 0]\n    odds = [num for num in numbers if num % 2 != 0]\n    return sum(evens), sum(odds)"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 884, "entry_point": "all_Bits_Set_In_The_Given_Range", "codes": ["def all_Bits_Set_In_The_Given_Range(n, left, right):\n    return (n & ((1 << right) - 1)) == ((1 << (right - left + 1)) - 1) << (left - 1)", "def all_Bits_Set_In_The_Given_Range(number, left, right):\n    mask = ((1 << (right - left + 1)) - 1) << (left - 1)\n    return (number & mask) == mask", "def all_Bits_Set_In_The_Given_Range(number, start, end):\n    mask = ((1 << (end - start + 1)) - 1) << (start - 1)\n    return (number & mask) == mask", "def all_Bits_Set_In_The_Given_Range(num, start, end):\n    mask = ((1 << end) - 1) ^ ((1 << (start - 1)) - 1)\n    return (num & mask) == (1 << (start - 1)) - 1", "def all_Bits_Set_In_The_Given_Range(number, start, end):\n    mask = ((1 << (end + 1)) - 1) ^ ((1 << start) - 1)\n    return (number & mask) == mask", "def all_Bits_Set_In_The_Given_Range(number, start, end):\n    return (number & ((1 << (end + 1)) - 1)) == (number & ~((1 << start) - 1))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 888, "entry_point": "substract_elements", "codes": ["def substract_elements(lhs, rhs):\n    return tuple(tuple(x - y for x, y in zip(inner_lhs, inner_rhs))\n                for inner_lhs, inner_rhs in zip(lhs, rhs))", "def substract_elements(lhs, rhs):\n    if isinstance(lhs, tuple) and isinstance(rhs, tuple):\n        return tuple(substract_elements(l, r) for l, r in zip(lhs, rhs))\n    return lhs - rhs", "def substract_elements(lhs, rhs):\n    if isinstance(lhs, tuple) and isinstance(rhs, tuple):\n        return tuple(substract_elements(x, y) for x, y in zip(lhs, rhs))\n    else:\n        return lhs - rhs", "def substract_elements(nested_tuples):\n    def is_leaf(node):\n        return isinstance(node, int)\n\n    def substract(node1, node2):\n        if is_leaf(node1) and is_leaf(node2):\n            return node1 - node2\n        elif isinstance(node1, tuple) and isinstance(node2, tuple):\n            return tuple(substract_elements((n1, n2)) for n1, n2 in zip(node1, node2))\n        else:\n            raise ValueError(\"Both nodes must be either leaves or tuples of the same length\")\n\n    stack = list(nested_tuples)\n    while stack:\n        node1 = stack.pop()\n        node2 = stack.pop()\n        result = substract(node1, node2)\n        stack.append(result)\n    return stack[0]", "def substract_elements(nested_tuple):\n    return tuple(substract_elements(sub_tuple) if isinstance(sub_tuple, tuple) else -sub_tuple for sub_tuple in nested_tuple)", "def substract_elements(nested_tuple):\n    def substract(t1, t2):\n        return tuple(substract_elements(x, y) if isinstance(x, tuple) and isinstance(y, tuple) else x - y for x, y in zip(t1, t2))\n    \n    def flatten(t):\n        for x in t:\n            if isinstance(x, tuple):\n                yield from flatten(x)\n            else:\n                yield x\n    \n    def unflatten(lst):\n        result = []\n        for x in lst:\n            if isinstance(result[-1], list):\n                result[-1].append(x)\n            else:\n                result.append([x])\n        return tuple(tuple(sub) for sub in result)\n    \n    flat_lhs = list(flatten(nested_tuple))\n    flat_rhs = list(flatten(nested_tuple))\n    result_flat = substract(flat_lhs, flat_rhs)\n    return unflatten(result_flat)", "def substract_elements(t1, t2):\n    return tuple(x - y for x, y in zip(t1, t2))", "def substract_elements(nested_tuple):\n    def substract(t1, t2):\n        if isinstance(t1, tuple) and isinstance(t2, tuple):\n            return tuple(substract(t1[i], t2[i]) for i in range(len(t1)))\n        return t1 - t2\n    \n    if not nested_tuple or len(nested_tuple) == 0:\n        return ()\n    \n    if len(nested_tuple) == 1:\n        return nested_tuple[0]\n    \n    result = nested_tuple[0]\n    for t in nested_tuple[1:]:\n        result = substract(result, t)\n    \n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 892, "entry_point": "remove_spaces", "codes": ["def remove_spaces(s):\n    return ' '.join(s.split())", "def remove_spaces(s):\n    return ' '.join(s.split())", "def remove_spaces(s):\n    return ''.join(helper(s))\n\ndef helper(s):\n    return ' '.join(filter(None, s.split()))", "def remove_spaces(s):\n    return ''.join(result)", "def remove_spaces(s):\n    return ''.join(s.split())", "def remove_spaces(s: str) -> str:\n    return ''.join(s.split())"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 894, "entry_point": "float_to_tuple", "codes": ["def float_to_tuple(float_str):\n    return tuple(map(float, float_str.split(',')))", "def float_to_tuple(s):\n    return tuple(map(float, s.split()))", "def float_to_tuple(s):\n    return tuple(float(x) for x in s.split())", "def float_to_tuple(float_str):\n    return tuple(map(float, float_str.split()))", "def float_to_tuple(float_string):\n    return tuple(map(float, float_string.split()))", "def float_to_tuple(s: str) -> tuple:\n    return tuple(map(float, s.split()))"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 895, "entry_point": "max_sum_subseq", "codes": ["def max_sum_subseq(nums):\n    if not nums:\n        return 0\n    \n    incl = 0\n    excl = 0\n    \n    for num in nums:\n        excl_new = max(excl, incl)\n        incl = excl + num\n        excl = excl_new\n    \n    return max(excl, incl)", "def max_sum_subseq(nums):\n    if not nums:\n        return 0\n    include = 0\n    exclude = 0\n    for num in nums:\n        new_exclude = max(exclude, include)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude)", "def max_sum_subseq(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    elif n == 1:\n        return nums[0]\n    \n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    \n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \n    return dp[n-1]", "def max_sum_subseq(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    \n    incl = max(arr[0], arr[1])\n    excl = 0\n    \n    for i in range(2, len(arr)):\n        excl_new = max(excl, incl)\n        incl = excl + arr[i]\n        excl = excl_new\n    \n    return max(excl, incl)", "def max_sum_subseq(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    elif n == 1:\n        return arr[0]\n    \n    incl = max(arr[0], arr[1])\n    excl = 0\n    \n    for i in range(2, n):\n        excl_new = max(excl, incl)\n        incl = excl + arr[i]\n        excl = excl_new\n    \n    return max(excl, incl)", "def max_sum_subseq(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    elif n == 1:\n        return nums[0]\n    \n    incl = max(nums[0], nums[1])\n    excl = 0\n    \n    for i in range(2, n):\n        excl_new = max(excl, incl)\n        incl = excl + nums[i]\n        excl = excl_new\n    \n    return max(excl, incl)", "def max_sum_subseq(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    incl = max(nums[0], nums[1])\n    excl = 0\n    for i in range(2, len(nums)):\n        excl_new = max(excl, incl)\n        incl = excl + nums[i]\n        excl = excl_new\n    return max(excl, incl)", "def max_sum_subseq(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    incl = max(nums[0], nums[1])\n    excl = 0\n    \n    for num in nums[2:]:\n        excl_new = max(excl, incl)\n        incl = excl + num\n        excl = excl_new\n    \n    return max(excl, incl)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 901, "entry_point": "smallest_multiple", "codes": ["import math\n\ndef smallest_multiple(n):\n    return math.lcm(*range(1, n + 1))", "def smallest_multiple(n):\n    from math import gcd\n    from functools import reduce\n    return reduce(lambda x, y: x * y // gcd(x, y), range(1, n + 1))", "def smallest_multiple(n):\n    from math import gcd\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n    result = 1\n    for i in range(2, n + 1):\n        result = lcm(result, i)\n    return result", "def smallest_multiple(n):\n    lcm = 1\n    for i in range(2, n + 1):\n        while lcm % i != 0:\n            lcm += 1\n    return lcm", "def smallest_multiple(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // smallest_multiple(a, b)\n\ndef smallest_multiple(n):\n    result = 1\n    for i in range(2, n + 1):\n        result = lcm(result, i)\n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 902, "entry_point": "add_dict", "codes": ["def add_dict(_lhs, _rhs):\n    return {k: _lhs.get(k, 0) + _rhs.get(k, 0) for k in set(_lhs) | set(_rhs)}", "def add_dict(d1, d2):\n    result = d1.copy()\n    for k, v in d2.items():\n        result[k] = result.get(k, 0) + v\n    return result", "def add_dict(d1, d2):\n    combined = d1.copy()\n    for k, v in d2.items():\n        combined[k] = combined.get(k, 0) + v\n    return combined", "def add_dict(_lhs, _rhs):\n    combined = _lhs.copy()\n    for k in combined:\n        if k in _rhs:\n            combined[k] += _rhs[k]\n    return combined", "def add_dict(lhs, rhs):\n    combined = lhs.copy()\n    combined.update((k, lhs[k] + rhs[k]) for k in set(lhs) & set(rhs))\n    return combined"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 903, "entry_point": "count_Unset_Bits", "codes": ["def count_Unset_Bits(n):\n    total_bits = 0\n    for i in range(1, n + 1):\n        total_bits += bin(i).count('0') - 1\n    return total_bits", "def count_Unset_Bits(n):\n    total = 0\n    for i in range(1, n + 1):\n        total += bin(i).count('0')\n    return total", "def count_Unset_Bits(n):\n    count = 0\n    for num in range(1, n + 1):\n        count += bin(num).count('0')\n    return count", "def count_Unset_Bits(n):\n    total = 0\n    for num in range(1, n + 1):\n        total += bin(num).count('0')\n    return total", "def count_Unset_Bits(n):\n    total_unset_bits = 0\n    for i in range(1, n + 1):\n        total_unset_bits += bin(i).count('0')\n    return total_unset_bits", "def count_Unset_Bits(n):\n    total_unset_bits = 0\n    for num in range(1, n + 1):\n        total_unset_bits += bin(num).count('0')\n    return total_unset_bits"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 904, "entry_point": "even_num", "codes": ["def even_num(n):\n    return n % 2 == 0", "def even_num(n):\n    return n == 0 or n % 2 == 0", "def even_num(n):\n    return {n % 2: False, 0: True}[n % 2]", "def even_num(n):\n    return n & 1 == 0"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 905, "entry_point": "sum_of_square", "codes": ["from math import comb\n\ndef sum_of_square(n):\n    return sum(comb(n, k) ** 2 for k in range(n + 1))", "def sum_of_square(n):\n    return (1 << (2 * n - 2))", "def sum_of_square(n):\n    if n == 0:\n        return 1\n    return 4 * sum_of_square(n - 1) + 1", "def sum_of_square(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = 2 * dp[i - 1] + i * dp[i - 1]\n    return dp[n] * dp[n]", "import math\n\ndef sum_of_square(n):\n    return (1 << (2 * n)) // (n + 1)", "import math\n\ndef sum_of_square(n):\n    return (2 ** (2 * n - 1)) // (2 * n)"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 911, "entry_point": "maximum_product", "codes": ["def maximum_product(nums):\n    import heapq\n    largest = heapq.nlargest(3, nums)\n    smallest = heapq.nsmallest(2, nums)\n    return max(largest[0] * largest[1] * largest[2], smallest[0] * smallest[1] * largest[0])", "import heapq\n\ndef maximum_product(nums):\n    max_nums = heapq.nlargest(3, nums)\n    min_nums = heapq.nsmallest(3, nums)\n    return max(max_nums[0] * max_nums[1] * max_nums[2], min_nums[0] * min_nums[1] * max_nums[0])", "import heapq\n\ndef maximum_product(nums):\n    largest = heapq.nlargest(3, nums)\n    smallest = heapq.nsmallest(3, nums)\n    return max(largest[0] * largest[1] * largest[2], largest[0] * smallest[0] * smallest[1])", "import heapq\n\ndef maximum_product(nums):\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 913, "entry_point": "end_num", "codes": ["def end_num(string):\n    return bool(string.endswith(('0', '1', '2', '3', '4', '5', '6', '7', '8', '9')))", "def end_num(s):\n    return s.endswith('0') or s.endswith('1') or s.endswith('2') or s.endswith('3') or s.endswith('4') or s.endswith('5') or s.endswith('6') or s.endswith('7') or s.endswith('8') or s.endswith('9')", "def end_num(string):\n    return string.endswith(\"0\") or string.endswith(\"1\") or string.endswith(\"2\") or string.endswith(\"3\") or string.endswith(\"4\") or string.endswith(\"5\") or string.endswith(\"6\") or string.endswith(\"7\") or string.endswith(\"8\") or string.endswith(\"9\")", "def end_num(string):\n    return bool(re.search(r\".*[0-9]$\", string))", "def end_num(string):\n    stack = []\n    for char in string:\n        stack.append(char)\n    if len(stack) < 2:\n        return False\n    return stack[-1] == 'm' and stack[-2] == 'n'"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 914, "entry_point": "is_Two_Alter", "codes": ["def is_Two_Alter(s):\n    return len(set(s)) == 2 and all(s[i] != s[i + 1] for i in range(len(s) - 1))", "def is_Two_Alter(s):\n    if len(s) < 2:\n        return False\n    a, b = s[0], s[1]\n    if a == b:\n        return False\n    return all(s[i] == a if i % 2 == 0 else s[i] == b for i in range(len(s)))", "def is_Two_Alter(s):\n    if len(s) < 2:\n        return False\n    char1, char2 = s[0], s[1]\n    if char1 == char2:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != char1 and s[i] != char2:\n            return False\n        char1, char2 = char2, s[i]\n    return True", "def is_Two_Alter(s):\n    if len(s) < 2:\n        return False\n    return s[1::2] == s[0] * ((len(s) + 1) // 2) and s[0::2] == s[1] * (len(s) // 2)", "def is_Two_Alter(s):\n    if len(s) < 2:\n        return False\n    return all(s[i] != s[i + 1] for i in range(len(s) - 1))", "def is_Two_Alter(s):\n    if len(s) < 2:\n        return False\n    first_char, second_char = s[0], s[1]\n    if first_char == second_char:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != first_char if i % 2 == 0 else second_char:\n            return False\n    return True", "def is_Two_Alter(s):\n    if len(s) < 2:\n        return False\n    first, second = s[0], s[1]\n    if first == second:\n        return False\n    for i in range(2, len(s)):\n        if s[i] != first if i % 2 == 0 else second:\n            return False\n    return True", "def is_Two_Alter(s):\n    if len(s) < 2:\n        return False\n    return s[0] != s[1] and all(s[i] == s[i - 2] for i in range(2, len(s)))\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs\n\n# Unit tests\nassert _equivalent(is_Two_Alter(\"ab\"), True)\nassert _equivalent(is_Two_Alter(\"aab\"), False)\nassert _equivalent(is_Two_Alter(\"abcd\"), True)\nassert _equivalent(is_Two_Alter(\"abab\"), True)\nassert _equivalent(is_Two_Alter(\"abc\"), False)\nassert _equivalent(is_Two_Alter(\"a\"), False)\nassert _equivalent(is_Two_Alter(\"ababab\"), True)\nassert _equivalent(is_Two_Alter(\"abababa\"), False)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 917, "entry_point": "text_uppercase_lowercase", "codes": ["def text_uppercase_lowercase(s):\n    return \"Found a match!\" if any(s[i].isupper() and s[i+1].islower() for i in range(len(s) - 1)) else \"Not matched!\"", "def text_uppercase_lowercase(s):\n    return \"Found a match!\" if any(s[i:i+2] == s[i].upper() + s[i+1].lower() for i in range(len(s) - 1)) else \"Not matched!\"", "import re\n\ndef text_uppercase_lowercase(s):\n    return \"Found a match!\" if re.search(r'[A-Z][a-z]+', s) else \"Not matched!\"", "import re\n\ndef text_uppercase_lowercase(s):\n    return re.findall(r'[A-Z][a-z]+', s)", "def text_uppercase_lowercase(s):\n    return ''.join(c for c in s if c.isupper() or (c.islower() and s[s.index(c)-1].isupper()))", "import re\n\ndef text_uppercase_lowercase(s):\n    return re.findall(r'[A-Z][a-z]+', s)", "def text_uppercase_lowercase(s):\n    return [s[i:i+2] for i in range(len(s) - 1) if s[i].isupper() and s[i+1].islower()]", "def text_uppercase_lowercase(s):\n    import re\n    return re.findall('[A-Z][a-z]+', s)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 919, "entry_point": "multiply_list", "codes": ["def multiply_list(lst):\n    return 1 if not lst else lst[0] * multiply_list(lst[1:])", "def multiply_list(lst):\n    result = 1\n    for item in lst:\n        result *= item\n    return result", "def multiply_list(items):\n    result = 1\n    for item in items:\n        result *= item\n    return result", "def multiply_list(lst):\n    return _equivalent(lst, 1, lambda x, y: x * y)", "def multiply_list(lst):\n    return reduce(lambda x, y: x * y, lst, 1)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 920, "entry_point": "remove_tuple", "codes": ["def remove_tuple(tuples):\n    return [t for t in tuples if any(t)]", "def remove_tuple(_tup_lst):\n    return [tup for tup in _tup_lst if any(tup)]", "def remove_tuple(lst):\n    return [t for t in lst if any(v is not None for v in t)]", "def remove_tuple(_tuple_list):\n    return tuple(t for t in _tuple_list if any(item is not None for item in t))", "def remove_tuple(tuples):\n    return tuple(t for t in tuples if any(t))", "def remove_tuple(tuples):\n    return tuple(filter(None, tuples))", "def remove_tuple(_tuples):\n    return tuple(t for t in _tuples if any(t))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 933, "entry_point": "camel_to_snake", "codes": ["import re\n\ndef camel_to_snake(s):\n    return re.sub(r'(?<!^)(?=[A-Z])', '_', s).lower()", "import re\n\ndef camel_to_snake(name):\n    return re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name).lower()", "import re\n\ndef camel_to_snake(name):\n    return re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name).replace('_', '_').lower()", "import re\n\ndef camel_to_snake(name):\n    return re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name).replace('_', '').replace(' ', '_')", "import re\n\ndef camel_to_snake(name):\n    return re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name).replace('_', '').lower()"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 934, "entry_point": "dealnnoy_num", "codes": ["def dealnnoy_num(n, m):\n    if n == 0 and m == 0:\n        return 1\n    if n == 0 or m == 0:\n        return 1\n    return dealnnoy_num(n-1, m) + dealnnoy_num(n, m-1) + dealnnoy_num(n-1, m-1)", "def dealnnoy_num(n):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(i + 1):\n            if i == 0 and j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + dp[i - 1][j - 1]\n    return dp[n][n]", "def dealnnoy_num(n):\n    if n == 0:\n        return 1\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n + 1):\n        for j in range(i + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n            if j < i:\n                dp[i][j] += dp[i - 1][j - 1]\n    return dp[n][n]", "def dealnnoy_num(n):\n    delannoy = {}\n    for i in range(n + 1):\n        for j in range(i + 1):\n            if i == 0 or j == 0:\n                delannoy[(i, j)] = 1\n            else:\n                delannoy[(i, j)] = delannoy[(i - 1, j)] + delannoy[(i, j - 1)] + delannoy[(i - 1, j - 1)]\n    return delannoy[(n, n)]", "def dealnnoy_num(n):\n    if n == 0:\n        return 1\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(i + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + 1\n            elif i == j:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + dp[i - 1][j - 1]\n    return dp[n][n]", "def dealnnoy_num(n):\n    dp = {0: {0: 1}}\n    for i in range(n + 1):\n        for j in range(i + 1):\n            dp[i][j] = (dp[i-1][j] if i > 0 else 0) + (dp[i][j-1] if j > 0 else 0) + (dp[i-1][j-1] if i > 0 and j > 0 else 0)\n    return dp[n][n]"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 936, "entry_point": "re_arrange_tuples", "codes": ["def re_arrange_tuples(tuples, order):\n    return [t for o in order for t in tuples if t[0] == o]", "def re_arrange_tuples(tuples, order):\n    return [tuples[i] for i in order]", "def re_arrange_tuples(tuples, order):\n    return tuple(t for _, t in sorted(zip(order, tuples)))", "def re_arrange_tuples(tuples, order):\n    return [t for t in tuples if t[0] in order]", "def re_arrange_tuples(tuples, order):\n    return tuple(sorted(tuples, key=lambda x: order.index(x[0])))", "def re_arrange_tuples(tuples_list, order_list):\n    return [t for o in order_list for t in tuples_list if o in t]"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 940, "entry_point": "heap_sort", "codes": ["import heapq\n\ndef heap_sort(arr):\n    heapq.heapify(arr)\n    sorted_arr = []\n    while arr:\n        sorted_arr.append(heapq.heappop(arr))\n    return sorted_arr", "def heap_sort(arr):\n    def heapify(n, i):\n        largest = i\n        l = 2 * i + 1\n        r = 2 * i + 2\n        if l < n and arr[i] < arr[l]:\n            largest = l\n        if r < n and arr[largest] < arr[r]:\n            largest = r\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(n, largest)\n\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(n, i)\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(i, 0)\n    return arr", "def heap_sort(arr):\n    def sift_down(start, end):\n        root = start\n        while True:\n            child = 2 * root + 1\n            if child > end:\n                break\n            if child + 1 <= end and arr[child] < arr[child + 1]:\n                child += 1\n            if arr[root] < arr[child]:\n                arr[root], arr[child] = arr[child], arr[root]\n                root = child\n            else:\n                break\n\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        sift_down(i, n - 1)\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        sift_down(0, i - 1)\n    return arr", "def heap_sort(arr):\n    def heapify(arr, n, i):\n        largest = i\n        l = 2 * i + 1\n        r = 2 * i + 2\n\n        if l < n and arr[i] < arr[l]:\n            largest = l\n\n        if r < n and arr[largest] < arr[r]:\n            largest = r\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    n = len(arr)\n\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)", "def heap_sort(arr):\n    n = len(arr)\n    \n    # Build a max heap\n    for i in range(n // 2 - 1, -1, -1):\n        _heapify(arr, n, i)\n    \n    # Extract elements from the heap\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # Swap\n        _heapify(arr, i, 0)\n\ndef _heapify(arr, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    \n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    \n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    \n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # Swap\n        _heapify(arr, n, largest)", "def heap_sort(arr):\n    n = len(arr)\n    for i in range(n, -1, -1):\n        _heapify(arr, n, i)\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        _heapify(arr, i, 0)\n\ndef _heapify(arr, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < n and arr[i] < arr[left]:\n        largest = left\n    if right < n and arr[largest] < arr[right]:\n        largest = right\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        _heapify(arr, n, largest)", "def heap_sort(arr):\n    n = len(arr)\n    # Build a maxheap.\n    for i in range(n // 2 - 1, -1, -1):\n        _heapify(arr, n, i)\n    # One by one extract elements\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # swap\n        _heapify(arr, i, 0)\n\ndef _heapify(arr, n, i):\n    largest = i  # Initialize largest as root\n    l = 2 * i + 1     # left = 2*i + 1\n    r = 2 * i + 2     # right = 2*i + 2\n\n    # See if left child of root exists and is\n    # greater than root\n    if l < n and arr[i] < arr[l]:\n        largest = l\n\n    # See if right child of root exists and is\n    # greater than root\n    if r < n and arr[largest] < arr[r]:\n        largest = r\n\n    # Change root, if needed\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # swap\n\n        # Heapify the root.\n        _heapify(arr, n, largest)", "def heap_sort(arr):\n    def heapify(arr, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[i] < arr[left]:\n            largest = left\n\n        if right < n and arr[largest] < arr[right]:\n            largest = right\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    n = len(arr)\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 941, "entry_point": "count_elim", "codes": ["def count_elim(lst):\n    return next((i for i, x in enumerate(lst) if isinstance(x, tuple)), len(lst))", "def count_elim(lst):\n    for i, x in enumerate(lst):\n        if isinstance(x, tuple):\n            return i\n    return len(lst)", "def count_elim(lst):\n    for i, element in enumerate(lst):\n        if isinstance(element, tuple):\n            return i\n    return len(lst)", "def count_elim(lst):\n    return sum(1 for x in lst if not isinstance(x, tuple))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 942, "entry_point": "check_element", "codes": ["def check_element(subset, s):\n    if not subset:\n        return False\n    elif subset[0] in s:\n        return True\n    else:\n        return check_element(subset[1:], s)", "def check_element(lst):\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return True\n        seen.add(item)\n    return False", "def check_element(lst, element):\n    return element in lst", "def check_element(lst, element):\n    seen = set()\n    for item in lst:\n        if item == element:\n            return True\n        seen.add(item)\n    return False", "def check_element(lst, element):\n    for item in lst:\n        if item == element:\n            return True\n    return False", "def check_element(lst):\n    return any(lst)"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 943, "entry_point": "combine_lists", "codes": ["import heapq\n\ndef combine_lists(list1, list2):\n    return list(heapq.merge(list1, list2))", "import heapq\n\ndef combine_lists(l1, l2):\n    return list(heapq.merge(l1, l2))", "import heapq\n\ndef combine_lists(lhs, rhs):\n    return list(heapq.merge(lhs, rhs))", "import heapq\n\ndef combine_lists(list1, list2):\n    return heapq.merge(list1, list2)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 946, "entry_point": "most_common_elem", "codes": ["from collections import Counter\n\ndef most_common_elem(text, n):\n    return Counter(text).most_common(n)", "from collections import Counter\n\ndef most_common_elem(text):\n    return Counter(text).most_common()", "def most_common_elem(text):\n    from collections import Counter\n    word_counts = Counter(text.split())\n    most_common = word_counts.most_common(1)\n    return most_common[0] if most_common else None", "def most_common_elem(text):\n    from collections import Counter\n    freq = Counter(text)\n    most_common = freq.most_common()\n    return most_common", "def most_common_elem(text):\n    from collections import Counter\n    counts = Counter(text)\n    sorted_counts = sorted(counts.items(), key=lambda x: (-x[1], x[0]))\n    most_common = [(char, count) for char, count in sorted_counts if count == sorted_counts[0][1]]\n    return most_common", "from collections import Counter\n\ndef _count_elements(text):\n    return Counter(text)\n\ndef most_common_elem(text):\n    return _count_elements(text).most_common()"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 948, "entry_point": "get_item", "codes": ["def get_item(t, index):\n    return t[index]", "def get_item(tup, index):\n    return tup[index]", "def get_item(t, index):\n    if index == 0:\n        return t[0]\n    elif index < 0:\n        return t[index]\n    else:\n        return get_item(t[1:], index - 1)", "def get_item(tup, index):\n    if index < 0 or index >= len(tup):\n        raise IndexError(\"Index out of range\")\n    return tup[index]\n\ndef _equivalent(_lhs, _rhs):\n    if _lhs is _rhs:\n        return True\n    if not isinstance(_lhs, tuple) or not isinstance(_rhs, tuple):\n        return False\n    if len(_lhs) != len(_rhs):\n        return False\n    for item1, item2 in zip(_lhs, _rhs):\n        if item1 != item2:\n            return False\n    return True", "def get_item(t, index):\n    stack = []\n    stack.append(t)\n    while index >= 0:\n        t = stack.pop()\n        if isinstance(t, tuple) and index < len(t):\n            stack.append(t[index])\n        index -= 1\n    return stack[0]", "def get_item(tup, index):\n    if index < 0 or index >= len(tup):\n        raise IndexError(\"Index out of range\")\n    return tup[index]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 949, "entry_point": "sort_list", "codes": ["def sort_list(tuples):\n    return sorted(tuples, key=lambda x: sum(len(str(digit)) for digit in x))", "def sort_list(tuples):\n    return sorted(tuples, key=lambda t: sum(len(str(x)) for x in t))", "def sort_list(tuples):\n    return sorted(tuples, key=lambda x: sum(len(str(abs(i))) for i in x))", "def sort_list(tuples_list):\n    return sorted(tuples_list, key=lambda t: sum(int(digit) for digit in str(t).replace(',', '')))", "def sort_list(tuples):\n    return sorted(tuples, key=lambda x: sum(map(len, str(abs(i)) for i in x)))", "def sort_list(tuples):\n    return sorted(tuples, key=lambda x: sum(map(len, str(abs(n)) for n in x)))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 951, "entry_point": "max_similar_indices", "codes": ["def max_similar_indices(list1, list2):\n    return [max(x, y) for x, y in zip(list1, list2)]", "def max_similar_indices(list1, list2):\n    return [(max(a, c), max(b, d)) for (a, b), (c, d) in zip(list1, list2)]", "def max_similar_indices(list1, list2):\n    return max(max(a, b) for a, b in zip(list1, list2))", "def max_similar_indices(list1, list2):\n    return [(max(a, b), max(c, d)) for (a, b), (c, d) in zip(list1, list2)]", "def max_similar_indices(list1, list2):\n    return [(max(x, y) for x, y in zip(sublist1, sublist2)) for sublist1, sublist2 in zip(list1, list2)]"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 952, "entry_point": "nCr_mod_p", "codes": ["from math import comb\n\ndef nCr_mod_p(n: int, r: int, p: int) -> int:\n    return comb(n, r) % p", "def nCr_mod_p(n, r, p):\n    from collections import defaultdict\n    mod = defaultdict(int)\n    mod[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, r), 0, -1):\n            mod[j] = (mod[j] + mod[j - 1]) % p\n    return mod[r]", "def nCr_mod_p(n, r, p):\n    if r > n:\n        return 0\n    num = [0] * (r + 1)\n    num[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, r), 0, -1):\n            num[j] = (num[j] + num[j - 1]) % p\n    return num[r]", "def nCr_mod_p(n, r, p):\n    from collections import Counter\n    from functools import reduce\n    from operator import mul\n\n    if r > n:\n        return 0\n\n    freq = Counter(range(n - r + 1, n + 1))\n    freq.subtract(range(1, r + 1))\n    freq += Counter({0: 1})\n    freq = list(freq.values())\n\n    numerator = reduce(mul, freq)\n    denominator = reduce(mul, range(1, r + 1))\n    return numerator * pow(denominator, p - 2, p) % p", "def nCr_mod_p(n, r, p):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    modinv = [0] * (r + 1)\n    modinv[1] = 1\n    for i in range(2, r + 1):\n        modinv[i] = (p - p // i) * modinv[p % i] % p\n    num = 1\n    den = 1\n    for i in range(1, r + 1):\n        num = (num * (n - i + 1)) % p\n        den = (den * i) % p\n    return (num * modinv[den]) % p", "def nCr_mod_p(n, r, p):\n    if r > n:\n        return 0\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator = (numerator * (n - i)) % p\n        denominator = (denominator * (i + 1)) % p\n    return (numerator * pow(denominator, p - 2, p)) % p", "def nCr_mod_p(n, r, p):\n    if r > n:\n        return 0\n    num = 1\n    den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den, p - 2, p)) % p", "def nCr_mod_p(n, r, p):\n    if r > n:\n        return 0\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 956, "entry_point": "split_list", "codes": ["import re\n\ndef split_list(text):\n    return re.findall('[A-Z][^A-Z]*', text)", "import re\n\ndef split_list(input_string):\n    return re.findall('[A-Z][^A-Z]*', input_string)", "import re\n\ndef split_list(s):\n    return re.findall('[A-Z][^A-Z]*', s)", "import re\n\ndef split_list(s):\n    return [part for part in re.split(r'[A-Z]', s) if part]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 959, "entry_point": "Average", "codes": ["def Average(numbers):\n    return sum(numbers) / len(numbers)", "def Average(lst):\n    return sum(lst) / len(lst)", "def Average(numbers):\n    return sum(numbers) / len(numbers)", "def Average(lst):\n    if not lst:\n        return 0\n    return lst[0] / len(lst) + Average(lst[1:])"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 961, "entry_point": "roman_to_int", "codes": ["def roman_to_int(s: str) -> int:\n    roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    for char in reversed(s):\n        value = roman_map[char]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    return total", "def roman_to_int(s: str) -> int:\n    roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    for char in s[::-1]:\n        value = roman_map[char]\n        if value >= prev_value:\n            total += value\n        else:\n            total -= value\n        prev_value = value\n    return total", "def roman_to_int(s: str) -> int:\n    roman_values = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    total = 0\n    prev_value = 0\n    for char in reversed(s):\n        value = roman_values[char]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    return total", "def roman_to_int(s: str) -> int:\n    roman_map = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n    return sum(map(lambda x: roman_map[x[0]] * (1 if x[0] not in \"VXDLM\" or x[0] >= x[1] else -1), zip(s, s[1:] + \"0\")))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 962, "entry_point": "sum_Even", "codes": ["def sum_Even(l, r):\n    return sum(x for x in range(l, r + 1) if x % 2 == 0)", "def sum_Even(l, r):\n    return sum(filter(lambda x: x % 2 == 0, range(l, r + 1)))", "def sum_Even(l, r):\n    return sum(i for i in range(r, l - 1, -1) if i % 2 == 0)", "def sum_Even(l, r):\n    return (r // 2 - (l - 1) // 2) * (l + r) // 2"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 965, "entry_point": "camel_to_snake", "codes": ["def camel_to_snake(s):\n    return ''.join(['_' + i.lower() if i.isupper() else i for i in s]).lstrip('_')", "def camel_to_snake(camel_str):\n    return ''.join(['_' + char.lower() if char.isupper() else char for char in camel_str]).lstrip('_')", "def camel_to_snake(name):\n    return ''.join(['_' + i.lower() if i.isupper() else i for i in name]).lstrip('_')", "def camel_to_snake(s):\n    snake = []\n    for char in s:\n        if char.isupper():\n            snake.append('_')\n            snake.append(char.lower())\n        else:\n            snake.append(char)\n    return ''.join(snake)", "def camel_to_snake(s):\n    return ''.join(c if c.islower() or c.isdigit() else '_' + c.lower() for i, c in enumerate(s))", "def camel_to_snake(name):\n    import re\n    return re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name).replace('_', '')", "def camel_to_snake(s):\n    def helper(s, i):\n        if i == len(s):\n            return []\n        if s[i].isupper():\n            return helper(s[:i], i) + ['_' + s[i].lower()] + helper(s[i+1:], i+1)\n        else:\n            return helper(s[:i+1], i+1)\n    return ''.join(helper(s, 0)).lstrip('_')"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 966, "entry_point": "remove_empty", "codes": ["def remove_empty(lst):\n    return list(filter(None, lst))", "def remove_empty(lst):\n    return [t for t in lst if t]", "def remove_empty(tuples):\n    return [t for t in tuples if t]", "def remove_empty(tuples):\n    return tuple(t for t in tuples if t)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 969, "entry_point": "join_tuples", "codes": ["def join_tuples(tuples):\n    result = []\n    for tup in tuples:\n        if result and result[-1][0] == tup[0]:\n            result[-1] += tup[1:]\n        else:\n            result.append(tup)\n    return result", "def join_tuples(tuples):\n    result = []\n    for t in tuples:\n        if result and t[0] == result[-1][0]:\n            result[-1] = result[-1] + t[1:]\n        else:\n            result.append(t)\n    return result", "def join_tuples(tuples):\n    result = []\n    for i in range(len(tuples)):\n        if i == 0 or tuples[i][0] != tuples[i - 1][0]:\n            result.append(tuples[i])\n        else:\n            result[-1] = result[-1] + tuples[i][1:]\n    return result", "def join_tuples(tuples):\n    stack = []\n    for tup in tuples:\n        if stack and stack[-1][0] == tup[0]:\n            stack[-1] = (stack[-1][0], stack[-1][1] + tup[1])\n        else:\n            stack.append(tup)\n    return stack", "def join_tuples(tuples):\n    result = []\n    seen = set()\n    for tup in tuples:\n        if tup[0] not in seen:\n            result.append(tup)\n            seen.add(tup[0])\n        else:\n            for i in range(len(result)):\n                if result[i][0] == tup[0]:\n                    result[i] = (result[i][0], result[i][1] + tup[1])\n                    break\n    return result", "def join_tuples(tuples):\n    grouped = {}\n    for t in tuples:\n        key = t[0]\n        if key in grouped:\n            grouped[key].append(t)\n        else:\n            grouped[key] = [t]\n    \n    result = []\n    for key, group in grouped.items():\n        if len(group) > 1:\n            result.append((key, *map(lambda x: x[1:], group)))\n        else:\n            result.append(group[0])\n    \n    return result", "def join_tuples(tuples):\n    result = {}\n    for tup in tuples:\n        if tup[0] not in result:\n            result[tup[0]] = tup[1:]\n        else:\n            result[tup[0]] += tup[1:]\n    return tuple(result.items())", "def join_tuples(tuples):\n    result = []\n    for tup in tuples:\n        if result and result[-1][0] == tup[0]:\n            result[-1] = (result[-1][0], result[-1][1] + tup[1])\n        else:\n            result.append(tup)\n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 971, "entry_point": "maximum_segments", "codes": ["def maximum_segments(n, a, b, c):\n    max_segments = 0\n    for i in range(n // a + 1):\n        for j in range(n // b + 1):\n            for k in range(n // c + 1):\n                if i * a + j * b + k * c == n:\n                    max_segments = max(max_segments, i + j + k)\n    return max_segments", "def maximum_segments(n, a, b, c):\n    dp = [-1] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        if i >= a:\n            dp[i] = max(dp[i], dp[i - a] + 1)\n        if i >= b:\n            dp[i] = max(dp[i], dp[i - b] + 1)\n        if i >= c:\n            dp[i] = max(dp[i], dp[i - c] + 1)\n\n    return dp[n]", "def maximum_segments(n, a, b, c):\n    dp = [-1] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        if i >= a and dp[i - a] != -1:\n            dp[i] = max(dp[i], dp[i - a] + 1)\n        if i >= b and dp[i - b] != -1:\n            dp[i] = max(dp[i], dp[i - b] + 1)\n        if i >= c and dp[i - c] != -1:\n            dp[i] = max(dp[i], dp[i - c] + 1)\n    \n    return dp[n]", "def maximum_segments(n, a, b, c):\n    max_segments = 0\n    for i in range(n // a + 1):\n        for j in range(n // b + 1):\n            k = (n - i * a - j * b) // c\n            if i * a + j * b + k * c == n:\n                max_segments = max(max_segments, i + j + k)\n    return max_segments", "def maximum_segments(n, a, b, c):\n    dp = [0] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        max_segments = 0\n        if i >= a:\n            max_segments = max(max_segments, dp[i - a] + 1)\n        if i >= b:\n            max_segments = max(max_segments, dp[i - b] + 1)\n        if i >= c:\n            max_segments = max(max_segments, dp[i - c] + 1)\n        dp[i] = max_segments\n    \n    return dp[n]", "def maximum_segments(n, a, b, c):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if i - a >= 0:\n            dp[i] = max(dp[i], dp[i - a] + 1)\n        if i - b >= 0:\n            dp[i] = max(dp[i], dp[i - b] + 1)\n        if i - c >= 0:\n            dp[i] = max(dp[i], dp[i - c] + 1)\n    return dp[n]", "def maximum_segments(n, a, b, c):\n    dp = [0] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        if i >= a and dp[i - a] != -1:\n            dp[i] = max(dp[i], dp[i - a] + 1)\n        if i >= b and dp[i - b] != -1:\n            dp[i] = max(dp[i], dp[i - b] + 1)\n        if i >= c and dp[i - c] != -1:\n            dp[i] = max(dp[i], dp[i - c] + 1)\n    \n    if dp[n] == 0:\n        return -1\n    return dp[n]", "def maximum_segments(n, a, b, c):\n    counts = [0] * (n + 1)\n    counts[0] = 0\n    for i in range(1, n + 1):\n        if i >= a and counts[i - a] >= 0:\n            counts[i] = max(counts[i], counts[i - a] + 1)\n        if i >= b and counts[i - b] >= 0:\n            counts[i] = max(counts[i], counts[i - b] + 1)\n        if i >= c and counts[i - c] >= 0:\n            counts[i] = max(counts[i], counts[i - c] + 1)\n    return counts[n]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 973, "entry_point": "left_rotate", "codes": ["def left_rotate(s, n):\n    return s[n:] + s[:n]", "def left_rotate(s, k):\n    return s[k:] + s[:k]", "def left_rotate(s: str, k: int) -> str:\n    return s[k:] + s[:k]", "def left_rotate(s):\n    return s[1:] + s[0]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 974, "entry_point": "min_sum_path", "codes": ["def min_sum_path(triangle):\n    n = len(triangle)\n    for i in range(n-2, -1, -1):\n        for j in range(i+1):\n            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\n    return triangle[0][0]", "def min_sum_path(triangle):\n    n = len(triangle)\n    for i in range(n-2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\n    return triangle[0][0]", "def min_sum_path(triangle):\n    n = len(triangle)\n    dp = {i: triangle[n-1][i] for i in range(n)}\n    for row in range(n-2, -1, -1):\n        for col in range(row + 1):\n            dp[col] = triangle[row][col] + min(dp[col], dp[col+1])\n    return dp[0]", "def min_sum_path(triangle):\n    if not triangle:\n        return 0\n\n    # Create a dictionary to store the minimum path sums\n    dp = {}\n\n    # Iterate over the triangle from the bottom up\n    for row in range(len(triangle) - 1, -1, -1):\n        for col in range(len(triangle[row])):\n            # Calculate the minimum path sum for the current element\n            dp[(row, col)] = triangle[row][col] + min(\n                dp.get((row + 1, col), float('inf')),\n                dp.get((row + 1, col + 1), float('inf'))\n            )\n\n    # The top element now contains the minimum path sum\n    return dp[(0, 0)]", "def min_sum_path(triangle):\n    n = len(triangle)\n    memo = [[float('inf')] * n for _ in range(n)]\n    memo[0][0] = triangle[0][0]\n\n    def dp(i, j):\n        if i == n - 1:\n            return triangle[i][j]\n        if memo[i][j] == float('inf'):\n            memo[i][j] = triangle[i][j] + min(dp(i + 1, j), dp(i + 1, j + 1))\n        return memo[i][j]\n\n    return dp(0, 0)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
