{"id": 38, "entry_point": "minFlipsMonoIncr", "codes": ["def minFlipsMonoIncr(S):\n    flip_to_one, flip_to_zero = 0, 0\n    for bit in S:\n        if bit == '0':\n            flip_to_one += 1\n        else:\n            flip_to_one = min(flip_to_one, flip_to_zero)\n            flip_to_zero += 1\n    return min(flip_to_one, flip_to_zero)", "def minFlipsMonoIncr(S):\n    ones = 0\n    flips = 0\n    for char in S:\n        if char == '1':\n            ones += 1\n        else:\n            flips += 1\n            flips = min(flips, ones)\n    return flips", "def minFlipsMonoIncr(S):\n    flips_ending_with_0 = flips_ending_with_1 = 0\n    for char in S:\n        if char == '0':\n            flips_ending_with_0 = min(flips_ending_with_0, flips_ending_with_1) + 1\n            flips_ending_with_1 += 1\n        else:\n            flips_ending_with_1 = min(flips_ending_with_0, flips_ending_with_1)\n    return min(flips_ending_with_0, flips_ending_with_1)", "def minFlipsMonoIncr(S):\n    flip_to_1 = 0\n    ones_count = 0\n    for char in S:\n        if char == '0':\n            flip_to_1 = min(flip_to_1, ones_count)\n        else:\n            ones_count += 1\n    return min(flip_to_1, ones_count)", "def minFlipsMonoIncr(S: str) -> int:\n    flips = zeros = ones = 0\n    for bit in S:\n        if bit == '0':\n            flips = min(flips, zeros)\n            zeros += 1\n        else:\n            ones += 1\n    return min(flips, zeros, ones)", "def minFlipsMonoIncr(S):\n    flip_to_0, flip_to_1 = 0, 0\n    for bit in S:\n        flip_to_0, flip_to_1 = min(flip_to_0, flip_to_1) + (bit == '1'), min(flip_to_0, flip_to_1) + (bit == '0')\n    return min(flip_to_0, flip_to_1)", "def minFlipsMonoIncr(S):\n    zero_count = S.count('0')\n    one_count = 0\n    min_flips = zero_count\n\n    for char in S:\n        if char == '0':\n            zero_count -= 1\n        else:\n            one_count += 1\n            min_flips = min(min_flips, zero_count + one_count)\n\n    return min_flips"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 5127, "entry_point": "largestValsFromLabels", "codes": ["def largestValsFromLabels(values, labels, num_wanted, use_limit):\n    items = sorted(zip(values, labels), reverse=True)\n    count = {}\n    result = 0\n    for value, label in items:\n        if count.get(label, 0) < use_limit:\n            count[label] = count.get(label, 0) + 1\n            result += value\n            num_wanted -= 1\n            if num_wanted == 0:\n                break\n    return result", "def largestValsFromLabels(values, labels, num_wanted, use_limit):\n    label_count = {}\n    total_sum = 0\n    items = sorted(zip(values, labels), reverse=True)\n    \n    for value, label in items:\n        if label_count.get(label, 0) < use_limit:\n            total_sum += value\n            label_count[label] = label_count.get(label, 0) + 1\n            num_wanted -= 1\n            if num_wanted == 0:\n                break\n    \n    return total_sum", "def largestValsFromLabels(values, labels, num_wanted, use_limit):\n    items = sorted(zip(values, labels), reverse=True)\n    label_count = {}\n    result = 0\n    count = 0\n    \n    for value, label in items:\n        if count >= num_wanted:\n            break\n        if label_count.get(label, 0) < use_limit:\n            result += value\n            label_count[label] = label_count.get(label, 0) + 1\n            count += 1\n    \n    return result", "import heapq\n\ndef largestValsFromLabels(values, labels, num_wanted, use_limit):\n    labeled_values = list(zip(values, labels))\n    heap = [-v for v, _ in labeled_values]  # Use negative values to simulate max-heap with heapq\n    heapq.heapify(heap)\n    \n    count = 0\n    result = 0\n    label_count = {}\n    \n    while heap and count < num_wanted:\n        value, label = -heapq.heappop(heap)\n        if label_count.get(label, 0) < use_limit:\n            result += value\n            count += 1\n            label_count[label] = label_count.get(label, 0) + 1\n    \n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 5148, "entry_point": "reverseOnlyLetters", "codes": ["def reverseOnlyLetters(S):\n    letters = [c for c in S if c.isalpha()]\n    return ''.join(letters.pop() if c.isalpha() else c for c in S)", "def reverseOnlyLetters(S):\n    letters = [c for c in S if c.isalpha()]\n    return ''.join(c if not c.isalpha() else letters.pop() for c in S)", "def reverseOnlyLetters(S):\n    letters = [c for c in S if c.isalpha()]\n    return ''.join([letters.pop() if c.isalpha() else c for c in S])", "def reverseOnlyLetters(S: str) -> str:\n    letters = [c for c in S if c.isalpha()][::-1]\n    return ''.join(next(letters) if c.isalpha() else c for c in S)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 5215, "entry_point": "lastSubstring", "codes": ["def lastSubstring(s):\n    return max(s[i:] for i in range(len(s)))", "def lastSubstring(s: str) -> str:\n    return max(s[i:] for i in range(len(s)))", "def lastSubstring(s):\n    max_char = max(s)\n    max_suffixes = [i for i, char in enumerate(s) if char == max_char]\n    return max(s[i:] for i in max_suffixes)", "def lastSubstring(s):\n    max_char = max(s)\n    return max(s.split(max_char))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 5255, "entry_point": "racecar", "codes": ["def racecar(target):\n    q = [(0, 1, 0)]\n    visited = set((0, 1))\n    while q:\n        pos, speed, moves = q.pop(0)\n        if pos == target:\n            return moves\n        # Accelerate\n        new_pos, new_speed = pos + speed, speed * 2\n        if (new_pos, new_speed) not in visited and new_pos >= 0:\n            visited.add((new_pos, new_speed))\n            q.append((new_pos, new_speed, moves + 1))\n        # Reverse\n        new_speed = -1 if speed > 0 else 1\n        if (pos, new_speed) not in visited and pos >= 0:\n            visited.add((pos, new_speed))\n            q.append((pos, new_speed, moves + 1))", "from heapq import heappush, heappop\n\ndef racecar(target):\n    pq = [(0, 0, 1)]\n    visited = set()\n    \n    while pq:\n        moves, pos, speed = heappop(pq)\n        \n        if pos == target:\n            return moves\n        \n        if (pos, speed) in visited:\n            continue\n        visited.add((pos, speed))\n        \n        # Accelerate\n        heappush(pq, (moves + 1, pos + speed, speed * 2))\n        \n        # Reverse\n        if speed > 0:\n            heappush(pq, (moves + 1, pos, -1))\n        else:\n            heappush(pq, (moves + 1, pos, 1))", "def racecar(target):\n    queue = [(0, 1, 0)]\n    visited = set((0, 1))\n    \n    while queue:\n        pos, speed, moves = queue.pop(0)\n        \n        if pos == target:\n            return moves\n        \n        # Accelerate\n        new_pos = pos + speed\n        new_speed = speed * 2\n        if (new_pos, new_speed) not in visited and new_pos > 0 and new_pos <= target * 2:\n            queue.append((new_pos, new_speed, moves + 1))\n            visited.add((new_pos, new_speed))\n        \n        # Reverse\n        new_speed = -1 if speed > 0 else 1\n        if (pos, new_speed) not in visited and new_speed != 0:\n            queue.append((pos, new_speed, moves + 1))\n            visited.add((pos, new_speed))", "def racecar(target):\n    def min_steps(pos, speed, memo):\n        if pos == target:\n            return 0\n        if (pos, speed) in memo:\n            return memo[(pos, speed)]\n        # Accelerate\n        memo[pos, speed] = min_steps(pos + speed, speed * 2, memo) + 1\n        # Reverse\n        if pos + speed > 0:\n            reverse_steps = min_steps(pos, -1, memo) + 1\n            memo[pos, speed] = min(memo[pos, speed], reverse_steps)\n        return memo[pos, speed]\n    \n    memo = {}\n    return min_steps(0, 1, memo)", "def racecar(target):\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for i in range(1, target + 1):\n        k = 1\n        while (1 << k) - 1 < i:\n            dp[i] = min(dp[i], dp[(1 << k) - 1 - i] + k + 1)\n            if (1 << k) - 1 - i < i:\n                dp[i] = min(dp[i], dp[i - ((1 << k) - 1 - i)] + k + 2)\n            k += 1\n\n        if (1 << k) - 1 == i:\n            dp[i] = k\n\n    return dp[target]", "def racecar(target):\n    dp = [0] * (target + 1)\n    for t in range(1, target + 1):\n        k = t.bit_length() - 1\n        if 2**k - 1 == t:\n            dp[t] = k\n        else:\n            dp[t] = dp[2**k - 1 - t] + k + 1 + (k > 1 and dp[t - 2**(k - 1)])\n    return dp[target]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 5431, "entry_point": "countDigitOne", "codes": ["def countDigitOne(n):\n    count = 0\n    for i in range(1, n + 1):\n        count += str(i).count('1')\n    return count", "def countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        low = n % i\n        digit = (n // i) % 10\n        high = n // (i * 10)\n        if digit == 0:\n            count += high * i\n        elif digit == 1:\n            count += high * i + low + 1\n        else:\n            count += (high + 1) * i\n        i *= 10\n    return count", "def countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        lowerNumbers = n - (n // i) * i\n        currentDigit = (n // i) % 10\n        higherNumbers = n // (i * 10)\n        if currentDigit < 1:\n            count += higherNumbers * i\n        elif currentDigit == 1:\n            count += higherNumbers * i + lowerNumbers + 1\n        else:\n            count += (higherNumbers + 1) * i\n        i *= 10\n    return count", "def countDigitOne(n: int) -> int:\n    if n <= 0:\n        return 0\n    \n    def helper(num: int) -> int:\n        if num == 0:\n            return 0\n        digit = num % 10\n        lower = num % 1000\n        higher = num // 1000\n        if digit == 0:\n            return helper(lower)\n        elif digit == 1:\n            return helper(lower) + higher + 1\n        else:\n            return helper(lower) + (higher + 1) * 1000 + digit * 100\n    \n    return helper(n)", "def countDigitOne(n):\n    def countInSubNumber(num, pos, mod, base):\n        higher = num // (base * 10)\n        current = (num // base) % 10\n        lower = num % base\n        total = 0\n        if current == 0:\n            total = higher * mod\n        elif current == 1:\n            total = higher * mod + lower + 1\n        else:\n            total = (higher + 1) * mod\n        return total\n\n    mod, result = 1, 0\n    while n >= mod:\n        result += countInSubNumber(n, mod, mod * 10, 10 * mod)\n        mod *= 10\n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 559, "entry_point": "tilingRectangle", "codes": ["def tilingRectangle(n, m):\n    from functools import lru_cache\n\n    @lru_cache(None)\n    def dp(a, b):\n        if a == b:\n            return 1\n        if a > b:\n            a, b = b, a\n        if a == 1:\n            return b\n        if a == 2:\n            return 3 if b == 3 else 2 * a\n        return min(dp(a, b - a) + dp(a, a), dp(a, b - 1) + dp(a - 1, b - 1) + dp(a - 1, b))\n    \n    return dp(n, m)", "def tilingRectangle(n, m):\n    def dfs(h, tries):\n        if all(h[i] == m for i in range(n)):\n            return tries\n        min_tiles = float('inf')\n        for i in range(n):\n            if h[i] < m:\n                for j in range(min(m - h[i], i + 1), 0, -1):\n                    new_h = h[:]\n                    for k in range(j):\n                        new_h[i - k] += j\n                    min_tiles = min(min_tiles, dfs(new_h, tries + 1))\n                    for k in range(j):\n                        new_h[i - k] -= j\n        return min_tiles\n\n    return dfs([0] * n, 0)", "def tilingRectangle(n, m):\n    def dfs(used, target):\n        if sum(used) == target:\n            return 0\n        if min(used) == target:\n            return target\n        return min(dfs(used[:i] + (used[i] - x,) + used[i+1:], target) + 1 for i in range(len(used)) for x in range(1, min(used[i], target - sum(used[:i]) + 1)))\n\n    return dfs((n,) * m, n * m)", "def tilingRectangle(n, m):\n    if n > m:\n        n, m = m, n\n\n    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            for size in range(1, min(i, j) + 1):\n                for x in range(i - size + 1):\n                    for y in range(j - size + 1):\n                        dp[i][j] = min(dp[i][j], 1 + dp[x][y] + dp[i - x][j - y])\n\n    return dp[n][m]", "def tilingRectangle(n, m):\n    def solve(x, y, w, h, state, memo):\n        if state == 0:\n            return 0\n        if (x, y, w, h, state) in memo:\n            return memo[(x, y, w, h, state)]\n        min_cuts = float('inf')\n        for i in range(1, min(w, h) + 1):\n            if (state & (1 << (x + i - 1 + (y + i - 1) * w))) == 0:\n                new_state = state\n                for j in range(i):\n                    for k in range(i):\n                        new_state |= (1 << (x + j + (y + k) * w))\n                min_cuts = min(min_cuts, 1 + solve(x + i, y, w - i, h, new_state, memo) + solve(x, y + i, w, h - i, new_state, memo))\n        memo[(x, y, w, h, state)] = min_cuts\n        return min_cuts\n\n    return solve(0, 0, n, m, (1 << (n * m)) - 1, {})", "def tilingRectangle(n: int, m: int) -> int:\n    def dfs(heights, count):\n        if all(h == n for h in heights):\n            return count\n        min_count = float('inf')\n        for i in range(len(heights)):\n            for j in range(i, len(heights)):\n                height = max(heights[i:j + 1])\n                if height == n:\n                    continue\n                new_heights = heights[:]\n                for k in range(i, j + 1):\n                    new_heights[k] += height\n                min_count = min(min_count, dfs(new_heights, count + 1))\n        return min_count\n\n    return dfs([0] * m, 0)", "def tilingRectangle(n, m):\n    def helper(x, y, width, height, memo):\n        if (x, y, width, height) in memo:\n            return memo[(x, y, width, height)]\n        if width == height:\n            memo[(x, y, width, height)] = 1\n        elif width > height:\n            memo[(x, y, width, height)] = helper(x, y, height, width, memo)\n        else:\n            res = float('inf')\n            for i in range(1, width + 1):\n                res = min(res, helper(x, y, width - i, height, memo) + helper(x + i, y, i, height, memo))\n                if res == 1:\n                    break\n            memo[(x, y, width, height)] = res\n        return memo[(x, y, width, height)]\n\n    return helper(0, 0, n, m, {})"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 5540, "entry_point": "numUniqueEmails", "codes": ["def numUniqueEmails(emails):\n    return len({local.replace('.', '').split('+')[0] + domain for local, domain in (email.split('@') for email in emails)})", "def numUniqueEmails(emails):\n    return len(set(map(normalize, emails)))\n\ndef normalize(email):\n    local, domain = email.split('@')\n    local = local.replace('.', '').split('+')[0]\n    return local + '@' + domain", "def numUniqueEmails(emails):\n    unique_emails = set()\n    for email in emails:\n        local, domain = email.split('@')\n        local = local.split('+')[0].replace('.', '')\n        unique_emails.add(local + '@' + domain)\n    return len(unique_emails)", "def numUniqueEmails(email):\n    local, domain = email.split('@')\n    local = local.replace('.', '').split('+')[0]\n    return f\"{local}@{domain}\"\n\ndef numUniqueEmails(emails):\n    return len({numUniqueEmails(email) for email in emails})"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 5544, "entry_point": "baseNeg2", "codes": ["def baseNeg2(N):\n    if N == 0:\n        return \"0\"\n    result = []\n    while N != 0:\n        N, remainder = divmod(N, -2)\n        if remainder < 0:\n            N, remainder = N + 1, remainder + 2\n        result.append(str(remainder))\n    return \"\".join(reversed(result))", "def baseNeg2(n):\n    if n == 0:\n        return \"0\"\n    digits = []\n    while n != 0:\n        n, remainder = divmod(n, -2)\n        if remainder < 0:\n            remainder += 2\n            n += 1\n        digits.append(str(remainder))\n    return ''.join(digits[::-1])", "def baseNeg2(N):\n    if N == 0:\n        return \"0\"\n    result = []\n    while N != 0:\n        remainder = N % -2\n        N //= -2\n        if remainder < 0:\n            remainder += 2\n            N += 1\n        result.append(str(remainder))\n    return ''.join(result[::-1])", "def baseNeg2(N):\n    return bin((N + (N & 1)) >> 1).replace(\"0b\", \"\").replace(\"-\", \"\")"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 5901, "entry_point": "brokenCalc", "codes": ["def brokenCalc(X, Y):\n    return X - Y if X >= Y else 1 + (brokenCalc(X, Y // 2) if Y % 2 == 0 else brokenCalc(X, Y + 1))", "def brokenCalc(X, Y):\n    if X >= Y:\n        return X - Y\n    elif Y % 2 == 0:\n        return 1 + brokenCalc(X, Y // 2)\n    else:\n        return 2 + brokenCalc(X, (Y + 1) // 2)", "def brokenCalc(X, Y):\n    if X >= Y:\n        return X - Y\n    if Y % 2 == 0:\n        return 1 + brokenCalc(X, Y // 2)\n    else:\n        return 1 + min(brokenCalc(X, Y + 1), brokenCalc(X, Y // 2))", "def brokenCalc(X, Y):\n    if X >= Y:\n        return X - Y\n    return 1 + (Y + 1) // 2 * (Y & 1) + brokenCalc(X, (Y + 1) // 2)", "def brokenCalc(X, Y):\n    if X >= Y:\n        return X - Y\n    dp = [float('inf')] * (Y + 1)\n    dp[0] = 0\n    dp[1] = 1\n    for y in range(2, Y + 1):\n        dp[y] = dp[y - 1] + 1\n        if y % 2 == 0:\n            dp[y] = min(dp[y], dp[y // 2] + 1)\n    return dp[Y] + X - 1", "def brokenCalc(X, Y):\n    if X >= Y:\n        return X - Y\n    return 1 + min(brokenCalc(X, Y + 1), brokenCalc(X, Y // 2)) if Y % 2 else brokenCalc(X, Y // 2)", "def brokenCalc(X, Y):\n    if X >= Y:\n        return X - Y\n    if Y % 2 == 0:\n        return 1 + brokenCalc(X, Y // 2)\n    else:\n        return 1 + min(brokenCalc(X, Y + 1), brokenCalc(X, Y - 1))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 5922, "entry_point": "minRefuelStops", "codes": ["def minRefuelStops(target, startFuel, stations):\n    refuels = 0\n    max_reach = startFuel\n    i = 0\n    pq = []\n    \n    while max_reach < target:\n        while i < len(stations) and stations[i][0] <= max_reach:\n            heapq.heappush(pq, -stations[i][1])\n            i += 1\n        if not pq:\n            return -1\n        max_reach -= heapq.heappop(pq)\n        refuels += 1\n    \n    return refuels", "def minRefuelStops(target, startFuel, stations):\n    stops = 0\n    fuel = startFuel\n    i = 0\n    max_heap = []\n    \n    while fuel < target:\n        while i < len(stations) and stations[i][0] <= fuel:\n            heapq.heappush(max_heap, -stations[i][1])\n            i += 1\n        if not max_heap:\n            return -1\n        fuel -= heapq.heappop(max_heap)\n        stops += 1\n    \n    return stops", "def minRefuelStops(target, startFuel, stations):\n    from heapq import heappop, heappush\n    max_heap = []\n    fuel = startFuel\n    stops = 0\n    i = 0\n    while fuel < target:\n        while i < len(stations) and stations[i][0] <= fuel:\n            heappush(max_heap, -stations[i][1])\n            i += 1\n        if not max_heap:\n            return -1\n        fuel += -heappop(max_heap)\n        stops += 1\n    return stops", "def minRefuelStops(target, startFuel, stations):\n    stations.append([target, 0])\n    pq = []\n    fuel = startFuel\n    stops = 0\n    \n    for pos, gas in stations:\n        fuel -= pos\n        while pq and fuel < 0:\n            fuel -= heapq.heappop(pq)\n            stops += 1\n        if fuel < 0:\n            return -1\n        heapq.heappush(pq, -gas)\n    \n    return stops", "def minRefuelStops(target, startFuel, stations):\n    import heapq\n    \n    stops = 0\n    max_reach = startFuel\n    refuel_heap = []\n    \n    stations.append([target, 0])\n    \n    for position, fuel in stations:\n        while max_reach < position:\n            if not refuel_heap:\n                return -1\n            max_reach -= heapq.heappop(refuel_heap)\n            stops += 1\n        heapq.heappush(refuel_heap, -fuel)\n    \n    return stops", "from heapq import heappop, heappush\n\ndef minRefuelStops(target, startFuel, stations):\n    max_heap = []\n    stops = 0\n    current_fuel = startFuel\n    \n    stations.append([target, 0])\n    \n    for position, fuel in stations:\n        while max_heap and current_fuel < position:\n            current_fuel -= heappop(max_heap)\n            stops += 1\n        if current_fuel < position:\n            return -1\n        heappush(max_heap, -fuel)\n    \n    return stops", "def minRefuelStops(target, startFuel, stations):\n    import heapq\n    stops = 0\n    fuel_heap = []\n    current_fuel = startFuel\n    \n    for station in stations:\n        while fuel_heap and current_fuel < station[0]:\n            current_fuel -= heapq.heappop(fuel_heap)\n            stops += 1\n        if current_fuel < station[0]:\n            return -1\n        heapq.heappush(fuel_heap, -station[1])\n    \n    while fuel_heap and current_fuel < target:\n        current_fuel -= heapq.heappop(fuel_heap)\n        stops += 1\n    if current_fuel < target:\n        return -1\n    \n    return stops", "def minRefuelStops(target, startFuel, stations):\n    max_reach = startFuel\n    fuel_stops = 0\n    stations.append([target, 0])\n    \n    for i in range(len(stations) - 1):\n        if max_reach < stations[i][0]:\n            return -1\n        while stations and max_reach >= stations[-1][0]:\n            max_reach += stations.pop()[1]\n        if max_reach < stations[i][0]:\n            return -1\n        max_reach -= stations[i][0]\n        fuel_stops += 1\n    \n    return fuel_stops"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 6263, "entry_point": "shortestCommonSupersequence", "codes": ["def shortestCommonSupersequence(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n        for j in range(n):\n            if str1[i] == str2[j]:\n                dp[i + 1][j + 1] = dp[i][j] + 1\n            else:\n                dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n\n    i, j = m, n\n    result = []\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1]:\n            result.append(str1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            result.append(str1[i - 1])\n            i -= 1\n        else:\n            result.append(str2[j - 1])\n            j -= 1\n\n    while i > 0:\n        result.append(str1[i - 1])\n        i -= 1\n\n    while j > 0:\n        result.append(str2[j - 1])\n        j -= 1\n\n    return ''.join(reversed(result))", "def shortestCommonSupersequence(str1: str, str2: str) -> str:\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    i, j = m, n\n    result = []\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1]:\n            result.append(str1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            result.append(str1[i - 1])\n            i -= 1\n        else:\n            result.append(str2[j - 1])\n            j -= 1\n\n    while i > 0:\n        result.append(str1[i - 1])\n        i -= 1\n\n    while j > 0:\n        result.append(str2[j - 1])\n        j -= 1\n\n    return ''.join(result[::-1])", "def shortestCommonSupersequence(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    lcs_len = dp[m][n]\n    i, j = m, n\n    result = []\n    \n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1]:\n            result.append(str1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            result.append(str1[i - 1])\n            i -= 1\n        else:\n            result.append(str2[j - 1])\n            j -= 1\n    \n    while i > 0:\n        result.append(str1[i - 1])\n        i -= 1\n    \n    while j > 0:\n        result.append(str2[j - 1])\n        j -= 1\n    \n    return ''.join(reversed(result))", "def shortestCommonSupersequence(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [['' for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if str1[i] == str2[j]:\n                dp[i][j] = str1[i] + dp[i + 1][j + 1]\n            else:\n                dp[i][j] = min(dp[i + 1][j], dp[i][j + 1], key=len)\n    \n    return dp[0][0]", "def shortestCommonSupersequence(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[\"\" for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + str1[i - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len)\n    \n    def build_result(dp, str1, str2):\n        i, j = len(str1), len(str2)\n        result = []\n        while i > 0 or j > 0:\n            if i > 0 and dp[i][j] == dp[i - 1][j]:\n                result.append(str1[i - 1])\n                i -= 1\n            elif j > 0 and dp[i][j] == dp[i][j - 1]:\n                result.append(str2[j - 1])\n                j -= 1\n            else:\n                result.append(dp[i][j][-1])\n                if dp[i][j][0] in str1:\n                    i -= 1\n                if dp[i][j][0] in str2:\n                    j -= 1\n        return ''.join(reversed(result))\n    \n    return build_result(dp, str1, str2)", "def shortestCommonSupersequence(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m - 1, -1, -1):\n        dp[i][n] = dp[i + 1][n] + str1[i]\n\n    for j in range(n - 1, -1, -1):\n        dp[m][j] = dp[m][j + 1] + str2[j]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if str1[i] == str2[j]:\n                dp[i][j] = dp[i + 1][j + 1] + str1[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j], dp[i][j + 1])\n\n    return dp[0][0]", "def shortestCommonSupersequence(str1: str, str2: str) -> str:\n    m, n = len(str1), len(str2)\n    dp = [['' for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if str1[i] == str2[j]:\n                dp[i][j] = str1[i] + dp[i + 1][j + 1]\n            else:\n                dp[i][j] = min(dp[i + 1][j], dp[i][j + 1], key=len)\n    \n    return dp[0][0]\n\ndef _equivalent(lhs: str, rhs: str) -> bool:\n    return lhs == rhs", "def shortestCommonSupersequence(str1: str, str2: str) -> str:\n    m, n = len(str1), len(str2)\n    dp = [['' for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if str1[i] == str2[j]:\n                dp[i][j] = str1[i] + dp[i + 1][j + 1]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + str2[j], dp[i][j + 1] + str1[i], key=len)\n\n    return dp[0][0]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 6353, "entry_point": "minNumberOfFrogs", "codes": ["def minNumberOfFrogs(croakOfFrogs: str) -> int:\n    if len(croakOfFrogs) % 5 != 0:\n        return -1\n    \n    counts = {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0}\n    frogs = 0\n    \n    for char in croakOfFrogs:\n        counts[char] += 1\n        \n        if counts['c'] < counts['r'] or counts['r'] < counts['o'] or counts['o'] < counts['a'] or counts['a'] < counts['k']:\n            return -1\n        \n        if char == 'k':\n            frogs = max(frogs, counts['c'])\n            for c in 'croak':\n                counts[c] -= 1\n    \n    return frogs if counts == {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0} else -1", "def minNumberOfFrogs(croakOfFrogs: str) -> int:\n    if len(croakOfFrogs) % 5 != 0:\n        return -1\n    \n    counts = {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0}\n    frogs = 0\n    \n    for char in croakOfFrogs:\n        counts[char] += 1\n        if char == 'c':\n            frogs = max(frogs, counts['c'])\n        elif char == 'k':\n            for c in counts:\n                counts[c] -= 1\n    \n    if any(counts.values()):\n        return -1\n    \n    return frogs", "def minNumberOfFrogs(croakOfFrogs: str) -> int:\n    count = [0] * 5\n    frogs = 0\n    for c in croakOfFrogs:\n        if c == 'c':\n            count[0] += 1\n            frogs = max(frogs, count[0])\n        elif c == 'r':\n            if count[0] == 0:\n                return -1\n            count[0] -= 1\n            count[1] += 1\n        elif c == 'o':\n            if count[1] == 0:\n                return -1\n            count[1] -= 1\n            count[2] += 1\n        elif c == 'a':\n            if count[2] == 0:\n                return -1\n            count[2] -= 1\n            count[3] += 1\n        elif c == 'k':\n            if count[3] == 0:\n                return -1\n            count[3] -= 1\n            count[4] += 1\n            count[0] -= 1\n    if any(count[i] != 0 for i in range(4)):\n        return -1\n    return frogs", "def minNumberOfFrogs(croakOfFrogs: str) -> int:\n    counts = {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0}\n    frogs = 0\n    max_frogs = 0\n\n    for char in croakOfFrogs:\n        counts[char] += 1\n        if char == 'c':\n            frogs += 1\n            max_frogs = max(max_frogs, frogs)\n        elif char == 'k':\n            frogs -= 1\n        else:\n            if counts[char] > counts[chr(ord(char) - 1)]:\n                return -1\n\n    if frogs != 0:\n        return -1\n\n    return max_frogs", "def minNumberOfFrogs(croakOfFrogs):\n    counts = {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0}\n    frogs = 0\n    max_frogs = 0\n    \n    for c in croakOfFrogs:\n        counts[c] += 1\n        if c == 'c':\n            frogs += 1\n            max_frogs = max(max_frogs, frogs)\n        elif c == 'k':\n            frogs -= 1\n    \n        if counts['c'] < counts['r'] or counts['r'] < counts['o'] or counts['o'] < counts['a'] or counts['a'] < counts['k']:\n            return -1\n    \n    if frogs != 0:\n        return -1\n    \n    return max_frogs", "def minNumberOfFrogs(croakOfFrogs):\n    counts = {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0}\n    frogs = 0\n    max_frogs = 0\n    \n    for char in croakOfFrogs:\n        counts[char] += 1\n        if char == 'c':\n            frogs += 1\n            max_frogs = max(max_frogs, frogs)\n        elif char == 'k':\n            frogs -= 1\n        elif counts['c'] < counts['r'] or counts['r'] < counts['o'] or counts['o'] < counts['a'] or counts['a'] < counts['k']:\n            return -1\n    \n    if frogs != 0:\n        return -1\n    \n    return max_frogs", "def minNumberOfFrogs(croakOfFrogs):\n    counts = {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0}\n    frogs = 0\n    max_frogs = 0\n    \n    for char in croakOfFrogs:\n        counts[char] += 1\n        if char == 'c':\n            frogs += 1\n            max_frogs = max(max_frogs, frogs)\n        elif char == 'k':\n            frogs -= 1\n    \n    if not all(counts[char] == counts['c'] for char in 'croak'):\n        return -1\n    \n    return max_frogs", "def minNumberOfFrogs(croakOfFrogs):\n    croak_map = {'c': 0, 'r': 1, 'o': 2, 'a': 3, 'k': 4}\n    count = [0] * 5\n    frogs = 0\n    for char in croakOfFrogs:\n        i = croak_map[char]\n        count[i] += 1\n        if i == 0:\n            frogs = max(frogs, count[0])\n        elif count[i] > count[i - 1]:\n            return -1\n    if any(count[i] != count[0] for i in range(1, 5)):\n        return -1\n    return frogs"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 6374, "entry_point": "findMedianSortedArrays", "codes": ["def findMedianSortedArrays(nums1, nums2):\n    def get_kth(a, b, k):\n        if len(a) > len(b):\n            a, b = b, a\n        if len(a) == 0:\n            return b[k]\n        if k == 0:\n            return min(a[0], b[0])\n        i = min(len(a) - 1, k // 2)\n        j = min(len(b) - 1, k // 2)\n        if a[i] > b[j]:\n            return get_kth(a, b[j+1:], k-j-1)\n        else:\n            return get_kth(a[i+1:], b, k-i-1)\n    \n    total_length = len(nums1) + len(nums2)\n    if total_length % 2 == 1:\n        return get_kth(nums1, nums2, total_length // 2)\n    else:\n        return (get_kth(nums1, nums2, total_length // 2 - 1) + get_kth(nums1, nums2, total_length // 2)) / 2", "def findMedianSortedArrays(nums1, nums2):\n    def find_kth(nums1, nums2, k):\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        if len(nums1) == 0:\n            return nums2[k]\n        if k == 0:\n            return min(nums1[0], nums2[0])\n        \n        i = min(len(nums1) - 1, k // 2)\n        j = min(len(nums2) - 1, k // 2)\n        \n        if nums1[i] > nums2[j]:\n            return find_kth(nums1, nums2[j+1:], k-j-1)\n        else:\n            return find_kth(nums1[i+1:], nums2, k-i-1)\n    \n    total = len(nums1) + len(nums2)\n    if total % 2 == 1:\n        return find_kth(nums1, nums2, total // 2)\n    else:\n        return (find_kth(nums1, nums2, total // 2 - 1) + find_kth(nums1, nums2, total // 2)) / 2", "def findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    x, y = len(nums1), len(nums2)\n    low, high = 0, x\n    \n    while low <= high:\n        partitionX = (low + high) // 2\n        partitionY = (x + y + 1) // 2 - partitionX\n        \n        maxX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n        minX = float('inf') if partitionX == x else nums1[partitionX]\n        \n        maxY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n        minY = float('inf') if partitionY == y else nums2[partitionY]\n        \n        if maxX <= minY and maxY <= minX:\n            if (x + y) % 2 == 0:\n                return (max(maxX, maxY) + min(minX, minY)) / 2\n            else:\n                return max(maxX, maxY)\n        elif maxX > minY:\n            high = partitionX - 1\n        else:\n            low = partitionX + 1", "def findMedianSortedArrays(nums1, nums2):\n    def find_kth(nums1, nums2, k):\n        if not nums1: return nums2[k]\n        if not nums2: return nums1[k]\n        if k == 0: return min(nums1[0], nums2[0])\n\n        mid1, mid2 = len(nums1) // 2, len(nums2) // 2\n        if nums1[mid1] < nums2[mid2]:\n            if k <= mid1 + mid2:\n                return find_kth(nums1[:mid1 + 1], nums2, k)\n            else:\n                return find_kth(nums1[mid1 + 1:], nums2, k - mid1 - 1)\n        else:\n            if k <= mid1 + mid2:\n                return find_kth(nums1, nums2[:mid2 + 1], k)\n            else:\n                return find_kth(nums1, nums2[mid2 + 1:], k - mid2 - 1)\n\n    total = len(nums1) + len(nums2)\n    if total % 2 == 1:\n        return find_kth(nums1, nums2, total // 2)\n    else:\n        return (find_kth(nums1, nums2, total // 2 - 1) + find_kth(nums1, nums2, total // 2)) / 2"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 6479, "entry_point": "maxProduct", "codes": ["def maxProduct(nums):\n    max_product = min_product = result = nums[0]\n    for num in nums[1:]:\n        if num < 0:\n            max_product, min_product = min_product, max_product\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n        result = max(result, max_product)\n    return result", "def maxProduct(nums):\n    if not nums:\n        return 0\n    \n    max_prod = min_prod = result = nums[0]\n    \n    for num in nums[1:]:\n        if num < 0:\n            max_prod, min_prod = min_prod, max_prod\n        \n        max_prod = max(num, max_prod * num)\n        min_prod = min(num, min_prod * num)\n        \n        result = max(result, max_prod)\n    \n    return result", "def maxProduct(nums):\n    if not nums:\n        return 0\n    \n    max_product = min_product = result = nums[0]\n    \n    for num in nums[1:]:\n        if num < 0:\n            max_product, min_product = min_product, max_product\n        \n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n        \n        result = max(result, max_product)\n    \n    return result", "def maxProduct(nums):\n    if not nums:\n        return 0\n    \n    max_product = current_max = current_min = nums[0]\n    \n    for num in nums[1:]:\n        if num == 0:\n            current_max, current_min = 1, 1\n            max_product = max(max_product, 0)\n        else:\n            temp_max = current_max * num\n            current_max = max(num, temp_max, current_min * num)\n            current_min = min(num, temp_min, current_min * num)\n            max_product = max(max_product, current_max)\n    \n    return max_product"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 6500, "entry_point": "containsNearbyDuplicate", "codes": ["def containsNearbyDuplicate(nums, k):\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        if num in num_to_index and i - num_to_index[num] <= k:\n            return True\n        num_to_index[num] = i\n    return False", "def containsNearbyDuplicate(nums, k):\n    seen = {}\n    for i, num in enumerate(nums):\n        if num in seen and i - seen[num] <= k:\n            return True\n        seen[num] = i\n    return False", "def containsNearbyDuplicate(nums, k):\n    num_indices = {}\n    for i, num in enumerate(nums):\n        if num in num_indices and i - num_indices[num] <= k:\n            return True\n        num_indices[num] = i\n    return False", "def containsNearbyDuplicate(nums, k):\n    seen = set()\n    for i, num in enumerate(nums):\n        if num in seen and i - seen[num] <= k:\n            return True\n        seen.add(num)\n        if len(seen) > k:\n            seen.remove(nums[i - k])\n    return False"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 6560, "entry_point": "calculate", "codes": ["def calculate(s: str) -> int:\n    stack, current_number, sign = [], 0, 1\n    for char in s:\n        if char.isdigit():\n            current_number = current_number * 10 + int(char)\n        elif char in '+-':\n            stack.append(current_number * sign)\n            current_number, sign = 0, 1 if char == '+' else -1\n        elif char == '(':\n            stack.append(sign)\n            current_number, sign = 0, 1\n        elif char == ')':\n            stack.append(current_number * sign)\n            sign = 1\n            current_number = sum(stack[-3::-2]) * stack[-2] + (stack[-1] if len(stack) % 2 else 0)\n            stack = stack[:-3]\n    stack.append(current_number * sign)\n    return sum(stack)", "def calculate(s: str) -> int:\n    stack = []\n    num = 0\n    sign = 1\n    result = 0\n\n    for i, char in enumerate(s):\n        if char.isdigit():\n            num = num * 10 + int(char)\n        if char == '+' or char == '-' or char == ')' or i == len(s) - 1:\n            result += sign * num\n            if char == ')':\n                prev_result = stack.pop()\n                result = prev_result + result if stack else result\n            sign = 1 if char == '+' else -1\n            num = 0\n        elif char == '(':\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n\n    return result", "def calculate(expression: str) -> int:\n    stack = []\n    current_number = 0\n    current_operation = '+'\n    \n    def apply_operation():\n        if current_operation == '+':\n            stack.append(current_number)\n        elif current_operation == '-':\n            stack.append(-current_number)\n    \n    for i, char in enumerate(expression):\n        if char.isdigit():\n            current_number = current_number * 10 + int(char)\n        if char in '+-(' or i == len(expression) - 1:\n            apply_operation()\n            current_operation = char\n            current_number = 0\n        if char == ')':\n            sum_of_stack = sum(stack)\n            stack = []\n            apply_operation()\n            stack.append(sum_of_stack)\n    \n    return sum(stack)", "def calculate(s: str) -> int:\n    def apply_operator(op, stack):\n        right = stack.pop()\n        left = stack.pop()\n        if op == '+':\n            stack.append(left + right)\n        elif op == '-':\n            stack.append(left - right)\n\n    def evaluate(expression):\n        stack = []\n        num = 0\n        op = '+'\n        i = 0\n        while i < len(expression):\n            if expression[i].isdigit():\n                num = num * 10 + int(expression[i])\n            if expression[i] in '+-(' or i == len(expression) - 1:\n                if op == '+':\n                    stack.append(num)\n                elif op == '-':\n                    stack.append(-num)\n                num = 0\n                op = expression[i]\n                if op == '(':\n                    num, j = evaluate(expression[i + 1:])\n                    i = j\n            i += 1\n        while stack:\n            apply_operator(op, stack)\n        return stack.pop()\n\n    return evaluate(s.replace(' ', ''))", "def calculate(s):\n    def helper(s):\n        def consume_space():\n            nonlocal i\n            while i < len(s) and s[i] == ' ':\n                i += 1\n        \n        def parse_number():\n            nonlocal i\n            start = i\n            while i < len(s) and s[i].isdigit():\n                i += 1\n            return int(s[start:i])\n        \n        def parse_term():\n            consume_space()\n            if i < len(s) and s[i] in \"+-\":\n                sign = s[i]\n                i += 1\n                consume_space()\n                num = parse_number()\n                return num if sign == '+' else -num\n            else:\n                return parse_number()\n        \n        def parse_expression():\n            consume_space()\n            result = parse_term()\n            consume_space()\n            while i < len(s) and s[i] in \"+-\":\n                operator = s[i]\n                i += 1\n                consume_space()\n                result += parse_term() if operator == '+' else -parse_term()\n                consume_space()\n            return result\n        \n        consume_space()\n        i = 0\n        return parse_expression()\n    \n    return helper(s)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 6602, "entry_point": "minSteps", "codes": ["def minSteps(n):\n    if n == 1:\n        return 0\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return i + minSteps(n // i)\n    return n", "def minSteps(n):\n    steps = 0\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            steps += divisor\n            n //= divisor\n        divisor += 1\n    return steps", "def minSteps(n):\n    steps = 0\n    factor = 2\n    while n > 1:\n        while n % factor == 0:\n            steps += factor\n            n //= factor\n        factor += 1\n    return steps", "def minSteps(n):\n    dp = list(range(n + 1))\n    for i in range(2, n + 1):\n        for j in range(i - 1, 0, -1):\n            if i % j == 0:\n                dp[i] = dp[j] + (i // j)\n                break\n    return dp[n]", "def minSteps(n):\n    return n if n <= 1 else min(x + minSteps(n // x) for x in range(2, n + 1) if n % x == 0)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 6631, "entry_point": "jump", "codes": ["def jump(nums):\n    def min_jumps(start, end):\n        if start >= end:\n            return 0\n        if nums[start] == 0:\n            return float('inf')\n        return min(1 + min_jumps(start + i, end) for i in range(1, nums[start] + 1))\n    \n    return min_jumps(0, len(nums) - 1)", "def jump(nums):\n    jumps = 0\n    current_end = 0\n    farthest = 0\n    \n    for i in range(len(nums) - 1):\n        farthest = max(farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = farthest\n    \n    return jumps", "def jump(nums):\n    n = len(nums)\n    jumps = 0\n    current_end = 0\n    farthest = 0\n    for i in range(n - 1):\n        farthest = max(farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = farthest\n            if current_end >= n - 1:\n                break\n    return jumps", "def jump(nums):\n    jumps = [0] * len(nums)\n    for i in range(len(nums) - 2, -1, -1):\n        if nums[i] == 0:\n            jumps[i] = float('inf')\n        else:\n            jumps[i] = min(jumps[min(i + nums[i], len(nums) - 1)] + 1, jumps[i + 1] if i + 1 < len(nums) else float('inf'))\n    return jumps[0]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 6771, "entry_point": "findLHS", "codes": ["from collections import Counter\n\ndef findLHS(nums):\n    count = Counter(nums)\n    return max(count[n] + count[n+1] for n in count if count[n+1] > 0)", "from collections import Counter\n\ndef findLHS(nums):\n    count = Counter(nums)\n    return max([count[n] + count[n + 1] for n in count if count[n + 1]], default=0)", "def findLHS(nums):\n    from collections import Counter\n    count = Counter(nums)\n    return max((count[n] + count[n + 1] for n in count if count[n + 1]), default=0)", "from collections import Counter\n\ndef findLHS(nums):\n    count = Counter(nums)\n    return max(count[num] + count[num+1] for num in count if num+1 in count, default=0)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 6909, "entry_point": "isSolvable", "codes": ["from itertools import permutations\n\ndef isSolvable(words, result):\n    chars = set(''.join(words + [result]))\n    if len(chars) > 10 or len(result) > len(words[0]):\n        return False\n    for perm in permutations('0123456789', len(chars)):\n        char_to_digit = dict(zip(chars, perm))\n        if any(char_to_digit[word[0]] == '0' for word in words + [result]):\n            continue\n        if sum(int(''.join(char_to_digit[char] for char in word)) for word in words) == int(''.join(char_to_digit[char] for char in result)):\n            return True\n    return False", "def isSolvable(words, result):\n    from itertools import permutations\n\n    letters = set(''.join(words) + result)\n    if len(letters) > 10 or len(result) > len(words[0]):\n        return False\n\n    for perm in permutations(range(10), len(letters)):\n        letter_to_digit = dict(zip(letters, perm))\n        if any(letter_to_digit[word[0]] == 0 for word in words + [result]):\n            continue\n        if sum(int(''.join(str(letter_to_digit[ch]) for ch in word)) for word in words) == int(''.join(str(letter_to_digit[ch]) for ch in result)):\n            return True\n    return False", "from itertools import permutations\n\ndef isSolvable(words, result):\n    chars = set(''.join(words) + result)\n    if len(chars) > 10:\n        return False\n    if len(result) > max(len(word) for word in words):\n        return False\n    digits = range(10)\n    for perm in permutations(digits, len(chars)):\n        char_to_digit = dict(zip(chars, perm))\n        if any(char_to_digit[word[0]] == 0 for word in words + [result]):\n            continue\n        if sum(int(''.join(map(char_to_digit.__getitem__, word))) for word in words) == int(''.join(map(char_to_digit.__getitem__, result))):\n            return True\n    return False", "def isSolvable(words, result):\n    from itertools import permutations\n\n    def _to_num(word):\n        return int(''.join(str(d) for d in word))\n\n    def _equivalent(lhs, rhs):\n        return _to_num(lhs) == _to_num(rhs)\n\n    chars = set(''.join(words + [result]))\n    if len(chars) > 10:\n        return False\n\n    if len(result) > len(words[0]):\n        words, result = result, words\n\n    leading_chars = set(word[0] for word in words + [result])\n    digits = list(range(10))\n    for perm in permutations(digits, len(chars)):\n        if any(perm[chars.index(c)] == 0 for c in leading_chars):\n            continue\n        if _equivalent(words, result, perm):\n            return True\n    return False", "from itertools import permutations\n\ndef isSolvable(words, result):\n    from collections import defaultdict\n    from functools import reduce\n    \n    # Collect all unique characters\n    all_chars = set(words + [result])\n    leading_chars = set(w[0] for w in words + [result] if len(w) > 1)\n    \n    # Generate all possible permutations of digit assignments to characters\n    digits = '0123456789'\n    for perm in permutations(digits, len(all_chars)):\n        char_to_digit = dict(zip(all_chars, perm))\n        \n        # Convert words and result to numbers using the current permutation\n        num_words = [int(''.join(char_to_digit[c] for c in word)) for word in words]\n        num_result = int(''.join(char_to_digit[c] for c in result))\n        \n        # Check if the equation holds and no leading character is assigned 0\n        if sum(num_words) == num_result and all(char_to_digit[c] != '0' for c in leading_chars):\n            return True\n    \n    return False", "def isSolvable(words, result):\n    from itertools import permutations\n\n    chars = set(''.join(words) + result)\n    if len(chars) > 10:\n        return False\n\n    def valid(perm):\n        total = 0\n        for word in words:\n            num = int(''.join(str(perm[ord(c) - ord('A')]) for c in word))\n            total += num\n        num = int(''.join(str(perm[ord(c) - ord('A')]) for c in result))\n        return total == num\n\n    for perm in permutations(range(10), len(chars)):\n        if valid(perm) and (len(words[0]) > 1 or perm[ord(words[0][0]) - ord('A')] != 0) and (len(result) > 1 or perm[ord(result[0]) - ord('A')] != 0):\n            return True\n    return False"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 6919, "entry_point": "getMaxRepetitions", "codes": ["def getMaxRepetitions(s1, n1, s2, n2):\n    if n1 == 0:\n        return 0\n    \n    idx = 0\n    count = 0\n    s1_length = len(s1)\n    s2_length = len(s2)\n    \n    for _ in range(n1):\n        for char in s1:\n            if char == s2[idx]:\n                idx += 1\n                if idx == s2_length:\n                    idx = 0\n                    count += 1\n    \n    return count // n2", "def getMaxRepetitions(s1, n1, s2, n2):\n    if n1 == 0:\n        return 0\n    \n    s1_len, s2_len = len(s1), len(s2)\n    s1_count, s2_count = 0, 0\n    s2_index = 0\n    \n    while s1_count < n1:\n        s1_count += 1\n        for char in s1:\n            if char == s2[s2_index]:\n                s2_index += 1\n                if s2_index == s2_len:\n                    s2_count += 1\n                    s2_index = 0\n    \n    return s2_count // n2", "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    if n1 == 0:\n        return 0\n    \n    count_s2 = 0\n    index_s1 = 0\n    len_s1 = len(s1)\n    len_s2 = len(s2)\n    \n    for _ in range(n1):\n        for char in s1:\n            if char == s2[index_s1]:\n                index_s1 += 1\n                if index_s1 == len_s2:\n                    count_s2 += 1\n                    index_s1 = 0\n    \n    return count_s2 // n2", "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    if n1 == 0:\n        return 0\n    s1_len, s2_len = len(s1), len(s2)\n    s1_reps, s2_reps = [0], [0]\n    i, j = 0, 0\n\n    while True:\n        i += 1\n        for char in s1:\n            if char == s2[j]:\n                j += 1\n                if j == s2_len:\n                    j = 0\n                    s2_reps.append(s2_reps[-1] + 1)\n        s1_reps.append(i)\n\n        if i - s1_reps[-2] == s1_reps[-1] - s1_reps[-3]:\n            cycle_length = i - s1_reps[-2]\n            cycle_s2_reps = s2_reps[-1] - s2_reps[-2]\n            remaining_length = n1 - s1_reps[-1]\n            full_cycles = remaining_length // cycle_length\n            return (s2_reps[-1] + full_cycles * cycle_s2_reps) // n2", "def getMaxRepetitions(s1, n1, s2, n2):\n    if n1 == 0:\n        return 0\n    \n    pos, cnt1, cnt2 = 0, 0, 0\n    seen = {}\n    \n    while cnt1 < n1:\n        pos = s1.find(s2[pos], pos + 1)\n        if pos == -1:\n            pos = s1.find(s2[0])\n            cnt1 += 1\n            cnt2 += 1\n        else:\n            pos += 1\n            cnt1 += 1\n            cnt2 += 1\n        \n        if (pos, cnt2) in seen:\n            break\n    \n    if (pos, cnt2) not in seen:\n        return cnt2 // n2\n    \n    prev_cnt1, prev_cnt2 = seen[(pos, cnt2)]\n    cycle_cnt1 = cnt1 - prev_cnt1\n    cycle_cnt2 = cnt2 - prev_cnt2\n    \n    remaining = n1 - prev_cnt1\n    full_cycles = remaining // cycle_cnt1\n    \n    return (prev_cnt2 + full_cycles * cycle_cnt2) // n2", "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    if n1 == 0:\n        return 0\n\n    dp = {}\n    p, q = 0, 0\n    count = 0\n\n    for i in range(n1):\n        for char in s1:\n            if char == s2[q]:\n                q += 1\n                if q == len(s2):\n                    q = 0\n                    count += 1\n            if (p, q) in dp:\n                break\n            dp[(p, q)] = i, count\n        p = i + 1\n\n    if (p, q) not in dp:\n        return count // n2\n\n    cycle_start_i, cycle_count = dp[(p, q)]\n    cycle_length = p - cycle_start_i\n    cycle_repetitions = (n1 - cycle_start_i) // cycle_length\n    remaining_count = count - cycle_count\n\n    return (remaining_count + cycle_repetitions * cycle_count) // n2", "def getMaxRepetitions(s1, n1, s2, n2):\n    if n1 == 0:\n        return 0\n\n    pos, count1, count2 = 0, 0, 0\n    len1, len2 = len(s1), len(s2)\n    repeat = {}\n\n    while count1 < n1:\n        pos = s1.find(s2[pos], pos)\n        if pos == -1:\n            count1 += 1\n            pos = 0\n        else:\n            pos += 1\n            count2 += 1\n\n            if pos == len2:\n                count2, count1 = count2 // n2, count1 + 1\n                pos = 0\n\n            if (pos, count1) in repeat:\n                prev_count1, prev_count2 = repeat[(pos, count1)]\n                cycle_len1 = count1 - prev_count1\n                cycle_len2 = count2 - prev_count2\n                remaining = (n1 - count1) // cycle_len1\n                count1 += remaining * cycle_len1\n                count2 += remaining * cycle_len2\n\n    return count2 // n2", "def getMaxRepetitions(s1, n1, s2, n2):\n    def count_repetitions(s1, s2):\n        count = i = j = 0\n        while i < len(s1):\n            if s1[i] == s2[j]:\n                j += 1\n                if j == len(s2):\n                    count += 1\n                    j = 0\n            i += 1\n        return count\n\n    if n1 == 0:\n        return 0\n\n    count = 0\n    repetitions = [0] * len(s2)\n    states = {}\n    index = 0\n\n    for _ in range(n1):\n        count += count_repetitions(s1, s2)\n        index = (index + count_repetitions(s1, s2)) % len(s2)\n        if index in states:\n            break\n        states[index] = (count, _)\n\n    if index not in states:\n        return count // n2\n\n    cycle_count = count - states[index][0]\n    cycle_length = _ - states[index][1]\n    full_cycles = (n1 - states[index][1] - 1) // cycle_length\n    remaining_repetitions = count_repetitions(s1[:states[index][1] + full_cycles * cycle_length + len(s1)], s2)\n\n    return (states[index][0] + full_cycles * cycle_count + remaining_repetitions) // n2"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 7091, "entry_point": "findPairs", "codes": ["def findPairs(nums, k):\n    if k < 0:\n        return 0\n    count = 0\n    num_set = set(nums)\n    for num in num_set:\n        if num + k in num_set:\n            count += 1\n    return count", "def findPairs(nums, k):\n    if k < 0:\n        return 0\n    num_set = set(nums)\n    pairs = set()\n    for num in num_set:\n        if num + k in num_set:\n            pairs.add((num, num + k))\n    return len(pairs)", "def findPairs(nums, k):\n    if k < 0:\n        return 0\n    count = 0\n    num_set = set(nums)\n    if k == 0:\n        return sum(1 for num in num_set if nums.count(num) > 1)\n    for num in num_set:\n        if num + k in num_set:\n            count += 1\n    return count", "def findPairs(nums, k):\n    from collections import Counter\n    count = Counter(nums)\n    return sum(v > 1 for v in count.values()) if k == 0 else sum(k in count for k in count)", "def findPairs(nums, k):\n    if k < 0:\n        return 0\n    count = 0\n    seen = set()\n    duplicates = set()\n    \n    for num in nums:\n        if (num - k) in seen and (num - k) not in duplicates:\n            count += 1\n            duplicates.add(num - k)\n        if (num + k) in seen and (num + k) not in duplicates:\n            count += 1\n            duplicates.add(num + k)\n        seen.add(num)\n    \n    return count", "def findPairs(nums, k):\n    if k < 0:\n        return 0\n    count = 0\n    seen = set()\n    for num in nums:\n        if num + k in seen:\n            count += 1\n        if num - k in seen:\n            count += 1\n        seen.add(num)\n    return count"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 7154, "entry_point": "threeSumMulti", "codes": ["def threeSumMulti(A, target):\n    count = {}\n    result = 0\n    mod = 10**9 + 7\n    \n    for k, x in enumerate(A):\n        result = (result + count.get(target - x, 0)) % mod\n        for j in range(k):\n            y = A[j]\n            count[x + y] = count.get(x + y, 0) + 1\n    \n    return result", "from collections import Counter\n\ndef threeSumMulti(A, target):\n    count = Counter(A)\n    result = 0\n    for i in range(101):\n        for j in range(i, 101):\n            k = target - i - j\n            if k < 0 or k > 100:\n                continue\n            if i == j == k:\n                result += count[i] * (count[i] - 1) * (count[i] - 2) // 6\n            elif i == j and i != k:\n                result += count[i] * (count[i] - 1) // 2 * count[k]\n            elif i < j and j < k:\n                result += count[i] * count[j] * count[k]\n    return result % (10**9 + 7)\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "from collections import Counter\n\ndef threeSumMulti(A, target):\n    count = Counter(A)\n    result = 0\n    mod = 10**9 + 7\n    \n    for i in range(101):\n        for j in range(i, 101):\n            k = target - i - j\n            if k >= j and k <= 100:\n                if i == j == k:\n                    result += count[i] * (count[i] - 1) * (count[i] - 2) // 6\n                elif i == j != k:\n                    result += count[i] * (count[i] - 1) // 2 * count[k]\n                elif i < j == k:\n                    result += count[i] * count[j] * (count[j] - 1) // 2\n                else:\n                    result += count[i] * count[j] * count[k]\n    \n    return result % mod", "from collections import Counter\nfrom typing import List\n\ndef threeSumMulti(A: List[int], target: int) -> int:\n    count = Counter(A)\n    result = 0\n    MOD = 10**9 + 7\n    \n    for i in sorted(count):\n        for j in sorted(count):\n            k = target - i - j\n            if k in count:\n                if i == j == k:\n                    result += count[i] * (count[i] - 1) * (count[i] - 2) // 6\n                elif i == j != k:\n                    result += count[i] * (count[i] - 1) // 2 * count[k]\n                elif i != j == k:\n                    result += count[j] * (count[j] - 1) // 2 * count[i]\n                else:\n                    result += count[i] * count[j] * count[k]\n                result %= MOD\n    \n    return result", "from collections import Counter\n\ndef threeSumMulti(A, target):\n    count = Counter(A)\n    mod = 10**9 + 7\n    result = 0\n\n    # Case 1: All three numbers are the same\n    for num in count:\n        if 3 * num == target:\n            result += count[num] * (count[num] - 1) * (count[num] - 2) // 6\n            result %= mod\n\n    # Case 2: Two numbers are the same, one is different\n    for num1 in count:\n        for num2 in count:\n            if num1 != num2 and num1 + 2 * num2 == target:\n                result += count[num1] * count[num2] * (count[num2] - 1) // 2\n                result %= mod\n\n    # Case 3: All three numbers are different\n    for num1 in count:\n        for num2 in count:\n            for num3 in count:\n                if num1 != num2 and num2 != num3 and num1 != num3 and num1 + num2 + num3 == target:\n                    result += count[num1] * count[num2] * count[num3]\n                    result %= mod\n\n    return result", "def threeSumMulti(A, target):\n    A.sort()\n    n = len(A)\n    count = 0\n    for i in range(n - 2):\n        if i > 0 and A[i] == A[i - 1]:\n            continue\n        j, k = i + 1, n - 1\n        while j < k:\n            total = A[i] + A[j] + A[k]\n            if total < target:\n                j += 1\n            elif total > target:\n                k -= 1\n            else:\n                if A[j] == A[k]:\n                    count += k - j\n                else:\n                    count += (k - j) * (k - j + 1) // 2\n                j += 1\n                k -= 1\n                while j < k and A[j] == A[j - 1]:\n                    j += 1\n                while j < k and A[k] == A[k + 1]:\n                    k -= 1\n    return count % (10**9 + 7)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 7166, "entry_point": "shortestPathAllKeys", "codes": ["from collections import deque\n\ndef shortestPathAllKeys(grid):\n    rows, cols = len(grid), len(grid[0])\n    start, keys = None, 0\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '@':\n                start = (r, c)\n            elif grid[r][c].islower():\n                keys |= 1 << (ord(grid[r][c]) - ord('a'))\n    \n    queue = deque([(start[0], start[1], 0)])\n    visited = set((start[0], start[1], 0))\n    moves = 0\n    \n    while queue:\n        for _ in range(len(queue)):\n            r, c, mask = queue.popleft()\n            if mask == keys:\n                return moves\n            \n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != '#':\n                    new_mask = mask\n                    if grid[nr][nc].islower():\n                        new_mask |= 1 << (ord(grid[nr][nc]) - ord('a'))\n                    elif grid[nr][nc].isupper() and (new_mask & (1 << (ord(grid[nr][nc].lower()) - ord('a')))) == 0:\n                        continue\n                    if (nr, nc, new_mask) not in visited:\n                        visited.add((nr, nc, new_mask))\n                        queue.append((nr, nc, new_mask))\n        moves += 1\n    \n    return -1", "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    R, C = len(grid), len(grid[0])\n    keys = set()\n    start = (0, 0)\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == '@':\n                start = (r, c)\n            elif grid[r][c].islower():\n                keys.add(grid[r][c])\n    \n    all_keys = (1 << len(keys)) - 1\n    queue = deque([(start, 0, 0)])\n    visited = set([(start, 0)])\n    \n    while queue:\n        (r, c), keys_collected, moves = queue.popleft()\n        if keys_collected == all_keys:\n            return moves\n        \n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] != '#':\n                new_keys_collected = keys_collected\n                if grid[nr][nc].islower():\n                    new_keys_collected |= 1 << (ord(grid[nr][nc]) - ord('a'))\n                if grid[nr][nc].isupper():\n                    if new_keys_collected & (1 << (ord(grid[nr][nc]) - ord('A'))):\n                        new_keys_collected &= ~(1 << (ord(grid[nr][nc]) - ord('A')))\n                    else:\n                        continue\n                \n                if (nr, nc, new_keys_collected) not in visited:\n                    visited.add((nr, nc, new_keys_collected))\n                    queue.append(((nr, nc), new_keys_collected, moves + 1))\n    \n    return -1", "def shortestPathAllKeys(grid):\n    from collections import deque\n    \n    M, N = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    def get_start_and_keys():\n        start = None\n        keys = set()\n        for i in range(M):\n            for j in range(N):\n                if grid[i][j] == '@':\n                    start = (i, j)\n                elif grid[i][j].islower():\n                    keys.add(grid[i][j])\n        return start, keys\n    \n    start, keys = get_start_and_keys()\n    all_keys = (1 << len(keys)) - 1\n    \n    queue = deque([(start, 0, 0)])\n    visited = set([(start, 0)])\n    \n    while queue:\n        (x, y), key_mask, steps = queue.popleft()\n        \n        if key_mask == all_keys:\n            return steps\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] != '#':\n                new_key_mask = key_mask\n                if grid[nx][ny].islower():\n                    new_key_mask |= 1 << (ord(grid[nx][ny]) - ord('a'))\n                if grid[nx][ny].isupper() and (new_key_mask & (1 << (ord(grid[nx][ny]) - ord('A')))) == 0:\n                    continue\n                if (nx, ny, new_key_mask) not in visited:\n                    visited.add((nx, ny, new_key_mask))\n                    queue.append(((nx, ny), new_key_mask, steps + 1))\n    \n    return -1", "from collections import deque\n\ndef shortestPathAllKeys(self, grid: list[str]) -> int:\n    m, n = len(grid), len(grid[0])\n    keys = sum(1 for c in grid for c in \"abcdef\" if c in c)\n    directions = [0, 1, 0, -1, 0]\n    start = None\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"@\":\n                start = (i, j)\n            elif grid[i][j] in \"abcdef\":\n                keys |= 1 << (ord(grid[i][j]) - ord(\"a\"))\n    queue = deque([(start, 0)])\n    visited = set(queue)\n    while queue:\n        (x, y), state = queue.popleft()\n        if state == keys:\n            return len(visited) - 1\n        for k in range(4):\n            nx, ny = x + directions[k], y + directions[k + 1]\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != \"#\":\n                new_state = state\n                if grid[nx][ny] in \"abcdef\":\n                    new_state |= 1 << (ord(grid[nx][ny]) - ord(\"a\"))\n                if grid[nx][ny].isupper() and not (new_state & (1 << (ord(grid[nx][ny].lower()) - ord(\"a\")))):\n                    continue\n                if (nx, ny, new_state) not in visited:\n                    visited.add((nx, ny, new_state))\n                    queue.append(((nx, ny), new_state))\n    return -1", "def shortestPathAllKeys(grid):\n    rows, cols = len(grid), len(grid[0])\n    directions = [0, 1, 0, -1, 0]\n    all_keys = 0\n    start = (0, 0)\n\n    # Find starting point and count all keys\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '@':\n                start = (r, c)\n            elif grid[r][c].islower():\n                all_keys |= 1 << (ord(grid[r][c]) - ord('a'))\n\n    # BFS initialization\n    queue = [(start[0], start[1], 0, 0)]  # (row, col, keys collected, moves)\n    visited = set(queue)\n\n    while queue:\n        r, c, keys, moves = queue.pop(0)\n\n        # Check all four directions\n        for i in range(4):\n            nr, nc = r + directions[i], c + directions[i + 1]\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != '#':\n                if grid[nr][nc].islower():\n                    new_keys = keys | (1 << (ord(grid[nr][nc]) - ord('a')))\n                    if new_keys == all_keys:\n                        return moves + 1\n                    if (nr, nc, new_keys) not in visited:\n                        visited.add((nr, nc, new_keys))\n                        queue.append((nr, nc, new_keys, moves + 1))\n                elif grid[nr][nc].isupper() and (keys & (1 << (ord(grid[nr][nc].lower()) - ord('a')))):\n                    if (nr, nc, keys) not in visited:\n                        visited.add((nr, nc, keys))\n                        queue.append((nr, nc, keys, moves + 1))\n\n    return -1", "def shortestPathAllKeys(self, grid):\n    R, C = len(grid), len(grid[0])\n    start = None\n    keys = set()\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == '@':\n                start = (r, c)\n            elif grid[r][c] in 'abcdef':\n                keys.add(grid[r][c])\n    all_keys = ''.join(sorted(keys))\n    target = (1 << len(keys)) - 1\n    q = [(0, start[0], start[1], 0)]\n    visited = set()\n    while q:\n        dist, r, c, state = q.pop(0)\n        if (r, c, state) in visited:\n            continue\n        visited.add((r, c, state))\n        if state == target:\n            return dist\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] != '#':\n                if grid[nr][nc] in 'abcdef':\n                    q.append((dist + 1, nr, nc, state | (1 << (ord(grid[nr][nc]) - ord('a')))))\n                elif grid[nr][nc] in 'ABCDEF' and (state & (1 << (ord(grid[nr][nc]) - ord('A')))):\n                    q.append((dist + 1, nr, nc, state))\n    return -1", "def shortestPathAllKeys(grid):\n    rows, cols = len(grid), len(grid[0])\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    start = None\n    keys = set()\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '@':\n                start = (r, c)\n            elif grid[r][c].islower():\n                keys.add(grid[r][c])\n    \n    target = (1 << len(keys)) - 1\n    queue = [(start[0], start[1], 0, 0)]\n    visited = set()\n    \n    while queue:\n        r, c, key_state, moves = queue.pop(0)\n        if (r, c, key_state) in visited:\n            continue\n        visited.add((r, c, key_state))\n        \n        if key_state == target:\n            return moves\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != '#':\n                if grid[nr][nc].islower():\n                    new_key_state = key_state | (1 << (ord(grid[nr][nc]) - ord('a')))\n                    queue.append((nr, nc, new_key_state, moves + 1))\n                elif grid[nr][nc].isupper() and (key_state & (1 << (ord(grid[nr][nc]) - ord('A')))):\n                    queue.append((nr, nc, key_state, moves + 1))\n    \n    return -1", "from collections import namedtuple\n\ndef shortestPathAllKeys(grid):\n    n, m = len(grid), len(grid[0])\n    Key = namedtuple('Key', 'x y keys')\n    \n    def get_start():\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '@':\n                    return Key(i, j, 0)\n        return None\n    \n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and grid[x][y] != '#'\n    \n    def get_neighbors(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny):\n                yield nx, ny\n    \n    start = get_start()\n    if not start:\n        return -1\n    \n    target_keys = (1 << k) for k in range(6) if grid[k][0].islower()\n    target_mask = sum(target_keys)\n    \n    queue = [(start.x, start.y, start.keys, 0)]\n    visited = set((start.x, start.y, start.keys))\n    \n    while queue:\n        x, y, keys, steps = queue.pop(0)\n        if keys == target_mask:\n            return steps\n        \n        for nx, ny in get_neighbors(x, y):\n            key = ord(grid[nx][ny]) - ord('a')\n            new_keys = keys\n            if key >= 0:\n                new_keys |= 1 << key\n            if (nx, ny, new_keys) not in visited and is_valid(nx, ny):\n                visited.add((nx, ny, new_keys))\n                queue.append((nx, ny, new_keys, steps + 1))\n    \n    return -1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 773, "entry_point": "hammingDistance", "codes": ["def hammingDistance(x, y):\n    return bin(x ^ y).count('1')", "def hammingDistance(x, y):\n    xor_result = x ^ y\n    distance = 0\n    while xor_result:\n        distance += xor_result & 1\n        xor_result >>= 1\n    return distance", "def hammingDistance(x, y):\n    xor = x ^ y\n    distance = 0\n    while xor:\n        distance += xor & 1\n        xor >>= 1\n    return distance", "def hammingDistance(x, y):\n    return (x ^ y).bit_count()"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 7575, "entry_point": "sumSubarrayMins", "codes": ["def sumSubarrayMins(A):\n    MOD = 10**9 + 7\n    total = 0\n    for i in range(len(A)):\n        min_val = A[i]\n        for j in range(i, len(A)):\n            min_val = min(min_val, A[j])\n            total = (total + min_val) % MOD\n    return total", "def sumSubarrayMins(A):\n    MOD = 10**9 + 7\n    stack = []\n    A = [0] + A + [0]\n    result = 0\n    for i, a in enumerate(A):\n        while stack and A[stack[-1]] > a:\n            j = stack.pop()\n            k = stack[-1]\n            result += A[j] * (i - j) * (j - k)\n        stack.append(i)\n    return result % MOD", "def sumSubarrayMins(A):\n    MOD = 10**9 + 7\n    total_sum = 0\n    stack = []\n    A = [0] + A + [0]\n    for i, num in enumerate(A):\n        while stack and A[stack[-1]] > num:\n            j = stack.pop()\n            k = stack[-1]\n            total_sum = (total_sum + A[j] * (i - j) * (j - k)) % MOD\n        stack.append(i)\n    return total_sum", "def sumSubarrayMins(A):\n    MOD = 10**9 + 7\n    n = len(A)\n    stack = []\n    left = [0] * n\n    right = [n] * n\n\n    for i in range(n):\n        while stack and A[stack[-1]] > A[i]:\n            stack.pop()\n        if stack:\n            left[i] = i - stack[-1]\n        stack.append(i)\n\n    stack = []\n    for i in range(n-1, -1, -1):\n        while stack and A[stack[-1]] >= A[i]:\n            stack.pop()\n        if stack:\n            right[i] = stack[-1] - i\n        stack.append(i)\n\n    return sum(A[i] * left[i] * right[i] for i in range(n)) % MOD"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 7686, "entry_point": "numRollsToTarget", "codes": ["def numRollsToTarget(d, f, target):\n    MOD = 10**9 + 7\n    dp = [[0] * (target + 1) for _ in range(d + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, d + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = sum(dp[i - 1][j - k] for k in range(1, f + 1) if j >= k) % MOD\n\n    return dp[d][target]", "def numRollsToTarget(d: int, f: int, target: int) -> int:\n    MOD = 10**9 + 7\n    dp = [[0] * (target + 1) for _ in range(d + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, d + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = sum(dp[i - 1][j - k] for k in range(1, f + 1) if j - k >= 0) % MOD\n\n    return dp[d][target]", "def numRollsToTarget(d, f, target):\n    MOD = 10**9 + 7\n    dp = [[0] * (target + 1) for _ in range(d + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, d + 1):\n        for j in range(1, target + 1):\n            for k in range(1, f + 1):\n                if j >= k:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % MOD\n\n    return dp[d][target]", "def numRollsToTarget(d, f, target):\n    MOD = 10**9 + 7\n    dp = [[0] * (target + 1) for _ in range(d + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, d + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = sum(dp[i-1][max(0, j-k)] for k in range(1, f + 1)) % MOD\n\n    return dp[d][target]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 7774, "entry_point": "maxProfit", "codes": ["def maxProfit(prices):\n    first_buy, first_sell = float('inf'), 0\n    second_buy, second_sell = float('inf'), 0\n    \n    for price in prices:\n        first_buy = min(first_buy, price)\n        first_sell = max(first_sell, price - first_buy)\n        second_buy = min(second_buy, price - first_sell)\n        second_sell = max(second_sell, price - second_buy)\n    \n    return second_sell", "def maxProfit(prices):\n    if not prices:\n        return 0\n\n    first_buy, first_sell = float('-inf'), 0\n    second_buy, second_sell = float('-inf'), 0\n\n    for price in prices:\n        first_buy = max(first_buy, -price)\n        first_sell = max(first_sell, first_buy + price)\n        second_buy = max(second_buy, first_sell - price)\n        second_sell = max(second_sell, second_buy + price)\n\n    return second_sell", "def maxProfit(prices):\n    n = len(prices)\n    if n == 0:\n        return 0\n    \n    first_buy, first_sell, second_buy, second_sell = float('-inf'), 0, float('-inf'), 0\n    \n    for price in prices:\n        first_buy = max(first_buy, -price)\n        first_sell = max(first_sell, first_buy + price)\n        second_buy = max(second_buy, first_sell - price)\n        second_sell = max(second_sell, second_buy + price)\n    \n    return second_sell", "def maxProfit(prices):\n    if not prices:\n        return 0\n    \n    n = len(prices)\n    left_profits = [0] * n\n    right_profits = [0] * n\n    \n    min_price = float('inf')\n    for i in range(n):\n        min_price = min(min_price, prices[i])\n        left_profits[i] = max(left_profits[i - 1], prices[i] - min_price)\n    \n    max_price = float('-inf')\n    for i in range(n - 1, -1, -1):\n        max_price = max(max_price, prices[i])\n        right_profits[i] = max(right_profits[i + 1], max_price - prices[i])\n    \n    max_profit = 0\n    for i in range(n):\n        max_profit = max(max_profit, left_profits[i] + right_profits[i])\n    \n    return max_profit", "def maxProfit(prices):\n    if not prices:\n        return 0\n\n    n = len(prices)\n    profit = 0\n    min_price = prices[0]\n\n    for i in range(1, n):\n        if prices[i] < min_price:\n            min_price = prices[i]\n        else:\n            profit = max(profit, prices[i] - min_price)\n\n    return profit", "def maxProfit(prices):\n    if not prices:\n        return 0\n    \n    n = len(prices)\n    dp = [[0] * 3 for _ in range(n)]\n    \n    for i in range(1, n):\n        max_diff = -prices[0]\n        for j in range(1, 3):\n            dp[i][j] = max(dp[i - 1][j], prices[i] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j - 1] - prices[i])\n    \n    return dp[-1][2]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 7793, "entry_point": "findBestValue", "codes": ["def findBestValue(arr, target):\n    arr.sort()\n    n = len(arr)\n    prefix_sum = 0\n    for i, num in enumerate(arr):\n        prefix_sum += num\n        if prefix_sum + (n - i - 1) * num >= target:\n            return (target - prefix_sum) // (n - i - 1) if n - i - 1 != 0 else arr[-1]\n    return arr[-1]", "def findBestValue(arr, target):\n    arr.sort()\n    prefix_sum = [0]\n    for num in arr:\n        prefix_sum.append(prefix_sum[-1] + num)\n    \n    n = len(arr)\n    left, right = 0, max(arr)\n    \n    while left < right:\n        mid = (left + right) // 2\n        idx = bisect.bisect(arr, mid)\n        current_sum = prefix_sum[idx] + mid * (n - idx)\n        \n        if current_sum == target:\n            return mid\n        elif current_sum < target:\n            left = mid + 1\n        else:\n            right = mid\n    \n    idx = bisect.bisect(arr, left)\n    if idx == 0 or abs(target - prefix_sum[idx] - left * (n - idx)) < abs(target - prefix_sum[idx - 1] - left * (n - idx - 1)):\n        return left\n    else:\n        return left - 1", "def findBestValue(arr, target):\n    arr.sort()\n    acc = [0]\n    for num in arr:\n        acc.append(acc[-1] + num)\n    \n    left, right = 0, arr[-1]\n    while left < right:\n        mid = (left + right) // 2\n        idx = bisect.bisect_right(arr, mid)\n        if acc[idx] + mid * (len(arr) - idx) < target:\n            left = mid + 1\n        else:\n            right = mid\n    \n    idx = bisect.bisect_right(arr, left)\n    if idx == 0:\n        return left\n    sum_before = acc[idx - 1]\n    diff_before = abs(sum_before + left * idx - target)\n    sum_after = acc[-1] - sum_before\n    diff_after = abs(sum_after + left * (len(arr) - idx) - target)\n    \n    if diff_before <= diff_after:\n        return arr[idx - 1]\n    else:\n        return left", "def findBestValue(arr, target):\n    arr.sort()\n    prefix_sum = [0]\n    for num in arr:\n        prefix_sum.append(prefix_sum[-1] + num)\n    n = len(arr)\n    left, right = 0, arr[-1]\n    best_value = 0\n    best_diff = float('inf')\n    while left <= right:\n        mid = (left + right) // 2\n        idx = bisect_right(arr, mid)\n        current_sum = prefix_sum[idx] + (n - idx) * mid\n        diff = abs(target - current_sum)\n        if diff < best_diff:\n            best_diff = diff\n            best_value = mid\n        if current_sum < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return best_value", "def findBestValue(arr, target):\n    arr.sort()\n    cumsum = [0]\n    for num in arr:\n        cumsum.append(cumsum[-1] + num)\n    \n    left, right = 0, max(arr)\n    while left < right:\n        mid = (left + right) // 2\n        idx = bisect.bisect_right(arr, mid)\n        if cumsum[idx] + mid * (len(arr) - idx) < target:\n            left = mid + 1\n        else:\n            right = mid\n    \n    idx = bisect.bisect_right(arr, left)\n    value1 = cumsum[idx] + left * (len(arr) - idx)\n    value2 = cumsum[idx - 1] + left * (len(arr) - idx + 1)\n    return left if abs(value1 - target) <= abs(value2 - target) else left - 1", "def findBestValue(arr, target):\n    left, right = 0, max(arr) + 1\n    while left < right:\n        mid = (left + right) // 2\n        current_sum = sum(min(mid, x) for x in arr)\n        if current_sum == target:\n            return mid\n        elif current_sum < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left if abs(target - sum(min(left, x) for x in arr)) < abs(target - sum(min(right, x) for x in arr)) else right"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 7895, "entry_point": "minNumberOperations", "codes": ["def minNumberOperations(target):\n    return sum(max(target[i] - target[i-1], 0) for i in range(1, len(target))) + target[0]", "def minNumberOperations(target):\n    return sum(max(0, target[i] - target[i - 1]) for i in range(1, len(target))) + target[0]", "def minNumberOperations(target):\n    increments = 0\n    for i in range(1, len(target)):\n        increments += max(0, target[i] - target[i-1])\n    return increments + target[0]", "def minNumberOperations(target):\n    return sum(map(lambda x: max(0, target[x] - target[x-1]), range(1, len(target))))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 811, "entry_point": "maxProfit", "codes": ["def maxProfit(prices):\n    if not prices:\n        return 0\n\n    buy, sell, cool = float('-inf'), 0, 0\n    for price in prices:\n        buy, sell, cool = max(buy, cool - price), buy + price, max(cool, sell)\n    return max(sell, cool)", "def maxProfit(prices):\n    if not prices:\n        return 0\n    \n    n = len(prices)\n    hold, sold, reset = float('-inf'), float('-inf'), 0\n    \n    for price in prices:\n        hold, sold, reset = max(hold, reset - price), hold + price, max(reset, sold)\n    \n    return max(sold, reset)", "def maxProfit(prices):\n    if not prices:\n        return 0\n\n    n = len(prices)\n    dp = [0] * n\n    for i in range(1, n):\n        dp[i] = max(dp[i-1], prices[i] - prices[i-1] + (dp[i-2] if i >= 2 else 0))\n    return dp[-1]", "def maxProfit(prices):\n    def dp(i, holding):\n        if i >= len(prices):\n            return 0\n        if (i, holding) in memo:\n            return memo[(i, holding)]\n        if holding:\n            profit = max(dp(i + 1, False) + prices[i], dp(i + 1, True))\n        else:\n            profit = max(dp(i + 1, True) - prices[i] - cooldown, dp(i + 1, False))\n        memo[(i, holding)] = profit\n        return profit\n\n    memo = {}\n    cooldown = 1\n    return dp(0, False)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 817, "entry_point": "rob", "codes": ["def rob(houses):\n    def rob_linear(houses):\n        prev1, prev2 = 0, 0\n        for house in houses:\n            prev1, prev2 = prev2, max(prev1 + house, prev2)\n        return prev2\n\n    if not houses:\n        return 0\n    if len(houses) == 1:\n        return houses[0]\n\n    return max(rob_linear(houses[:-1]), rob_linear(houses[1:]))", "def rob(nums):\n    def rob_linear(houses):\n        dp = [0, 0]\n        for house in houses:\n            dp.append(max(dp[-1], dp[-2] + house))\n        return dp[-1]\n\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    return max(rob_linear(nums[1:]), rob_linear(nums[:-1]))", "def rob(houses):\n    def rob_linear(houses):\n        dp = [0] * (len(houses) + 1)\n        dp[1] = houses[0]\n        for i in range(2, len(houses) + 1):\n            dp[i] = max(dp[i-1], dp[i-2] + houses[i-1])\n        return dp[-1]\n\n    if not houses:\n        return 0\n    if len(houses) == 1:\n        return houses[0]\n    return max(rob_linear(houses[:-1]), rob_linear(houses[1:]))", "def rob(houses):\n    def rob_linear(houses):\n        if not houses:\n            return 0\n        if len(houses) == 1:\n            return houses[0]\n        prev1, prev2 = 0, 0\n        for house in houses:\n            prev1, prev2 = prev2, max(prev1, prev2 + house)\n        return prev2\n\n    if not houses:\n        return 0\n    if len(houses) == 1:\n        return houses[0]\n    return max(rob_linear(houses[:-1]), rob_linear(houses[1:]))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 8014, "entry_point": "shortestPalindrome", "codes": ["def shortestPalindrome(s):\n    n = len(s)\n    rev = s[::-1]\n    for i in range(n + 1):\n        if s.startswith(rev[i:]):\n            return rev[:i] + s", "def shortestPalindrome(s):\n    if not s:\n        return \"\"\n    \n    for i in range(len(s), -1, -1):\n        if s[:i] == s[:i][::-1]:\n            return s[i:][::-1] + s", "def shortestPalindrome(s):\n    if s == s[::-1]:\n        return s\n    for i in range(len(s), 0, -1):\n        if s[:i] == s[:i][::-1]:\n            return s[i:][::-1] + s", "def shortestPalindrome(s: str) -> str:\n    if s == s[::-1]:\n        return s\n    for i in range(len(s)):\n        if s[i:] == s[i:][::-1]:\n            return s[:i][::-1] + s", "def shortestPalindrome(s):\n    if s == s[::-1]:\n        return s\n    for i in range(len(s)):\n        if s[:i] == s[:i][::-1]:\n            return s[i:][::-1] + s", "def shortestPalindrome(s):\n    if s == s[::-1]:\n        return s\n    \n    for i in range(len(s)):\n        if s[i:] == s[i:][::-1]:\n            return s[:i][::-1] + s\n    \n    return s", "def shortestPalindrome(s):\n    if s == s[::-1]:\n        return s\n    for i in range(len(s)):\n        if s[i:] == s[i:][::-1]:\n            return s[:i][::-1] + s", "def shortestPalindrome(s):\n    if not s:\n        return \"\"\n    for i in range(len(s)):\n        if s[i:] == s[i:][::-1]:\n            return s[:i][::-1] + s"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 8045, "entry_point": "backspaceCompare", "codes": ["def backspaceCompare(S, T):\n    def build(s):\n        result = []\n        for char in s:\n            if char != '#':\n                result.append(char)\n            elif result:\n                result.pop()\n        return ''.join(result)\n    return build(S) == build(T)", "def backspaceCompare(S, T):\n    def build(s):\n        stack = []\n        for char in s:\n            if char == '#' and stack:\n                stack.pop()\n            elif char != '#':\n                stack.append(char)\n        return ''.join(stack)\n    \n    return build(S) == build(T)", "def backspaceCompare(S: str, T: str) -> bool:\n    def process_string(s: str) -> str:\n        result = []\n        for char in s:\n            if char != '#':\n                result.append(char)\n            elif result:\n                result.pop()\n        return ''.join(result)\n    \n    return process_string(S) == process_string(T)", "def backspaceCompare(S: str, T: str) -> bool:\n    def process(s: str) -> str:\n        return ''.join(c for c in reversed(s) if c != '#' or not (yield from range(next((i for i, ch in enumerate(s) if ch == '#'), len(s), -1) - 1)))\n\n    return process(S) == process(T)", "def backspaceCompare(S, T):\n    def build(s):\n        return ''.join(c for c in reversed(s) if c != '#' or (c == '#' and (yield)))\n\n    return build(S) == build(T)", "def backspaceCompare(S: str, T: str) -> bool:\n    def process(s):\n        skip = 0\n        for i in reversed(range(len(s))):\n            if s[i] == '#':\n                skip += 1\n            elif skip:\n                skip -= 1\n            else:\n                yield s[i]\n    \n    return all(x == y for x, y in zip_longest(process(S), process(T)))", "def backspaceCompare(S: str, T: str) -> bool:\n    def process(s: str) -> str:\n        return ''.join(filter(None, (c[:-1] if c == '#' else c for c in ''.join(reversed(list(s))))))\n\n    return process(S) == process(T)", "def backspaceCompare(S: str, T: str) -> bool:\n    def process(s):\n        skip = 0\n        for char in reversed(s):\n            if char == '#':\n                skip += 1\n            elif skip:\n                skip -= 1\n            else:\n                yield char\n\n    return all(x == y for x, y in itertools.zip_longest(process(S), process(T)))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 8215, "entry_point": "reformat", "codes": ["def reformat(s: str) -> str:\n    digits, letters = [], []\n    for char in s:\n        if char.isdigit():\n            digits.append(char)\n        else:\n            letters.append(char)\n    if abs(len(digits) - len(letters)) > 1:\n        return \"\"\n    if len(digits) > len(letters):\n        digits, letters = letters, digits\n    result = []\n    for digit, letter in zip(digits, letters):\n        result.extend([digit, letter])\n    if len(digits) < len(letters):\n        result.append(letters[-1])\n    return \"\".join(result)", "def reformat(s):\n    digits = [char for char in s if char.isdigit()]\n    letters = [char for char in s if char.isalpha()]\n    \n    if abs(len(digits) - len(letters)) > 1:\n        return \"\"\n    \n    if len(digits) > len(letters):\n        digits, letters = letters, digits\n    \n    return \"\".join(d + l for d, l in zip(digits, letters)) + (digits[-1] if len(digits) > len(letters) else \"\")", "def reformat(s):\n    digits = [c for c in s if c.isdigit()]\n    letters = [c for c in s if c.isalpha()]\n    \n    if abs(len(digits) - len(letters)) > 1:\n        return \"\"\n    \n    if len(digits) > len(letters):\n        digits, letters = letters, digits\n    \n    result = []\n    for d, l in zip(digits, letters):\n        result.extend([d, l])\n    \n    if digits:\n        result.append(digits[-1])\n    \n    return \"\".join(result)", "def reformat(s: str) -> str:\n    letters = [c for c in s if c.isalpha()]\n    digits = [c for c in s if c.isdigit()]\n    \n    if abs(len(letters) - len(digits)) > 1:\n        return \"\"\n    \n    if len(letters) < len(digits):\n        letters, digits = digits, letters\n    \n    result = []\n    for i in range(len(digits)):\n        result.append(letters[i])\n        result.append(digits[i])\n    \n    if len(letters) > len(digits):\n        result.append(letters[-1])\n    \n    return \"\".join(result)", "def reformat(s):\n    digits = [c for c in s if c.isdigit()]\n    letters = [c for c in s if c.isalpha()]\n    \n    if abs(len(digits) - len(letters)) > 1:\n        return \"\"\n    \n    if len(digits) > len(letters):\n        digits, letters = letters, digits\n    \n    result = []\n    for d, l in zip(digits, letters):\n        result.extend([d, l])\n    \n    if len(digits) < len(letters):\n        result.append(letters[-1])\n    \n    return \"\".join(result)", "def reformat(s: str) -> str:\n    digits = [c for c in s if c.isdigit()]\n    letters = [c for c in s if c.isalpha()]\n    if abs(len(digits) - len(letters)) > 1:\n        return \"\"\n    if len(digits) > len(letters):\n        digits, letters = letters, digits\n    return \"\".join(a + b for a, b in zip(letters, digits)) + letters[-1] if len(letters) > len(digits) else \"\".join(a + b for a, b in zip(digits, letters))"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 8323, "entry_point": "maxSumTwoNoOverlap", "codes": ["def maxSumTwoNoOverlap(A, L, M):\n    n = len(A)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    max_L = [0] * n\n    max_M = [0] * n\n    \n    # Calculate max sum of L-length subarray ending at each position\n    for i in range(L - 1, n):\n        max_L[i] = max(max_L[i - 1], prefix_sum[i + 1] - prefix_sum[i + 1 - L])\n    \n    # Calculate max sum of M-length subarray ending at each position\n    for i in range(M - 1, n):\n        max_M[i] = max(max_M[i - 1], prefix_sum[i + 1] - prefix_sum[i + 1 - M])\n    \n    # Calculate max sum of two non-overlapping subarrays\n    result = 0\n    for i in range(L - 1, n - M):\n        result = max(result, max_L[i] + prefix_sum[i + M + 1] - prefix_sum[i + 1])\n    for i in range(M - 1, n - L):\n        result = max(result, max_M[i] + prefix_sum[i + L + 1] - prefix_sum[i + 1])\n    \n    return result", "def maxSumTwoNoOverlap(A, L, M):\n    n = len(A)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    def maxSum(subarray_length):\n        max_sum = float('-inf')\n        current_max = 0\n        for i in range(subarray_length, n + 1):\n            current_max = max(current_max, prefix_sum[i] - prefix_sum[i - subarray_length])\n            max_sum = max(max_sum, prefix_sum[i] - prefix_sum[i - subarray_length] + current_max)\n        return max_sum\n    \n    return max(maxSum(L) + maxSum(M), maxSum(M) + maxSum(L))", "def maxSumTwoNoOverlap(A, L, M):\n    n = len(A)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    max_l_sum = [0] * n\n    for i in range(L - 1, n):\n        max_l_sum[i] = prefix_sum[i + 1] - prefix_sum[i - L + 1]\n    \n    max_m_sum = [0] * n\n    for i in range(M - 1, n):\n        max_m_sum[i] = prefix_sum[i + 1] - prefix_sum[i - M + 1]\n    \n    max_l_sum[i] = max(max_l_sum[i], max_l_sum[i - 1])\n    max_m_sum[i] = max(max_m_sum[i], max_m_sum[i - 1])\n    \n    result = 0\n    for i in range(L - 1, n - M):\n        result = max(result, max_l_sum[i] + max_m_sum[i + M])\n    \n    for i in range(M - 1, n - L):\n        result = max(result, max_m_sum[i] + max_l_sum[i + L])\n    \n    return result", "def maxSumTwoNoOverlap(A, L, M):\n    n = len(A)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    def maxSumOne(length):\n        max_sum = float('-inf')\n        current_sum = 0\n        for i in range(length, n + 1):\n            current_sum = prefix_sum[i] - prefix_sum[i - length]\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    \n    max_L = maxSumOne(L)\n    max_M = maxSumOne(M)\n    \n    max_sum = 0\n    for i in range(L, n - M + 1):\n        max_sum = max(max_sum, max_L + prefix_sum[i + M] - prefix_sum[i])\n    for i in range(M, n - L + 1):\n        max_sum = max(max_sum, max_M + prefix_sum[i + L] - prefix_sum[i])\n    \n    return max_sum", "def maxSumTwoNoOverlap(A, L, M):\n    n = len(A)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + A[i]\n\n    def maxSumOfSubarray(length):\n        dp = [0] * n\n        max_sum = 0\n        for i in range(length - 1, n):\n            dp[i] = prefix[i + 1] - prefix[i - length + 1]\n            max_sum = max(max_sum, dp[i])\n            if i >= length:\n                dp[i] += max_sum\n        return max(dp)\n\n    sum_L = maxSumOfSubarray(L)\n    sum_M = maxSumOfSubarray(M)\n    return max(sum_L + sum_M - max(sum_L, sum_M), sum_L + maxSumOfSubarray(M), sum_M + maxSumOfSubarray(L))", "def maxSumTwoNoOverlap(A, L, M):\n    def maxSumOneSubarray(A, length):\n        max_sum = float('-inf')\n        current_sum = 0\n        for i in range(len(A)):\n            current_sum += A[i]\n            if i >= length:\n                current_sum -= A[i - length]\n            if i >= length - 1:\n                max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    maxL = maxSumOneSubarray(A, L)\n    maxM = maxSumOneSubarray(A, M)\n    max_sum = float('-inf')\n\n    for i in range(len(A) - L - M + 1):\n        sum1 = sum(A[i:i+L])\n        sum2 = sum(A[i+L:i+L+M])\n        max_sum = max(max_sum, sum1 + sum2)\n\n    for i in range(len(A) - L - M + 1):\n        sum1 = sum(A[i:i+M])\n        sum2 = sum(A[i+M:i+M+L])\n        max_sum = max(max_sum, sum1 + sum2)\n\n    return max(max_sum, maxL + maxM)"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 8342, "entry_point": "isGoodArray", "codes": ["from math import gcd\nfrom functools import reduce\n\ndef isGoodArray(nums):\n    return reduce(gcd, nums) == 1", "def isGoodArray(nums):\n    from functools import reduce\n    from math import gcd\n    return reduce(gcd, nums) == 1", "def isGoodArray(nums):\n    gcd = nums[0]\n    for num in nums:\n        gcd = math.gcd(gcd, num)\n    return gcd == 1", "def isGoodArray(nums):\n    return all(gcd(x, y) == 1 for x, y in pairwise(nums))\n\nfrom itertools import pairwise\nfrom math import gcd", "def isGoodArray(nums):\n    acc = 0\n    for num in nums:\n        acc = gcd(acc, num)\n    return acc == 1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 8381, "entry_point": "countBattleships", "codes": ["def countBattleships(board):\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[i])):\n            if board[i][j] == 'X':\n                if (i == 0 or board[i-1][j] != 'X') and (j == 0 or board[i][j-1] != 'X'):\n                    count += 1\n    return count", "def countBattleships(board):\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'X':\n                if (i == 0 or board[i-1][j] == '.') and (j == 0 or board[i][j-1] == '.'):\n                    count += 1\n    return count", "def countBattleships(board):\n    count = 0\n    rows, cols = len(board), len(board[0])\n    for i in range(rows):\n        for j in range(cols):\n            if board[i][j] == 'X':\n                if (i == 0 or board[i-1][j] == '.') and (j == 0 or board[i][j-1] == '.'):\n                    count += 1\n    return count", "def countBattleships(board):\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'X':\n                if (i == 0 or board[i-1][j] != 'X') and (j == 0 or board[i][j-1] != 'X'):\n                    count += 1\n    return count"], "rewards": [1.0, -1.0, -1.0, -1.0]}
{"id": 877, "entry_point": "longestSubarray", "codes": ["def longestSubarray(nums):\n    max_length = zero_count = start = 0\n    for end, num in enumerate(nums):\n        zero_count += num == 0\n        while zero_count > 1:\n            zero_count -= nums[start] == 0\n            start += 1\n        max_length = max(max_length, end - start)\n    return max_length", "def longestSubarray(nums):\n    max_length = 0\n    left = 0\n    zero_count = 0\n    \n    for right in range(len(nums)):\n        zero_count += nums[right] == 0\n        \n        while zero_count > 1:\n            zero_count -= nums[left] == 0\n            left += 1\n        \n        max_length = max(max_length, right - left)\n    \n    return max_length", "def longestSubarray(nums):\n    max_length = 0\n    left = 0\n    zero_count = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zero_count += 1\n\n        while zero_count > 1:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n\n        max_length = max(max_length, right - left)\n\n    return max_length", "def longestSubarray(nums):\n    max_length = 0\n    prev_length = 0\n    zero_count = 0\n    \n    for i, num in enumerate(nums):\n        if num == 0:\n            zero_count += 1\n            if zero_count > 1:\n                max_length = max(max_length, prev_length + zero_count - 1)\n                prev_length = zero_count - 1\n                zero_count = 1\n            else:\n                prev_length = zero_count\n        else:\n            prev_length += 1\n    \n    return max(max_length, prev_length - (1 if zero_count > 0 else 0))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 8511, "entry_point": "numBusesToDestination", "codes": ["def numBusesToDestination(routes, S, T):\n    if S == T:\n        return 0\n    \n    from collections import deque, defaultdict\n    \n    stop_to_routes = defaultdict(list)\n    for i, route in enumerate(routes):\n        for stop in route:\n            stop_to_routes[stop].append(i)\n    \n    visited_routes = set()\n    queue = deque([(S, 0)])\n    \n    while queue:\n        current_stop, current_buses = queue.popleft()\n        \n        for route_id in stop_to_routes[current_stop]:\n            if route_id in visited_routes:\n                continue\n            visited_routes.add(route_id)\n            \n            for next_stop in routes[route_id]:\n                if next_stop == T:\n                    return current_buses + 1\n                queue.append((next_stop, current_buses + 1))\n    \n    return -1", "from collections import deque\n\ndef numBusesToDestination(routes, S, T):\n    if S == T:\n        return 0\n    \n    stop_to_routes = {}\n    for i, route in enumerate(routes):\n        for stop in route:\n            if stop not in stop_to_routes:\n                stop_to_routes[stop] = []\n            stop_to_routes[stop].append(i)\n    \n    queue = deque([(S, 1)])\n    visited_routes = set()\n    \n    while queue:\n        current_stop, buses_taken = queue.popleft()\n        for bus in stop_to_routes[current_stop]:\n            if bus not in visited_routes:\n                visited_routes.add(bus)\n                for next_stop in routes[bus]:\n                    if next_stop == T:\n                        return buses_taken\n                    if next_stop not in visited_routes:\n                        queue.append((next_stop, buses_taken + 1))\n    \n    return -1", "def numBusesToDestination(routes, S, T):\n    if S == T:\n        return 0\n    \n    from collections import defaultdict, deque\n    \n    stop_to_routes = defaultdict(list)\n    for i, route in enumerate(routes):\n        for stop in route:\n            stop_to_routes[stop].append(i)\n    \n    queue = deque([(S, 1)])\n    visited_stops = set([S])\n    visited_routes = set()\n    \n    while queue:\n        current_stop, buses_taken = queue.popleft()\n        for route_index in stop_to_routes[current_stop]:\n            if route_index not in visited_routes:\n                visited_routes.add(route_index)\n                for next_stop in routes[route_index]:\n                    if next_stop == T:\n                        return buses_taken\n                    if next_stop not in visited_stops:\n                        visited_stops.add(next_stop)\n                        queue.append((next_stop, buses_taken + 1))\n    \n    return -1", "from collections import defaultdict, deque\n\ndef numBusesToDestination(routes, S, T):\n    if S == T:\n        return 0\n    \n    graph = defaultdict(set)\n    for bus, stops in enumerate(routes):\n        for stop in stops:\n            graph[stop].add(bus)\n    \n    visited_stops = set()\n    visited_buses = set()\n    queue = deque([(S, 1)])\n    \n    while queue:\n        current_stop, buses_taken = queue.popleft()\n        if current_stop == T:\n            return buses_taken\n        \n        visited_stops.add(current_stop)\n        for bus in graph[current_stop]:\n            if bus not in visited_buses:\n                visited_buses.add(bus)\n                for next_stop in routes[bus]:\n                    if next_stop not in visited_stops:\n                        queue.append((next_stop, buses_taken + 1))\n    \n    return -1"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 8625, "entry_point": "smallestDistancePair", "codes": ["def smallestDistancePair(nums, k):\n    nums.sort()\n    n = len(nums)\n    distances = []\n    \n    for i in range(n-1):\n        for j in range(i+1, n):\n            distances.append(nums[j] - nums[i])\n    \n    distances.sort()\n    return distances[k-1]", "from typing import List\nimport bisect\n\ndef smallestDistancePair(nums: List[int], k: int) -> int:\n    nums.sort()\n    distances = []\n    \n    for i in range(1, len(nums)):\n        distances.extend(nums[j] - nums[i-1] for j in range(i))\n    \n    distances.sort()\n    return distances[k-1]", "def smallestDistancePair(nums, k):\n    nums.sort()\n    n = len(nums)\n    left, right = 0, nums[-1] - nums[0]\n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        j = 0\n        for i in range(n):\n            while j < n and nums[j] - nums[i] <= mid:\n                j += 1\n            count += j - i - 1\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "def smallestDistancePair(nums, k):\n    nums.sort()\n    n = len(nums)\n    left, right = 0, nums[-1] - nums[0]\n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        for i in range(n):\n            j = bisect.bisect_right(nums, nums[i] + mid)\n            count += j - i - 1\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "def smallestDistancePair(nums, k):\n    nums.sort()\n    n = len(nums)\n    left, right = 0, nums[-1] - nums[0]\n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        for i in range(n):\n            j = bisect_right(nums, nums[i] + mid, i + 1)\n            count += j - i - 1\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 8754, "entry_point": "clumsy", "codes": ["def clumsy(N: int) -> int:\n    if N == 1: return 1\n    if N == 2: return 2 * 1\n    if N == 3: return 3 * 2 // 1\n    if N == 4: return 4 * 3 // 2 + 1\n    return N * (N-1) // (N-2) + clumsy(N-3)", "def clumsy(N):\n    ops = ['*', '//', '+', '-']\n    stack = [N]\n    op_index = 0\n    \n    for i in range(1, N):\n        if ops[op_index] == '*':\n            stack.append(stack.pop() * (N - i))\n        elif ops[op_index] == '//':\n            stack.append(int(stack.pop() / (N - i)))\n        elif ops[op_index] == '+':\n            stack.append(N - i)\n        elif ops[op_index] == '-':\n            stack.append(-(N - i))\n        \n        op_index = (op_index + 1) % 4\n    \n    return sum(stack)", "def clumsy(N):\n    stack = [N]\n    op = 0\n    for i in range(N - 1, 0, -1):\n        if op == 0:\n            stack[-1] *= i\n        elif op == 1:\n            stack[-1] //= i\n        elif op == 2:\n            stack.append(i)\n        elif op == 3:\n            stack.append(-i)\n        op = (op + 1) % 4\n    return sum(stack)\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "def clumsy(N):\n    from operator import mul, truediv, add, sub\n    ops = [mul, truediv, add, sub]\n    stack = [N]\n    for i in range(1, N):\n        op = ops[i % 4]\n        if op == mul:\n            stack[-1] *= N - i\n        elif op == truediv:\n            stack[-1] = int(stack[-1] / (N - i))\n        else:\n            stack.append(N - i)\n            stack.append(op)\n    return int(eval(' '.join(map(str, stack))))", "def clumsy(N):\n    ops = [\"*\", \"//\", \"+\", \"-\"]\n    stack = [N]\n    i = 1\n    while i < N:\n        op = ops[i % 4]\n        if op == \"*\":\n            stack.append(stack.pop() * (N - i))\n        elif op == \"//\":\n            stack.append(int(stack.pop() / (N - i)))\n        elif op == \"+\":\n            stack.append(N - i)\n        elif op == \"-\":\n            stack.append(-(N - i))\n        i += 1\n    return sum(stack)", "def clumsy(N: int) -> int:\n    stack = []\n    ops = ['*', '/', '+', '-']\n    op_index = 0\n    \n    for i in range(N, 0, -1):\n        if not stack:\n            stack.append(i)\n        else:\n            if ops[op_index] == '*':\n                stack[-1] *= i\n            elif ops[op_index] == '/':\n                stack[-1] = int(stack[-1] / i)\n            elif ops[op_index] == '+':\n                stack.append(i)\n            elif ops[op_index] == '-':\n                stack.append(-i)\n        \n        op_index = (op_index + 1) % 4\n    \n    return sum(stack)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 8825, "entry_point": "nthUglyNumber", "codes": ["def nthUglyNumber(n, a, b, c):\n    def count(x):\n        return x // a + x // b + x // c - x // ab - x // ac - x // bc + x // abc\n\n    ab = a * b // math.gcd(a, b)\n    ac = a * c // math.gcd(a, c)\n    bc = b * c // math.gcd(b, c)\n    abc = a * b * c // math.gcd(a, math.gcd(b, c))\n\n    low, high = 1, 2 * 10**9\n    while low < high:\n        mid = (low + high) // 2\n        if count(mid) < n:\n            low = mid + 1\n        else:\n            high = mid\n    return low", "def nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\n    from math import gcd\n    ab = a * b // gcd(a, b)\n    ac = a * c // gcd(a, c)\n    bc = b * c // gcd(b, c)\n    abc = a * bc // gcd(a, bc)\n    \n    def count(x):\n        return x // a + x // b + x // c - x // ab - x // ac - x // bc + x // abc\n    \n    low, high = 1, 2 * 10**9\n    while low < high:\n        mid = (low + high) // 2\n        if count(mid) < n:\n            low = mid + 1\n        else:\n            high = mid\n    return low", "def nthUglyNumber(n, a, b, c):\n    from math import gcd\n\n    def lcm(x, y):\n        return x * y // gcd(x, y)\n\n    ab = lcm(a, b)\n    ac = lcm(a, c)\n    bc = lcm(b, c)\n    abc = lcm(ab, c)\n\n    def count(x):\n        return x // a + x // b + x // c - x // ab - x // ac - x // bc + x // abc\n\n    left, right = 1, 2 * 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count(mid) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "from math import gcd\n\ndef nthUglyNumber(x, y):\n    return x * y // gcd(x, y)\n\ndef nthUglyNumber(n, a, b, c):\n    ab = nthUglyNumber(a, b)\n    ac = nthUglyNumber(a, c)\n    bc = nthUglyNumber(b, c)\n    abc = nthUglyNumber(a, bc)\n    \n    def count(x):\n        return x // a + x // b + x // c - x // ab - x // ac - x // bc + x // abc\n    \n    left, right = 1, 2 * 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count(mid) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "def nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\n    def count(x):\n        return x // a + x // b + x // c - x // ab - x // ac - x // bc + x // abc\n\n    ab = a * b // gcd(a, b)\n    ac = a * c // gcd(a, c)\n    bc = b * c // gcd(b, c)\n    abc = a * b * c // gcd(a, b, c)\n    left, right = 1, 2 * 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count(mid) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "from math import gcd\n\ndef nthUglyNumber(x, y):\n    return x * y // gcd(x, y)\n\ndef count_ugly_numbers(n, a, b, c):\n    lcm_ab = nthUglyNumber(a, b)\n    lcm_ac = nthUglyNumber(a, c)\n    lcm_bc = nthUglyNumber(b, c)\n    lcm_abc = nthUglyNumber(a, nthUglyNumber(b, c))\n    \n    return n // a + n // b + n // c - n // lcm_ab - n // lcm_ac - n // lcm_bc + n // lcm_abc\n\ndef nthUglyNumber(n, a, b, c):\n    left, right = 1, 2 * 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count_ugly_numbers(mid, a, b, c) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "def nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    def lcm(x: int, y: int) -> int:\n        return x * y // gcd(x, y)\n\n    def count(x: int) -> int:\n        return x // a + x // b + x // c - x // ab - x // ac - x // bc + x // abc\n\n    ab = lcm(a, b)\n    ac = lcm(a, c)\n    bc = lcm(b, c)\n    abc = lcm(a, b, c)\n\n    left, right = 1, 2 * 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count(mid) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "def nthUglyNumber(n, a, b, c):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def lcm(x, y):\n        return x * y // gcd(x, y)\n\n    def count(x):\n        return x // a + x // b + x // c - x // lcm(a, b) - x // lcm(a, c) - x // lcm(b, c) + x // lcm(a, b, c)\n\n    left, right = 1, 2 * 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count(mid) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 8844, "entry_point": "getKth", "codes": ["def getKth(lo, hi, k):\n    def power(x):\n        steps = 0\n        while x != 1:\n            x = x // 2 if x % 2 == 0 else 3 * x + 1\n            steps += 1\n        return steps\n\n    return sorted(range(lo, hi + 1), key=power)[k - 1]", "def getKth(lo, hi, k):\n    def power(x):\n        steps = 0\n        while x != 1:\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x = 3 * x + 1\n            steps += 1\n        return steps\n\n    return sorted(range(lo, hi + 1), key=power)[k - 1]", "def getKth(lo, hi, k):\n    def power(x):\n        steps = 0\n        while x != 1:\n            if x % 2 == 0:\n                x = x // 2\n            else:\n                x = 3 * x + 1\n            steps += 1\n        return steps\n\n    return sorted(range(lo, hi + 1), key=power)[k - 1]", "def getKth(lo, hi, k):\n    @lru_cache(None)\n    def power(x):\n        steps = 0\n        while x != 1:\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x = 3 * x + 1\n            steps += 1\n        return steps\n\n    numbers = list(range(lo, hi + 1))\n    numbers.sort(key=lambda x: (power(x), x))\n    return numbers[k - 1]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 8861, "entry_point": "shortestSubarray", "codes": ["def shortestSubarray(A, K):\n    n = len(A)\n    min_length = float('inf')\n    start = 0\n    current_sum = 0\n    \n    for end in range(n):\n        current_sum += A[end]\n        \n        while current_sum >= K:\n            min_length = min(min_length, end - start + 1)\n            current_sum -= A[start]\n            start += 1\n    \n    return min_length if min_length != float('inf') else -1", "from collections import deque\n\ndef shortestSubarray(A, K):\n    deque_idx = deque()\n    prefix_sum = [0]\n    for num in A:\n        prefix_sum.append(prefix_sum[-1] + num)\n    \n    min_length = float('inf')\n    for i, curr_sum in enumerate(prefix_sum):\n        while deque_idx and curr_sum - prefix_sum[deque_idx[0]] >= K:\n            min_length = min(min_length, i - deque_idx.popleft())\n        while deque_idx and curr_sum <= prefix_sum[deque_idx[-1]]:\n            deque_idx.pop()\n        deque_idx.append(i)\n    \n    return min_length if min_length != float('inf') else -1", "def shortestSubarray(A, K):\n    n = len(A)\n    ans = float('inf')\n    prefix_sum = [0]\n    for x in A:\n        prefix_sum.append(prefix_sum[-1] + x)\n    \n    queue = []\n    for i, acc in enumerate(prefix_sum):\n        while queue and acc - prefix_sum[queue[0]] >= K:\n            ans = min(ans, i - queue.pop(0))\n        while queue and acc <= prefix_sum[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    \n    return ans if ans < float('inf') else -1", "def shortestSubarray(A, K):\n    prefix_sum = [0]\n    min_length = float('inf')\n    min_index = {0: -1}\n    \n    for i, num in enumerate(A):\n        prefix_sum.append(prefix_sum[-1] + num)\n    \n    for i, total in enumerate(prefix_sum):\n        if total - K in min_index:\n            min_length = min(min_length, i - min_index[total - K])\n        \n        while min_index and total <= prefix_sum[min_index[-1]]:\n            min_index.pop()\n        \n        min_index[total] = i\n    \n    return min_length if min_length != float('inf') else -1", "def shortestSubarray(A, K):\n    n = len(A)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    deque = []\n    min_length = float('inf')\n    \n    for i in range(n + 1):\n        while deque and prefix_sum[i] - prefix_sum[deque[0]] >= K:\n            min_length = min(min_length, i - deque.popleft())\n        while deque and prefix_sum[i] <= prefix_sum[deque[-1]]:\n            deque.pop()\n        deque.append(i)\n    \n    return min_length if min_length != float('inf') else -1", "def shortestSubarray(A, K):\n    from collections import deque\n    \n    queue = deque()\n    prefix_sum = 0\n    min_length = float('inf')\n    \n    for i, num in enumerate(A):\n        prefix_sum += num\n        \n        while queue and prefix_sum - A[queue[0]] >= K:\n            min_length = min(min_length, i - queue.popleft())\n        \n        while queue and prefix_sum <= A[queue[-1]]:\n            queue.pop()\n        \n        queue.append(i)\n    \n    return min_length if min_length != float('inf') else -1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 8898, "entry_point": "minDays", "codes": ["def minDays(n):\n    memo = {0: 0, 1: 1}\n    \n    def dp(x):\n        if x not in memo:\n            memo[x] = 1 + min(x % 2 + dp(x // 2), x % 3 + dp(x // 3))\n        return memo[x]\n    \n    return dp(n)", "def minDays(n):\n    from functools import lru_cache\n\n    @lru_cache(None)\n    def dp(x):\n        if x <= 1:\n            return x\n        return 1 + min(dp(x // 2) + x % 2, dp(x // 3) + x % 3)\n\n    return dp(n)", "def minDays(n: int) -> int:\n    from functools import lru_cache\n    \n    @lru_cache(None)\n    def dp(x):\n        if x <= 1:\n            return x\n        return 1 + min(x % 2 + dp(x // 2), x % 3 + dp(x // 3))\n    \n    return dp(n)", "def minDays(n):\n    @lru_cache(None)\n    def dfs(x):\n        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        return 1 + min(x % 2 + dfs(x // 2), x % 3 + dfs(x // 3))\n    return dfs(n)", "def minDays(n):\n    from functools import lru_cache\n    \n    @lru_cache(None)\n    def dp(x):\n        if x == 1:\n            return 1\n        return 1 + min(x % 2 + dp(x // 2), x % 3 + dp(x // 3))\n    \n    return dp(n)", "from functools import lru_cache\n\n@lru_cache(None)\ndef minDays(n):\n    if n == 1:\n        return 1\n    return 1 + min(n % 2 + minDays(n // 2), n % 3 + minDays(n // 3))", "def minDays(n):\n    memo = {}\n    def dp(n):\n        if n in memo:\n            return memo[n]\n        if n <= 1:\n            return n\n        div2 = dp(n // 2) if n % 2 == 0 else float('inf')\n        div3 = dp(n // 3) if n % 3 == 0 else float('inf')\n        memo[n] = 1 + min(div2, div3)\n        return memo[n]\n    return dp(n)", "def minDays(n):\n    from functools import lru_cache\n    @lru_cache(None)\n    def dp(n):\n        if n == 1:\n            return 1\n        if n % 2 == 0 and n % 3 == 0:\n            return 1 + min(dp(n // 2), dp(n // 3))\n        elif n % 2 == 0:\n            return 1 + dp(n // 2)\n        elif n % 3 == 0:\n            return 1 + dp(n // 3)\n        else:\n            return 1 + dp(n - 1)\n    return dp(n)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 8916, "entry_point": "combinationSum3", "codes": ["def combinationSum3(k, n):\n    def dfs(path, start, remaining):\n        if remaining == 0 and len(path) == k:\n            result.append(path)\n            return\n        if remaining < 0 or len(path) > k:\n            return\n        for i in range(start, 10):\n            dfs(path + [i], i + 1, remaining - i)\n    \n    result = []\n    dfs([], 1, n)\n    return result", "def combinationSum3(k, n):\n    def backtrack(start, path, remaining):\n        if len(path) == k and remaining == 0:\n            result.append(path)\n            return\n        if len(path) == k or remaining < 0:\n            return\n        for i in range(start, 10):\n            backtrack(i + 1, path + [i], remaining - i)\n\n    result = []\n    backtrack(1, [], n)\n    return result", "def combinationSum3(k, n):\n    results = []\n    \n    def backtrack(start, path, remaining):\n        if len(path) == k and remaining == 0:\n            results.append(path)\n            return\n        if len(path) == k or remaining <= 0:\n            return\n        for i in range(start, 10):\n            backtrack(i + 1, path + [i], remaining - i)\n    \n    backtrack(1, [], n)\n    return results", "def combinationSum3(k: int, n: int) -> List[List[int]]:\n    def backtrack(start, k, n, path):\n        if k == 0 and n == 0:\n            results.append(path[:])\n            return\n        if k == 0 or n < 0:\n            return\n        for i in range(start, 10):\n            path.append(i)\n            backtrack(i + 1, k - 1, n - i, path)\n            path.pop()\n\n    results = []\n    backtrack(1, k, n, [])\n    return results"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 9211, "entry_point": "generateTheString", "codes": ["def generateTheString(n):\n    return 'a' * (n - 1) + ('b' if n % 2 == 0 else 'a')", "def generateTheString(n):\n    if n % 2 == 1:\n        return 'a' * n\n    else:\n        return 'a' * (n - 1) + 'b'", "def generateTheString(n):\n    if n % 2 == 0:\n        return 'a' * (n - 1) + 'b'\n    else:\n        return 'a' * n", "def generateTheString(n: int) -> str:\n    return 'a' * (n - (n & 1)) + 'b' * (n & 1)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 9273, "entry_point": "findKthNumber", "codes": ["def findKthNumber(n, k):\n    count = 0\n    current = 1\n    while count < k:\n        if current <= n:\n            count += 1\n        if count == k:\n            return current\n        if current * 10 > n:\n            current += 1\n        else:\n            current *= 10", "def findKthNumber(n: int, k: int) -> int:\n    count = 0\n    current = 1\n    while count < k:\n        count += 1\n        if count == k:\n            return current\n        if current * 10 <= n:\n            current *= 10\n        else:\n            current += 1\n            while current > n or current % 10 == 0:\n                current //= 10\n                current += 1", "def findKthNumber(n, k):\n    def count_numbers(prefix):\n        count = 0\n        current = prefix\n        while current <= n:\n            count += min(n + 1, current + 10) - current\n            current *= 10\n        return count\n\n    prefix = 1\n    k -= 1\n    while k > 0:\n        count = count_numbers(prefix)\n        if k < count:\n            prefix *= 10\n            k -= 1\n        else:\n            prefix += 1\n            k -= count\n    return prefix", "def findKthNumber(n, k):\n    return sorted(range(1, n + 1))[k - 1]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 9327, "entry_point": "heightChecker", "codes": ["def heightChecker(heights):\n    return sum(h1 != h2 for h1, h2 in zip(heights, sorted(heights)))", "def heightChecker(heights):\n    return sum(h != s for h, s in zip(heights, sorted(heights)))", "def heightChecker(heights):\n    sorted_heights = sorted(heights)\n    return sum(h1 != h2 for h1, h2 in zip(heights, sorted_heights))", "def heightChecker(heights):\n    sorted_heights = sorted(heights)\n    index_map = {height: idx for idx, height in enumerate(sorted_heights)}\n    return sum(index_map[height] != idx for idx, height in enumerate(heights))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 9382, "entry_point": "uniquePaths", "codes": ["def uniquePaths(m, n):\n    from math import comb\n    return comb(m + n - 2, n - 1)", "from math import comb\n\ndef uniquePaths(m, n):\n    return comb(m + n - 2, n - 1)", "def uniquePaths(m, n):\n    dp = [1] * n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[j] += dp[j - 1]\n    return dp[-1]", "def uniquePaths(m, n):\n    def helper(x, y):\n        if x == 0 or y == 0:\n            return 0\n        if x == 1 and y == 1:\n            return 1\n        return helper(x-1, y) + helper(x, y-1)\n    \n    return helper(m-1, n-1)", "def uniquePaths(m, n):\n    def dp(i, j):\n        if i == 0 or j == 0:\n            return 0\n        if i == 1 and j == 1:\n            return 1\n        return dp(i-1, j) + dp(j-1, i)\n    return dp(m-1, n-1)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 9459, "entry_point": "maxSumDivThree", "codes": ["def maxSumDivThree(nums):\n    mod = [0] * 3\n    for num in nums:\n        for j in mod[:]:\n            mod[(j + num) % 3] = max(mod[(j + num) % 3], j + num)\n    return mod[0]", "def maxSumDivThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        for d in dp[:]:\n            dp[(d + num) % 3] = max(dp[(d + num) % 3], d + num)\n    return dp[0]", "def maxSumDivThree(nums):\n    mod_sum = [0, 0, 0]\n    for num in nums:\n        for i in range(2, -1, -1):\n            mod_sum[(i + num) % 3] = max(mod_sum[(i + num) % 3], mod_sum[i] + num)\n    return mod_sum[0]", "def maxSumDivThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        for mod in [num % 3, (num + dp[0]) % 3, (num + dp[1]) % 3]:\n            dp[mod] = max(dp[mod], dp[(mod - num) % 3] + num)\n    return dp[0]", "def maxSumDivThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        for i in range(2, -1, -1):\n            dp[(i + num) % 3] = max(dp[(i + num) % 3], dp[i] + num)\n    return dp[0]", "def maxSumDivThree(nums):\n    dp = [0, float('-inf'), float('-inf')]\n    for num in nums:\n        for mod in range(3):\n            dp[(mod + num) % 3] = max(dp[(mod + num) % 3], dp[mod] + num)\n    return dp[0]", "def maxSumDivThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        for mod, val in enumerate(dp[:]):\n            dp[(mod + num) % 3] = max(dp[(mod + num) % 3], val + num)\n    return dp[0]"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 9461, "entry_point": "maximumSwap", "codes": ["def maximumSwap(n):\n    digits = list(str(n))\n    last = {int(d): i for i, d in enumerate(digits)}\n    for i, d in enumerate(digits):\n        for d2 in range(9, int(d), -1):\n            if last.get(d2, -1) > i:\n                digits[i], digits[last[d2]] = digits[last[d2]], digits[i]\n                return int(''.join(digits))\n    return n", "def maximumSwap(num):\n    digits = list(str(num))\n    last = {int(d): i for i, d in enumerate(digits)}\n    for i, d in enumerate(digits):\n        for k in range(9, int(d), -1):\n            if last.get(k, -1) > i:\n                digits[i], digits[last[k]] = digits[last[k]], digits[i]\n                return int(''.join(digits))\n    return num", "def maximumSwap(n):\n    digits = [int(d) for d in str(n)]\n    pos = {d: i for i, d in enumerate(digits)}\n    for i, d in enumerate(digits):\n        for k in range(9, d, -1):\n            if pos.get(k, -1) > i:\n                digits[i], digits[pos[k]] = digits[pos[k]], digits[i]\n                return int(''.join(map(str, digits)))\n    return n", "def maximumSwap(num):\n    digits = list(str(num))\n    last = {int(d): i for i, d in enumerate(digits)}\n    for i, d in enumerate(digits):\n        d = int(d)\n        for k in range(9, d, -1):\n            if last.get(k) > i:\n                digits[i], digits[last[k]] = digits[last[k]], digits[i]\n                return int(''.join(digits))\n    return num", "def maximumSwap(num):\n    digits = list(str(num))\n    last = {int(d): i for i, d in enumerate(digits)}\n    for i, d in enumerate(digits):\n        for d2 in range(9, int(d), -1):\n            if last[d2] > i:\n                digits[i], digits[last[d2]] = digits[last[d2]], digits[i]\n                return int(''.join(digits))\n    return num", "def maximumSwap(num):\n    digits = list(str(num))\n    idx = {int(d): i for i, d in enumerate(digits)}\n    for i in range(len(digits)):\n        for d in range(9, int(digits[i]), -1):\n            d = str(d)\n            if idx[int(d)] > i:\n                digits[i], digits[idx[int(d)]] = digits[idx[int(d)]], digits[i]\n                return int(''.join(digits))\n    return num"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 9539, "entry_point": "numEquivDominoPairs", "codes": ["def numEquivDominoPairs(dominoes):\n    from collections import Counter\n    count = Counter(tuple(sorted(d)) for d in dominoes)\n    return sum(v * (v - 1) // 2 for v in count.values())", "def numEquivDominoPairs(dominoes):\n    domino_counts = {}\n    for domino in dominoes:\n        sorted_domino = tuple(sorted(domino))\n        domino_counts[sorted_domino] = domino_counts.get(sorted_domino, 0) + 1\n    return sum(count * (count - 1) // 2 for count in domino_counts.values())", "from collections import Counter\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs or lhs == rhs[::-1]\n\ndef numEquivDominoPairs(dominoes):\n    count = Counter(tuple(sorted(d)) for d in dominoes)\n    return sum(v * (v - 1) // 2 for v in count.values())", "def numEquivDominoPairs(dominoes):\n    from collections import Counter\n    count = Counter(tuple(sorted(d)) for d in dominoes)\n    return sum(v * (v - 1) // 2 for v in count.values())\n\ndef _equivalent(lhs, rhs):\n    return sorted(lhs) == sorted(rhs)", "def _equivalent(lhs, rhs):\n    return sorted(lhs) == sorted(rhs)\n\ndef numEquivDominoPairs(dominoes):\n    counts = {}\n    for domino in dominoes:\n        key = tuple(sorted(domino))\n        counts[key] = counts.get(key, 0) + 1\n    return sum(v * (v - 1) // 2 for v in counts.values())", "def numEquivDominoPairs(dominoes):\n    count = 0\n    for i in range(len(dominoes)):\n        for j in range(i + 1, len(dominoes)):\n            if (dominoes[i][0] == dominoes[j][0] and dominoes[i][1] == dominoes[j][1]) or \\\n               (dominoes[i][0] == dominoes[j][1] and dominoes[i][1] == dominoes[j][0]):\n                count += 1\n    return count\n\ndef _equivalent(lhs, rhs):\n    return (lhs[0] == rhs[0] and lhs[1] == rhs[1]) or (lhs[0] == rhs[1] and lhs[1] == rhs[0])"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 9591, "entry_point": "leastInterval", "codes": ["from collections import Counter\n\ndef leastInterval(tasks, n):\n    return max(len(tasks), (n + 1) * (max(Counter(tasks).values()) - 1) + list(Counter(tasks).values()).count(max(Counter(tasks).values())))", "def leastInterval(tasks, n):\n    freq = sorted([tasks.count(task) for task in set(tasks)], reverse=True)\n    max_freq = freq[0]\n    max_count = freq.count(max_freq)\n    return max((max_freq - 1) * (n + 1) + max_count, len(tasks))", "def leastInterval(tasks, n):\n    from collections import Counter\n    freq = list(Counter(tasks).values())\n    max_freq = max(freq)\n    max_count = freq.count(max_freq)\n    return max((max_freq - 1) * (n + 1) + max_count, len(tasks))", "def leastInterval(tasks, n):\n    freq = [0] * 26\n    for task in tasks:\n        freq[ord(task) - ord('A')] += 1\n    max_freq = max(freq)\n    max_count = freq.count(max_freq)\n    return max((max_freq - 1) * (n + 1) + max_count, len(tasks))", "def leastInterval(tasks, n):\n    if n == 0:\n        return len(tasks)\n    \n    task_counts = [0] * 26\n    for task in tasks:\n        task_counts[ord(task) - ord('A')] += 1\n    \n    max_count = max(task_counts)\n    max_tasks = task_counts.count(max_count)\n    \n    return max((max_count - 1) * (n + 1) + max_tasks, len(tasks))", "def leastInterval(tasks, n):\n    task_counts = [0] * 26\n    max_count = 0\n    max_count_tasks = 0\n    \n    for task in tasks:\n        task_counts[ord(task) - ord('A')] += 1\n        if task_counts[ord(task) - ord('A')] > max_count:\n            max_count = task_counts[ord(task) - ord('A')]\n            max_count_tasks = 1\n        elif task_counts[ord(task) - ord('A')] == max_count:\n            max_count_tasks += 1\n    \n    part_count = max_count - 1\n    part_length = n - (max_count_tasks - 1)\n    empty_slots = part_count * part_length\n    available_tasks = len(tasks) - max_count * max_count_tasks\n    \n    idles = max(0, empty_slots - available_tasks)\n    \n    return len(tasks) + idles", "def leastInterval(tasks, n):\n    freq = list(collections.Counter(tasks).values())\n    max_freq = max(freq)\n    n_max = freq.count(max_freq)\n    return max(len(tasks), (max_freq - 1) * (n + 1) + n_max)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 9652, "entry_point": "longestDecomposition", "codes": ["def longestDecomposition(text: str) -> int:\n    def dfs(left, right):\n        if left >= right:\n            return 0\n        for i in range(1, right - left + 1):\n            if text[left:left + i] == text[right - i + 1:right + 1]:\n                return 2 + dfs(left + i, right - i)\n        return 1\n    \n    return dfs(0, len(text) - 1)", "def longestDecomposition(text: str) -> int:\n    n = len(text)\n    dp = [0] * (n + 1)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if text[:i + 1] == text[j:]: \n                dp[j] = max(dp[j], dp[i] + 2)\n    return dp[n]", "def longestDecomposition(text):\n    n = len(text)\n    result = 0\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and text[i:j] != text[n-j:i:-1]:\n            j += 1\n        result += 2 if j == n else 1\n        i = j\n    return result", "def longestDecomposition(text):\n    n = len(text)\n    result = 0\n    i, j = 0, n - 1\n    while i < j:\n        k = 1\n        while text[i:i+k] != text[j-k+1:j+1]:\n            k += 1\n        result += 2\n        i += k\n        j -= k\n    if i == j:\n        result += 1\n    return result", "def longestDecomposition(text):\n    n = len(text)\n    i = 0\n    j = n - 1\n    result = 0\n    prefix = []\n    suffix = []\n    \n    while i < j:\n        prefix.append(text[i])\n        suffix.insert(0, text[j])\n        if prefix == suffix:\n            result += 2\n            prefix.clear()\n            suffix.clear()\n        i += 1\n        j -= 1\n    \n    if i == j:\n        result += 1\n    \n    return result", "def longestDecomposition(text: str) -> int:\n    k, n = 0, len(text)\n    i, j = 0, n\n    while i < j:\n        while text[i:j] != text[n-j:n-i]:\n            j -= 1\n        k += 2\n        i = j\n        j = n\n    return k + (n - i) % 2"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 9693, "entry_point": "new21Game", "codes": ["def new21Game(N, K, W):\n    if K == 0 or N >= K + W:\n        return 1.0\n    dp = [0] * (N + 1)\n    dp[0] = 1.0\n    window_sum = 1.0\n    \n    for i in range(1, N + 1):\n        dp[i] = window_sum / W\n        if i < K:\n            window_sum += dp[i]\n        if i >= W:\n            window_sum -= dp[i - W]\n    \n    return sum(dp[K:])", "def new21Game(N, K, W):\n    if K == 0 or N >= K + W:\n        return 1.0\n    dp = [0.0] * (N + 1)\n    dp[0] = 1.0\n    window_sum = 1.0\n    for i in range(1, N + 1):\n        dp[i] = window_sum / W\n        if i < K:\n            window_sum += dp[i]\n        if i - W >= 0:\n            window_sum -= dp[i - W]\n    return sum(dp[K:])", "def new21Game(N: int, K: int, W: int) -> float:\n    if K == 0 or N >= K + W:\n        return 1.0\n    dp = [0.0] * (N + 1)\n    dp[0] = 1.0\n    window_sum = 1.0\n    for i in range(1, N + 1):\n        dp[i] = window_sum / W\n        if i < K:\n            window_sum += dp[i]\n        if i >= W:\n            window_sum -= dp[i - W]\n    return sum(dp[K:])", "def new21Game(N, K, W):\n    if K == 0:\n        return 1.0\n    dp = [0.0] * (N + W + 1)\n    dp[N] = 1.0\n    for i in range(N - 1, -1, -1):\n        for j in range(1, W + 1):\n            if i + j <= N:\n                dp[i] += dp[i + j]\n    return sum(dp[:K])", "from functools import lru_cache\n\n@lru_cache(None)\ndef new21Game(N, K, W):\n    if K == 0 or N >= K + W:\n        return 1.0\n    return sum(new21Game(N - i, K, W) for i in range(1, W + 1)) / W", "def new21Game(N, K, W):\n    if K == 0:\n        return 1.0\n    dp = [0.0] * (N + W + 1)\n    dp[N] = 1.0\n    for i in range(N - 1, -1, -1):\n        dp[i] = sum(dp[i + 1:i + W + 1]) / W\n    return sum(dp[:K])", "def new21Game(N: int, K: int, W: int) -> float:\n    if K == 0 or N >= K + W:\n        return 1.0\n    dp = [0.0] * (K + W + 1)\n    dp[K] = 1.0\n    for i in range(K - 1, -1, -1):\n        dp[i] = sum(dp[i + 1:i + W + 1]) / W\n    return dp[0]", "def new21Game(N, K, W):\n    if K == 0:\n        return 1.0\n    dp = [0.0] * (N + W + 1)\n    for i in range(N, -1, -1):\n        for j in range(W, 0, -1):\n            if i + j <= N:\n                dp[i] += dp[i + j] / W\n    return dp[0]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 9695, "entry_point": "canConstruct", "codes": ["def canConstruct(ransomNote: str, magazine: str) -> bool:\n    return all(magazine.count(char) >= ransomNote.count(char) for char in set(ransomNote))", "def canConstruct(ransomNote, magazine):\n    from collections import Counter\n    return not Counter(ransomNote) - Counter(magazine)", "def canConstruct(ransomNote: str, magazine: str) -> bool:\n    from collections import Counter\n    return not Counter(ransomNote) - Counter(magazine)", "def canConstruct(ransomNote, magazine):\n    count = [0] * 26\n    for char in magazine:\n        count[ord(char) - ord('a')] += 1\n    for char in ransomNote:\n        if count[ord(char) - ord('a')] == 0:\n            return False\n        count[ord(char) - ord('a')] -= 1\n    return True", "def canConstruct(ransomNote: str, magazine: str) -> bool:\n    count = [0] * 26\n    for char in magazine:\n        count[ord(char) - ord('a')] += 1\n    for char in ransomNote:\n        if count[ord(char) - ord('a')] == 0:\n            return False\n        count[ord(char) - ord('a')] -= 1\n    return True"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 9788, "entry_point": "numDupDigitsAtMostN", "codes": ["def numDupDigitsAtMostN(N):\n    def has_repeated_digits(num):\n        digits = str(num)\n        return len(digits) != len(set(digits))\n    \n    count = 0\n    for i in range(1, N + 1):\n        if has_repeated_digits(i):\n            count += 1\n    return count", "def numDupDigitsAtMostN(N):\n    def has_repeated_digits(n):\n        digits = []\n        while n:\n            d = n % 10\n            if d in digits:\n                return True\n            digits.append(d)\n            n //= 10\n        return False\n\n    return sum(has_repeated_digits(i) for i in range(1, N + 1))", "def numDupDigitsAtMostN(N):\n    def has_repeated_digits(number):\n        digits = []\n        while number > 0:\n            digit = number % 10\n            if digit in digits:\n                return True\n            digits.append(digit)\n            number //= 10\n        return False\n\n    return sum(has_repeated_digits(i) for i in range(1, N + 1))", "def numDupDigitsAtMostN(N):\n    def count_non_repeated(n):\n        if n == 0:\n            return 1\n        digits = [i for i in range(1, 10)]\n        count = 0\n        while n > 0:\n            d = n % 10\n            count += len(digits) * factorial(len(digits) - 1)\n            digits.remove(d)\n            n //= 10\n        return count\n\n    def factorial(n):\n        if n == 0:\n            return 1\n        result = 1\n        for i in range(1, n + 1):\n            result *= i\n        return result\n\n    def has_repeated_digits(n):\n        seen = set()\n        while n > 0:\n            d = n % 10\n            if d in seen:\n                return True\n            seen.add(d)\n            n //= 10\n        return False\n\n    count = 0\n    for i in range(1, len(str(N)) + 1):\n        count += 9 * count_non_repeated(i - 1)\n    count -= sum(1 for i in range(1, len(str(N)) + 1) if has_repeated_digits(i))\n    return count", "def numDupDigitsAtMostN(N):\n    def has_repeated_digits(n):\n        digits = []\n        while n > 0:\n            d = n % 10\n            if d in digits or d == 0:\n                return True\n            digits.append(d)\n            n //= 10\n        return False\n\n    return sum(1 for i in range(1, N + 1) if has_repeated_digits(i))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 9930, "entry_point": "findKthPositive", "codes": ["def findKthPositive(arr, k):\n    count = 0\n    num = 1\n    while True:\n        if num not in arr:\n            count += 1\n        if count == k:\n            return num\n        num += 1", "def findKthPositive(arr, k):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] - mid - 1 < k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left + k", "def findKthPositive(arr, k):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        missing = arr[mid] - mid - 1\n        if missing < k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left + k", "def findKthPositive(arr, k):\n    return next(x for x in range(1, arr[-1] + k + 1) if x not in arr)", "def findKthPositive(arr, k):\n    return k + len([x for x in range(1, arr[-1] + k + 1) if x not in arr])", "def findKthPositive(arr, k):\n    return arr[-1] + k - sum(arr)", "def findKthPositive(arr, k):\n    missing_count = 0\n    i = 0\n    n = len(arr)\n    \n    while missing_count < k:\n        if i >= n or arr[i] != i + 1:\n            missing_count += 1\n        else:\n            i += 1\n    \n    return missing_count + i"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 9934, "entry_point": "jobScheduling", "codes": ["def jobScheduling(startTime, endTime, profit):\n    n = len(startTime)\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n    dp = [0] * (n + 1)\n    last_end_time = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        last = i - 1\n        while last >= 0 and jobs[last][1] > jobs[i - 1][0]:\n            last -= 1\n        dp[i] = max(dp[i - 1], jobs[i - 1][2] + dp[last + 1])\n        last_end_time[i] = last + 1\n    \n    return dp[n]", "def jobScheduling(startTime, endTime, profit):\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n    dp = [0] * len(jobs)\n    dp[0] = jobs[0][2]\n    for i in range(1, len(jobs)):\n        dp[i] = max(jobs[i][2], dp[i-1])\n        j = i - 1\n        while j >= 0 and jobs[j][1] <= jobs[i][0]:\n            j -= 1\n        if j >= 0:\n            dp[i] = max(dp[i], dp[j] + jobs[i][2])\n    return dp[-1]", "def jobScheduling(startTime, endTime, profit):\n    n = len(startTime)\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n    dp = [0] * (n + 1)\n    last_end_time = 0\n\n    for i in range(1, n + 1):\n        s, e, p = jobs[i - 1]\n        dp[i] = dp[i - 1]\n        j = bisect_right(jobs, (s, float('inf')), key=lambda x: x[1], hi=last_end_time)\n        if j > 0:\n            dp[i] = max(dp[i], dp[j] + p)\n        last_end_time = max(last_end_time, e)\n\n    return dp[n]", "def jobScheduling(startTime, endTime, profit):\n    n = len(startTime)\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n    dp = [0] * (n + 1)\n    stack = []\n\n    for i in range(n):\n        start, end, profit = jobs[i]\n        while stack and stack[-1][1] > start:\n            stack.pop()\n        if not stack:\n            dp[i + 1] = dp[i] + profit\n        else:\n            dp[i + 1] = max(dp[i], dp[stack[-1][0]] + profit)\n        stack.append((i, end))\n\n    return dp[n]\n\ndef _equivalent(_lhs, _rhs):\n    return _lhs == _rhs", "def jobScheduling(startTime, endTime, profit):\n    n = len(startTime)\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n    dp = [(0, 0)]\n    for s, e, p in jobs:\n        i = bisect.bisect(dp, (s, float('inf'))) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append((e, dp[i][1] + p))\n    return dp[-1][1]", "def jobScheduling(startTime, endTime, profit):\n    n = len(startTime)\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n    dp = [0] * (n + 1)\n    end_indices = [0] * (n + 1)\n    \n    for i in range(n - 1, -1, -1):\n        end_indices[i] = bisect_right(jobs, jobs[i][1], key=lambda x: x[0])\n        dp[i] = max(jobs[i][2] + dp[end_indices[i]], dp[i + 1])\n    \n    return dp[0]"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 9935, "entry_point": "lengthLongestPath", "codes": ["def lengthLongestPath(path: str) -> int:\n    max_length = 0\n    path_length = {0: 0}\n    \n    for line in path.split('\\n'):\n        depth = line.count('\\t')\n        name = line.lstrip('\\t')\n        \n        if '.' in name:\n            max_length = max(max_length, path_length[depth] + len(name))\n        else:\n            path_length[depth + 1] = path_length[depth] + len(name) + 1\n    \n    return max_length", "def lengthLongestPath(input):\n    stack, max_len = [], 0\n    for line in input.split('\\n'):\n        depth = line.count('\\t')\n        name = line.replace('\\t', '')\n        while stack and stack[-1][1] >= depth:\n            stack.pop()\n        if '.' in name:\n            max_len = max(max_len, sum(len(x[0]) for x in stack) + len(name))\n        else:\n            stack.append((name, depth))\n    return max_len", "def lengthLongestPath(_path: str) -> int:\n    path_length = 0\n    max_length = 0\n    level_length = [0]\n    \n    for line in _path.split('\\n'):\n        depth = line.count('\\t')\n        line = line.replace('\\t', '')\n        \n        if '.' in line:\n            max_length = max(max_length, path_length + len(line) - depth + 1)\n        else:\n            level_length[depth] = path_length + len(line) + 1\n            path_length = level_length[depth]\n    \n    return max_length - 1 if max_length > 0 else 0", "def lengthLongestPath(input):\n    max_len = 0\n    path_len = [0]\n    \n    for line in input.splitlines():\n        name = line.lstrip('\\t')\n        depth = len(line) - len(name)\n        \n        while depth + 1 > len(path_len):\n            path_len.append(0)\n        \n        path_len[depth + 1] = path_len[depth] + len(name)\n        \n        if '.' in name:\n            max_len = max(max_len, path_len[depth + 1] + depth)\n    \n    return max_len", "def lengthLongestPath(fs):\n    max_len = depth = 0\n    stack = [(-1, 0)]  # (depth, length)\n    for line in fs.split('\\n'):\n        name = line.lstrip('\\t')\n        depth = len(line) - len(name)\n        while stack and stack[-1][0] >= depth:\n            stack.pop()\n        stack.append((depth, stack[-1][1] + len(name) + (1 if '.' in name else 0)))\n        if '.' in name:\n            max_len = max(max_len, stack[-1][1])\n    return max_len", "def lengthLongestPath(_input: str) -> int:\n    max_len, path_len = 0, {}\n    for line in _input.split('\\n'):\n        depth = line.count('\\t')\n        name = line.lstrip('\\t')\n        path_len[depth] = path_len[depth - 1] + len(name) + (1 if depth > 0 else 0)\n        if '.' in name:\n            max_len = max(max_len, path_len[depth])\n    return max_len"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 9971, "entry_point": "findLengthOfLCIS", "codes": ["def findLengthOfLCIS(nums):\n    longest = current = 0\n    for i in range(len(nums)):\n        if i == 0 or nums[i] > nums[i - 1]:\n            current += 1\n        else:\n            longest = max(longest, current)\n            current = 1\n    return max(longest, current)", "def findLengthOfLCIS(nums):\n    max_len = 0\n    current_len = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    return max(max_len, current_len)", "def findLengthOfLCIS(nums):\n    longest, current = 0, 0\n    prev = float('-inf')\n    for num in nums:\n        if num > prev:\n            current += 1\n        else:\n            longest = max(longest, current)\n            current = 1\n        prev = num\n    return max(longest, current)", "def findLengthOfLCIS(nums):\n    return max((len(list(group)) for num, group in itertools.groupby(nums, key=lambda x, y=iter(nums): next(y, x) > x)), default=0)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 1038, "entry_point": "numberToWords", "codes": ["def numberToWords(num):\n    if num == 0:\n        return \"Zero\"\n    \n    belowTwenty = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n    tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n    thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n    \n    def words(n):\n        if n < 20:\n            return belowTwenty[n]\n        elif n < 100:\n            return tens[n // 10] + (\" \" + words(n % 10) if n % 10 else \"\")\n        else:\n            return belowTwenty[n // 100] + \" Hundred\" + (\" \" + words(n % 100) if n % 100 else \"\")\n    \n    res = \"\"\n    i = 0\n    while num > 0:\n        if num % 1000 != 0:\n            res = words(num % 1000) + \" \" + thousands[i] + \" \" + res\n        num //= 1000\n        i += 1\n    \n    return res.strip()", "def numberToWords(num):\n    if num == 0:\n        return \"Zero\"\n    belowTwenty = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n    tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n    thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n    def helper(n):\n        if n == 0:\n            return \"\"\n        elif n < 20:\n            return belowTwenty[n] + \" \"\n        elif n < 100:\n            return tens[n // 10] + \" \" + helper(n % 10)\n        else:\n            return belowTwenty[n // 100] + \" Hundred \" + helper(n % 100)\n\n    result = \"\"\n    i = 0\n    while num > 0:\n        if num % 1000 != 0:\n            result = helper(num % 1000) + thousands[i] + \" \" + result\n        num //= 1000\n        i += 1\n    return result.strip()", "def numberToWords(num):\n    if num == 0:\n        return \"Zero\"\n    \n    LESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n    TENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n    THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n    \n    def helper(n):\n        if n == 0:\n            return \"\"\n        elif n < 20:\n            return LESS_THAN_20[n] + \" \"\n        elif n < 100:\n            return TENS[n // 10] + \" \" + helper(n % 10)\n        else:\n            return LESS_THAN_20[n // 100] + \" Hundred \" + helper(n % 100)\n    \n    result = \"\"\n    i = 0\n    while num > 0:\n        if num % 1000 != 0:\n            result = helper(num % 1000) + THOUSANDS[i] + \" \" + result\n        num //= 1000\n        i += 1\n    \n    return result.strip()", "def numberToWords(num):\n    if num == 0:\n        return \"Zero\"\n    \n    def ones(n):\n        switcher = {\n            1: \"One\",\n            2: \"Two\",\n            3: \"Three\",\n            4: \"Four\",\n            5: \"Five\",\n            6: \"Six\",\n            7: \"Seven\",\n            8: \"Eight\",\n            9: \"Nine\"\n        }\n        return switcher.get(n, \"\")\n    \n    def teens(n):\n        switcher = {\n            10: \"Ten\",\n            11: \"Eleven\",\n            12: \"Twelve\",\n            13: \"Thirteen\",\n            14: \"Fourteen\",\n            15: \"Fifteen\",\n            16: \"Sixteen\",\n            17: \"Seventeen\",\n            18: \"Eighteen\",\n            19: \"Nineteen\"\n        }\n        return switcher.get(n, \"\")\n    \n    def tens(n):\n        switcher = {\n            2: \"Twenty\",\n            3: \"Thirty\",\n            4: \"Forty\",\n            5: \"Fifty\",\n            6: \"Sixty\",\n            7: \"Seventy\",\n            8: \"Eighty\",\n            9: \"Ninety\"\n        }\n        return switcher.get(n, \"\")\n    \n    def hundreds(n):\n        return ones(n) + \" Hundred\"\n    \n    def three_digit(n):\n        if n == 0:\n            return \"\"\n        elif n < 10:\n            return ones(n)\n        elif n < 20:\n            return teens(n)\n        elif n < 100:\n            return tens(n // 10) + (\" \" + ones(n % 10) if n % 10 != 0 else \"\")\n        else:\n            return hundreds(n // 100) + (\" \" + three_digit(n % 100) if n % 100 != 0 else \"\")\n    \n    units = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n    result = []\n    i = 0\n    \n    while num > 0:\n        if num % 1000 != 0:\n            result.append(three_digit(num % 1000) + (\" \" + units[i] if i >", "def numberToWords(num):\n    def one(num):\n        switcher = {\n            1: 'One',\n            2: 'Two',\n            3: 'Three',\n            4: 'Four',\n            5: 'Five',\n            6: 'Six',\n            7: 'Seven',\n            8: 'Eight',\n            9: 'Nine'\n        }\n        return switcher.get(num)\n\n    def two_less_20(num):\n        switcher = {\n            10: 'Ten',\n            11: 'Eleven',\n            12: 'Twelve',\n            13: 'Thirteen',\n            14: 'Fourteen',\n            15: 'Fifteen',\n            16: 'Sixteen',\n            17: 'Seventeen',\n            18: 'Eighteen',\n            19: 'Nineteen'\n        }\n        return switcher.get(num)\n\n    def ten(num):\n        switcher = {\n            2: 'Twenty',\n            3: 'Thirty',\n            4: 'Forty',\n            5: 'Fifty',\n            6: 'Sixty',\n            7: 'Seventy',\n            8: 'Eighty',\n            9: 'Ninety'\n        }\n        return switcher.get(num)\n\n    def two(num):\n        if not num:\n            return ''\n        elif num < 10:\n            return one(num)\n        elif num < 20:\n            return two_less_20(num)\n        else:\n            tenner = num // 10\n            rest = num - tenner * 10\n            return ten(tenner) + (' ' + one(rest) if rest else '')\n\n    def three(num):\n        hundred = num // 100\n        rest = num - hundred * 100\n        if hundred and rest:\n            return one(hundred) + ' Hundred ' + two(rest)\n        elif not hundred and rest:\n            return two(rest)\n        elif hundred and not rest:\n            return one(hundred) + ' Hundred'\n\n    billion = num // 1000000000\n    million = (num - billion * 1000000000) // 1000000\n    thousand = (num - billion * 1000", "def numberToWords(num):\n    if num == 0:\n        return \"Zero\"\n    \n    def one(num):\n        switcher = {\n            1: 'One',\n            2: 'Two',\n            3: 'Three',\n            4: 'Four',\n            5: 'Five',\n            6: 'Six',\n            7: 'Seven',\n            8: 'Eight',\n            9: 'Nine'\n        }\n        return switcher.get(num, \"\")\n    \n    def two_less_20(num):\n        switcher = {\n            10: 'Ten',\n            11: 'Eleven',\n            12: 'Twelve',\n            13: 'Thirteen',\n            14: 'Fourteen',\n            15: 'Fifteen',\n            16: 'Sixteen',\n            17: 'Seventeen',\n            18: 'Eighteen',\n            19: 'Nineteen'\n        }\n        return switcher.get(num, \"\")\n    \n    def ten(num):\n        switcher = {\n            2: 'Twenty',\n            3: 'Thirty',\n            4: 'Forty',\n            5: 'Fifty',\n            6: 'Sixty',\n            7: 'Seventy',\n            8: 'Eighty',\n            9: 'Ninety'\n        }\n        return switcher.get(num, \"\")\n    \n    def two(num):\n        if num < 10:\n            return one(num)\n        elif num < 20:\n            return two_less_20(num)\n        else:\n            tenner = num // 10\n            rest = num - tenner * 10\n            return ten(tenner) + (\" \" + one(rest) if rest else \"\")\n    \n    def three(num):\n        hundred = num // 100\n        rest = num - hundred * 100\n        if hundred and rest:\n            return one(hundred) + \" Hundred \" + two(rest)\n        elif hundred:\n            return one(hundred) + \" Hundred\"\n        elif rest:\n            return two(rest)\n    \n    billions = num // 1000000000\n    millions = (num % 1000000000) // 1000000\n    thousands = (num % 1", "def numberToWords(num):\n    if num == 0:\n        return \"Zero\"\n\n    def one(num):\n        switcher = {\n            1: 'One',\n            2: 'Two',\n            3: 'Three',\n            4: 'Four',\n            5: 'Five',\n            6: 'Six',\n            7: 'Seven',\n            8: 'Eight',\n            9: 'Nine'\n        }\n        return switcher.get(num)\n\n    def two_less_20(num):\n        switcher = {\n            10: 'Ten',\n            11: 'Eleven',\n            12: 'Twelve',\n            13: 'Thirteen',\n            14: 'Fourteen',\n            15: 'Fifteen',\n            16: 'Sixteen',\n            17: 'Seventeen',\n            18: 'Eighteen',\n            19: 'Nineteen'\n        }\n        return switcher.get(num)\n\n    def ten(num):\n        switcher = {\n            2: 'Twenty',\n            3: 'Thirty',\n            4: 'Forty',\n            5: 'Fifty',\n            6: 'Sixty',\n            7: 'Seventy',\n            8: 'Eighty',\n            9: 'Ninety'\n        }\n        return switcher.get(num)\n\n    def two(num):\n        if not num:\n            return ''\n        elif num < 10:\n            return one(num)\n        elif num < 20:\n            return two_less_20(num)\n        else:\n            tenner = num // 10\n            rest = num - tenner * 10\n            return ten(tenner) + (' ' + one(rest) if rest else '')\n\n    def three(num):\n        hundred = num // 100\n        rest = num - hundred * 100\n        if hundred and rest:\n            return one(hundred) + ' Hundred ' + two(rest)\n        elif not hundred and rest:\n            return two(rest)\n        elif hundred and not rest:\n            return one(hundred) + ' Hundred'\n\n    billion = num // 1000000000\n    million = (num - billion * 1000000000) // 1000000", "class Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def two(num):\n            if not num:\n                return \"\"\n            elif num < 10:\n                return ones[num]\n            elif num < 20:\n                return teens[num - 10]\n            else:\n                return tens[num // 10] + (\" \" + ones[num % 10] if num % 10 else \"\")\n\n        def three(num):\n            hundred = num // 100\n            rest = num % 100\n            if hundred:\n                return ones[hundred] + \" Hundred\" + (\" \" + two(rest) if rest else \"\")\n            else:\n                return two(rest)\n\n        result = \"\"\n        i = 0\n        while num > 0:\n            group = num % 1000\n            if group:\n                result = three(group) + (\" \" + thousands[i] if i else \"\") + (\" \" + result if result else \"\")\n            num //= 1000\n            i += 1\n\n        return result"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 10054, "entry_point": "kthFactor", "codes": ["def kthFactor(n, k):\n    for i in range(1, n + 1):\n        if n % i == 0:\n            k -= 1\n            if k == 0:\n                return i\n    return -1", "def kthFactor(n: int, k: int) -> int:\n    for i in range(1, n + 1):\n        if n % i == 0:\n            k -= 1\n            if k == 0:\n                return i\n    return -1", "def kthFactor(n, k):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n            if count == k:\n                return i\n    return -1", "def kthFactor(n, k):\n    return next((i for i in range(1, n + 1) if n % i == 0), -1) if (len([i for i in range(1, n + 1) if n % i == 0])) >= k else -1", "def kthFactor(n, k):\n    left, right = 1, n\n    while left <= right:\n        mid = (left + right) // 2\n        if n % mid == 0:\n            k -= 1\n            if k == 0:\n                return mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 10132, "entry_point": "canConvertString", "codes": ["from collections import Counter\n\ndef canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    shifts = [ord(t[i]) - ord(s[i]) if ord(t[i]) >= ord(s[i]) else 26 + ord(t[i]) - ord(s[i]) for i in range(len(s))]\n    counts = Counter(shifts)\n    \n    for shift, count in counts.items():\n        if count > 1 and shift * (count - 1) + shift > k:\n            return False\n    \n    return True", "def canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    shifts = [0] * 26\n    for cs, ct in zip(s, t):\n        diff = (ord(ct) - ord(cs) + 26) % 26\n        if diff > 0:\n            if shifts[diff] >= k:\n                return False\n            shifts[diff] += 26\n    return True", "def canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    shifts = [0] * 26\n    for a, b in zip(s, t):\n        if a != b:\n            diff = (ord(b) - ord(a) + 26) % 26\n            if shifts[diff] * 26 + diff > k:\n                return False\n            shifts[diff] += 1\n    \n    return True", "def canConvertString(s, t, k):\n    if len(s) != len(t):\n        return False\n    shifts = [0] * 26\n    for cs, ct in zip(s, t):\n        shift = (ord(ct) - ord(cs) + 26) % 26\n        if shift == 0:\n            continue\n        shifts[shift] += 1\n        if shifts[shift] * 26 + shift > k:\n            return False\n    return True", "def canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    shifts = [0] * 26\n    for c1, c2 in zip(s, t):\n        shift = (ord(c2) - ord(c1) + 26) % 26\n        if shifts[shift] * 26 + shift > k:\n            return False\n        shifts[shift] += 1\n    \n    return True", "def canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    shifts = [0] * 26\n    for cs, ct in zip(s, t):\n        shift = (ord(ct) - ord(cs) + 26) % 26\n        if shift == 0:\n            continue\n        shifts[shift - 1] += 26\n        shifts[shift - 1] -= 1\n        if shifts[shift - 1] > k:\n            return False\n    return True", "def canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    shifts = [0] * 26\n    for i in range(len(s)):\n        diff = (ord(t[i]) - ord(s[i])) % 26\n        if diff == 0 and shifts[0] == 0 and k > 0:\n            shifts[0] = 1\n            k -= 1\n        elif shifts[diff] == 0 and k >= diff:\n            shifts[diff] = 1\n            k -= diff\n        elif k >= diff + 26 * shifts[diff]:\n            shifts[diff] += 1\n            k -= diff + 26 * shifts[diff]\n        else:\n            return False\n    return True", "def canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    shifts = [0] * 26\n    for sc, tc in zip(s, t):\n        shift = (ord(tc) - ord(sc) + 26) % 26\n        if shift == 0:\n            continue\n        shifts[shift - 1] += 1\n        if shifts[shift - 1] * 26 + shift > k:\n            return False\n    return True"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 10303, "entry_point": "longestPalindrome", "codes": ["def longestPalindrome(s):\n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    longest = \"\"\n    for i in range(len(s)):\n        odd = expand_around_center(i, i)\n        even = expand_around_center(i, i + 1)\n        longest = max(longest, odd, even, key=len)\n    return longest", "def longestPalindrome(s):\n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    if len(s) < 2:\n        return s\n\n    longest = \"\"\n    for i in range(len(s)):\n        odd = expand_around_center(i, i)\n        even = expand_around_center(i, i + 1)\n        longest = max(longest, odd, even, key=len)\n\n    return longest", "def longestPalindrome(s):\n    n = len(s)\n    if n == 0:\n        return \"\"\n    \n    def expand_around_center(left, right):\n        while left >= 0 and right < n and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n    \n    longest = \"\"\n    for i in range(n):\n        odd = expand_around_center(i, i)\n        even = expand_around_center(i, i + 1)\n        longest = max(longest, odd, even, key=len)\n    \n    return longest", "def longestPalindrome(s):\n    n = len(s)\n    if n == 0:\n        return \"\"\n    start, max_len = 0, 1\n    dp = [[False] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = True\n        if i < n - 1 and s[i] == s[i + 1]:\n            dp[i][i + 1] = True\n            start = i\n            max_len = 2\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if dp[i + 1][j - 1] and s[i] == s[j]:\n                dp[i][j] = True\n                start = i\n                max_len = length\n    return s[start:start + max_len]", "def longestPalindrome(s):\n    n = len(s)\n    start, max_len = 0, 1\n    \n    for i in range(n):\n        len1 = expandAroundCenter(s, i, i)\n        len2 = expandAroundCenter(s, i, i + 1)\n        max_len = max(max_len, len1, len2)\n        \n        if max_len > 2 * (i - start + 1):\n            start = i - (max_len - 1) // 2\n    \n    return s[start:start + max_len]\n\ndef expandAroundCenter(s, left, right):\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n        right += 1\n    return right - left - 1", "def longestPalindrome(s):\n    if not s:\n        return \"\"\n    \n    start, end = 0, 0\n    \n    def expandAroundCenter(left, right):\n        nonlocal start, end\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        if right - left - 1 > end - start:\n            start, end = left + 1, right - 1\n    \n    for i in range(len(s)):\n        expandAroundCenter(i, i)\n        expandAroundCenter(i, i + 1)\n    \n    return s[start:end + 1]", "def longestPalindrome(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    start, end = 0, 0\n    \n    for i in range(len(s)):\n        len1 = expandAroundCenter(s, i, i)\n        len2 = expandAroundCenter(s, i, i + 1)\n        max_len = max(len1, len2)\n        \n        if max_len > end - start:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n    \n    return s[start:end + 1]\n\ndef expandAroundCenter(s: str, left: int, right: int) -> int:\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n        right += 1\n    return right - left - 1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 10304, "entry_point": "maxNumberOfBalloons", "codes": ["def maxNumberOfBalloons(text: str) -> int:\n    count = {char: text.count(char) for char in set(text)}\n    return min(count['b'], count['a'], count['l'] // 2, count['o'] // 2, count['n'])", "def maxNumberOfBalloons(text):\n    from collections import Counter\n    count = Counter(text)\n    return min(count['b'], count['a'], count['l'] // 2, count['o'] // 2, count['n'])", "from collections import Counter\n\ndef maxNumberOfBalloons(text):\n    count = Counter(text)\n    return min(count['b'], count['a'], count['l'] // 2, count['o'] // 2, count['n'])", "def maxNumberOfBalloons(text):\n    count = Counter(text)\n    return min(count['b'], count['a'], count['l'] // 2, count['o'] // 2, count['n'])", "def maxNumberOfBalloons(text):\n    count = [0] * 26\n    for char in text:\n        count[ord(char) - ord('a')] += 1\n    return min(count[ord('b') - ord('a')], count[ord('a') - ord('a')], count[ord('l') - ord('a')] // 2, count[ord('o') - ord('a')] // 2, count[ord('n') - ord('a')])"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 10466, "entry_point": "checkValidString", "codes": ["def checkValidString(s):\n    low = high = 0\n    for c in s:\n        low += 1 if c == '(' else -1\n        high += 1 if c != ')' else -1\n        if high < 0:\n            return False\n        low = max(0, low)\n    return low == 0", "def checkValidString(s: str) -> bool:\n    low = high = 0\n    for char in s:\n        low += 1 if char in '(*' else -1\n        high += 1 if char in ')*' else -1\n        if high < 0:\n            return False\n        low = max(0, low)\n    return low == 0", "def checkValidString(s):\n    low = high = 0\n    for char in s:\n        low += 1 if char in '(*' else -1\n        high += 1 if char in ')*' else -1\n        if high < 0:\n            return False\n        low = max(low, 0)\n    return low == 0", "def checkValidString(s):\n    low = high = 0\n    for char in s:\n        low += 1 if char in '(*' else -1\n        high += 1 if char in ')*' else -1\n        if high < 0:\n            return False\n        low = max(0, low)\n    return low == 0", "def checkValidString(s):\n    lo = hi = 0\n    for char in s:\n        lo += 1 if char != ')' else -1\n        hi += 1 if char != '(' else -1\n        if hi < 0:\n            return False\n        lo = max(lo, 0)\n    return lo == 0", "def checkValidString(s: str) -> bool:\n    lo = hi = 0\n    for char in s:\n        lo += 1 if char in '(*' else -1\n        hi += 1 if char in ')*' else -1\n        if hi < 0:\n            break\n        lo = max(lo, 0)\n    return lo == 0"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 1057, "entry_point": "makesquare", "codes": ["def makesquare(nums):\n    total = sum(nums)\n    if total % 4 != 0:\n        return False\n    target = total // 4\n    nums.sort(reverse=True)\n    if nums[0] > target:\n        return False\n    \n    def dfs(index, sides):\n        if index == len(nums):\n            return all(side == target for side in sides)\n        for i in range(4):\n            if sides[i] + nums[index] <= target:\n                sides[i] += nums[index]\n                if dfs(index + 1, sides):\n                    return True\n                sides[i] -= nums[index]\n        return False\n    \n    return dfs(0, [0, 0, 0, 0])", "def makesquare(matchsticks):\n    total = sum(matchsticks)\n    if total % 4 != 0:\n        return False\n    side = total // 4\n    matchsticks.sort(reverse=True)\n    if matchsticks[0] > side:\n        return False\n    used = [False] * len(matchsticks)\n    \n    def dfs(sides_left, start):\n        if sides_left == 0:\n            return True\n        for i in range(start, len(matchsticks)):\n            if not used[i] and matchsticks[i] <= side:\n                used[i] = True\n                if dfs(sides_left - 1, i + 1):\n                    return True\n                used[i] = False\n        return False\n    \n    return dfs(3, 0)", "def makesquare(matchsticks):\n    total_sum = sum(matchsticks)\n    if total_sum % 4 != 0:\n        return False\n    side_length = total_sum // 4\n    if max(matchsticks) > side_length:\n        return False\n    matchsticks.sort(reverse=True)\n    sides = [0] * 4\n\n    def dfs(index):\n        if index == len(matchsticks):\n            return all(side == side_length for side in sides)\n        for i in range(4):\n            if sides[i] + matchsticks[index] <= side_length:\n                sides[i] += matchsticks[index]\n                if dfs(index + 1):\n                    return True\n                sides[i] -= matchsticks[index]\n        return False\n\n    return dfs(0)", "def makesquare(nums):\n    if not nums or len(nums) < 4:\n        return False\n    total_length = sum(nums)\n    if total_length % 4 != 0:\n        return False\n    side_length = total_length // 4\n    nums.sort(reverse=True)\n    if nums[0] > side_length:\n        return False\n\n    @lru_cache(None)\n    def can_make_square(sides, used, remaining):\n        if remaining == 0:\n            return True\n        if sides == 0:\n            return can_make_square(3, used, side_length)\n        for i in range(len(nums)):\n            if used & (1 << i):\n                continue\n            if nums[i] > remaining:\n                break\n            if can_make_square(sides - 1, used | (1 << i), remaining - nums[i]):\n                return True\n        return False\n\n    return can_make_square(3, 0, side_length)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 10543, "entry_point": "longestStrChain", "codes": ["def longestStrChain(words):\n    words.sort(key=len)\n    dp = {}\n    for word in words:\n        dp[word] = max(dp.get(word[:i] + word[i+1:], 0) for i in range(len(word))) + 1\n    return max(dp.values())", "def longestStrChain(words):\n    words = set(words)\n    dp = {}\n    for word in sorted(words, key=len):\n        dp[word] = 1 + max(dp.get(word[:i] + word[i+1:], 0) for i in range(len(word)))\n    return max(dp.values())", "def longestStrChain(words):\n    dp = {}\n    for word in sorted(words, key=len):\n        dp[word] = 1\n        for i in range(len(word)):\n            predecessor = word[:i] + word[i+1:]\n            if predecessor in dp:\n                dp[word] = max(dp[word], dp[predecessor] + 1)\n    return max(dp.values())", "def longestStrChain(words):\n    from collections import defaultdict\n    words = sorted(words, key=len)\n    dp = defaultdict(lambda: 1)\n    for word in words:\n        for i in range(len(word)):\n            predecessor = word[:i] + word[i+1:]\n            if predecessor in dp:\n                dp[word] = max(dp[word], dp[predecessor] + 1)\n    return max(dp.values())"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 10580, "entry_point": "arrangeWords", "codes": ["def arrangeWords(text):\n    words = text.lower().split()\n    words.sort(key=len)\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "def arrangeWords(text):\n    words = text.split()\n    words[0] = words[0].lower()\n    words.sort(key=len)\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "def arrangeWords(text: str) -> str:\n    words = text.split()\n    words[0] = words[0].lower()\n    words.sort(key=len)\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "def arrangeWords(text):\n    words = text.split()\n    words.sort(key=lambda word: (len(word), words.index(word)))\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "def arrangeWords(text: str) -> str:\n    words = text.split()\n    words.sort(key=lambda word: (len(word), words.index(word)))\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "def arrangeWords(text: str) -> str:\n    words = text.split()\n    words[0] = words[0].lower()\n    words.sort(key=lambda x: (len(x), words.index(x)))\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "def arrangeWords(text):\n    words = text.split()\n    words.sort(key=lambda x: (len(x), words.index(x)))\n    words[0] = words[0].capitalize()\n    return ' '.join(words)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 10585, "entry_point": "nthUglyNumber", "codes": ["def nthUglyNumber(n):\n    ugly = [1]\n    i2 = i3 = i5 = 0\n    while len(ugly) < n:\n        while ugly[i2] * 2 <= ugly[-1]:\n            i2 += 1\n        while ugly[i3] * 3 <= ugly[-1]:\n            i3 += 1\n        while ugly[i5] * 5 <= ugly[-1]:\n            i5 += 1\n        ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))\n    return ugly[-1]", "def nthUglyNumber(n: int) -> int:\n    def is_ugly(num: int) -> bool:\n        for factor in 2, 3, 5:\n            while num % factor == 0:\n                num //= factor\n        return num == 1\n\n    count = 0\n    num = 0\n    while count < n:\n        num += 1\n        if is_ugly(num):\n            count += 1\n    return num", "def nthUglyNumber(n):\n    ugly_numbers = [1]\n    i2, i3, i5 = 0, 0, 0\n    while len(ugly_numbers) < n:\n        next_ugly = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)\n        ugly_numbers.append(next_ugly)\n        if next_ugly == ugly_numbers[i2] * 2:\n            i2 += 1\n        if next_ugly == ugly_numbers[i3] * 3:\n            i3 += 1\n        if next_ugly == ugly_numbers[i5] * 5:\n            i5 += 1\n    return ugly_numbers[-1]", "def nthUglyNumber(n: int) -> int:\n    ugly = {1}\n    factors = [2, 3, 5]\n    while len(ugly) < n:\n        next_ugly = min(ugly * factors)\n        ugly.add(next_ugly)\n    return min(ugly)", "def nthUglyNumber(n: int) -> int:\n    ugly_numbers = {1}\n    factors = [2, 3, 5]\n    for _ in range(n - 1):\n        next_ugly = min(ugly_numbers) * factor for factor in factors)\n        ugly_numbers.add(next_ugly)\n        ugly_numbers.remove(min(ugly_numbers))\n    return min(ugly_numbers)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 10634, "entry_point": "countTriplets", "codes": ["def countTriplets(arr):\n    count = 0\n    for i in range(len(arr)):\n        xor = 0\n        for j in range(i, len(arr)):\n            xor ^= arr[j]\n            if xor == 0:\n                count += j - i\n    return count", "def countTriplets(arr):\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        xor_sum = 0\n        for j in range(i, n):\n            xor_sum ^= arr[j]\n            if xor_sum == 0:\n                count += j - i\n    return count", "def countTriplets(arr):\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        xor_sum = 0\n        for j in range(i, n):\n            xor_sum ^= arr[j]\n            if xor_sum == 0:\n                count += j - i\n    return count", "def countTriplets(arr):\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] ^ sum(arr[i + 1:j]) == 0:\n                count += j - i - 1\n    return count", "def countTriplets(arr):\n    n = len(arr)\n    return sum((i + 1) * (j - i - 1) for i in range(n) for j in range(i + 1, n + 1) if sum(arr[i:j]) == 0)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 10745, "entry_point": "isRectangleOverlap", "codes": ["def isRectangleOverlap(rec1, rec2):\n    return rec1[1] < rec2[3] and rec1[3] > rec2[1] and rec1[0] < rec2[2] and rec1[2] > rec2[0]", "def isRectangleOverlap(rec1, rec2):\n    return rec1[2] > rec2[0] and rec2[2] > rec1[0] and rec1[3] > rec2[1] and rec2[3] > rec1[1]", "def isRectangleOverlap(rec1, rec2):\n    return all([rec1[1] < rec2[3], rec1[3] > rec2[1], rec1[0] < rec2[2], rec1[2] > rec2[0]])", "def isRectangleOverlap(rec1, rec2):\n    return all(x < y[3] and y[3] > x[1] and x[0] < y[2] and y[2] > x[0] for x, y in [(rec1, rec2), (rec2, rec1)])"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 10867, "entry_point": "findLUSlength", "codes": ["def findLUSlength(words):\n    words = sorted(words, key=lambda x: (-len(x), x))\n    for i, word in enumerate(words):\n        if all(word not in other for other in words if other != word):\n            return len(word)\n    return -1", "def findLUSlength(strs):\n    freq = {}\n    for s in strs:\n        freq[s] = freq.get(s, 0) + 1\n    for s, count in freq.items():\n        if count == 1:\n            return len(s)\n    return -1", "def findLUSlength(strs):\n    def is_subsequence(word, other):\n        it = iter(other)\n        return all(char in it for char in word)\n    \n    for i, word in enumerate(strs):\n        if not any(is_subsequence(word, strs[j]) for j in range(len(strs)) if i != j):\n            return len(word)\n    return -1", "def findLUSlength strs:\n    count = {}\n    for s in strs:\n        count[s] = count.get(s, 0) + 1\n    for s, cnt in count.items():\n        if cnt == 1:\n            return len(s)\n    return -1", "def findLUSlength strs:\n    freq = {}\n    for s in strs:\n        freq[s] = freq.get(s, 0) + 1\n    max_len = -1\n    for s, count in freq.items():\n        if count == 1:\n            max_len = max(max_len, len(s))\n    return max_len", "def findLUSlength strs):\n    longest = -1\n    for i in range(len(strs)):\n        is_uncommon = True\n        for j in range(len(strs)):\n            if i != j and findLUSlength(strs[i], strs[j]):\n                is_uncommon = False\n                break\n        if is_uncommon:\n            longest = max(longest, len(strs[i]))\n    return longest\n\ndef findLUSlength(s, t):\n    t_iter = iter(t)\n    return all(c in t_iter for c in s)", "def findLUSlength strs:\n    longest = -1\n    for i, s1 in enumerate(strs):\n        is_uncommon = True\n        for j, s2 in enumerate(strs):\n            if i != j and s1 in s2:\n                is_uncommon = False\n                break\n        if is_uncommon:\n            longest = max(longest, len(s1))\n    return longest"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 10983, "entry_point": "maxRepOpt1", "codes": ["def maxRepOpt1(text: str) -> int:\n    from collections import Counter\n    \n    count = Counter(text)\n    length = len(text)\n    result = 0\n    \n    for i in range(length):\n        if i + 1 < length and text[i] == text[i + 1]:\n            j = i + 2\n            while j < length and text[j] == text[i]:\n                j += 1\n            if j < length and text[j] == text[i] and count[text[i]] > j - i:\n                j += 1\n            result = max(result, j - i)\n            i = j - 1\n        else:\n            result = max(result, count[text[i]])\n    \n    return result", "def maxRepOpt1(text: str) -> int:\n    count = {}\n    for char in text:\n        count[char] = count.get(char, 0) + 1\n    \n    longest = 0\n    for i in range(len(text)):\n        if i > 0 and text[i] == text[i - 1]:\n            continue\n        \n        length = 1\n        for j in range(i + 1, len(text)):\n            if text[j] == text[i]:\n                length += 1\n            elif j - i > 1:\n                break\n        \n        if count[text[i]] > length:\n            length += 1\n        \n        longest = max(longest, length)\n    \n    return longest", "from collections import Counter\n\ndef maxRepOpt1(text):\n    count = Counter(text)\n    groups = [(k, sum(1 for _ in v)) for k, v in.groupby(text)]\n    result = 0\n    \n    for i, (char1, len1) in enumerate(groups):\n        if i > 0 and len1 < groups[i-1][1] + (i+1 < len(groups) and groups[i+1][1]):\n            result = max(result, min(count[char1], len1 + (i+1 < len(groups) and groups[i+1][1])))\n        elif i+1 < len(groups) and len1 < groups[i+1][1] + (i > 0 and groups[i-1][1]):\n            result = max(result, min(count[char1], len1 + (i > 0 and groups[i-1][1])))\n        else:\n            result = max(result, min(count[char1], len1))\n    \n    return result", "def maxRepOpt1(text):\n    from collections import defaultdict\n\n    def _equivalent(lhs, rhs):\n        return lhs == rhs\n\n    n = len(text)\n    left, right = 0, 0\n    max_length = 0\n    char_count = defaultdict(int)\n    window_count = defaultdict(int)\n\n    while right < n:\n        char_count[text[right]] += 1\n        window_count[text[right]] += 1\n\n        while (right - left + 1) - max(window_count.values()) > 1:\n            window_count[text[left]] -= 1\n            if window_count[text[left]] == 0:\n                del window_count[text[left]]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n        if right + 1 < n and text[right] == text[right + 1]:\n            right += 1\n            continue\n\n        if max(window_count.values()) == char_count[text[right]]:\n            window_count = defaultdict(int)\n            left = right + 1\n        else:\n            max_length = max(max_length, right - left + 2)\n            window_count = defaultdict(int)\n            left = right + 1\n\n        right += 1\n\n    return max_length", "def maxRepOpt1(text):\n    count = [0] * 26\n    for char in text:\n        count[ord(char) - ord('a')] += 1\n    \n    def max_len_with_one_swap(start):\n        max_len = 0\n        i = start\n        while i < len(text):\n            j = i\n            while j < len(text) and text[j] == text[i]:\n                j += 1\n            length = j - i\n            if length + 1 <= count[ord(text[i]) - ord('a')] and j < len(text) and text[j] == text[i]:\n                length += 1\n            if length + 2 <= count[ord(text[i]) - ord('a')] and j < len(text) and text[j] != text[i]:\n                length += 1\n            max_len = max(max_len, length)\n            if j == len(text) or text[j] != text[i]:\n                break\n            i = j + 1\n        return max_len\n    \n    max_len = 0\n    for i in range(len(text)):\n        max_len = max(max_len, max_len_with_one_swap(i))\n    return max_len", "def maxRepOpt1(text: str) -> int:\n    from collections import Counter\n\n    count = Counter(text)\n    n = len(text)\n    i, j = 0, 0\n    result = 0\n\n    while j < n:\n        if text[j] != text[i]:\n            if j - i > result:\n                result = j - i\n            i = j\n        j += 1\n\n    if j - i > result:\n        result = j - i\n\n    for k in range(i, j):\n        if count[text[k]] > j - i:\n            result = j - i + 1\n            break\n\n    return result", "def maxRepOpt1(text):\n    from collections import Counter\n    \n    # Count the frequency of each character\n    char_count = Counter(text)\n    # Group consecutive identical characters\n    groups = [(char, len(list(group))) for char, group in itertools.groupby(text)]\n    \n    max_length = 0\n    \n    for i, (char, length) in enumerate(groups):\n        # Check the current group itself\n        if length + 1 < char_count[char]:\n            max_length = max(max_length, length + 1)\n        else:\n            max_length = max(max_length, length)\n        \n        # Check the previous and next groups\n        if i > 0 and i + 1 < len(groups) and groups[i - 1][0] == groups[i + 1][0]:\n            combined_length = groups[i - 1][1] + groups[i + 1][1] + (length + 1 < char_count[groups[i - 1][0]])\n            max_length = max(max_length, combined_length)\n    \n    return max_length"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 11081, "entry_point": "hasAllCodes", "codes": ["def hasAllCodes(s: str, k: int) -> bool:\n    if len(s) < 2**k:\n        return False\n    seen = set()\n    for i in range(len(s) - k + 1):\n        seen.add(s[i:i+k])\n        if len(seen) == 2**k:\n            return True\n    return False", "def hasAllCodes(s: str, k: int) -> bool:\n    return len({s[i-k:i] for i in range(k, len(s)+1)}) == 2**k", "def hasAllCodes(s: str, k: int) -> bool:\n    seen = set()\n    for i in range(k, len(s) + 1):\n        seen.add(s[i - k:i])\n    return len(seen) == 2 ** k", "def hasAllCodes(s: str, k: int) -> bool:\n    return len({s[i:i+k] for i in range(len(s) - k + 1)}) == 1 << k", "def hasAllCodes(s: str, k: int) -> bool:\n    mask = (1 << k) - 1\n    seen = set()\n    value = 0\n    for i in range(len(s)):\n        value = (value << 1 | int(s[i])) & mask\n        if i >= k - 1:\n            seen.add(value)\n            value -= int(s[i - k + 1]) << (k - 1)\n    return len(seen) == 1 << k", "def hasAllCodes(s: str, k: int) -> bool:\n    return len(set(s[i:i+k] for i in range(k, len(s) + 1))) == 1 << k"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 11105, "entry_point": "maxProductPath", "codes": ["def maxProductPath(grid):\n    rows, cols = len(grid), len(grid[0])\n    MOD = 10**9 + 7\n\n    if grid[0][0] < 0 or grid[-1][-1] < 0:\n        return -1 if (rows * cols) % 2 else 0\n\n    dp_max = [[0] * cols for _ in range(rows)]\n    dp_min = [[0] * cols for _ in range(rows)]\n    dp_max[0][0] = dp_min[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp_max[i][0] = dp_min[i][0] = dp_max[i-1][0] * grid[i][0]\n\n    for j in range(1, cols):\n        dp_max[0][j] = dp_min[0][j] = dp_max[0][j-1] * grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] == 0:\n                dp_max[i][j] = dp_min[i][j] = 0\n            elif grid[i][j] > 0:\n                dp_max[i][j] = max(dp_max[i-1][j], dp_max[i][j-1]) * grid[i][j]\n                dp_min[i][j] = min(dp_min[i-1][j], dp_min[i][j-1]) * grid[i][j]\n            else:\n                dp_max[i][j] = min(dp_min[i-1][j], dp_min[i][j-1]) * grid[i][j]\n                dp_min[i][j] = max(dp_max[i-1][j], dp_max[i][j-1]) * grid[i][j]\n\n    return dp_max[-1][-1] % MOD if dp_max[-1][-1] >= 0 else -1", "def maxProductPath(grid):\n    rows, cols = len(grid), len(grid[0])\n    MOD = 10**9 + 7\n    \n    # Initialize the DP table with negative infinity\n    max_dp = [[-float('inf')] * cols for _ in range(rows)]\n    min_dp = [[float('inf')] * cols for _ in range(rows)]\n    \n    # Base case\n    max_dp[0][0] = grid[0][0]\n    min_dp[0][0] = grid[0][0]\n    \n    # Fill the DP table\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                continue\n            if i == 0:\n                max_dp[i][j] = max_dp[i][j-1] * grid[i][j]\n                min_dp[i][j] = min_dp[i][j-1] * grid[i][j]\n            elif j == 0:\n                max_dp[i][j] = max_dp[i-1][j] * grid[i][j]\n                min_dp[i][j] = min_dp[i-1][j] * grid[i][j]\n            else:\n                max_dp[i][j] = max(max_dp[i-1][j] * grid[i][j], max_dp[i][j-1] * grid[i][j])\n                min_dp[i][j] = min(min_dp[i-1][j] * grid[i][j], min_dp[i][j-1] * grid[i][j])\n    \n    # Return the result modulo 10^9 + 7\n    result = max_dp[-1][-1]\n    return result % MOD if result >= 0 else -1", "def maxProductPath(grid):\n    rows, cols = len(grid), len(grid[0])\n    mod = 10**9 + 7\n    \n    @lru_cache(None)\n    def dp(r, c):\n        if r == rows or c == cols:\n            return float('-inf'), float('inf')\n        if r == rows - 1 and c == cols - 1:\n            return grid[r][c], grid[r][c]\n        min_p1, max_p1 = dp(r + 1, c)\n        min_p2, max_p2 = dp(r, c + 1)\n        min_p = min(grid[r][c] * min_p1, grid[r][c] * min_p2, grid[r][c] * max_p1, grid[r][c] * max_p2)\n        max_p = max(grid[r][c] * min_p1, grid[r][c] * min_p2, grid[r][c] * max_p1, grid[r][c] * max_p2)\n        return min_p, max_p\n    \n    min_p, max_p = dp(0, 0)\n    return max_p % mod if max_p >= 0 else -1", "def maxProductPath(grid):\n    rows, cols = len(grid), len(grid[0])\n    MOD = 10**9 + 7\n    \n    @lru_cache(None)\n    def dp(r, c):\n        if r == rows or c == cols:\n            return float('-inf'), float('inf')\n        max_neg, max_pos = dp(r + 1, c) if r + 1 < rows else (float('-inf'), 0), dp(r, c + 1) if c + 1 < cols else (0, float('inf'))\n        max_neg *= grid[r][c]\n        max_pos *= grid[r][c]\n        if grid[r][c] == 0:\n            return 0, 0\n        elif grid[r][c] < 0:\n            return max_pos, max_neg\n        else:\n            return max_neg, max_pos\n    \n    result = dp(0, 0)\n    return result[0] % MOD if result[0] >= 0 else -1", "def maxProductPath(grid):\n    MOD = 10**9 + 7\n    rows, cols = len(grid), len(grid[0])\n    dp = [[(0, 0)] * cols for _ in range(rows)]\n    dp[0][0] = (grid[0][0], grid[0][0])\n    \n    for i in range(1, rows):\n        dp[i][0] = (dp[i-1][0][0] * grid[i][0], dp[i-1][0][1] * grid[i][0])\n    \n    for j in range(1, cols):\n        dp[0][j] = (dp[0][j-1][0] * grid[0][j], dp[0][j-1][1] * grid[0][j])\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            max_prod = max(dp[i-1][j][0], dp[i-1][j][1], dp[i][j-1][0], dp[i][j-1][1]) * grid[i][j]\n            min_prod = min(dp[i-1][j][0], dp[i-1][j][1], dp[i][j-1][0], dp[i][j-1][1]) * grid[i][j]\n            dp[i][j] = (max_prod, min_prod)\n    \n    max_product = dp[-1][-1][0]\n    return max_product % MOD if max_product >= 0 else -1", "def maxProductPath(grid):\n    MOD = 10**9 + 7\n    rows, cols = len(grid), len(grid[0])\n    dp = [[(1, 1) for _ in range(cols)] for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 0:\n                dp[i][j] = (0, 0)\n            elif grid[i][j] < 0:\n                if i > 0:\n                    dp[i][j] = (dp[i-1][j][1] * grid[i][j], dp[i-1][j][0] * grid[i][j])\n                if j > 0:\n                    dp[i][j] = (dp[i][j-1][1] * grid[i][j], dp[i][j-1][0] * grid[i][j])\n            else:\n                if i > 0:\n                    dp[i][j] = (max(dp[i-1][j][0], dp[i-1][j][1]) * grid[i][j], min(dp[i-1][j][0], dp[i-1][j][1]) * grid[i][j])\n                if j > 0:\n                    dp[i][j] = (max(dp[i][j-1][0], dp[i][j-1][1]) * grid[i][j], min(dp[i][j-1][0], dp[i][j-1][1]) * grid[i][j])\n\n    result = dp[-1][-1]\n    return result[0] if result[0] >= 0 else -1"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 11130, "entry_point": "findLatestStep", "codes": ["from collections import Counter\n\ndef findLatestStep(arr, m):\n    n = len(arr)\n    if m == n:\n        return n\n    groups = Counter()\n    latest_step = -1\n    bits = [0] * (n + 2)\n    for i, x in enumerate(arr, 1):\n        left = bits[x-1]\n        right = bits[x+1]\n        groups[left] -= 1\n        groups[right] -= 1\n        groups[left + right + 1] += 1\n        bits[x - left] = bits[x + right] = left + right + 1\n        if groups[m] > 0:\n            latest_step = i\n    return latest_step", "def findLatestStep(arr, m):\n    if m == len(arr):\n        return m\n    bits = [0] * (len(arr) + 2)\n    counts = {0}\n    for i, x in enumerate(arr, 1):\n        l, r = bits[x-1], bits[x+1]\n        if l == m or r == m:\n            return i - 1\n        bits[x] = bits[x-l] = bits[x+r] = l + r + 1\n        counts.remove(l)\n        counts.remove(r)\n        counts.add(l + r + 1)\n    return -1", "def findLatestStep(arr, m):\n    n = len(arr)\n    if m == n:\n        return n\n    groups = {}\n    counts = {}\n    latest_step = -1\n    for i, a in enumerate(arr, 1):\n        start, end = a, a\n        if a - 1 in groups:\n            start = groups[a - 1]\n            counts[start] -= 1\n            if counts[start] == 0:\n                del counts[start]\n        if a + 1 in groups:\n            end = groups[a + 1]\n            counts[end] -= 1\n            if counts[end] == 0:\n                del counts[end]\n        groups[start] = end\n        groups[end] = start\n        counts[start] = end - start + 1\n        if counts.get(m, 0) > 0:\n            latest_step = i\n    return latest_step", "def findLatestStep(arr, m):\n    if m == len(arr):\n        return len(arr)\n    groups = set()\n    for i, x in enumerate(arr, 1):\n        left, right = x - 1, x + 1\n        left_len, right_len = 0, 0\n        if left in groups:\n            left_len = groups.pop(left)\n        if right in groups:\n            right_len = groups.pop(right)\n        new_group = left_len + right_len + 1\n        if new_group == m:\n            return i\n        groups.add(x - left_len)\n        groups.add(x + right_len)\n    return -1", "def findLatestStep(arr, m):\n    if m == len(arr):\n        return len(arr)\n    bitset = [0] * (len(arr) + 2)\n    groups = {}\n    latest_step = -1\n\n    for step, pos in enumerate(arr, 1):\n        left, right = bitset[pos - 1], bitset[pos + 1]\n        group_size = left + right + 1\n\n        if left in groups:\n            groups.pop(left)\n        if right in groups:\n            groups.pop(right)\n\n        groups[group_size] = True\n        bitset[pos - left] = group_size\n        bitset[pos + right] = group_size\n\n        if group_size == m:\n            latest_step = step\n\n    return latest_step", "from collections import defaultdict\n\ndef findLatestStep(arr, m):\n    n = len(arr)\n    bit_string = [0] * n\n    group_sizes = defaultdict(int)\n    latest_step = -1\n    \n    for step, pos in enumerate(arr, 1):\n        pos -= 1\n        bit_string[pos] = 1\n        \n        # Check left and right neighbors\n        left_size = group_sizes.get(pos - 1, 0)\n        right_size = group_sizes.get(pos + 1, 0)\n        \n        # Update group sizes\n        group_sizes[left_size] -= 1\n        group_sizes[right_size] -= 1\n        group_sizes[left_size + right_size + 1] += 1\n        \n        # Check if the new group size is m\n        if left_size + right_size + 1 == m:\n            latest_step = step\n    \n    return latest_step"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 11170, "entry_point": "isEscapePossible", "codes": ["def isEscapePossible(blocked, source, target):\n    blocked = set(map(tuple, blocked))\n    max_distance = len(blocked) ** 2\n    directions = [0, 1, 0, -1, 0]\n\n    def bfs(start, end):\n        visited = set([tuple(start)])\n        queue = [start]\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) == end:\n                return True\n            for i in range(4):\n                nx, ny = x + directions[i], y + directions[i + 1]\n                if 0 <= nx < 10**6 and 0 <= ny < 10**6 and (nx, ny) not in visited and (nx, ny) not in blocked:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    if len(visited) > max_distance:\n                        return True\n        return False\n\n    return bfs(source, target) and bfs(target, source)", "def isEscapePossible(blocked, source, target):\n    n = len(blocked)\n    blocked = set(map(tuple, blocked))\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def bfs(start, end):\n        visited = set([tuple(start)])\n        queue = [start]\n        for _ in range(n * n):\n            if not queue:\n                break\n            x, y = queue.pop(0)\n            if [x, y] == end:\n                return True\n            for dx, dy in directions:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < 10**6 and 0 <= new_y < 10**6 and (new_x, new_y) not in visited and (new_x, new_y) not in blocked:\n                    visited.add((new_x, new_y))\n                    queue.append((new_x, new_y))\n        return False\n\n    return bfs(source, target) and bfs(target, source)", "def isEscapePossible(blocked, source, target):\n    if not blocked:\n        return True\n    \n    def is_possible(blocked, start, end):\n        blocked = set(map(tuple, blocked))\n        seen = set()\n        queue = [start]\n        \n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) == end:\n                return True\n            if (x, y) in seen:\n                continue\n            seen.add((x, y))\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < 10**6 and 0 <= ny < 10**6 and (nx, ny) not in seen and (nx, ny) not in blocked:\n                    queue.append((nx, ny))\n            if len(seen) > len(blocked):\n                return True\n        return False\n    \n    return is_possible(blocked, source, target) and is_possible(blocked, target, source)", "def isEscapePossible(blocked, source, target):\n    def bfs(start, end):\n        if not blocked:\n            return True\n        if len(blocked) < 2:\n            return True\n        if start == end:\n            return True\n        \n        blocked_set = set(map(tuple, blocked))\n        max_dist = len(blocked) ** 2\n        queue = [start]\n        visited = {start}\n        \n        for _ in range(max_dist):\n            if end in visited:\n                return True\n            new_queue = []\n            for x, y in queue:\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < 10**6 and 0 <= ny < 10**6 and (nx, ny) not in blocked_set and (nx, ny) not in visited:\n                        new_queue.append((nx, ny))\n                        visited.add((nx, ny))\n            queue = new_queue\n        \n        return False\n    \n    return bfs(source, target) and bfs(target, source)", "def isEscapePossible(blocked, source, target):\n    def bfs(start, end, blocked):\n        m, n = 10**6, 10**6\n        blocked = set(map(tuple, blocked))\n        queue = [start]\n        visited = set([start])\n        while queue:\n            x, y = queue.pop(0)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < m and 0 <= new_y < n and (new_x, new_y) not in visited and (new_x, new_y) not in blocked:\n                    if (new_x, new_y) == end:\n                        return True\n                    visited.add((new_x, new_y))\n                    queue.append((new_x, new_y))\n        return False\n\n    if not blocked:\n        return True\n\n    max_distance = len(blocked) * (len(blocked) - 1) // 2\n    return bfs(source, target, blocked) and bfs(target, source, blocked)", "def isEscapePossible(blocked, source, target):\n    def bfs(blocked, start, end):\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        queue = [start]\n        visited = set(queue)\n        blocked = set(tuple(b) for b in blocked)\n        for _ in range(20000):  # Maximum 200^2 steps to escape\n            if end in visited:\n                return True\n            for _ in range(len(queue)):\n                x, y = queue.pop(0)\n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < 1000000 and 0 <= ny < 1000000 and (nx, ny) not in visited and (nx, ny) not in blocked:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n        return False\n    \n    return bfs(blocked, source, target) and bfs(blocked, target, source)", "def isEscapePossible(blocked, source, target):\n    if not blocked:\n        return True\n    if len(blocked) <= 1:\n        return True\n    \n    blocked = set(map(tuple, blocked))\n    n = len(blocked)\n    boundary = n * (n - 1) // 2\n    \n    def bfs(start, end):\n        queue = [start]\n        visited = set([start])\n        while queue:\n            if len(visited) > boundary:\n                return True\n            x, y = queue.pop(0)\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < 10**6 and 0 <= new_y < 10**6 and (new_x, new_y) not in visited and (new_x, new_y) not in blocked:\n                    visited.add((new_x, new_y))\n                    queue.append((new_x, new_y))\n                    if (new_x, new_y) == end:\n                        return True\n        return len(visited) > boundary\n    \n    return bfs(source, target) and bfs(target, source)", "def isEscapePossible(blocked, source, target):\n    if not blocked:\n        return True\n    \n    def bfs(start, end):\n        blocked = set(map(tuple, blocked))\n        queue = [start]\n        visited = {start}\n        bound = len(blocked) ** 2\n        \n        while queue and len(visited) < bound:\n            x, y = queue.pop(0)\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < 1000000 and 0 <= ny < 1000000 and (nx, ny) not in visited and (nx, ny) not in blocked:\n                    if (nx, ny) == end:\n                        return True\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n        \n        return False\n    \n    return bfs(source, target) and bfs(target, source)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 11369, "entry_point": "minWindow", "codes": ["def minWindow(s: str, t: str) -> str:\n    from collections import Counter\n    target_count, window_count = Counter(t), Counter()\n    left, right = 0, 0\n    formed = 0\n    min_length = float('inf')\n    min_window = \"\"\n\n    while right < len(s):\n        character = s[right]\n        window_count[character] += 1\n\n        if character in target_count and window_count[character] == target_count[character]:\n            formed += 1\n\n        while left <= right and formed == len(target_count):\n            character = s[left]\n            if right - left + 1 < min_length:\n                min_length = right - left + 1\n                min_window = s[left:right + 1]\n\n            window_count[character] -= 1\n            if character in target_count and window_count[character] < target_count[character]:\n                formed -= 1\n\n            left += 1\n\n        right += 1\n\n    return min_window", "def minWindow(s: str, t: str) -> str:\n    if not t or not s:\n        return \"\"\n\n    from collections import Counter\n\n    dict_t = Counter(t)\n    required = len(dict_t)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = {}\n\n    ans = float(\"inf\"), None, None\n\n    while right < len(s):\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n\n        while left <= right and formed == required:\n            character = s[left]\n\n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n\n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n\n            left += 1    \n\n        right += 1    \n    return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]", "def minWindow(s: str, t: str) -> str:\n    from collections import Counter\n\n    t_count = Counter(t)\n    s_count = Counter()\n    required = len(t_count)\n    formed = 0\n    l = 0\n    r = 0\n    min_len = float('inf')\n    min_window = \"\"\n\n    while r < len(s):\n        character = s[r]\n        s_count[character] += 1\n\n        if character in t_count and s_count[character] == t_count[character]:\n            formed += 1\n\n        while l <= r and formed == required:\n            character = s[l]\n            if r - l + 1 < min_len:\n                min_len = r - l + 1\n                min_window = s[l:r+1]\n\n            s_count[character] -= 1\n            if character in t_count and s_count[character] < t_count[character]:\n                formed -= 1\n\n            l += 1\n\n        r += 1\n\n    return min_window", "def minWindow(s: str, t: str) -> str:\n    from collections import Counter\n    \n    if not t or not s:\n        return \"\"\n    \n    t_counter = Counter(t)\n    s_counter = Counter()\n    \n    required = len(t_counter)\n    formed = 0\n    \n    l = 0\n    min_length = float(\"inf\")\n    min_start = 0\n    \n    for r in range(len(s)):\n        s_counter[s[r]] += 1\n        \n        if s_counter[s[r]] == t_counter[s[r]]:\n            formed += 1\n        \n        while l <= r and formed == required:\n            if r - l + 1 < min_length:\n                min_length = r - l + 1\n                min_start = l\n            \n            s_counter[s[l]] -= 1\n            if s_counter[s[l]] < t_counter[s[l]]:\n                formed -= 1\n            l += 1\n    \n    return \"\" if min_length == float(\"inf\") else s[min_start:min_start + min_length]\n\n# Helper function to check if two strings are equivalent\ndef _equivalent(lhs: str, rhs: str) -> bool:\n    return lhs == rhs\n\n# Unit tests to satisfy\nassert _equivalent(minWindow(\"ADOBECODEBANC\", \"ABC\"), \"BANC\")\nassert _equivalent(minWindow(\"a\", \"a\"), \"a\")\nassert _equivalent(minWindow(\"a\", \"aa\"), \"\")\nassert _equivalent(minWindow(\"aa\", \"aa\"), \"aa\")\nassert _equivalent(minWindow(\"abcdebdde\", \"dab\"), \"abdbd\")", "def minWindow(s: str, t: str) -> str:\n    from collections import Counter\n    \n    if not t or not s:\n        return \"\"\n    \n    t_count = Counter(t)\n    required = len(t_count)\n    \n    s_count = Counter()\n    formed = 0\n    \n    l = 0\n    min_length = float(\"inf\")\n    min_left = 0\n    min_right = 0\n    \n    for r in range(len(s)):\n        if s[r] in s_count:\n            s_count[s[r]] += 1\n            if s_count[s[r]] == t_count[s[r]]:\n                formed += 1\n        \n        while l <= r and formed == required:\n            window_length = r - l + 1\n            if window_length < min_length:\n                min_length = window_length\n                min_left, min_right = l, r\n            \n            if s[l] in s_count:\n                s_count[s[l]] -= 1\n                if s_count[s[l]] < t_count[s[l]]:\n                    formed -= 1\n            \n            l += 1\n    \n    return s[min_left:min_right + 1] if min_length != float(\"inf\") else \"\""], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 11413, "entry_point": "checkInclusion", "codes": ["def checkInclusion(s1, s2):\n    from collections import Counter\n    \n    s1_count = Counter(s1)\n    s2_count = Counter()\n    \n    for i in range(len(s2)):\n        s2_count[s2[i]] += 1\n        \n        if i >= len(s1):\n            if s2_count[s2[i - len(s1)]] == 1:\n                del s2_count[s2[i - len(s1)]]\n            else:\n                s2_count[s2[i - len(s1)]] -= 1\n        \n        if s1_count == s2_count:\n            return True\n    \n    return False", "from collections import Counter\n\ndef checkInclusion(s1, s2):\n    s1_count = Counter(s1)\n    s2_count = Counter(s2[:len(s1)])\n    \n    if s1_count == s2_count:\n        return True\n    \n    for i in range(len(s1), len(s2)):\n        s2_count[s2[i]] += 1\n        s2_count[s2[i - len(s1)]] -= 1\n        if s2_count[s2[i - len(s1)]] == 0:\n            del s2_count[s2[i - len(s1)]]\n        if s1_count == s2_count:\n            return True\n    \n    return False", "def checkInclusion(s1, s2):\n    from collections import Counter\n    \n    s1_count = Counter(s1)\n    window_count = Counter()\n    window_size = len(s1)\n    \n    for i in range(len(s2)):\n        window_count[s2[i]] += 1\n        if i >= window_size:\n            if window_count[s2[i - window_size]] == 1:\n                del window_count[s2[i - window_size]]\n            else:\n                window_count[s2[i - window_size]] -= 1\n        if window_count == s1_count:\n            return True\n    return False", "def checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    s1_count = [0] * 26\n    s2_count = [0] * 26\n    \n    for i in range(len(s1)):\n        s1_count[ord(s1[i]) - ord('a')] += 1\n        s2_count[ord(s2[i]) - ord('a')] += 1\n    \n    if s1_count == s2_count:\n        return True\n    \n    for i in range(len(s1), len(s2)):\n        s2_count[ord(s2[i]) - ord('a')] += 1\n        s2_count[ord(s2[i - len(s1)]) - ord('a')] -= 1\n        \n        if s1_count == s2_count:\n            return True\n    \n    return False", "def checkInclusion(s1: str, s2: str) -> bool:\n    if len(s1) > len(s2):\n        return False\n    \n    s1_count = [0] * 26\n    s2_count = [0] * 26\n    \n    for i in range(len(s1)):\n        s1_count[ord(s1[i]) - ord('a')] += 1\n        s2_count[ord(s2[i]) - ord('a')] += 1\n    \n    if s1_count == s2_count:\n        return True\n    \n    for i in range(len(s1), len(s2)):\n        s2_count[ord(s2[i]) - ord('a')] += 1\n        s2_count[ord(s2[i - len(s1)]) - ord('a')] -= 1\n        if s1_count == s2_count:\n            return True\n    \n    return False"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 11461, "entry_point": "calculate", "codes": ["def calculate(expression):\n    num, op = 0, '+'\n    stack = []\n    for char in expression + '+':\n        if char.isdigit():\n            num = num * 10 + int(char)\n        elif char in '+-*/':\n            if op == '+':\n                stack.append(num)\n            elif op == '-':\n                stack.append(-num)\n            elif op == '*':\n                stack.append(stack.pop() * num)\n            elif op == '/':\n                stack.append(int(stack.pop() / num))\n            num, op = 0, char\n    return sum(stack)", "def calculate(expression):\n    stack = []\n    num = 0\n    sign = '+'\n    \n    for i, char in enumerate(expression):\n        if char.isdigit():\n            num = num * 10 + int(char)\n        \n        if char in '+-*/' or i == len(expression) - 1:\n            if sign == '+':\n                stack.append(num)\n            elif sign == '-':\n                stack.append(-num)\n            elif sign == '*':\n                stack.append(stack.pop() * num)\n            elif sign == '/':\n                stack.append(int(stack.pop() / num))\n            \n            sign = char\n            num = 0\n    \n    return sum(stack)", "def calculate(s):\n    stack = []\n    num = 0\n    op = '+'\n    for i, c in enumerate(s):\n        if c.isdigit():\n            num = num * 10 + int(c)\n        if i == len(s) - 1 or c in '+-*/':\n            if op == '+':\n                stack.append(num)\n            elif op == '-':\n                stack.append(-num)\n            elif op == '*':\n                stack.append(stack.pop() * num)\n            elif op == '/':\n                stack.append(int(stack.pop() / num))\n            op = c\n            num = 0\n    return sum(stack)", "def calculate(s):\n    def apply_operator(operators, values):\n        operator = operators.pop()\n        right = values.pop()\n        left = values.pop()\n        if operator == '+':\n            values.append(left + right)\n        elif operator == '-':\n            values.append(left - right)\n        elif operator == '*':\n            values.append(left * right)\n        elif operator == '/':\n            values.append(int(left / right))\n\n    operators = []\n    values = []\n    i = 0\n    while i < len(s):\n        if s[i].isspace():\n            i += 1\n            continue\n        if s[i].isdigit():\n            j = i\n            while j < len(s) and s[j].isdigit():\n                j += 1\n            values.append(int(s[i:j]))\n            i = j\n            continue\n        if s[i] in '+-*/':\n            while (operators and operators[-1] != '(' and\n                   (s[i] == '*' or s[i] == '/' or\n                    operators[-1] == '*' or operators[-1] == '/')):\n                apply_operator(operators, values)\n            operators.append(s[i])\n            i += 1\n            continue\n        if s[i] == '(':\n            operators.append(s[i])\n            i += 1\n            continue\n        if s[i] == ')':\n            while operators[-1] != '(':\n                apply_operator(operators, values)\n            operators.pop()\n            i += 1\n            continue\n    while operators:\n        apply_operator(operators, values)\n    return values[0]", "def calculate(s: str) -> int:\n    def calc(op, num, res):\n        if op == '+':\n            return res + num\n        elif op == '-':\n            return res - num\n        elif op == '*':\n            return res * num\n        elif op == '/':\n            return res // num\n        else:\n            return num\n\n    op, num, res, i = '', 0, 0, 0\n    while i < len(s):\n        if s[i].isdigit():\n            num = num * 10 + int(s[i])\n        elif s[i] in '+-*/':\n            res = calc(op, num, res)\n            op, num = s[i], 0\n        i += 1\n    return calc(op, num, res)", "def calculate(expression):\n    def apply_operator(operators, values):\n        operator = operators.pop()\n        right = values.pop()\n        left = values.pop()\n        if operator == '+':\n            values.append(left + right)\n        elif operator == '-':\n            values.append(left - right)\n        elif operator == '*':\n            values.append(left * right)\n        elif operator == '/':\n            values.append(int(left / right))\n\n    def greater_precedence(op1, op2):\n        precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n        return precedence[op1] > precedence[op2]\n\n    operators = []\n    values = []\n    i = 0\n    while i < len(expression):\n        if expression[i].isspace():\n            i += 1\n            continue\n        if expression[i].isdigit():\n            j = i\n            while j < len(expression) and expression[j].isdigit():\n                j += 1\n            values.append(int(expression[i:j]))\n            i = j\n        else:\n            while (operators and operators[-1] != '(' and\n                   greater_precedence(operators[-1], expression[i])):\n                apply_operator(operators, values)\n            operators.append(expression[i])\n            i += 1\n    while operators:\n        apply_operator(operators, values)\n    return values[0]", "def calculate(expression: str) -> int:\n    ops = {\"+\": lambda a, b: a + b, \"-\": lambda a, b: a - b, \"*\": lambda a, b: a * b, \"/\": lambda a, b: int(a / b)}\n    \n    def evaluate(tokens):\n        stack = []\n        sign = '+'\n        num = 0\n        \n        for token in tokens:\n            if token.isdigit():\n                num = num * 10 + int(token)\n            \n            if token in ops or token == ')' or not token:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack.append(stack.pop() * num)\n                elif sign == '/':\n                    stack.append(int(stack.pop() / num))\n                \n                sign = token\n                num = 0\n            \n            if token == '(':\n                stack.append(evaluate(expression.split()[tokens.index(token) + 1:tokens.index(')')]))\n        \n        return sum(stack)\n    \n    return evaluate(expression.split())", "def calculate(expression: str) -> int:\n    tokens = expression.replace(' ', '').split()\n    stack = []\n    num = 0\n    sign = '+'\n    \n    for i, token in enumerate(tokens):\n        if token.isdigit():\n            num = num * 10 + int(token)\n        \n        if token in '+-*/' or i == len(tokens) - 1:\n            if sign == '+':\n                stack.append(num)\n            elif sign == '-':\n                stack.append(-num)\n            elif sign == '*':\n                stack.append(stack.pop() * num)\n            elif sign == '/':\n                stack.append(int(stack.pop() / num))\n            \n            sign = token\n            num = 0\n    \n    return sum(stack)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 1189, "entry_point": "constrainedSubsetSum", "codes": ["def constrainedSubsetSum(nums, k):\n    n = len(nums)\n    dp = nums[:]\n    for i in range(1, n):\n        dp[i] += max(0, max(dp[max(0, i-k):i]))\n    return max(dp)", "def constrainedSubsetSum(nums, k):\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    max_queue = [0]\n\n    for i in range(1, len(nums)):\n        dp[i] = nums[i] + max(0, dp[max_queue[0]])\n        while max_queue and dp[i] >= dp[max_queue[-1]]:\n            max_queue.pop()\n        while max_queue and max_queue[0] <= i - k:\n            max_queue.pop(0)\n        max_queue.append(i)\n\n    return max(dp)", "def constrainedSubsetSum(nums, k):\n    dp = [nums[0]]\n    deque = [0]\n    for i in range(1, len(nums)):\n        dp.append(nums[i] + dp[deque[0]])\n        while deque and dp[i] >= dp[deque[-1]]:\n            deque.pop()\n        deque.append(i)\n        if i - deque[0] >= k:\n            deque.popleft()\n        dp[i] = max(dp[i], nums[i], dp[i] - nums[i])\n    return max(dp)", "def constrainedSubsetSum(nums, k):\n    n = len(nums)\n    dp = nums.copy()\n    max_queue = []\n    \n    for i in range(1, n):\n        while max_queue and i - max_queue[0] > k:\n            heappop(max_queue)\n        dp[i] += nums[i] + (dp[max_queue[0]] if max_queue else 0)\n        heappush(max_queue, i)\n    \n    return max(dp)", "from collections import deque\n\ndef constrainedSubsetSum(nums, k):\n    dp = nums[:]\n    max_queue = deque()\n    \n    for i in range(1, len(nums)):\n        dp[i] += max(0, dp[max_queue[0]] if max_queue[0] >= 0 else 0)\n        while max_queue and dp[i] >= dp[max_queue[-1]]:\n            max_queue.pop()\n        max_queue.append(i)\n        if i >= k and dp[max_queue[0]] == dp[i - k]:\n            max_queue.popleft()\n    \n    return max(dp)", "from collections import deque\n\ndef constrainedSubsetSum(nums, k):\n    n = len(nums)\n    max_sum = [0] * n\n    max_sum[0] = nums[0]\n    queue = deque([0])\n    \n    for i in range(1, n):\n        while queue and i - queue[0] > k:\n            queue.popleft()\n        max_sum[i] = max(queue[0] + nums[i], nums[i])\n        while queue and max_sum[i] > queue[-1]:\n            queue.pop()\n        queue.append(i)\n    \n    return max(max_sum)", "def constrainedSubsetSum(nums, k):\n    dp = []\n    from heapq import heappush, heappop\n    for i, num in enumerate(nums):\n        while dp and dp[0][1] < i - k:\n            heappop(dp)\n        current_max = num + (dp[0][0] if dp else 0)\n        heappush(dp, (current_max, i))\n    return max(dp)[0]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 1197, "entry_point": "findDuplicate", "codes": ["def findDuplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)", "def findDuplicate(nums):\n    for i in range(len(nums)):\n        idx = abs(nums[i]) - 1\n        if nums[idx] < 0:\n            return abs(nums[i])\n        nums[idx] = -nums[idx]\n    return -1", "def findDuplicate(nums):\n    slow = nums[0]\n    fast = nums[nums[0]]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n    slow = 0\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    return slow", "def findDuplicate(nums):\n    mid = len(nums) // 2\n    while True:\n        lower, upper = 1, mid\n        countLower = countUpper = 0\n        for num in nums:\n            if lower <= num <= mid:\n                countLower += 1\n            else:\n                countUpper += 1\n        if countLower > mid - lower + 1:\n            upper = mid\n        else:\n            lower = mid + 1\n        if lower == upper:\n            return lower\n        mid = (lower + upper) // 2"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 11655, "entry_point": "totalNQueens", "codes": ["def totalNQueens(n):\n    def solve(row, queens, diag1, diag2):\n        if row == n:\n            return 1\n        count = 0\n        for col in range(n):\n            if col not in queens and row - col not in diag1 and row + col not in diag2:\n                queens.add(col)\n                diag1.add(row - col)\n                diag2.add(row + col)\n                count += solve(row + 1, queens, diag1, diag2)\n                queens.remove(col)\n                diag1.remove(row - col)\n                diag2.remove(row + col)\n        return count\n\n    return solve(0, set(), set(), set())", "def totalNQueens(n):\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i] == col or abs(board[i] - col) == abs(i - row):\n                return False\n        return True\n\n    def backtrack(row, count):\n        if row == n:\n            count[0] += 1\n            return\n        for col in range(n):\n            if is_safe(board, row, col):\n                board[row] = col\n                backtrack(row + 1, count)\n                board[row] = -1\n\n    board = [-1] * n\n    count = [0]\n    backtrack(0, count)\n    return count[0]", "def totalNQueens(n):\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i][col] == 'Q' or (row - i == col - board[i].index('Q')) or (row - i == board[i].index('Q') - col):\n                return False\n        return True\n\n    def solve_n_queens(board, row):\n        if row == n:\n            solutions.append([''.join(row) for row in board])\n            return\n        for col in range(n):\n            if is_safe(board, row, col):\n                board[row][col] = 'Q'\n                solve_n_queens(board, row + 1)\n                board[row][col] = '.'\n\n    solutions = []\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    solve_n_queens(board, 0)\n    return len(solutions)", "def totalNQueens(n):\n    def is_not_under_attack(row, col):\n        return all(abs(r - row) != abs(c - col) and r != row for r, c in queens)\n\n    def place_queen(row, col):\n        queens.add((row, col))\n\n    def remove_queen(row, col):\n        queens.remove((row, col))\n\n    def backtrack(row = 0):\n        for col in range(n):\n            if is_not_under_attack(row, col):\n                place_queen(row, col)\n                if row + 1 == n:\n                    count[0] += 1\n                else:\n                    backtrack(row + 1)\n                remove_queen(row, col)\n\n    queens, count = set(), [0]\n    backtrack()\n    return count[0]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 11675, "entry_point": "calculateMinimumHP", "codes": ["def calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m][n - 1] = dp[m - 1][n] = 1\n    \n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            min_hp_needed = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]\n            dp[i][j] = max(1, min_hp_needed)\n    \n    return dp[0][0]", "def calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m][n - 1] = dp[m - 1][n] = 1\n    \n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            hp_needed = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]\n            dp[i][j] = max(1, hp_needed)\n    \n    return dp[0][0]", "def calculateMinimumHP(dungeon):\n    M, N = len(dungeon), len(dungeon[0])\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[M][N - 1] = dp[M - 1][N] = 1\n\n    for i in range(M - 1, -1, -1):\n        for j in range(N - 1, -1, -1):\n            min_hp = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]\n            dp[i][j] = max(1, min_hp)\n\n    return dp[0][0]", "def calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1])\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            hp = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]\n            dp[i][j] = max(1, hp)\n    return dp[0][0]", "def calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1])\n    \n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            need = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]\n            dp[i][j] = max(1, need)\n    \n    return dp[0][0]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 11700, "entry_point": "findReplaceString", "codes": ["def findReplaceString(S, indexes, sources, targets):\n    result = list(S)\n    for i, x, y in sorted(zip(indexes, sources, targets), reverse=True):\n        if S.startswith(x, i):\n            result[i:i+len(x)] = y\n    return ''.join(result)", "def findReplaceString(S, indexes, sources, targets):\n    result = list(S)\n    for i, x, y in sorted(zip(indexes, sources, targets), reverse=True):\n        if S[i:i+len(x)] == x:\n            result[i:i+len(x)] = y\n    return ''.join(result)", "def findReplaceString(S, indexes, sources, targets):\n    result = list(S)\n    for i, x, y in sorted(zip(indexes, sources, targets), reverse=True):\n        if S[i:i+len(x)] == x:\n            result[i:i+len(x)] = [y]\n    return ''.join(result)", "def findReplaceString(S: str, indexes: List[int], sources: List[str], targets: List[str]) -> str:\n    result = list(S)\n    for i, x, y in sorted(zip(indexes, sources, targets), reverse=True):\n        if S[i:i+len(x)] == x:\n            result[i:i+len(x)] = [y]\n    return ''.join(result)", "def findReplaceString(S, indexes, sources, targets):\n    # Create a list of tuples (start_index, source, target)\n    operations = sorted(zip(indexes, sources, targets))\n    \n    # Initialize the result string\n    result = []\n    i = 0\n    \n    # Process each operation\n    for start, source, target in operations:\n        # Add the part of S that is not being replaced\n        result.append(S[i:start])\n        \n        # Check if the source matches the substring of S starting at start\n        if S[start:start + len(source)] == source:\n            # Append the target to the result\n            result.append(target)\n        \n        # Move the index forward\n        i = start + len(source)\n    \n    # Add the remaining part of S\n    result.append(S[i:])\n    \n    # Join the parts to form the final result\n    return ''.join(result)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 11732, "entry_point": "stoneGameIII", "codes": ["def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [0] * (n + 1)\n    \n    for i in range(n - 1, -1, -1):\n        dp[i] = max(sum(stoneValue[i:i+k]) - dp[i+k] for k in range(1, 4) if i + k <= n)\n    \n    alice_score = dp[0]\n    bob_score = sum(stoneValue) - alice_score\n    \n    if alice_score > bob_score:\n        return \"Alice\"\n    elif alice_score < bob_score:\n        return \"Bob\"\n    else:\n        return \"Tie\"", "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        dp[i] = max(sum(stoneValue[i:i + k]) - dp[i + k] for k in range(1, 4))\n    alice_score = dp[0]\n    total_score = sum(stoneValue)\n    bob_score = total_score - alice_score\n    if alice_score > bob_score:\n        return \"Alice\"\n    elif alice_score < bob_score:\n        return \"Bob\"\n    else:\n        return \"Tie\"", "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [0] * (n + 1)\n    \n    for i in range(n - 1, -1, -1):\n        dp[i] = max(sum(stoneValue[i:i + k]) - dp[i + k] for k in range(1, 4))\n    \n    score = dp[0]\n    if score > 0:\n        return \"Alice\"\n    elif score < 0:\n        return \"Bob\"\n    else:\n        return \"Tie\"", "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [0] * (n + 1)\n    \n    for i in range(n - 1, -1, -1):\n        dp[i] = max(sum(stoneValue[i:i + k]) - dp[i + k] for k in range(1, 4))\n    \n    if dp[0] > 0:\n        return \"Alice\"\n    elif dp[0] < 0:\n        return \"Bob\"\n    else:\n        return \"Tie\"", "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    @lru_cache(None)\n    def dp(i):\n        if i == n:\n            return 0\n        return stoneValue[i] - min(dp(i + 1), dp(i + 2), dp(i + 3))\n    score = dp(0)\n    if score > 0:\n        return \"Alice\"\n    elif score < 0:\n        return \"Bob\"\n    else:\n        return \"Tie\"", "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        dp[i] = max(sum(stoneValue[i:i + k]) - dp[i + k] for k in range(1, 4))\n    score_diff = dp[0]\n    if score_diff > 0:\n        return \"Alice\"\n    elif score_diff < 0:\n        return \"Bob\"\n    else:\n        return \"Tie\""], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 11966, "entry_point": "tictactoe", "codes": ["def tictactoe(moves):\n    board = [[' ' for _ in range(3)] for _ in range(3)]\n    players = ['A', 'B']\n    \n    for i, (row, col) in enumerate(moves):\n        board[row][col] = players[i % 2]\n        \n        if any(all(board[r][c] == board[row][col] for c in range(3)) for r in range(3)) or \\\n           any(all(board[r][c] == board[row][col] for r in range(3)) for c in range(3)) or \\\n           all(board[i][i] == board[row][col] for i in range(3)) or \\\n           all(board[i][2 - i] == board[row][col] for i in range(3)):\n            return players[i % 2]\n    \n    return \"Pending\" if len(moves) < 9 else \"Draw\"", "def tictactoe(moves):\n    board = [[' ' for _ in range(3)] for _ in range(3)]\n    player = 'A'\n    \n    for move in moves:\n        row, col = move\n        board[row][col] = player\n        \n        # Check rows and columns\n        if all(board[row][i] == player for i in range(3)) or \\\n           all(board[i][col] == player for i in range(3)):\n            return player\n        \n        # Check diagonals\n        if row == col and all(board[i][i] == player for i in range(3)):\n            return player\n        if row + col == 2 and all(board[i][2 - i] == player for i in range(3)):\n            return player\n        \n        player = 'B' if player == 'A' else 'A'\n    \n    if len(moves) < 9:\n        return \"Pending\"\n    return \"Draw\"", "def tictactoe(moves):\n    board = [' '] * 9\n    player = 'A'\n    for move in moves:\n        index = move[0] * 3 + move[1]\n        board[index] = player\n        if check_winner(board):\n            return player\n        player = 'B' if player == 'A' else 'A'\n    return 'Draw' if len(moves) == 9 else 'Pending'\n\ndef check_winner(board):\n    winning_lines = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8],  # rows\n        [0, 3, 6], [1, 4, 7], [2, 5, 8],  # columns\n        [0, 4, 8], [2, 4, 6]              # diagonals\n    ]\n    for line in winning_lines:\n        if board[line[0]] == board[line[1]] == board[line[2]] != ' ':\n            return True\n    return False", "def tictactoe(moves):\n    board = [[\" \" for _ in range(3)] for _ in range(3)]\n    player = \"X\"\n    \n    for row, col in moves:\n        board[row][col] = player\n        if check_winner(board, player):\n            return player\n        player = \"O\" if player == \"X\" else \"X\"\n    \n    if len(moves) == 9:\n        return \"Draw\"\n    return \"Pending\"\n\ndef check_winner(board, player):\n    for row in board:\n        if all(cell == player for cell in row):\n            return True\n    for col in range(3):\n        if all(board[row][col] == player for row in range(3)):\n            return True\n    if board[0][0] == board[1][1] == board[2][2] == player:\n        return True\n    if board[0][2] == board[1][1] == board[2][0] == player:\n        return True\n    return False", "def tictactoe(moves):\n    board = [[\" \"] * 3 for _ in range(3)]\n    player = \"X\"\n    \n    for move in moves:\n        row, col = move\n        board[row][col] = player\n        if check_winner(board, player):\n            return player\n        player = \"O\" if player == \"X\" else \"X\"\n    \n    return \"Pending\" if len(moves) < 9 else \"Draw\"\n\ndef check_winner(board, player):\n    # Check rows\n    for row in board:\n        if all(cell == player for cell in row):\n            return True\n    \n    # Check columns\n    for col in range(3):\n        if all(board[row][col] == player for row in range(3)):\n            return True\n    \n    # Check diagonals\n    if all(board[i][i] == player for i in range(3)):\n        return True\n    if all(board[i][2 - i] == player for i in range(3)):\n        return True\n    \n    return False", "def tictactoe(moves):\n    board = [[' ' for _ in range(3)] for _ in range(3)]\n    players = ['X', 'O']\n    \n    for i, (r, c) in enumerate(moves):\n        board[r][c] = players[i % 2]\n    \n    def check_winner():\n        for row in board:\n            if row[0] == row[1] == row[2] != ' ':\n                return row[0]\n        for col in range(3):\n            if board[0][col] == board[1][col] == board[2][col] != ' ':\n                return board[0][col]\n        if board[0][0] == board[1][1] == board[2][2] != ' ':\n            return board[0][0]\n        if board[0][2] == board[1][1] == board[2][0] != ' ':\n            return board[0][2]\n        return None\n    \n    winner = check_winner()\n    if winner:\n        return winner\n    if len(moves) < 9:\n        return \"Pending\"\n    return \"Draw\"", "def tictactoe(moves):\n    board = [[\" \"] * 3 for _ in range(3)]\n    for i, (r, c) in enumerate(moves):\n        board[r][c] = \"AB\"[i % 2]\n    \n    def check_winner(player):\n        for i in range(3):\n            if all(board[i][j] == player for j in range(3)) or \\\n               all(board[j][i] == player for j in range(3)):\n                return True\n        if board[0][0] == board[1][1] == board[2][2] == player or \\\n           board[0][2] == board[1][1] == board[2][0] == player:\n            return True\n        return False\n    \n    if check_winner(\"A\"):\n        return \"A\"\n    if check_winner(\"B\"):\n        return \"B\"\n    if len(moves) == 9:\n        return \"Draw\"\n    return \"Pending\"", "def tictactoe(moves):\n    grid = [['' for _ in range(3)] for _ in range(3)]\n    players = ['A', 'B']\n    \n    for i, (row, col) in enumerate(moves):\n        grid[row][col] = players[i % 2]\n    \n    def check_winner(player):\n        # Check rows and columns\n        for i in range(3):\n            if all(grid[i][j] == player for j in range(3)) or all(grid[j][i] == player for j in range(3)):\n                return True\n        # Check diagonals\n        if all(grid[i][i] == player for i in range(3)) or all(grid[i][2 - i] == player for i in range(3)):\n            return True\n        return False\n    \n    for player in players:\n        if check_winner(player):\n            return player\n    \n    if len(moves) == 9:\n        return \"Draw\"\n    else:\n        return \"Pending\""], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 12064, "entry_point": "validUtf8", "codes": ["def validUtf8(data):\n    def count_ones(byte):\n        count = 0\n        while byte & 0b10000000:\n            byte <<= 1\n            count += 1\n        return count\n\n    i = 0\n    while i < len(data):\n        ones = count_ones(data[i])\n        if ones == 1 or ones > 4:\n            return False\n        if ones == 0:\n            i += 1\n        else:\n            if i + ones > len(data):\n                return False\n            for j in range(1, ones):\n                if data[i + j] & 0b11000000 != 0b10000000:\n                    return False\n            i += ones\n    return True", "def validUtf8(data):\n    def bits(n):\n        return bin(n)[2:].zfill(8)[-8:]\n    \n    i = 0\n    while i < len(data):\n        byte = bits(data[i])\n        if byte.startswith('0'):\n            i += 1\n        elif byte.startswith('110'):\n            if i + 1 >= len(data) or not bits(data[i + 1]).startswith('10'):\n                return False\n            i += 2\n        elif byte.startswith('1110'):\n            if i + 2 >= len(data) or not all(bits(data[j]).startswith('10') for j in range(i + 1, i + 3)):\n                return False\n            i += 3\n        elif byte.startswith('11110'):\n            if i + 3 >= len(data) or not all(bits(data[j]).startswith('10') for j in range(i + 1, i + 4)):\n                return False\n            i += 4\n        else:\n            return False\n    return True", "def validUtf8(data):\n    state = 0\n    for byte in data:\n        if state == 0:\n            if (byte >> 5) == 0b110:\n                state = 1\n            elif (byte >> 4) == 0b1110:\n                state = 2\n            elif (byte >> 3) == 0b11110:\n                state = 3\n            elif (byte >> 7):\n                return False\n        elif state == 1:\n            if (byte >> 6) != 0b10:\n                return False\n            state = 0\n        elif state == 2:\n            if (byte >> 6) != 0b10:\n                return False\n            state = 1\n        elif state == 3:\n            if (byte >> 6) != 0b10:\n                return False\n            state = 2\n    return state == 0", "def validUtf8(data):\n    def _is_leading_byte(byte):\n        return byte >> 5 == 0b110\n\n    def _is_continuation_byte(byte):\n        return byte >> 6 == 0b10\n\n    i = 0\n    while i < len(data):\n        if not _is_leading_byte(data[i]):\n            return False\n        num_bytes = data[i] >> 3 & 0b11\n        if num_bytes < 2 or num_bytes > 4 or i + num_bytes > len(data):\n            return False\n        for j in range(1, num_bytes):\n            if not _is_continuation_byte(data[i + j]):\n                return False\n        i += num_bytes\n    return True", "def validUtf8(data):\n    states = [\n        lambda byte: (byte >> 7) == 0,\n        lambda byte: (byte >> 5) == 0b110,\n        lambda byte: (byte >> 4) == 0b1110,\n        lambda byte: (byte >> 3) == 0b11110\n    ]\n    state = 0\n    for byte in data:\n        if state == 0:\n            for i in range(4, -1, -1):\n                if states[i](byte):\n                    state = i\n                    break\n            else:\n                return False\n        elif not states[state - 1](byte):\n            return False\n        state -= 1\n    return state == 0", "def validUtf8(data):\n    mask1, mask2 = 1 << 7, 1 << 6\n    n = len(data)\n    \n    i = 0\n    while i < n:\n        if (data[i] & mask1) == 0:\n            i += 1\n        elif (data[i] & mask1) and not (data[i] & mask2):\n            return False\n        elif (data[i] & mask1) and (data[i] & mask2):\n            num_bytes = 2\n            while num_bytes > 1:\n                i += 1\n                if i == n or (data[i] & mask1) or not (data[i] & mask2):\n                    return False\n                num_bytes -= 1\n        else:\n            return False\n    return True", "def validUtf8(data):\n    state = 0\n    for byte in data:\n        if state == 0:\n            if byte & 0b10000000 == 0:\n                state = 0\n            elif byte & 0b11111000 == 0b11100000:\n                state = 1\n            elif byte & 0b11110000 == 0b11110000:\n                state = 2\n            elif byte & 0b11111100 == 0b11111000:\n                state = 3\n            else:\n                return False\n        elif state == 1:\n            if byte & 0b11000000 != 0b10000000:\n                return False\n            state -= 1\n        elif state == 2:\n            if byte & 0b11000000 != 0b10000000:\n                return False\n            state -= 1\n        elif state == 3:\n            if byte & 0b11000000 != 0b10000000:\n                return False\n            state -= 1\n    return state == 0", "def validUtf8(data):\n    def is_leading_byte(byte):\n        return byte >> 5 == 0b110\n    \n    def is_continuation_byte(byte):\n        return byte >> 6 == 0b10\n    \n    i = 0\n    while i < len(data):\n        if not is_leading_byte(data[i]):\n            return False\n        \n        num_bytes = 0\n        if (data[i] >> 3) == 0b1110:\n            num_bytes = 3\n        elif (data[i] >> 4) == 0b11110:\n            num_bytes = 4\n        elif (data[i] >> 5) == 0b110:\n            num_bytes = 1\n        else:\n            return False\n        \n        i += 1\n        for _ in range(num_bytes):\n            if i >= len(data) or not is_continuation_byte(data[i]):\n                return False\n            i += 1\n    \n    return True"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 12126, "entry_point": "isAlienSorted", "codes": ["def isAlienSorted(words, order):\n    return all(words[i] <= words[i + 1] for i in range(len(words) - 1))", "def isAlienSorted(words, order):\n    alien_order = {char: idx for idx, char in enumerate(order)}\n    return words == sorted(words, key=lambda word: [alien_order[char] for char in word])", "def isAlienSorted(words, order):\n    order_map = {char: idx for idx, char in enumerate(order)}\n    return words == sorted(words, key=lambda word: [order_map[char] for char in word])", "def isAlienSorted(words, order):\n    return all(order.index(w1[i]) < order.index(w2[i]) for w1, w2 in zip(words, words[1:]) for i in range(min(len(w1), len(w2))) if w1[i] != w2[i]) and all(order.index(w[i]) < order.index(w[i+1]) for w in words for i in range(len(w)-1))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 12174, "entry_point": "flipgame", "codes": ["def flipgame(fronts, backs):\n    same = {f for f, b in zip(fronts, backs) if f == b}\n    return min((f for f in fronts + backs if f not in same), default=0)", "def flipgame(fronts, backs):\n    same = {x for x, y in zip(fronts, backs) if x == y}\n    return min((x for x in fronts + backs if x not in same), default=0)", "def flipgame(fronts, backs):\n    same = {x for x, y in zip(fronts, backs) if x == y}\n    return min([x for x in fronts + backs if x not in same] or [0])", "def flipgame(fronts, backs):\n    not_on_front = set(b for a, b in zip(fronts, backs) if a != b)\n    return min(not_on_front.union(fronts), default=0)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 12339, "entry_point": "findTheDifference", "codes": ["def findTheDifference(s, t):\n    return chr(sum(map(ord, t)) - sum(map(ord, s)))", "def findTheDifference(s, t):\n    return chr(sum(ord(c) for c in t) - sum(ord(c) for c in s))", "def findTheDifference(s: str, t: str) -> str:\n    return chr(sum(map(ord, t)) - sum(map(ord, s)))", "def findTheDifference(s: str, t: str) -> str:\n    return list((collections.Counter(t) - collections.Counter(s)).elements())[0]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 12396, "entry_point": "canVisitAllRooms", "codes": ["def canVisitAllRooms(rooms):\n    visited = set()\n    stack = [0]\n    \n    while stack:\n        room = stack.pop()\n        if room not in visited:\n            visited.add(room)\n            stack.extend(rooms[room])\n    \n    return len(visited) == len(rooms)", "def canVisitAllRooms(rooms):\n    stack, visited = [0], set([0])\n    while stack:\n        room = stack.pop()\n        for key in rooms[room]:\n            if key not in visited:\n                visited.add(key)\n                stack.append(key)\n    return len(visited) == len(rooms)", "def canVisitAllRooms(rooms):\n    visited = set([0])\n    stack = [0]\n    while stack:\n        room = stack.pop()\n        for key in rooms[room]:\n            if key not in visited:\n                visited.add(key)\n                stack.append(key)\n    return len(visited) == len(rooms)", "def canVisitAllRooms(rooms):\n    stack = [0]\n    visited = set()\n    while stack:\n        room = stack.pop()\n        if room not in visited:\n            visited.add(room)\n            stack.extend(rooms[room] - visited)\n    return len(visited) == len(rooms)", "def canVisitAllRooms(rooms):\n    visited = set()\n    stack = [0]\n    while stack:\n        room = stack.pop()\n        if room not in visited:\n            visited.add(room)\n            stack.extend(rooms[room] - visited)\n    return len(visited) == len(rooms)", "def canVisitAllRooms(rooms):\n    to_visit = {0}\n    visited = set()\n    \n    while to_visit:\n        room = to_visit.pop()\n        if room not in visited:\n            visited.add(room)\n            to_visit.update(rooms[room] - visited)\n    \n    return len(visited) == len(rooms)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 12414, "entry_point": "minMalwareSpread", "codes": ["def minMalwareSpread(graph, initial):\n    n = len(graph)\n    colors = [-1] * n\n    color = 0\n    \n    def dfs(node, color):\n        colors[node] = color\n        for neighbor, connected in enumerate(graph[node]):\n            if connected and colors[neighbor] == -1:\n                dfs(neighbor, color)\n    \n    for i in range(n):\n        if colors[i] == -1:\n            dfs(i, color)\n            color += 1\n    \n    color_count = [0] * color\n    color_nodes = [[] for _ in range(color)]\n    \n    for i in range(n):\n        color_count[colors[i]] += 1\n        color_nodes[colors[i]].append(i)\n    \n    initial_set = set(initial)\n    initial_count = [0] * color\n    \n    for node in initial:\n        initial_count[colors[node]] += 1\n    \n    max_removed = 0\n    min_node = float('inf')\n    \n    for node in initial:\n        color_idx = colors[node]\n        if initial_count[color_idx] == 1:\n            if color_count[color_idx] > max_removed or (color_count[color_idx] == max_removed and node < min_node):\n                max_removed = color_count[color_idx]\n                min_node = node\n    \n    if min_node == float('inf'):\n        min_node = min(initial)\n    \n    return min_node", "def minMalwareSpread(graph, initial):\n    n = len(graph)\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        parent[find(x)] = find(y)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if graph[i][j] == 1:\n                union(i, j)\n    \n    component_size = [0] * n\n    malware_count = [0] * n\n    \n    for i in range(n):\n        component_size[find(i)] += 1\n    \n    for node in initial:\n        malware_count[find(node)] += 1\n    \n    result = (-1, float('inf'))\n    \n    for node in sorted(initial):\n        component = find(node)\n        if malware_count[component] == 1:\n            if component_size[component] > result[1] or (component_size[component] == result[1] and node < result[0]):\n                result = (node, component_size[component])\n    \n    return result[0]", "def minMalwareSpread(graph, initial):\n    n = len(graph)\n    parent = list(range(n))\n    size = [1] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n            size[rootY] += size[rootX]\n\n    # Union nodes based on the graph\n    for i in range(n):\n        for j in range(i + 1, n):\n            if graph[i][j] == 1:\n                union(i, j)\n\n    # Count the number of malware nodes in each component\n    malware_count = [0] * n\n    for node in initial:\n        malware_count[find(node)] += 1\n\n    # Find the node with the minimum impact if removed\n    min_infected = float('inf')\n    result = min(initial)\n    for node in initial:\n        root = find(node)\n        if malware_count[root] == 1 and size[root] < min_infected:\n            min_infected = size[root]\n            result = node\n\n    return result", "def minMalwareSpread(graph, initial):\n    from collections import defaultdict\n    \n    n = len(graph)\n    components = defaultdict(set)\n    color = 0\n    \n    def dfs(node, c):\n        if node in components[c]:\n            return\n        components[c].add(node)\n        for neighbor, connected in enumerate(graph[node]):\n            if connected:\n                dfs(neighbor, c)\n    \n    for i in range(n):\n        if i not in components[color]:\n            dfs(i, color)\n            color += 1\n    \n    size = [len(components[c]) for c in components]\n    malware_count = [sum(1 for node in comp if node in initial) for comp in components.values()]\n    \n    def _equivalent(lhs, rhs):\n        return lhs == rhs\n    \n    result = float('inf')\n    max_safe = 0\n    \n    for i in range(n):\n        if sum(1 for node in components[0] if node in initial) > 1:\n            if malware_count[i] == 1 and size[i] > max_safe:\n                max_safe = size[i]\n                result = min(result, i)\n            elif malware_count[i] == 1 and size[i] == max_safe:\n                result = min(result, i)\n        else:\n            result = min(result, i)\n    \n    return result", "def minMalwareSpread(graph, initial):\n    n = len(graph)\n    infected_count = [0] * n\n    component_size = {}\n    \n    def dfs(node, component):\n        if node in component:\n            return\n        component.add(node)\n        component_size[component] = len(component)\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1:\n                dfs(neighbor, component)\n    \n    components = []\n    for node in range(n):\n        component = set()\n        dfs(node, component)\n        components.append(component)\n    \n    initial.sort()\n    for node in initial:\n        infected_count[node] += 1\n    \n    remove_node = -1\n    min_infected = float('inf')\n    for node in initial:\n        infected = 0\n        for component in components:\n            if node in component:\n                infected += component_size[component]\n                if infected_count[node] > 1:\n                    break\n        if infected < min_infected:\n            min_infected = infected\n            remove_node = node\n    \n    return remove_node", "def minMalwareSpread(graph, initial):\n    n = len(graph)\n    parents = list(range(n))\n    \n    def find(x):\n        if parents[x] != x:\n            parents[x] = find(parents[x])\n        return parents[x]\n    \n    def union(x, y):\n        parents[find(x)] = find(y)\n    \n    # Union connected components\n    for i in range(n):\n        for j in range(i + 1, n):\n            if graph[i][j] == 1:\n                union(i, j)\n    \n    # Count nodes in each component\n    component_size = [0] * n\n    for i in range(n):\n        component_size[find(i)] += 1\n    \n    # Count initial nodes in each component\n    component_initial = [0] * n\n    for node in initial:\n        component_initial[find(node)] += 1\n    \n    # Remove one node from initial to minimize malware spread\n    removal_count = [0] * n\n    for node in initial:\n        if component_initial[find(node)] == 1:\n            removal_count[find(node)] += 1\n    \n    # Find the node with the maximum removal count\n    max_removal = max(removal_count)\n    result = min(initial)\n    for node in initial:\n        if removal_count[find(node)] == max_removal:\n            result = min(result, node)\n    \n    return result"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 12495, "entry_point": "isNStraightHand", "codes": ["def isNStraightHand(hand, W):\n    from collections import Counter\n    \n    count = Counter(hand)\n    for h in sorted(hand):\n        if count[h] > 0:\n            for i in range(W):\n                count[h + i] -= 1\n                if count[h + i] < 0:\n                    return False\n    return True", "from collections import Counter\n\ndef isNStraightHand(hand, W):\n    count = Counter(hand)\n    for card in sorted(count):\n        if count[card] > 0:\n            for i in range(W - 1, -1, -1):\n                count[card + i] -= 1\n                if count[card + i] < 0:\n                    return False\n    return True", "from collections import Counter\n\ndef isNStraightHand(hand, W):\n    count = Counter(hand)\n    for card in sorted(hand):\n        if count[card] == 0:\n            continue\n        for next_card in range(card, card + W):\n            if count[next_card] == 0:\n                return False\n            count[next_card] -= 1\n    return True", "def isNStraightHand(hand, W):\n    if len(hand) % W != 0:\n        return False\n    \n    hand.sort()\n    hand_set = set(hand)\n    \n    while hand_set:\n        start = min(hand_set)\n        for i in range(W):\n            if start + i not in hand_set:\n                return False\n            hand_set.remove(start + i)\n    \n    return True"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 12536, "entry_point": "permute", "codes": ["def permute(nums):\n    if len(nums) == 1:\n        return [nums]\n    perms = []\n    for i in range(len(nums)):\n        for perm in permute(nums[:i] + nums[i+1:]):\n            perms.append([nums[i]] + perm)\n    return perms", "def permute(nums):\n    def backtrack(path, remaining):\n        if not remaining:\n            result.append(path)\n            return\n        for i in range(len(remaining)):\n            backtrack(path + [remaining[i]], remaining[:i] + remaining[i+1:])\n    \n    result = []\n    backtrack([], nums)\n    return result", "def permute(nums):\n    return _permute(nums)\n\ndef _permute(nums):\n    if len(nums) == 1:\n        return [nums]\n    perms = []\n    for i in range(len(nums)):\n        for perm in _permute(nums[:i] + nums[i+1:]):\n            perms.append([nums[i]] + perm)\n    return perms", "from itertools import permutations\n\ndef permute(nums):\n    return list(permutations(nums))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 12575, "entry_point": "minSubArrayLen", "codes": ["def minSubArrayLen(s, nums):\n    left, total, min_len = 0, 0, float('inf')\n    for right in range(len(nums)):\n        total += nums[right]\n        while total >= s:\n            min_len = min(min_len, right - left + 1)\n            total -= nums[left]\n            left += 1\n    return min_len if min_len != float('inf') else 0", "def minSubArrayLen(s, nums):\n    min_len = float('inf')\n    start = 0\n    current_sum = 0\n    \n    for end in range(len(nums)):\n        current_sum += nums[end]\n        while current_sum >= s:\n            min_len = min(min_len, end - start + 1)\n            current_sum -= nums[start]\n            start += 1\n    \n    return min_len if min_len != float('inf') else 0", "def minSubArrayLen(s, nums):\n    min_length = float('inf')\n    left = 0\n    current_sum = 0\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        while current_sum >= s:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0", "def minSubArrayLen(s, nums):\n    def divide_and_conquer(nums, start, end, s):\n        if start > end:\n            return float('inf')\n        if start == end:\n            return nums[start] >= s\n        mid = (start + end) // 2\n        left_min_len = divide_and_conquer(nums, start, mid, s)\n        right_min_len = divide_and_conquer(nums, mid + 1, end, s)\n        if left_min_len != float('inf') or right_min_len != float('inf'):\n            return min(left_min_len, right_min_len)\n        cross_min_len = float('inf')\n        current_sum = 0\n        for i in range(mid, end, -1):\n            current_sum += nums[i]\n            if current_sum >= s:\n                cross_min_len = min(cross_min_len, end - i + 1)\n                break\n        current_sum = 0\n        for i in range(mid + 1, end + 1):\n            current_sum += nums[i]\n            if current_sum >= s:\n                cross_min_len = min(cross_min_len, i - mid)\n                break\n        return min(left_min_len, right_min_len, cross_min_len)\n    \n    result = divide_and_conquer(nums, 0, len(nums) - 1, s)\n    return result if result != float('inf') else 0", "def minSubArrayLen(s, nums):\n    def min_len(left, right):\n        if left > right:\n            return float('inf')\n        mid = (left + right) // 2\n        total = sum(nums[left:mid + 1])\n        if total == s:\n            return mid - left + 1\n        elif total < s:\n            return min(min_len(mid + 1, right), mid - left + 1 + min_len(left, mid - 1))\n        else:\n            return min_len(left, mid - 1)\n    \n    result = min_len(0, len(nums) - 1)\n    return result if result != float('inf') else 0", "def minSubArrayLen(s, nums):\n    def divide_and_conquer(left, right):\n        if left > right:\n            return float('inf')\n        mid = (left + right) // 2\n        sum_left = sum(nums[left:mid+1])\n        sum_right = sum(nums[mid+1:right+1])\n        if sum_left >= s:\n            min_len_left = 1\n        else:\n            min_len_left = divide_and_conquer(left, mid)\n        if sum_right >= s:\n            min_len_right = 1\n        else:\n            min_len_right = divide_and_conquer(mid+1, right)\n        if sum_left + sum_right >= s:\n            min_len_cross = mid - left + 2\n        else:\n            min_len_cross = float('inf')\n        return min(min_len_left, min_len_right, min_len_cross)\n    \n    n = len(nums)\n    result = divide_and_conquer(0, n-1)\n    return result if result != float('inf') else 0"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 12613, "entry_point": "generate", "codes": ["from math import comb\n\ndef generate(numRows):\n    return [[comb(n, k) for k in range(n + 1)] for n in range(numRows)]", "def generate(numRows):\n    triangle = []\n    for row_num in range(numRows):\n        row = [1] * (row_num + 1)\n        for j in range(1, row_num):\n            row[j] = triangle[row_num - 1][j - 1] + triangle[row_num - 1][j]\n        triangle.append(row)\n    return triangle", "def generate(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i-1][j-1] + triangle[i-1][j]\n        triangle.append(row)\n    return triangle", "def generate(numRows):\n    def helper(row):\n        if len(row) == 1:\n            return [1]\n        return [1] + [row[i] + row[i + 1] for i in range(len(row) - 1)] + [1]\n    \n    result = [[1]]\n    for _ in range(1, numRows):\n        result.append(helper(result[-1]))\n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 12692, "entry_point": "numDistinct", "codes": ["def numDistinct(s: str, t: str) -> int:\n    dp = [0] * (len(t) + 1)\n    dp[0] = 1\n    for char in s:\n        for j in range(len(t), 0, -1):\n            if t[j - 1] == char:\n                dp[j] += dp[j - 1]\n    return dp[-1]", "def numDistinct(s, t):\n    m, n = len(s), len(t)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(m):\n        for j in range(n, 0, -1):\n            if s[i] == t[j - 1]:\n                dp[j] += dp[j - 1]\n    return dp[n]", "def numDistinct(s: str, t: str) -> int:\n    m, n = len(s), len(t)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(m):\n        for j in range(n - 1, -1, -1):\n            if s[i] == t[j]:\n                dp[j + 1] += dp[j]\n    \n    return dp[n]", "def numDistinct(s: str, t: str) -> int:\n    m, n = len(t), len(s)\n    dp = {0: 1}\n    for j in range(1, n + 1):\n        ndp = {0: dp[0]}\n        for i in range(1, m + 1):\n            ndp[i] = dp[i]\n            if t[i - 1] == s[j - 1]:\n                ndp[i] += dp[i - 1]\n        dp = ndp\n    return dp[m]", "def numDistinct(s: str, t: str) -> int:\n    dp = {0: 1}\n    for char in s:\n        for i in range(len(t), 0, -1):\n            dp[i] += dp[i - 1] if char == t[i - 1] else 0\n    return dp[len(t)]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 12835, "entry_point": "majorityElement", "codes": ["def majorityElement(nums):\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    return [num for num, c in count.items() if c > len(nums) // 3]", "def majorityElement(nums):\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    return [num for num, count in counts.items() if count > len(nums) // 3]", "def majorityElement(nums):\n    counts = {}\n    threshold = len(nums) // 3\n    result = []\n    \n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n        if counts[num] > threshold and num not in result:\n            result.append(num)\n    \n    return result", "def majorityElement(nums):\n    candidates = {}\n    threshold = len(nums) // 3\n    \n    for num in nums:\n        if num in candidates:\n            candidates[num] += 1\n        else:\n            candidates[num] = 1\n        \n        if candidates[num] > threshold:\n            candidates[num] = 0\n    \n    return [num for num, count in candidates.items() if count > 0]", "def majorityElement(nums):\n    count = {}\n    threshold = len(nums) // 3\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n        if count[num] > threshold:\n            count[num] = 0\n    return [num for num, cnt in count.items() if cnt > 0]", "from collections import defaultdict\n\ndef majorityElement(nums):\n    count = defaultdict(int)\n    n = len(nums)\n    threshold = n // 3\n    \n    for num in nums:\n        count[num] += 1\n        if count[num] > threshold:\n            return [num]\n    \n    return []"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 12881, "entry_point": "maxJumps", "codes": ["def maxJumps(arr, d):\n    n = len(arr)\n    dp = [1] * n\n    \n    for i in range(n):\n        for j in range(i + 1, min(i + d + 1, n)):\n            if arr[i] <= arr[j]:\n                break\n            dp[i] = max(dp[i], dp[j] + 1)\n        \n        for j in range(i - 1, max(i - d - 1, -1), -1):\n            if arr[i] <= arr[j]:\n                break\n            dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "def maxJumps(arr, d):\n    n = len(arr)\n    dp = [1] * n\n    \n    def dfs(i):\n        if dp[i] > 1:\n            return dp[i]\n        mx = 0\n        for x in range(1, d + 1):\n            if i + x < n and arr[i + x] < arr[i]:\n                mx = max(mx, dfs(i + x))\n            else:\n                break\n        for x in range(1, d + 1):\n            if i - x >= 0 and arr[i - x] < arr[i]:\n                mx = max(mx, dfs(i - x))\n            else:\n                break\n        dp[i] = mx + 1\n        return dp[i]\n    \n    for i in range(n):\n        dfs(i)\n    \n    return max(dp)", "def maxJumps(arr, d):\n    n = len(arr)\n    dp = [1] * n\n    stack = []\n    for i in range(n):\n        while stack and arr[stack[-1]] < arr[i]:\n            j = stack.pop()\n            left = right = 0\n            if i - j <= d:\n                left = dp[j]\n            if j - stack[-1] <= d:\n                right = dp[stack[-1]]\n            dp[i] = max(dp[i], max(left, right) + 1)\n        stack.append(i)\n    return max(dp)", "def maxJumps(arr, d):\n    n = len(arr)\n    jumps = [1] * n\n    \n    for i in range(n):\n        for x in range(1, d + 1):\n            if i + x < n and arr[i] > arr[i + x]:\n                jumps[i] = max(jumps[i], jumps[i + x] + 1)\n            else:\n                break\n            if i - x >= 0 and arr[i] > arr[i - x]:\n                jumps[i] = max(jumps[i], jumps[i - x] + 1)\n            else:\n                break\n    \n    return max(jumps)", "def maxJumps(arr, d):\n    n = len(arr)\n    dp = [1] * n\n    \n    def dfs(i):\n        if dp[i] > 1:\n            return dp[i]\n        for x in range(1, d + 1):\n            if i + x < n and arr[i] > arr[i + x]:\n                dp[i] = max(dp[i], dfs(i + x) + 1)\n            if i - x >= 0 and arr[i] > arr[i - x]:\n                dp[i] = max(dp[i], dfs(i - x) + 1)\n        return dp[i]\n    \n    return max(dfs(i) for i in range(n))", "from collections import defaultdict\n\ndef maxJumps(arr, d):\n    n = len(arr)\n    jumps = [1] * n\n    indices = defaultdict(list)\n    for i, x in enumerate(arr):\n        indices[x].append(i)\n    \n    for x in sorted(indices):\n        for i in indices[x]:\n            for j in range(1, d + 1):\n                if i + j < n and arr[i] > arr[i + j]:\n                    jumps[i] = max(jumps[i], jumps[i + j] + 1)\n                if i - j >= 0 and arr[i] > arr[i - j]:\n                    jumps[i] = max(jumps[i], jumps[i - j] + 1)\n    \n    return max(jumps)", "def maxJumps(arr, d):\n    n = len(arr)\n    jumps = [1] * n\n    \n    def can_jump(i, j):\n        return 0 < abs(i - j) <= d and arr[i] > arr[j]\n    \n    for i in range(n):\n        for x in range(1, d + 1):\n            if i + x < n and can_jump(i, i + x):\n                jumps[i] = max(jumps[i], jumps[i + x] + 1)\n            if i - x >= 0 and can_jump(i, i - x):\n                jumps[i] = max(jumps[i], jumps[i - x] + 1)\n    \n    return max(jumps)"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 12907, "entry_point": "minKBitFlips", "codes": ["def minKBitFlips(A, K):\n    flips = 0\n    flip_state = [0] * len(A)\n    for i in range(len(A)):\n        if i >= K:\n            flip_state[i - K] = 0\n        if flip_state[i] % 2 == A[i]:\n            if i + K > len(A):\n                return -1\n            flip_state[i] = 1\n            flips += 1\n    return flips", "def minKBitFlips(A, K):\n    n = len(A)\n    flips = 0\n    flip_stack = []\n    \n    for i in range(n):\n        if flip_stack and flip_stack[0] == i - K:\n            flip_stack.pop(0)\n        \n        if len(flip_stack) % 2 == A[i]:\n            if i + K > n:\n                return -1\n            flips += 1\n            flip_stack.append(i)\n    \n    return flips", "def minKBitFlips(A, K):\n    n = len(A)\n    flips = 0\n    flip_at = [0] * (n + 1)\n    flip_count = 0\n    \n    for i in range(n):\n        flip_count += flip_at[i]\n        if (flip_count % 2) == A[i]:\n            if i + K > n:\n                return -1\n            flips += 1\n            flip_count += 1\n            flip_at[i + K] -= 1\n    \n    return flips", "def minKBitFlips(A, K):\n    n = len(A)\n    flips = 0\n    flip_at = [0] * (n + 1)\n    \n    for i in range(n):\n        flips += flip_at[i]\n        if (A[i] + flips) % 2 == 0:\n            if i + K > n:\n                return -1\n            flips += 1\n            flip_at[i + K] -= 1\n    \n    return flips", "def minKBitFlips(A, K):\n    n = len(A)\n    flips = 0\n    flip_stack = []\n    \n    for i in range(n):\n        if flip_stack and i >= flip_stack[0] + K:\n            flip_stack.pop(0)\n        \n        if flip_stack and i % 2 == flip_stack[0] % 2:\n            continue\n        \n        if i + K > n:\n            return -1\n        \n        flips += 1\n        flip_stack.append(i)\n    \n    return flips", "def minKBitFlips(A, K):\n    n = len(A)\n    flips = 0\n    flip_at = [0] * (n + 1)\n    \n    for i in range(n):\n        flips += flip_at[i]\n        if (flips % 2 == A[i]):\n            if (i + K > n):\n                return -1\n            flips += 1\n            flip_at[i + K] -= 1\n    \n    return flips", "def minKBitFlips(A, K):\n    n = len(A)\n    flip_count = 0\n    current_flips = 0\n    for i in range(n):\n        if i >= K:\n            current_flips ^= A[i - K]\n        if (A[i] ^ current_flips) == 0:\n            if i + K > n:\n                return -1\n            A[i] ^= 1\n            current_flips ^= 1\n            flip_count += 1\n    return flip_count", "def minKBitFlips(A, K):\n    n = len(A)\n    flips = 0\n    flip_count = [0] * (n + 1)\n    \n    for i in range(n):\n        flip_count[i] += flip_count[i - 1]\n        if (A[i] + flip_count[i]) % 2 == 0:\n            if i + K > n:\n                return -1\n            flips += 1\n            flip_count[i + K] -= 1\n    \n    return flips"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 12974, "entry_point": "palindromePartition", "codes": ["from functools import lru_cache\n\ndef palindromePartition(s: str, k: int) -> int:\n    @lru_cache(None)\n    def min_changes(i: int, j: int) -> int:\n        return 0 if i >= j else (min_changes(i + 1, j - 1) + (s[i] != s[j]))\n\n    @lru_cache(None)\n    def dp(i: int, k: int) -> int:\n        return min(dp(j, k - 1) + min_changes(j + 1, i) for j in range(k - 2, i)) if k > 1 else min_changes(0, i)\n\n    return dp(len(s) - 1, k)", "def palindromePartition(s, k):\n    n = len(s)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    for i in range(n, -1, -1):\n        for j in range(1, k + 1):\n            dp[i][j] = float('inf')\n            for l in range(i, n):\n                cost = sum(1 for x, y in zip(s[i:l], reversed(s[l:i-1:-1])) if x != y)\n                dp[i][j] = min(dp[i][j], cost + dp[l + 1][j - 1])\n    \n    return dp[0][k]", "def palindromePartition(s: str, k: int) -> int:\n    n = len(s)\n    cost = [[0] * n for _ in range(n)]\n    \n    # Calculate the cost to make substring s[i:j+1] a palindrome\n    for i in range(n-1, -1, -1):\n        for j in range(i, n):\n            cost[i][j] = cost[i+1][j-1] + (s[i] != s[j])\n    \n    dp = [[float('inf')] * k for _ in range(n)]\n    \n    # Initialize the dp array\n    for i in range(n):\n        dp[i][0] = cost[0][i]\n    \n    # Fill the dp array\n    for i in range(1, n):\n        for j in range(1, min(i+1, k)):\n            for p in range(j-1, i):\n                dp[i][j] = min(dp[i][j], dp[p][j-1] + cost[p+1][i])\n    \n    return dp[n-1][k-1]", "def palindromePartition(s: str, k: int) -> int:\n    n = len(s)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    cost = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        cost[i][i] = 0\n        for j in range(i + 1, n):\n            cost[i][j] = cost[i + 1][j - 1] + (s[i] != s[j])\n    \n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            dp[i][j] = min(dp[i][j], min(dp[p][j - 1] + cost[p][i - 1] for p in range(j - 1, i)))\n    \n    return dp[n][k]", "def palindromePartition(s: str, k: int) -> int:\n    n = len(s)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            for l in range(i):\n                dp[i][j] = min(dp[i][j], dp[l][j - 1] + sum(s[l] != s[i - 1 - m] for m in range(l, i)))\n\n    return dp[n][k]", "def palindromePartition(s: str, k: int) -> int:\n    n = len(s)\n    cost = [[0] * n for _ in range(n)]\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            cost[i][j] = cost[i + 1][j - 1] + (s[i] != s[j])\n    \n    dp = [float('inf')] * (k + 1)\n    dp[0] = 0\n    \n    for _ in range(1, k + 1):\n        for i in range(n):\n            dp[i + 1] = min(dp[i + 1], min(dp[j] + cost[j + 1][i] for j in range(i)))\n    \n    return dp[n]"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 13042, "entry_point": "winnerSquareGame", "codes": ["def winnerSquareGame(n):\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = any(not dp[i - j * j] for j in range(1, int(math.sqrt(i)) + 1))\n    return dp[n]", "def winnerSquareGame(n):\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = any(not dp[i - j * j] for j in range(1, int(i**0.5) + 1))\n    return dp[n]", "from functools import cache\n\n@cache\ndef winnerSquareGame(n):\n    if n == 0:\n        return False\n    return any(not winnerSquareGame(n - i * i) for i in range(1, int(n**0.5) + 1))", "import math\n\ndef winnerSquareGame(n):\n    @lru_cache(None)\n    def helper(n):\n        return any(not helper(n - j * j) for j in range(1, int(math.sqrt(n)) + 1))\n    \n    return helper(n)", "def winnerSquareGame(n):\n    @cache\n    def can_win(x):\n        return any(not can_win(x - i * i) for i in range(1, int(x**0.5) + 1))\n    return can_win(n)", "def winnerSquareGame(n: int) -> bool:\n    @cache\n    def helper(n: int) -> bool:\n        return any(not helper(n - i * i) for i in range(1, int(n**0.5) + 1))\n    return helper(n)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 13133, "entry_point": "minimumSwap", "codes": ["def minimumSwap(s1: str, s2: str) -> int:\n    if (s1.count('x') + s2.count('x')) % 2 != 0:\n        return -1\n    mismatches = sum(1 for c1, c2 in zip(s1, s2) if c1 != c2)\n    return mismatches // 2 + mismatches % 2 * 2", "def minimumSwap(s1: str, s2: str) -> int:\n    count = {'x': 0, 'y': 0}\n    for a, b in zip(s1, s2):\n        if a != b:\n            count[a] += 1\n    if (count['x'] + count['y']) % 2 != 0:\n        return -1\n    return count['x'] // 2 + count['y'] // 2 + count['x'] % 2", "def minimumSwap(s1, s2):\n    count = {'x': 0, 'y': 0}\n    for c1, c2 in zip(s1, s2):\n        if c1 != c2:\n            count[c1] += 1\n    if (count['x'] + count['y']) % 2 != 0:\n        return -1\n    return count['x'] // 2 + count['y'] // 2 + count['x'] % 2 + count['y'] % 2", "def minimumSwap(s1: str, s2: str) -> int:\n    count = {'xx': 0, 'yy': 0, 'xy': 0, 'yx': 0}\n    for c1, c2 in zip(s1, s2):\n        count[c1 + c2] += 1\n    \n    xy = count['xy']\n    yx = count['yx']\n    \n    if (xy + yx) % 2 != 0:\n        return -1\n    \n    return xy // 2 + yx // 2 + xy % 2 + yx % 2", "def minimumSwap(s1: str, s2: str) -> int:\n    if len(s1) != len(s2):\n        return -1\n    \n    count = {'xx': 0, 'yy': 0, 'xy': 0, 'yx': 0}\n    for char1, char2 in zip(s1, s2):\n        count[char1 + char2] += 1\n    \n    if (count['xy'] + count['yx']) % 2 != 0:\n        return -1\n    \n    return count['xy'] // 2 + count['yx'] // 2 + count['xy'] % 2 + count['yx'] % 2"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 13384, "entry_point": "pushDominoes", "codes": ["def pushDominoes(dominoes):\n    n = len(dominoes)\n    force = [0] * n\n    left = 0\n    for i in range(n):\n        if dominoes[i] == 'R':\n            left = n\n        elif dominoes[i] == 'L':\n            left = 0\n        else:\n            left = max(left - 1, 0)\n        force[i] += left\n    \n    right = 0\n    for i in range(n - 1, -1, -1):\n        if dominoes[i] == 'L':\n            right = n\n        elif dominoes[i] == 'R':\n            right = 0\n        else:\n            right = max(right - 1, 0)\n        force[i] -= right\n    \n    result = []\n    for f in force:\n        if f == 0:\n            result.append('.')\n        elif f > 0:\n            result.append('R')\n        else:\n            result.append('L')\n    \n    return ''.join(result)", "def pushDominoes(s):\n    s = \"L\" + s + \"R\"\n    result = []\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[j] == '.':\n            j += 1\n        if s[i] == s[j]:\n            result.append(s[i] * (j - i))\n        elif s[i] == 'L' and s[j] == 'R':\n            result.append('.' * (j - i))\n        else:\n            mid = (j - i - 1) // 2\n            result.append('R' * mid + '.' * (j - i - 2 * mid) + 'L' * mid)\n        i = j\n    return ''.join(result)", "def pushDominoes(dominoes: str) -> str:\n    n = len(dominoes)\n    result = list(dominoes)\n    i = 0\n    while i < n:\n        j = i\n        while j < n and result[j] == '.':\n            j += 1\n        if j == n:\n            break\n        if i == 0 and result[i] == '.':\n            if result[j] == 'L':\n                result[i:j] = ['L'] * (j - i)\n        elif result[i] == 'L':\n            if result[j] == 'L':\n                result[i:j] = ['L'] * (j - i)\n            elif result[j] == 'R':\n                pass\n        elif result[i] == 'R':\n            if result[j] == 'L':\n                mid = (j - i) // 2\n                result[i + mid] = result[j - mid] = 'R' if (j - i) % 2 == 0 else '.'\n            elif result[j] == 'R':\n                result[i:j] = ['R'] * (j - i)\n        i = j\n    return ''.join(result)", "def pushDominoes(s: str) -> str:\n    n = len(s)\n    s = list('L' + s + 'R')\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n + 1 and s[j] == '.':\n            j += 1\n        if s[j] == 'L':\n            if s[i] == 'R':\n                mid = (j - i - 1) // 2\n                s[i + 1:i + 1 + mid] = 'R' * mid\n                s[i + 1 + mid:i + 1 + (j - i - 1) // 2 + 1] = 'L' * (j - i - 1 - 2 * mid)\n            i = j\n        else:\n            i = j\n    return ''.join(s[1:n+1])", "def pushDominoes(s: str) -> str:\n    result = list(s)\n    n = len(result)\n    i = 0\n    while i < n:\n        if result[i] == '.':\n            j = i + 1\n            while j < n and result[j] == '.':\n                j += 1\n            if i > 0 and result[i - 1] == 'R':\n                if j == n or result[j] == 'L':\n                    for k in range(i, j):\n                        result[k] = 'R' if i == k else 'L' if j == k else '.'\n                else:\n                    for k in range(i, j):\n                        result[k] = 'R' if (k - i) < (j - k) else 'L' if (k - i) > (j - k) else '.'\n            i = j\n        else:\n            i += 1\n    return ''.join(result)", "def pushDominoes(s):\n    s = 'L' + s + 'R'\n    n = len(s)\n    i = 0\n    result = []\n    while i < n - 1:\n        j = i + 1\n        while j < n and s[j] == '.':\n            j += 1\n        if s[i] == s[j]:\n            result.append(s[i] * (j - i))\n        elif s[i] == 'L' and s[j] == 'R':\n            result.append('.' * (j - i))\n        else:\n            result.append('R' * ((j - i) // 2) + '.' * ((j - i) % 2) + 'L' * ((j - i) // 2))\n        i = j\n    return ''.join(result)"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 13418, "entry_point": "maxFreq", "codes": ["def maxFreq(s, maxLetters, minSize, maxSize):\n    from collections import Counter\n    cnt = Counter(s[i:i+minSize] for i in range(len(s) - minSize + 1))\n    return max((cnt[w] for w in cnt if len(set(w)) <= maxLetters), default=0)", "def maxFreq(s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n    from collections import Counter\n    substr_count = Counter(s[i:i+minSize] for i in range(len(s) - minSize + 1))\n    return max((count for substring, count in substr_count.items() if len(set(substring)) <= maxLetters), default=0)", "def maxFreq(s, maxLetters, minSize, maxSize):\n    freq = {}\n    for i in range(len(s) - minSize + 1):\n        substring = s[i:i + minSize]\n        if len(set(substring)) <= maxLetters:\n            freq[substring] = freq.get(substring, 0) + 1\n    return max(freq.values()) if freq else 0", "def maxFreq(s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n    return max([s[i:i+minSize] for i in range(len(s)-minSize+1)].count(sub) for sub in set(s[i:i+minSize] for i in range(len(s)-minSize+1)) if len(set(sub)) <= maxLetters) if minSize <= len(s) <= maxSize else 0"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 13420, "entry_point": "largestNumber", "codes": ["def largestNumber(nums):\n    nums = list(map(str, nums))\n    nums.sort(key=lambda x: x*3, reverse=True)\n    return str(int(''.join(nums)))", "def largestNumber(nums):\n    from functools import cmp_to_key\n    nums = list(map(str, nums))\n    nums.sort(key=cmp_to_key(lambda x, y: int(y + x) - int(x + y)))\n    return str(int(''.join(nums)))", "from functools import cmp_to_key\n\ndef largestNumber(nums):\n    def compare(x, y):\n        return int(y + x) - int(x + y)\n    \n    nums = sorted(map(str, nums), key=cmp_to_key(compare))\n    return str(int(''.join(nums)))", "def largestNumber(nums):\n    nums = list(map(str, nums))\n    nums.sort(key=lambda x, y: y + x > x + y)\n    return ''.join(nums).lstrip('0') or '0'", "def largestNumber(nums):\n    # Convert integers to strings for custom comparison\n    nums = list(map(str, nums))\n    # Define a custom comparator\n    def compare(x, y):\n        return (int(y + x) - int(x + y))\n    # Sort numbers based on the custom comparator\n    nums.sort(key=cmp_to_key(compare))\n    # Concatenate sorted numbers into a single string\n    result = ''.join(nums)\n    # Handle the edge case where the result is all zeros\n    return result if result[0] != '0' else '0'", "from functools import cmp_to_key\n\ndef largestNumber(nums):\n    def compare(x, y):\n        return int(y + x) - int(x + y)\n    \n    nums = map(str, nums)\n    nums.sort(key=cmp_to_key(compare))\n    return str(int(''.join(nums)))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 13470, "entry_point": "monotoneIncreasingDigits", "codes": ["def monotoneIncreasingDigits(N):\n    digits = list(map(int, str(N)))\n    n = len(digits)\n    \n    for i in range(n - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            digits[i - 1] -= 1\n            for j in range(i, n):\n                digits[j] = 9\n    \n    return int(''.join(map(str, digits)))", "def monotoneIncreasingDigits(N):\n    digits = list(map(int, str(N)))\n    n = len(digits)\n    for i in range(n-2, -1, -1):\n        if digits[i] > digits[i+1]:\n            digits[i] -= 1\n            for j in range(i+1, n):\n                digits[j] = 9\n    return int(''.join(map(str, digits)))", "def monotoneIncreasingDigits(N):\n    digits = list(str(N))\n    n = len(digits)\n    for i in range(n - 2, -1, -1):\n        if digits[i] > digits[i + 1]:\n            digits[i] = str(int(digits[i]) - 1)\n            for j in range(i + 1, n):\n                digits[j] = '9'\n    return int(''.join(digits))\n\ndef _equivalent(lhs, rhs):\n    return monotoneIncreasingDigits(lhs) == rhs", "def monotoneIncreasingDigits(N):\n    digits = list(str(N))\n    i = 1\n    while i < len(digits) and digits[i] >= digits[i - 1]:\n        i += 1\n    while i > 0 and digits[i] < digits[i - 1]:\n        digits[i - 1] = str(int(digits[i - 1]) - 1)\n        i -= 1\n    for j in range(i, len(digits)):\n        digits[j] = '9'\n    return int(''.join(digits))", "def monotoneIncreasingDigits(N):\n    N = str(N)\n    stack = []\n    for i, digit in enumerate(N):\n        while stack and digit < stack[-1]:\n            stack.pop()\n        stack.append(digit)\n    result = ''.join(stack)\n    return int(result if len(result) == len(N) else result[:-1] + str(int(result[-1]) - 1))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 13495, "entry_point": "toHex", "codes": ["def toHex(num):\n    if num == 0:\n        return \"0\"\n    hex_chars = \"0123456789abcdef\"\n    hex_str = \"\"\n    for _ in range(8):\n        hex_str = hex_chars[num & 15] + hex_str\n        num >>= 4\n    return hex_str.lstrip('0')", "def toHex(num):\n    if num == 0:\n        return \"0\"\n    hex_chars = \"0123456789abcdef\"\n    hex_string = \"\"\n    for _ in range(8):\n        hex_string = hex_chars[num & 15] + hex_string\n        num >>= 4\n    return hex_string.lstrip('0')", "def toHex(num):\n    if num == 0:\n        return '0'\n    hex_digits = \"0123456789abcdef\"\n    if num < 0:\n        num += 0x100000000\n    hex_str = ''\n    while num > 0:\n        hex_str = hex_digits[num % 16] + hex_str\n        num //= 16\n    return hex_str", "def toHex(number):\n    if number == 0:\n        return \"0\"\n    hex_digits = \"0123456789abcdef\"\n    if number < 0:\n        number += 1 << 32\n    return \"\".join(hex_digits[(number // (16 ** i)) % 16] for i in range(7, -1, -1))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 1388, "entry_point": "catMouseGame", "codes": ["def catMouseGame(graph):\n    def dfs(mouse, cat, turn):\n        if (mouse, cat, turn) in memo:\n            return memo[(mouse, cat, turn)]\n        if mouse == 0:\n            result = 1\n        elif mouse == cat:\n            result = 2\n        elif turn == len(graph) * 2:\n            result = 0\n        else:\n            if turn % 2 == 0:\n                moves = graph[mouse]\n                result = 2\n                for next_mouse in moves:\n                    if dfs(next_mouse, cat, turn + 1) == 1:\n                        result = 1\n                        break\n                    if dfs(next_mouse, cat, turn + 1) == 0:\n                        result = 0\n            else:\n                moves = graph[cat] if cat != 0 else []\n                result = 1\n                for next_cat in moves:\n                    if dfs(mouse, next_cat, turn + 1) == 2:\n                        result = 2\n                    if dfs(mouse, next_cat, turn + 1) == 0:\n                        result = 0\n        memo[(mouse, cat, turn)] = result\n        return result\n\n    memo = {}\n    return dfs(1, 2, 0)", "def catMouseGame(graph):\n    n = len(graph)\n    DRAW = 0\n    MOUSE_WIN = 1\n    CAT_WIN = 2\n    state = [[[0] * n for _ in range(n)] for _ in range(n * 2)]\n    \n    def dfs(m, c, t):\n        if state[t][m][c]:\n            return state[t][m][c]\n        if t >= 2 * n * n:\n            state[t][m][c] = DRAW\n        elif m == 0:\n            state[t][m][c] = MOUSE_WIN\n        elif m == c:\n            state[t][m][c] = CAT_WIN\n        else:\n            if t % 2 == 0:\n                if any(dfs(nxt, c, t + 1) == MOUSE_WIN for nxt in graph[m]):\n                    state[t][m][c] = MOUSE_WIN\n                else:\n                    state[t][m][c] = CAT_WIN if all(dfs(nxt, c, t + 1) == CAT_WIN for nxt in graph[m]) else DRAW\n            else:\n                if any(dfs(m, nxt, t + 1) == CAT_WIN for nxt in graph[c] if nxt != 0):\n                    state[t][m][c] = CAT_WIN\n                else:\n                    state[t][m][c] = MOUSE_WIN if all(dfs(m, nxt, t + 1) == MOUSE_WIN for nxt in graph[c] if nxt != 0) else DRAW\n        return state[t][m][c]\n    \n    return dfs(1, 2, 0)", "def catMouseGame(graph):\n    n = len(graph)\n    dp = [[[0] * 2 for _ in range(n)] for _ in range(n)]\n    \n    def move(m, c, t):\n        if dp[m][c][t] > 0:\n            return dp[m][c][t]\n        if m == 0:\n            dp[m][c][t] = 1\n        elif m == c:\n            dp[m][c][t] = 2\n        elif t == 2 * n - 1:\n            dp[m][c][t] = 0\n        else:\n            moves = graph[m] if t % 2 == 0 else [x for x in graph[c] if x != 0]\n            if all(move(m, c, t + 1) == 1 for move in moves):\n                dp[m][c][t] = 1\n            elif all(move(m, c, t + 1) == 2 for move in moves):\n                dp[m][c][t] = 2\n            else:\n                dp[m][c][t] = 0\n        return dp[m][c][t]\n    \n    return move(1, 2, 0)", "def catMouseGame(graph):\n    n = len(graph)\n    memo = [[[0] * n for _ in range(n)] for _ in range(2 * n)]\n\n    def dfs(m, c, t):\n        if memo[m][c][t] > 0:\n            return memo[m][c][t]\n        if t >= 2 * n:\n            return 0\n        if m == 0:\n            memo[m][c][t] = 1\n        elif c == m:\n            memo[m][c][t] = 2\n        else:\n            mouse_turn = t % 2 == 0\n            if mouse_turn:\n                result = 2\n                for nei in graph[m]:\n                    if nei == 0:\n                        continue\n                    res = dfs(nei, c, t + 1)\n                    if res == 1:\n                        memo[m][c][t] = 1\n                        break\n                    elif res == 0:\n                        result = 0\n                if memo[m][c][t] == 0:\n                    memo[m][c][t] = result\n            else:\n                result = 1\n                for nei in graph[c]:\n                    if nei == m:\n                        continue\n                    res = dfs(m, nei, t + 1)\n                    if res == 2:\n                        memo[m][c][t] = 2\n                        break\n                    elif res == 0:\n                        result = 0\n                if memo[m][c][t] == 0:\n                    memo[m][c][t] = result\n        return memo[m][c][t]\n\n    return dfs(1, 2, 0)", "def catMouseGame(graph):\n    n = len(graph)\n    dp = [[[0] * n for _ in range(n)] for _ in range(n * n * 2)]\n    \n    def dfs(m, c, t):\n        if dp[m][c][t] != 0:\n            return dp[m][c][t]\n        if m == 0:\n            dp[m][c][t] = 1\n        elif m == c:\n            dp[m][c][t] = 2\n        else:\n            if t % 2 == 0:\n                next_moves = graph[m]\n            else:\n                next_moves = graph[c]\n                next_moves.remove(0)\n            \n            if all(dfs(next_m, c, t + 1) == 1 for next_m in next_moves):\n                dp[m][c][t] = 1\n            elif all(dfs(m, next_c, t + 1) == 2 for next_c in next_moves):\n                dp[m][c][t] = 2\n            else:\n                dp[m][c][t] = 0\n        \n        return dp[m][c][t]\n    \n    return dfs(1, 2, 0)", "def catMouseGame(graph):\n    n = len(graph)\n    DRAW, MOUSE, CAT = 0, 1, 2\n    dp = [[[-1] * 2 for _ in range(n)] for _ in range(n)]\n\n    def search(m, c, t):\n        if dp[m][c][t] != -1:\n            return dp[m][c][t]\n        if t == 2 * n:\n            dp[m][c][t] = DRAW\n        elif m == 0:\n            dp[m][c][t] = MOUSE\n        elif m == c:\n            dp[m][c][t] = CAT\n        else:\n            paths = []\n            if t % 2 == 0:  # Mouse's turn\n                paths = graph[m]\n            else:  # Cat's turn\n                paths = graph[c] if c != 0 else []\n            result = DRAW\n            for next_pos in paths:\n                next_t = t + 1\n                next_result = search(next_pos, c, next_t)\n                if next_result == MOUSE:\n                    result = MOUSE\n                    break\n                if next_result == CAT:\n                    paths.remove(next_pos)\n                    continue\n                if len(paths) == 1:\n                    result = CAT\n                    break\n            dp[m][c][t] = result\n        return dp[m][c][t]\n\n    return search(1, 2, 0)"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 13515, "entry_point": "numRookCaptures", "codes": ["def numRookCaptures(board):\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'R':\n                return sum(board[i][j+k] in 'Rp' for k in range(1, 8)) + sum(board[i+k][j] in 'Rp' for k in range(1, 8))\n    return 0", "def numRookCaptures(board):\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'R':\n                return sum(board[i][j+x] == 'p' or board[i+x][j] == 'p' for x in range(1, 8) if board[i][j+x] != '.' or board[i+x][j] != '.')\n    return 0", "def numRookCaptures(board):\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'R':\n                return sum(1 for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)) \n                           for x, y in zip(range(i, 8, dx), range(j, 8, dy)) \n                           if board[x][y] in 'Rp')\n    return 0", "def numRookCaptures(board):\n    rows, cols = len(board), len(board[0])\n    r, c = next((i, j) for i in range(rows) for j in range(cols) if board[i][j] == 'R')\n    \n    def scan(dx, dy):\n        x, y = r + dx, c + dy\n        while 0 <= x < rows and 0 <= y < cols:\n            if board[x][y] in 'Rp':\n                return 1\n            if board[x][y] != '.':\n                break\n            x, y = x + dx, y + dy\n        return 0\n    \n    return sum(scan(dx, dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)])", "def numRookCaptures(board):\n    for r, row in enumerate(board):\n        for c, cell in enumerate(row):\n            if cell == 'R':\n                directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n                captures = 0\n                for dr, dc in directions:\n                    i, j = r + dr, c + dc\n                    while 0 <= i < 8 and 0 <= j < 8:\n                        if board[i][j] in 'Rp':\n                            captures += board[i][j] == 'p'\n                            break\n                        i += dr\n                        j += dc\n                return captures", "def numRookCaptures(board):\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'R':\n                return sum(1 for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0))\n                           if 0 <= i + di < 8 and 0 <= j + dj < 8 and (board[i + di][j + dj] == 'p' or board[i + di][j + dj] == 'B'))", "def numRookCaptures(board):\n    def find_rook():\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'R':\n                    return i, j\n    \n    def count_captures(i, j):\n        captures = 0\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            while 0 <= ni < 8 and 0 <= nj < 8:\n                if board[ni][nj] in ['B', 'p']:\n                    captures += board[ni][nj] == 'p'\n                    break\n                ni, nj = ni + di, nj + dj\n        return captures\n    \n    ri, rj = find_rook()\n    return count_captures(ri, rj)", "def numRookCaptures(board):\n    rows = len(board)\n    cols = len(board[0])\n    rook_pos = None\n    \n    # Find the position of the rook\n    for i in range(rows):\n        for j in range(cols):\n            if board[i][j] == 'R':\n                rook_pos = (i, j)\n                break\n        if rook_pos:\n            break\n    \n    # Directions: north, east, south, west\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    count = 0\n    \n    # Check each direction\n    for dr, dc in directions:\n        r, c = rook_pos\n        while 0 <= r + dr < rows and 0 <= c + dc < cols:\n            if board[r + dr][c + dc] == 'p':\n                count += 1\n                break\n            if board[r + dr][c + dc] == 'B':\n                break\n            r += dr\n            c += dc\n    \n    return count"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 13585, "entry_point": "profitableSchemes", "codes": ["def profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    dp = [[0] * (G + 1) for _ in range(P + 1)]\n    dp[0][0] = 1\n    \n    for g, p in zip(group, profit):\n        for i in range(P, -1, -1):\n            for j in range(G, g - 1, -1):\n                dp[min(i + p, P)][j] = (dp[min(i + p, P)][j] + dp[i][j - g]) % MOD\n    \n    return sum(dp[P]) % MOD", "def profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    dp = [[0] * (G + 1) for _ in range(P + 1)]\n    dp[0][0] = 1\n    \n    for g, p in zip(group, profit):\n        for i in range(P, -1, -1):\n            for j in range(G - g, -1, -1):\n                dp[min(i + p, P)][j + g] += dp[i][j]\n                dp[min(i + p, P)][j + g] %= MOD\n    \n    return sum(dp[P]) % MOD", "def profitableSchemes(G, P, group, profit):\n    mod = 10**9 + 7\n    n = len(group)\n    dp = [[0] * (G + 1) for _ in range(P + 1)]\n    dp[0][0] = 1\n\n    for p, g in zip(profit, group):\n        for i in range(P, p - 1, -1):\n            for j in range(G, g - 1, -1):\n                dp[i][j] = (dp[i][j] + dp[i - p][j - g]) % mod\n\n    return sum(dp[p][g] for p in range(P + 1)) % mod", "def profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    dp = [[0] * (P + 1) for _ in range(G + 1)]\n    dp[0][0] = 1\n\n    for g in range(G + 1):\n        for p in range(P + 1):\n            dp[g][p] = dp[g][p] + dp[g][p] % MOD\n            if g >= group[i] and p >= profit[i]:\n                dp[g][p] = (dp[g][p] + dp[g - group[i]][p - profit[i]]) % MOD\n\n    return sum(dp[G][p] for p in range(P + 1)) % MOD", "def profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    n = len(group)\n    dp = [[0] * (G + 1) for _ in range(P + 1)]\n    dp[0][0] = 1\n\n    for g in range(G + 1):\n        for p in range(P, -1, -1):\n            for i in range(n):\n                if g >= group[i]:\n                    dp[min(p + profit[i], P)][g] = (dp[min(p + profit[i], P)][g] + dp[p][g - group[i]]) % MOD\n\n    return sum(dp[p][G] for p in range(P + 1)) % MOD", "def profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    n = len(group)\n    dp = [[0] * (P + 1) for _ in range(G + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for g in range(G, group[i] - 1, -1):\n            for p in range(P, -1, -1):\n                dp[g][p] = (dp[g][p] + dp[g - group[i]][max(0, p - profit[i])]) % MOD\n\n    return sum(dp[g][p] for g in range(G + 1) for p in range(P + 1)) % MOD", "from functools import lru_cache\n\ndef profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    \n    @lru_cache(None)\n    def dp(i, group_left, profit_left):\n        if i == len(group):\n            return 1 if profit_left >= 0 else 0\n        if group_left < group[i]:\n            return dp(i + 1, group_left, profit_left)\n        return (dp(i + 1, group_left, profit_left) + dp(i + 1, group_left - group[i], profit_left - profit[i])) % MOD\n    \n    return dp(0, G, P)", "def profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    n = len(group)\n    dp = [[0] * (P + 1) for _ in range(G + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        g, p = group[i], profit[i]\n        for j in range(G, g - 1, -1):\n            for k in range(P, -1, -1):\n                dp[j][k] = (dp[j][k] + dp[j-g][k-p]) % MOD\n\n    return sum(dp[g][p] for g in range(G + 1) for p in range(P, -1, -1)) % MOD"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 13691, "entry_point": "isBoomerang", "codes": ["def isBoomerang(points):\n    return (points[1][0] - points[0][0]) * (points[2][1] - points[0][1]) != (points[2][0] - points[0][0]) * (points[1][1] - points[0][1])", "def isBoomerang(points):\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n    return (y2 - y1) * (x3 - x1) != (y3 - y1) * (x2 - x1)", "def isBoomerang(points):\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n    return (y2 - y1) * (x3 - x2) != (y3 - y2) * (x2 - x1)", "def isBoomerang(points):\n    return len(set(map(tuple, points))) == 3 and (points[2][1] - points[1][1]) * (points[1][0] - points[0][0]) != (points[1][1] - points[0][1]) * (points[2][0] - points[1][0])", "def isBoomerang(points):\n    (x1, y1), (x2, y2), (x3, y3) = points\n    return (x2 - x1) * (y3 - y1) != (x3 - x1) * (y2 - y1)", "def isBoomerang(points):\n    return len(set(map(tuple, points))) == 3", "def isBoomerang(points):\n    return len(set(map(tuple, points))) == 3 and (points[0][0] * (points[1][1] - points[2][1]) + points[1][0] * (points[2][1] - points[0][1]) + points[2][0] * (points[0][1] - points[1][1])) != 0"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 13743, "entry_point": "singleNumber", "codes": ["def singleNumber(nums):\n    ones, twos = 0, 0\n    for num in nums:\n        ones = (ones ^ num) & ~twos\n        twos = (twos ^ num) & ~ones\n    return ones", "def singleNumber(nums):\n    nums.sort()\n    for i in range(0, len(nums) - 2, 3):\n        if nums[i] != nums[i + 1]:\n            return nums[i]\n    return nums[-1]", "def singleNumber(nums):\n    return sorted(nums)[len(nums)//3]", "def singleNumber(nums):\n    return sorted(nums)[len(nums) // 3 * 2]"], "rewards": [1.0, 1.0, -1.0, -1.0]}
{"id": 13882, "entry_point": "maxWidthRamp", "codes": ["def maxWidthRamp(A):\n    min_index = 0\n    max_width = 0\n    \n    for j in range(len(A)):\n        if A[j] < A[min_index]:\n            min_index = j\n        else:\n            max_width = max(max_width, j - min_index)\n    \n    return max_width", "def maxWidthRamp(A):\n    min_indices = []\n    max_width = 0\n    \n    for i, a in enumerate(A):\n        if not min_indices or A[min_indices[-1]] > a:\n            min_indices.append(i)\n    \n    for i in range(len(A) - 1, -1, -1):\n        while min_indices and A[min_indices[-1]] <= A[i]:\n            max_width = max(max_width, i - min_indices.pop())\n    \n    return max_width", "def maxWidthRamp(A):\n    min_stack = []\n    max_width = 0\n    \n    for j in range(len(A)):\n        if not min_stack or A[j] < A[min_stack[-1]]:\n            min_stack.append(j)\n    \n    for i in range(len(A) - 1, -1, -1):\n        while min_stack and A[i] >= A[min_stack[-1]]:\n            max_width = max(max_width, i - min_stack.pop())\n    \n    return max_width", "def maxWidthRamp(A):\n    min_vals = [A[0]]\n    for i in range(1, len(A)):\n        min_vals.append(min(min_vals[-1], A[i]))\n    \n    max_width = 0\n    j = len(A) - 1\n    for i in range(len(A) - 1, -1, -1):\n        while j > i and A[j] >= min_vals[i]:\n            max_width = max(max_width, j - i)\n            j -= 1\n    \n    return max_width", "def maxWidthRamp(A):\n    min_index = float('inf')\n    max_width = 0\n    \n    for i in range(len(A)):\n        if A[i] < A[min_index]:\n            min_index = i\n        else:\n            max_width = max(max_width, i - min_index)\n    \n    return max_width", "def maxWidthRamp(A):\n    min_left = []\n    curr_min = float('inf')\n    for i, a in enumerate(A):\n        if a < curr_min:\n            curr_min = a\n        min_left.append(curr_min)\n\n    max_ramp = 0\n    max_right = A[-1]\n    for i in range(len(A) - 1, -1, -1):\n        if A[i] > max_right:\n            max_right = A[i]\n        if min_left[i] <= max_right:\n            max_ramp = max(max_ramp, i - min_left[i])\n    return max_ramp", "def maxWidthRamp(A):\n    min_index = float('inf')\n    max_width = 0\n    \n    for j in range(len(A)):\n        min_index = min(min_index, A[j] - j)\n        max_width = max(max_width, A[j] - min_index)\n    \n    return max_width", "def maxWidthRamp(A):\n    min_index = float('inf')\n    max_width = 0\n    for j, a in enumerate(A):\n        if a < A[min_index]:\n            min_index = j\n        elif a >= A[min_index]:\n            max_width = max(max_width, j - min_index)\n    return max_width"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 13985, "entry_point": "isMatch", "codes": ["def isMatch(s, p):\n    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n    dp[-1][-1] = True\n    for i in range(len(s), -1, -1):\n        for j in range(len(p) - 1, -1, -1):\n            match = i < len(s) and (s[i] == p[j] or p[j] == '?')\n            dp[i][j] = match and dp[i + 1][j + 1] or (p[j] == '*' and (dp[i + 1][j] or dp[i][j + 1]))\n    return dp[0][0]", "def isMatch(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and p[j - 1] == '*'\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n            elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n    \n    return dp[m][n]", "def isMatch(s, p):\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    \n    for j in range(1, n + 1):\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 1]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] in {s[i - 1], '?'}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    \n    return dp[m][n]", "def isMatch(s: str, p: str) -> bool:\n    return bool(re.fullmatch(p.replace('?', '.').replace('*', '.*'), s))", "def isMatch(s, p):\n    return bool(re.fullmatch(p.replace('?', '.').replace('*', '.*'), s))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 14040, "entry_point": "getHappyString", "codes": ["def getHappyString(n, k):\n    if k > 3 * (2 ** (n - 1)):\n        return \"\"\n    return \"\".join(x for x in generate_happy_strings(n)[k - 1])\n\ndef generate_happy_strings(n):\n    if n == 1:\n        return [\"a\", \"b\", \"c\"]\n    prev = generate_happy_strings(n - 1)\n    return [c + s for s in prev for c in \"abc\" if c != s[0]]", "def getHappyString(n, k):\n    if k > 3 * (2 ** (n - 1)):\n        return \"\"\n    def generate_happy_strings(length, last_char):\n        if length == 1:\n            return ['a', 'b', 'c'] if last_char is None else [c for c in 'abc' if c != last_char]\n        return [char + s for char in 'abc' for s in generate_happy_strings(length - 1, char) if char != last_char]\n    happy_strings = generate_happy_strings(n, None)\n    return happy_strings[k - 1]", "def getHappyString(n: int, k: int) -> str:\n    def backtrack(path, last_char):\n        if len(path) == n:\n            results.append(path)\n            return\n        for char in ['a', 'b', 'c']:\n            if char != last_char:\n                backtrack(path + char, char)\n    \n    results = []\n    backtrack(\"\", \"\")\n    return results[k - 1] if k <= len(results) else \"\"", "def getHappyString(n, k):\n    total = 3 * 2 ** (n - 1)\n    if k > total:\n        return \"\"\n    \n    result = []\n    for i in range(n):\n        choices = ['a', 'b', 'c']\n        if result:\n            choices.remove(result[-1])\n        choices.remove(result[-2] if result else '')\n        result.append(choices[(k - 1) // (2 ** (n - i - 2))])\n        k %= 2 ** (n - i - 2)\n    \n    return ''.join(result)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 14195, "entry_point": "minAddToMakeValid", "codes": ["def minAddToMakeValid(S):\n    balance = 0\n    additions = 0\n    for char in S:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            if balance > 0:\n                balance -= 1\n            else:\n                additions += 1\n    return additions + balance", "def minAddToMakeValid(s):\n    open_count = close_count = 0\n    for char in s:\n        if char == '(':\n            open_count += 1\n        else:\n            if open_count > 0:\n                open_count -= 1\n            else:\n                close_count += 1\n    return open_count + close_count", "def minAddToMakeValid(s: str) -> int:\n    balance = 0\n    open_count = 0\n    for char in s:\n        if char == '(':\n            open_count += 1\n        elif char == ')' and open_count > 0:\n            open_count -= 1\n        else:\n            balance += 1\n    return balance + open_count", "def minAddToMakeValid(s: str) -> int:\n    balance = 0\n    result = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            result += 1\n            balance = 0\n    return result + balance", "def minAddToMakeValid(S: str) -> int:\n    balance = 0\n    result = 0\n    for char in S:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n            if balance < 0:\n                result += 1\n                balance = 0\n    return result + balance", "def minAddToMakeValid(S):\n    balance = 0\n    min_add = 0\n    for char in S:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n            if balance < 0:\n                min_add += 1\n                balance = 0\n    return min_add + balance"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 14198, "entry_point": "hIndex", "codes": ["def hIndex(citations):\n    left, right = 0, len(citations)\n    while left < right:\n        mid = (left + right + 1) // 2\n        if citations[len(citations) - mid] < mid:\n            right = mid - 1\n        else:\n            left = mid\n    return left", "def hIndex(citations):\n    left, right = 0, len(citations)\n    while left < right:\n        mid = (left + right) // 2\n        if citations[mid] < len(citations) - mid:\n            left = mid + 1\n        else:\n            right = mid\n    return len(citations) - left", "def hIndex(citations):\n    left, right = 0, len(citations)\n    while left < right:\n        mid = (left + right) // 2\n        if citations[mid] >= len(citations) - mid:\n            right = mid\n        else:\n            left = mid + 1\n    return len(citations) - left", "def hIndex(citations):\n    n = len(citations)\n    left, right = 0, n\n    while left < right:\n        mid = (left + right) // 2\n        if citations[mid] >= n - mid:\n            right = mid\n        else:\n            left = mid + 1\n    return n - left\n\ndef _equivalent(_lhs, _rhs):\n    return _lhs == _rhs\n\n# Unit tests\nassert hIndex([0,1,3,5,6]) == 3\nassert hIndex([1,2,3]) == 3\nassert hIndex([0,0,0]) == 0\nassert hIndex([0]) == 0\nassert hIndex([1]) == 1\nassert hIndex([2, 2, 2]) == 2\nassert hIndex([1, 3, 3, 5, 6]) == 3\nassert hIndex([1, 2, 3, 4, 5]) == 5\nassert hIndex([1, 1, 2, 2, 3, 3, 4, 4]) == 4"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 14275, "entry_point": "minDifference", "codes": ["def minDifference(nums):\n    nums.sort()\n    n = len(nums)\n    return min(nums[n-4]-nums[0], nums[n-3]-nums[1], nums[n-2]-nums[2], nums[n-1]-nums[3]) if n > 4 else 0", "def minDifference(nums):\n    if len(nums) <= 4:\n        return 0\n    nums.sort()\n    return min(nums[i + 4] - nums[i] for i in range(4))", "def minDifference(nums):\n    if len(nums) <= 4:\n        return 0\n    nums.sort()\n    return min(nums[i+4] - nums[i] for i in range(5))", "def minDifference(nums):\n    nums.sort()\n    return min(nums[-i] - nums[i-1] for i in range(1, 5))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 1454, "entry_point": "numSteps", "codes": ["def numSteps(s):\n    s = list(s)\n    steps = 0\n    while len(s) > 1:\n        if s[-1] == '0':\n            s.pop()\n        else:\n            i = len(s) - 1\n            while i >= 0 and s[i] == '1':\n                s[i] = '0'\n                i -= 1\n            if i >= 0:\n                s[i] = '1'\n            else:\n                s.insert(0, '1')\n        steps += 1\n    return steps", "def numSteps(s: str) -> int:\n    count = 0\n    num = int(s, 2)\n    while num > 1:\n        if num % 2 == 0:\n            num //= 2\n        else:\n            num += 1\n        count += 1\n    return count", "def numSteps(s: str) -> int:\n    return sum(1 for _ in (lambda x: (x // 2, x + 1)[x % 2] until x == 1)(int(s, 2)))", "def numSteps(s):\n    steps = 0\n    while len(s) > 1:\n        if s[-1] == '0':\n            s = s[:-1]\n        else:\n            s = bin(int(s, 2) + 1)[2:]\n        steps += 1\n    return steps", "def numSteps(s: str) -> int:\n    steps = 0\n    while s != \"1\":\n        if s[-1] == \"0\":\n            s = s[:-1]\n        else:\n            s = bin(int(s, 2) + 1)[2:]\n        steps += 1\n    return steps", "def numSteps(s):\n    count = 0\n    while len(s) > 1:\n        if s[-1] == '0':\n            s = s[:-1]\n        else:\n            s = bin(int(s, 2) + 1)[2:]\n        count += 1\n    return count"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 1490, "entry_point": "maxPower", "codes": ["def maxPower(s):\n    max_count = current_count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            current_count += 1\n        else:\n            max_count = max(max_count, current_count)\n            current_count = 1\n    return max(max_count, current_count)", "def maxPower(s):\n    max_len = 0\n    current_len = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    return max(max_len, current_len)", "def maxPower(s):\n    max_count = 0\n    current_count = 1\n\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            current_count += 1\n        else:\n            max_count = max(max_count, current_count)\n            current_count = 1\n\n    return max(max_count, current_count)", "def maxPower(s: str) -> int:\n    max_len = 0\n    current_len = 1\n\n    for i, (char1, char2) in enumerate(s):\n        if char1 == char2:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n\n    return max(max_len, current_len)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 14528, "entry_point": "mirrorReflection", "codes": ["def mirrorReflection(p, q):\n    while q % p:\n        q, p = p, q % p\n    if q == 0:\n        return 0\n    return 1 if (p // q) % 2 else 2", "def mirrorReflection(p, q):\n    while p % 2 == 0 and q % 2 == 0:\n        p //= 2\n        q //= 2\n    if p % 2 == 1 and q % 2 == 0:\n        return 0\n    if p % 2 == 0 and q % 2 == 1:\n        return 2\n    return 1", "def mirrorReflection(p, q):\n    while q and p % q:\n        p, q = q, p % q\n    if p // q % 2 == 0:\n        return 0\n    elif q == 0:\n        return 2\n    else:\n        return 1", "def mirrorReflection(p, q):\n    while q % p == 0:\n        q //= 2\n    return (q % 2) + (1 if p % 2 == 1 else 0)", "def mirrorReflection(p, q):\n    while p % 2 == 0 and q % 2 == 0:\n        p //= 2\n        q //= 2\n    return 0 if p % 2 == 0 else (1 if q % 2 == 0 else 2)", "def mirrorReflection(p, q):\n    while q and q % p:\n        q %= p\n    return 1 if q == 0 else 2 if (p // q) % 2 else 0", "def mirrorReflection(p, q):\n    while q % p:\n        q += p\n    return 2 if q // p % 2 else 1 if p // 2 % 2 else 0"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 14541, "entry_point": "predictPartyVictory", "codes": ["def predictPartyVictory(senate: str) -> str:\n    while len(set(senate)) > 1:\n        senate = ''.join(c for c in senate if senate.count(c) > 1)\n    return 'Radiant' if 'R' in senate else 'Dire'", "def predictPartyVictory(senate):\n    R, D = [], []\n    for i, c in enumerate(senate):\n        if c == 'R':\n            R.append(i)\n        else:\n            D.append(i)\n    while R and D:\n        r, d = R.pop(0), D.pop(0)\n        if r < d:\n            R.append(r + len(senate))\n        else:\n            D.append(d + len(senate))\n    return \"Radiant\" if R else \"Dire\"", "def predictPartyVictory(senate):\n    radiant, dire = [], []\n    n = len(senate)\n    \n    for i, s in enumerate(senate):\n        if s == 'R':\n            radiant.append(i)\n        else:\n            dire.append(i)\n    \n    while radiant and dire:\n        r = radiant.pop(0)\n        d = dire.pop(0)\n        \n        if r < d:\n            radiant.append(r + n)\n        else:\n            dire.append(d + n)\n    \n    return \"Radiant\" if radiant else \"Dire\"", "def predictPartyVictory(senate):\n    radiant, dire = [], []\n    queue = list(senate)\n    \n    while queue:\n        for _ in range(len(queue)):\n            s = queue.pop(0)\n            if s == 'R':\n                if dire:\n                    dire.pop(0)\n                else:\n                    radiant.append('R')\n            else:\n                if radiant:\n                    radiant.pop(0)\n                else:\n                    dire.append('D')\n        queue = radiant + dire\n    \n    return \"Radiant\" if radiant else \"Dire\"", "def predictPartyVictory(senate: str) -> str:\n    while len(set(senate)) > 1:\n        bans = [0, 0]\n        new_senate = []\n        for s in senate:\n            if s == 'R':\n                if bans[1] > 0:\n                    bans[1] -= 1\n                else:\n                    bans[0] += 1\n                    new_senate.append(s)\n            else:\n                if bans[0] > 0:\n                    bans[0] -= 1\n                else:\n                    bans[1] += 1\n                    new_senate.append(s)\n        senate = ''.join(new_senate)\n    return 'Radiant' if senate[0] == 'R' else 'Dire'", "def predictPartyVictory(senate: str) -> str:\n    radiant = [i for i, c in enumerate(senate) if c == 'R']\n    dire = [i for i, c in enumerate(senate) if c == 'D']\n    while radiant and dire:\n        r, d = radiant.pop(0), dire.pop(0)\n        if r < d:\n            radiant.append(r + len(senate))\n        else:\n            dire.append(d + len(senate))\n    return \"Radiant\" if radiant else \"Dire\""], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 14792, "entry_point": "minOperations", "codes": ["def minOperations(nums):\n    d = 0\n    while max(nums) > 1:\n        d += sum(1 for x in nums if x & 1)\n        nums = [x // 2 for x in nums]\n        d += 1\n    return d + sum(nums)", "def minOperations(nums):\n    def steps(x):\n        ops = 0\n        while x > 0:\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x -= 1\n                ops += 1\n        return ops\n\n    return sum(map(steps, nums)) + max(nums).bit_length() - 1", "def minOperations(nums):\n    max_double = 0\n    total_increments = 0\n    for num in nums:\n        double_count = 0\n        while num > 0:\n            if num % 2 == 0:\n                num //= 2\n                double_count += 1\n            else:\n                num -= 1\n                total_increments += 1\n        max_double = max(max_double, double_count)\n    return total_increments + max_double", "def minOperations(nums):\n    total = 0\n    max_double = 0\n    for num in nums:\n        ops = 0\n        while num > 0:\n            if num % 2 == 0:\n                num //= 2\n                ops += 1\n            else:\n                num -= 1\n                ops += 1\n        total += ops\n        max_double = max(max_double, ops)\n    return total + max_double - 1", "def minOperations(nums):\n    from math import log2\n    return sum(max(int(log2(num)), num.bit_length() - 1) for num in nums) + sum(nums)", "def minOperations(nums):\n    from math import ceil, log2\n    return sum(max(ceil(log2(n)), n.bit_count() - 1) for n in nums)", "def minOperations(nums):\n    from math import ceil, log2\n    return sum(nums) + sum(ceil(log2(n)) for n in nums if n > 1)", "def minOperations(nums):\n    operations = 0\n    max_double = 0\n    for num in nums:\n        double = 0\n        while num > 0:\n            if num % 2 == 1:\n                num -= 1\n                operations += 1\n            else:\n                num //= 2\n                double += 1\n        operations += double\n        max_double = max(max_double, double)\n    operations += max_double - 1\n    return operations"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 14846, "entry_point": "countLargestGroup", "codes": ["def countLargestGroup(n):\n    from collections import Counter\n    count = Counter(sum(map(int, str(i))) for i in range(1, n + 1))\n    max_size = max(count.values())\n    return sum(1 for size in count.values() if size == max_size)", "def countLargestGroup(n):\n    from collections import Counter\n    groups = Counter(sum(int(digit) for digit in str(i)) for i in range(1, n + 1))\n    max_size = max(groups.values())\n    return sum(1 for size in groups.values() if size == max_size)", "def countLargestGroup(n):\n    count = [0] * 37\n    for i in range(1, n + 1):\n        count[sum(int(digit) for digit in str(i))] += 1\n    max_size = max(count)\n    return count.count(max_size)", "def countLargestGroup(n):\n    from collections import Counter\n    from itertools import groupby\n    from operator import itemgetter\n    \n    # Calculate the sum of digits for each number from 1 to n\n    sums_of_digits = [sum(map(int, str(i))) for i in range(1, n + 1)]\n    \n    # Group numbers by the sum of their digits\n    grouped = groupby(sorted(sums_of_digits), itemgetter(0))\n    \n    # Count the size of each group\n    group_sizes = Counter(len(list(group)) for _, group in grouped)\n    \n    # Find the maximum group size\n    max_size = max(group_sizes.values())\n    \n    # Count how many groups have the maximum size\n    return sum(1 for size in group_sizes.values() if size == max_size)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 155, "entry_point": "modifyString", "codes": ["def modifyString(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == '?':\n            for ch in 'abc':\n                if (i == 0 or s[i-1] != ch) and (i == len(s) - 1 or s[i+1] != ch):\n                    s[i] = ch\n                    break\n    return ''.join(s)", "def modifyString(s):\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == '?':\n            options = set('abc')\n            if i > 0:\n                options.discard(s[i - 1])\n            if i < len(s) - 1:\n                options.discard(s[i + 1])\n            s[i] = next(iter(options))\n    return ''.join(s)", "def modifyString(s):\n    chars = list(s)\n    for i in range(len(chars)):\n        if chars[i] == '?':\n            options = 'abc'\n            if i > 0:\n                options = options.replace(chars[i-1], '')\n            if i < len(chars) - 1:\n                options = options.replace(chars[i+1], '')\n            chars[i] = options[0]\n    return ''.join(chars)", "def modifyString(s: str) -> str:\n    chars = list(s)\n    used_chars = set()\n    \n    for i in range(len(chars)):\n        if chars[i] == '?':\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if not (i > 0 and chars[i-1] == c) and (i < len(chars) - 1 and chars[i+1] == c):\n                    used_chars.add(c)\n                    chars[i] = c\n                    used_chars.remove(c)\n                    break\n    \n    return ''.join(chars)", "def modifyString(s):\n    chars = list(s)\n    for i in range(len(chars)):\n        if chars[i] == '?':\n            options = 'abc'\n            if i > 0:\n                options = options.replace(chars[i - 1], '')\n            if i < len(chars) - 1:\n                options = options.replace(chars[i + 1], '')\n            chars[i] = options[0]\n    return ''.join(chars)\n\n# Unit tests to satisfy:\ndef _equivalent(lhs, rhs):\n    return lhs == rhs\n\nassert _equivalent(modifyString(\"?zs\"), \"azs\")\nassert _equivalent(modifyString(\"ubv?w\"), \"ubvaw\")\nassert _equivalent(modifyString(\"j?qg??b\"), \"jaqgacb\")\nassert _equivalent(modifyString(\"??yw?ipkj?\"), \"acywaipkja\")"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 15011, "entry_point": "balancedStringSplit", "codes": ["def balancedStringSplit(s):\n    balance = count = 0\n    for char in s:\n        balance += 1 if char == 'R' else -1\n        if balance == 0:\n            count += 1\n    return count", "def balancedStringSplit(s):\n    count = balance = 0\n    for char in s:\n        balance += 1 if char == 'R' else -1\n        if balance == 0:\n            count += 1\n    return count", "def balancedStringSplit(s: str) -> int:\n    balance = count = 0\n    for char in s:\n        balance += 1 if char == 'R' else -1\n        if balance == 0:\n            count += 1\n    return count", "def balancedStringSplit(s):\n    balance = 0\n    count = 0\n    for char in s:\n        if char == 'L':\n            balance += 1\n        else:\n            balance -= 1\n        if balance == 0:\n            count += 1\n    return count", "def balancedStringSplit(s):\n    balance, count = 0, 0\n    for char in s:\n        if char == 'L':\n            balance += 1\n        else:\n            balance -= 1\n        if balance == 0:\n            count += 1\n    return count", "def balancedStringSplit(s: str) -> int:\n    balance = 0\n    count = 0\n    for char in s:\n        if char == 'L':\n            balance += 1\n        else:\n            balance -= 1\n        if balance == 0:\n            count += 1\n    return count", "def balancedStringSplit(s: str) -> int:\n    balance = 0\n    result = 0\n    for char in s:\n        if char == 'L':\n            balance += 1\n        else:\n            balance -= 1\n        if balance == 0:\n            result += 1\n    return result", "def balancedStringSplit(s: str) -> int:\n    count = 0\n    balance = 0\n    for char in s:\n        if char == 'L':\n            balance -= 1\n        else:\n            balance += 1\n        if balance == 0:\n            count += 1\n    return count"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 15118, "entry_point": "match_arrays", "codes": ["def match_arrays(arr1, arr2): return [sum(x in arr2 for x in arr1)]", "def match_arrays(arr1, arr2):\n    return [len(set(arr1) & set(arr2))]", "def match_arrays(arr1, arr2):\n    return sum(1 for x in arr1 if x in arr2)", "def match_arrays(arr1, arr2):\n    count = 0\n    i = 0\n    while i < len(arr1):\n        if arr1[i] in arr2:\n            count += 1\n        i += 1\n    return count", "def match_arrays(arr1, arr2):\n    return len(set(arr1) & set(arr2))"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 15268, "entry_point": "maxDiff", "codes": ["def maxDiff(num):\n    s = str(num)\n    max_val = int(s.replace(s[0], '9') if s[0] != '9' else s)\n    min_val = int('1' + s[1:].replace(s[1], '0') if s[0] == '1' else s.replace(s[0], '1'))\n    return max_val - min_val", "def maxDiff(num):\n    digits = list(str(num))\n    max_val = int(''.join('9' if d != digits[0] else '9' for d in digits))\n    min_val = int(''.join('1' if d != digits[0] else '1' for d in digits) if digits[0] != '1' else \n                   ''.join('0' if d != digits[1] else '0' for d in digits[1:]))\n    return max_val - min_val", "def maxDiff(num):\n    num_str = str(num)\n    max_val = int(num_str.replace(num_str[0], '9'))\n    if num_str[0] == '1':\n        min_val = int(num_str.replace(num_str[1], '0'))\n    else:\n        min_val = int(num_str.replace(num_str[0], '1'))\n    return max_val - min_val", "def maxDiff(num):\n    num_str = str(num)\n    max_val = int(''.join('9' if d == num_str[0] else '9' if d == max_d else d for d in num_str))\n    min_val = int(''.join('1' if i == 0 and d != '1' else '0' if d == max_d else d for i, d in enumerate(num_str)))\n    return max_val - min_val", "def maxDiff(num):\n    digits = list(str(num))\n    max_num = digits[:]\n    min_num = digits[:]\n    \n    for i, digit in enumerate(digits):\n        if digit != '9':\n            max_num = [str(9) if x == digit else x for x in digits]\n            break\n    \n    for i, digit in enumerate(digits):\n        if digit == '1' and i != 0:\n            min_num = [str(0) if x == digit else x for x in digits]\n            break\n        if digit != '0' and digit != digits[0]:\n            min_num = [str(1) if x == digit else x for x in digits]\n            break\n    \n    return int(''.join(max_num)) - int(''.join(min_num))", "def maxDiff(num):\n    num_str = str(num)\n    max_val = int(num_str.replace(num_str[0], '9'))\n    min_val = int(num_str.replace(num_str[0], '1')) if num_str[0] != '1' else int(num_str.replace(num_str[1], '0'))\n    for char in set(num_str):\n        min_val = min(min_val, int(num_str.replace(char, '0')) if char != '0' else int(num_str.replace(char, '1')))\n    return max_val - min_val", "def maxDiff(num: int) -> int:\n    s = str(num)\n    max_val = int(''.join(str(9 if d != s[0] else 1) if d != '1' and d != '0' else d for d in s))\n    min_val = int(''.join(str(1 if d == s[0] else 0) if d == s[0] and s[0] != '1' else str(1 if d != '0' and d != '1' else 0) if d != '0' and d != '1' else d for d in s))\n    return max_val - min_val"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 15315, "entry_point": "missingNumber", "codes": ["def missingNumber(nums):\n    return len(nums) * (len(nums) + 1) // 2 - sum(nums)", "def missingNumber(nums):\n    return list(set(range(len(nums) + 1)) - set(nums))[0]", "def missingNumber(nums):\n    n = len(nums)\n    return n * (n + 1) // 2 - sum(nums)", "def missingNumber(nums):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == mid:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 15438, "entry_point": "subsets", "codes": ["def subsets(nums):\n    dp = [[]]\n    for num in nums:\n        dp += [s + [num] for s in dp]\n    return dp", "def subsets(nums):\n    result = [[]]\n    for num in nums:\n        result += [subset + [num] for subset in result]\n    return result", "def subsets(nums):\n    result = [[]]\n    for num in nums:\n        result += [s + [num] for s in result]\n    return result", "def subsets(nums):\n    return [[]] + [[num] + s for num in nums for s in subsets(nums[1:])]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 15494, "entry_point": "minTaps", "codes": ["def minTaps(n: int, ranges: list[int]) -> int:\n    intervals = sorted((max(0, i - r), min(n, i + r)) for i, r in enumerate(ranges))\n    cover, end, taps = 0, 0, 0\n    i = 0\n    while cover < n:\n        while i < len(intervals) and intervals[i][0] <= cover:\n            end = max(end, intervals[i][1])\n            i += 1\n        if end == cover:\n            return -1\n        cover = end\n        taps += 1\n    return taps", "def minTaps(n, ranges):\n    intervals = []\n    for i, r in enumerate(ranges):\n        intervals.append((max(0, i - r), min(n, i + r)))\n    intervals.sort()\n\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for start, end in intervals:\n        if dp[start] == float('inf'):\n            continue\n        for j in range(start + 1, end + 1):\n            dp[j] = min(dp[j], dp[start] + 1)\n\n    return dp[n] if dp[n] != float('inf') else -1", "def minTaps(n, ranges):\n    intervals = sorted([(i - r, i + r) for i, r in enumerate(ranges) if r > 0])\n    end, farthest, taps = 0, 0, 0\n    i = 0\n    while i < len(intervals):\n        while i < len(intervals) and intervals[i][0] <= end:\n            farthest = max(farthest, intervals[i][1])\n            i += 1\n        if end == farthest:\n            return -1\n        taps += 1\n        end = farthest\n        if end >= n:\n            return taps\n    return -1", "def minTaps(n, ranges):\n    intervals = []\n    for i, r in enumerate(ranges):\n        if r > 0:\n            intervals.append((max(0, i - r), min(n, i + r)))\n    intervals.sort()\n\n    max_reach = 0\n    end = 0\n    taps = 0\n\n    for start, stop in intervals:\n        if start > end:\n            return -1\n        max_reach = max(max_reach, stop)\n        if end == start:\n            continue\n        end = max_reach\n        taps += 1\n        if end == n:\n            return taps\n\n    return -1", "def minTaps(n, ranges):\n    intervals = []\n    for i, r in enumerate(ranges):\n        if r > 0:\n            intervals.append([max(0, i - r), min(n, i + r)])\n    intervals.sort()\n    dp = [-1] * (n + 1)\n    dp[0] = 0\n    for i in range(n + 1):\n        if dp[i] == -1:\n            continue\n        left, right = i, min(n, i + 1)\n        while right <= n and (j := bisect_left(intervals, [left, float('inf')])) < len(intervals):\n            if intervals[j][0] <= right:\n                right = max(right, intervals[j][1])\n                if right == n:\n                    return dp[i] + 1\n            else:\n                break\n        if left < right:\n            dp[right] = dp[i] + 1\n    return dp[n]", "def minTaps(n, ranges):\n    intervals = sorted([[i - r, i + r] for i, r in enumerate(ranges)])\n    end, farthest, count = 0, 0, 0\n    i = 0\n    while i < len(intervals) and end < n:\n        farthest = max(farthest, intervals[i][1])\n        if i == end:\n            end = farthest\n            count += 1\n            if i == end and end < n:\n                return -1\n        i += 1\n    return count if end >= n else -1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 15531, "entry_point": "originalDigits", "codes": ["from collections import Counter\n\ndef originalDigits(s: str) -> str:\n    count = Counter(s)\n    result = [0] * 10\n    \n    # Unique characters\n    result[0] = count['z']\n    result[2] = count['w']\n    result[4] = count['u']\n    result[6] = count['x']\n    result[8] = count['g']\n    \n    # Characters that appear in only one digit\n    result[1] = count['o'] - result[0] - result[2] - result[4]\n    result[3] = count['h'] - result[8]\n    result[5] = count['f'] - result[4]\n    result[7] = count['s'] - result[6]\n    result[9] = count['i'] - result[5] - result[6] - result[8]\n    \n    return ''.join(str(i) * freq for i, freq in enumerate(result))", "def originalDigits(s: str) -> str:\n    from collections import Counter\n    \n    count = Counter(s)\n    result = [0] * 10\n    \n    # Unique characters for each digit\n    result[0] = count['z']\n    result[2] = count['w']\n    result[4] = count['u']\n    result[6] = count['x']\n    result[8] = count['g']\n    \n    # Characters that appear uniquely or after others\n    result[3] = count['h'] - result[8]\n    result[5] = count['f'] - result[4]\n    result[7] = count['s'] - result[6]\n    result[9] = count['i'] - result[5] - result[6] - result[8]\n    \n    result[1] = count['o'] - result[0] - result[2] - result[4]\n    \n    return ''.join(str(i) * freq for i, freq in enumerate(result))", "def originalDigits(s):\n    from collections import Counter\n    count = Counter(s)\n    result = [0] * 10\n    \n    # Unique characters that can be directly identified\n    result[0] = count['z']\n    result[2] = count['w']\n    result[4] = count['u']\n    result[6] = count['x']\n    result[8] = count['g']\n    \n    # Characters that can be identified after others\n    result[3] = count['h'] - result[8]\n    result[5] = count['f'] - result[4]\n    result[7] = count['s'] - result[6]\n    result[9] = count['i'] - result[5] - result[6] - result[8]\n    \n    # Characters that can be identified after others\n    result[1] = count['o'] - result[0] - result[2] - result[4]\n    \n    return ''.join(str(i) * freq for i, freq in enumerate(result))", "def originalDigits(s: str) -> str:\n    count = [0] * 10\n    char_count = [0] * 26\n    \n    for char in s:\n        char_count[ord(char) - ord('a')] += 1\n    \n    count[0] = char_count[2]  # zero\n    count[2] = char_count[4]  # two\n    count[4] = char_count[6]  # four\n    count[6] = char_count[8]  # six\n    count[8] = char_count[3] - count[2] - count[4] - count[6]  # eight\n    count[5] = char_count[5] - count[4]  # five\n    count[7] = char_count[7] - count[6]  # seven\n    count[3] = char_count[3] - count[2] - count[4] - count[6] - count[8]  # three\n    count[9] = char_count[9] - count[5] - count[6] - count[8]  # nine\n    count[1] = char_count[1] - count[3] - count[7]  # one\n    \n    return ''.join(str(digit) * freq for digit, freq in enumerate(count))", "def originalDigits(s):\n    count = [0] * 10\n    count['z'] = s.count('z')\n    count['o'] = s.count('o') - count['z'] - count['w'] - count['u']\n    count['w'] = s.count('w')\n    count['h'] = s.count('h') - count['g']\n    count['u'] = s.count('u')\n    count['f'] = s.count('f') - count['u']\n    count['x'] = s.count('x')\n    count['s'] = s.count('s') - count['x']\n    count['g'] = s.count('g')\n    count['i'] = s.count('i') - count['x'] - count['g'] - count['z']\n    count['t'] = s.count('t') - count['w'] - count['g']\n\n    result = [str(digit) * freq for digit, freq in enumerate(count)]\n    return ''.join(result)", "def originalDigits(s: str) -> str:\n    counts = [0] * 10\n    mapping = {\n        \"z\": 0,\n        \"o\": 2,\n        \"w\": 2,\n        \"u\": 4,\n        \"x\": 6,\n        \"g\": 8,\n        \"s\": 7,\n        \"v\": 5,\n        \"i\": 9,\n    }\n    \n    for char, digit in mapping.items():\n        counts[digit] += s.count(char)\n    \n    counts[3] = s.count('h') - counts[8]\n    counts[5] -= counts[7]\n    counts[7] -= counts[6]\n    counts[9] -= counts[5]\n    \n    result = ''.join(str(digit) * count for digit, count in enumerate(counts))\n    return result", "def originalDigits(s):\n    from collections import Counter\n    count = Counter(s)\n    result = [0] * 10\n    \n    # Unique characters that identify each digit\n    unique_chars = {\n        0: 'z', 2: 'w', 4: 'u', 6: 'x', 8: 'g',\n        3: 'h', 5: 'f', 7: 's', 9: 'i'\n    }\n    \n    # Count the digits based on unique characters\n    for digit, char in unique_chars.items():\n        result[digit] = count[char]\n        for c in str(digit):\n            count[c] -= result[digit]\n    \n    # Remaining characters that can identify other digits\n    for digit in [1, 3, 5, 7, 9]:\n        result[digit] = count[str(digit)]\n    \n    # Convert result to string\n    return ''.join(str(digit) * count for digit, count in enumerate(result))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 15660, "entry_point": "leastBricks", "codes": ["def leastBricks(wall):\n    edge_counts = {}\n    for row in wall:\n        position = 0\n        for width in row[:-1]:\n            position += width\n            edge_counts[position] = edge_counts.get(position, 0) + 1\n    return len(wall) - max(edge_counts.values() or [0])", "def leastBricks(wall):\n    edge_counts = {}\n    for row in wall:\n        edge = 0\n        for brick in row[:-1]:\n            edge += brick\n            edge_counts[edge] = edge_counts.get(edge, 0) + 1\n    return len(wall) - (max(edge_counts.values()) if edge_counts else 0)", "def leastBricks(wall):\n    from collections import Counter\n    edges = Counter()\n    for row in wall:\n        total = 0\n        for width in row[:-1]:\n            total += width\n            edges[total] += 1\n    return len(wall) - (max(edges.values()) if edges else 0)", "from collections import Counter\n\ndef leastBricks(wall):\n    edge_counts = Counter(sum(row[:-1]) for row in wall)\n    return len(wall) - (edge_counts.most_common(1)[0][1] if edge_counts else 0)", "def leastBricks(wall):\n    from collections import Counter\n    edge_counts = Counter(sum(wall[i][:-1]) for i in range(len(wall)))\n    return len(wall) - (max(edge_counts.values()) if edge_counts else 0)", "from collections import Counter\n\ndef leastBricks(wall):\n    edge_counts = Counter(sum(wall[i][:-1]) for i in range(len(wall)) if len(wall[i]) > 1)\n    return len(wall) - (max(edge_counts.values()) if edge_counts else 0)", "def leastBricks(wall):\n    from collections import Counter\n    edge_counts = Counter(sum(row[:-1]) for row in wall)\n    return len(wall) - (edge_counts.most_common(1)[0][1] if edge_counts else 0)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 15680, "entry_point": "numMagicSquaresInside", "codes": ["def numMagicSquaresInside(grid):\n    rows, cols = len(grid), len(grid[0])\n    count = 0\n    \n    def is_magic(square):\n        target_sum = sum(square[0])\n        for row in square:\n            if sum(row) != target_sum:\n                return False\n        for col in range(3):\n            if sum(square[row][col] for row in range(3)) != target_sum:\n                return False\n        if sum(square[i][i] for i in range(3)) != target_sum:\n            return False\n        if sum(square[i][2-i] for i in range(3)) != target_sum:\n            return False\n        return True\n    \n    for r in range(rows - 2):\n        for c in range(cols - 2):\n            subgrid = [grid[r+i][c:c+3] for i in range(3)]\n            if sorted(sum(subgrid, [])) == list(range(1, 10)) and is_magic(subgrid):\n                count += 1\n    \n    return count", "def numMagicSquaresInside(grid):\n    count = 0\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    for i in range(rows - 2):\n        for j in range(cols - 2):\n            subgrid = [\n                grid[i][j:j+3], grid[i+1][j:j+3], grid[i+2][j:j+3]\n            ]\n            if is_magic_square(subgrid):\n                count += 1\n    \n    return count\n\ndef is_magic_square(subgrid):\n    flattened = [num for row in subgrid for num in row]\n    if sorted(flattened) != list(range(1, 10)):\n        return False\n    \n    target_sum = sum(subgrid[0])\n    for row in subgrid[1:]:\n        if sum(row) != target_sum:\n            return False\n    \n    for j in range(3):\n        if sum(subgrid[i][j] for i in range(3)) != target_sum:\n            return False\n    \n    if sum(subgrid[i][i] for i in range(3)) != target_sum:\n        return False\n    \n    if sum(subgrid[i][2-i] for i in range(3)) != target_sum:\n        return False\n    \n    return True", "def numMagicSquaresInside(grid):\n    def is_magic(square):\n        target = sum(square[0][:3])\n        for row in square:\n            if sum(row) != target:\n                return False\n        for col in range(3):\n            if sum(square[row][col] for row in range(3)) != target:\n                return False\n        if sum(square[i][i] for i in range(3)) != target:\n            return False\n        if sum(square[i][2-i] for i in range(3)) != target:\n            return False\n        return True\n\n    count = 0\n    for r in range(1, len(grid) - 1):\n        for c in range(1, len(grid[0]) - 1):\n            if grid[r][c] == 5:\n                subgrid = [grid[r-1][c-1:c+2], grid[r][c-1:c+2], grid[r+1][c-1:c+2]]\n                if set(map(sum, subgrid)) == {15} and is_magic(subgrid):\n                    count += 1\n    return count", "def numMagicSquaresInside(grid):\n    def is_magic_square(subgrid):\n        if subgrid[1][1] != 5:\n            return False\n        nums = set(subgrid[i][j] for i in range(3) for j in range(3))\n        if len(nums) != 9 or 1 not in nums or 9 not in nums:\n            return False\n        return (sum(subgrid[i][j] for i in range(3)) == 15 for j in range(3)) and \\\n               (sum(subgrid[i][j] for i in range(3)) == 15 for i in range(3)) and \\\n               (subgrid[0][0] + subgrid[1][1] + subgrid[2][2] == 15) and \\\n               (subgrid[0][2] + subgrid[1][1] + subgrid[2][0] == 15)\n    \n    count = 0\n    rows, cols = len(grid), len(grid[0])\n    for i in range(rows - 2):\n        for j in range(cols - 2):\n            subgrid = [grid[i+x][j:y+3] for x, y in ((0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2))]\n            if is_magic_square(subgrid):\n                count += 1\n    return count", "def numMagicSquaresInside(grid):\n    rows, cols = len(grid), len(grid[0])\n    count = 0\n\n    def is_magic(subgrid):\n        magic_sum = sum(subgrid[0])\n        for row in subgrid:\n            if sum(row) != magic_sum:\n                return False\n        for col in range(3):\n            if sum(subgrid[row][col] for row in range(3)) != magic_sum:\n                return False\n        if sum(subgrid[i][i] for i in range(3)) != magic_sum:\n            return False\n        if sum(subgrid[i][2-i] for i in range(3)) != magic_sum:\n            return False\n        if 1 not in subgrid[0] or 2 not in subgrid[0] or 7 not in subgrid[0] or 6 not in subgrid[0] or 3 not in subgrid[0] or 8 not in subgrid[0] or 4 not in subgrid[0] or 5 not in subgrid[0]:\n            return False\n        return True\n\n    for i in range(rows - 2):\n        for j in range(cols - 2):\n            subgrid = [grid[i+k][j:j+3] for k in range(3)]\n            if is_magic(subgrid):\n                count += 1\n\n    return count", "def numMagicSquaresInside(grid):\n    def is_magic(square):\n        if square[1] != 5:\n            return False\n        sums = {sum(square[i:i+3]) for i in (0, 3, 6)}\n        if len(sums) != 1:\n            return False\n        for i in range(3):\n            if sum(square[i::3]) != sums.pop():\n                return False\n        return True\n\n    count = 0\n    for i in range(len(grid) - 2):\n        for j in range(len(grid[0]) - 2):\n            square = [grid[i+k][j+l] for k in range(3) for l in range(3)]\n            if is_magic(square):\n                count += 1\n    return count", "def numMagicSquaresInside(grid):\n    def is_magic(s):\n        if s[4] != 5 or 1 not in s or 9 not in s: return False\n        for i in range(3):\n            if sum(s[i*3:i*3+3]) != 15 or sum(s[j] for j in range(i, i+9, 3)) != 15: return False\n        return sum(s[::4]) == 15 and sum(s[2:8:2]) == 15\n    \n    count = 0\n    for i in range(len(grid) - 2):\n        for j in range(len(grid[0]) - 2):\n            s = set(grid[i+k][j:j+3] for k in range(3))\n            s = {num for row in s for num in row}\n            if len(s) == 9 and is_magic(s):\n                count += 1\n    return count"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 15682, "entry_point": "numWays", "codes": ["def numWays(s: str) -> int:\n    mod = 10**9 + 7\n    ones = s.count('1')\n    if ones % 3 != 0:\n        return 0\n    target = ones // 3\n    if target == 0:\n        return (len(s) - 1) * (len(s) - 2) // 2 % mod\n    i = j = k = -1\n    count = 0\n    for pos, char in enumerate(s):\n        if char == '1':\n            count += 1\n            if count == target and i == -1:\n                i = pos\n            elif count == 2 * target and j == -1:\n                j = pos\n            elif count == 3 * target:\n                k = pos\n                break\n    return (j - i) * (k - j) % mod", "def numWays(s):\n    count = s.count('1')\n    if count % 3 != 0:\n        return 0\n    if count == 0:\n        return (len(s) - 2) * (len(s) - 3) // 2 % (10**9 + 7)\n    ones_per_part = count // 3\n    first_part_end = s.index('1' * ones_per_part)\n    second_part_end = s.index('1' * ones_per_part, first_part_end + 1)\n    return (second_part_end - first_part_end) % (10**9 + 7)", "def numWays(s):\n    ones = s.count('1')\n    if ones % 3 != 0:\n        return 0\n    \n    if ones == 0:\n        n = len(s) - 1\n        return (n * (n + 1) // 2) % (10**9 + 7)\n    \n    k = ones // 3\n    first = s.index('1') + 1\n    second = s.rindex('1') - 1\n    \n    count1 = 0\n    count2 = 0\n    \n    for i in range(first, second + 1):\n        if s[i] == '1':\n            count1 += 1\n    \n    for i in range(second, len(s) - 1):\n        if s[i] == '1':\n            count2 += 1\n    \n    return (count1 * count2) % (10**9 + 7)", "def numWays(s: str) -> int:\n    MOD = 10**9 + 7\n    ones = s.count('1')\n    if ones % 3 != 0:\n        return 0\n    if ones == 0:\n        return (len(s) - 2) * (len(s) - 3) // 2 % MOD\n    n = ones // 3\n    first = s.index('1') + s[s.index('1') + 1:].index('1') + 2\n    second = s.rindex('1') - s[:s.rindex('1') - 1].rindex('1') - 2\n    return first * second % MOD", "def numWays(s: str) -> int:\n    ones = s.count('1')\n    if ones % 3 != 0:\n        return 0\n    if ones == 0:\n        return (len(s) - 1) * (len(s) - 2) // 2 % 1_000_000_007\n    \n    part_ones = ones // 3\n    first_break = s.index('1' * part_ones) + part_ones\n    second_break = s.index('1' * part_ones, first_break) + part_ones\n    \n    return (second_break - first_break) * (len(s) - second_break) % 1_000_000_007", "def numWays(s):\n    MOD = 10**9 + 7\n    ones = s.count('1')\n    if ones % 3 != 0:\n        return 0\n    if ones == 0:\n        return (len(s) - 1) * (len(s) - 2) // 2 % MOD\n    target = ones // 3\n    first_cut = second_cut = -1\n    count = 0\n    for i, char in enumerate(s):\n        if char == '1':\n            count += 1\n            if count == target and first_cut == -1:\n                first_cut = i\n            elif count == 2 * target and second_cut == -1:\n                second_cut = i\n    return (second_cut - first_cut) * (len(s) - second_cut - 1) % MOD"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 15727, "entry_point": "firstMissingPositive", "codes": ["def firstMissingPositive(nums):\n    nums = set(nums)\n    i = 1\n    while True:\n        if i not in nums:\n            return i\n        i += 1", "def firstMissingPositive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1", "def firstMissingPositive(nums):\n    n = len(nums)\n    if 1 not in nums:\n        return 1\n    for i in range(n):\n        if nums[i] <= 0 or nums[i] > n:\n            nums[i] = 1\n    for i in range(n):\n        index = abs(nums[i]) - 1\n        nums[index] = -abs(nums[index])\n    for i in range(n):\n        if nums[i] > 0:\n            return i + 1\n    return n + 1", "def firstMissingPositive(nums):\n    n = len(nums)\n    if 1 not in nums:\n        return 1\n    \n    contains_one = 1 in nums\n    if not contains_one:\n        return 1\n    \n    nums = [0] + nums\n    n += 1\n    \n    for i in range(n):\n        if nums[i] <= 0 or nums[i] >= n:\n            nums[i] = n\n    \n    for i in range(1, n):\n        if abs(nums[i]) == n:\n            continue\n        index = abs(nums[i])\n        nums[index - 1] = -abs(nums[index - 1])\n    \n    for i in range(1, n):\n        if nums[i] > 0:\n            return i\n    \n    return n"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 15756, "entry_point": "findMinFibonacciNumbers", "codes": ["def findMinFibonacciNumbers(k):\n    fibs = [1, 1]\n    while fibs[-1] < k:\n        fibs.append(fibs[-1] + fibs[-2])\n    \n    dp = [0] * (k + 1)\n    for i in range(1, k + 1):\n        dp[i] = min(dp[i - f] + 1 for f in fibs if f <= i)\n    \n    return dp[k]", "def findMinFibonacciNumbers(k):\n    fibs = [1, 1]\n    while fibs[-1] < k:\n        fibs.append(fibs[-1] + fibs[-2])\n    \n    count = 0\n    for f in reversed(fibs):\n        while k >= f:\n            k -= f\n            count += 1\n    return count", "def findMinFibonacciNumbers(k):\n    fibs = [1, 1]\n    while fibs[-1] < k:\n        fibs.append(fibs[-1] + fibs[-2])\n    count = 0\n    while k > 0:\n        count += k // fibs[-1]\n        k %= fibs[-1]\n        fibs.pop()\n    return count", "def findMinFibonacciNumbers(k):\n    def generate_fibonacci(max_val):\n        fibs = [1, 1]\n        while fibs[-1] + fibs[-2] <= max_val:\n            fibs.append(fibs[-1] + fibs[-2])\n        return fibs\n    \n    fibs = generate_fibonacci(k)\n    count = 0\n    \n    while k > 0:\n        idx = bisect.bisect_right(fibs, k) - 1\n        k -= fibs[idx]\n        count += 1\n    \n    return count", "def findMinFibonacciNumbers(k):\n    fibs = [0, 1]\n    while fibs[-1] < k:\n        fibs.append(fibs[-1] + fibs[-2])\n    \n    def helper(k):\n        if k == 0:\n            return 0\n        idx = bisect.bisect_right(fibs, k) - 1\n        return 1 + helper(k - fibs[idx])\n    \n    return helper(k)", "def findMinFibonacciNumbers(k):\n    fibs = [0, 1]\n    while fibs[-1] < k:\n        fibs.append(fibs[-1] + fibs[-2])\n    fibs = fibs[:-1]\n    \n    count = 0\n    for num in reversed(fibs):\n        if num <= k:\n            k -= num\n            count += 1\n    return count", "def findMinFibonacciNumbers(k):\n    fibs = [0, 1, 1]\n    while fibs[-1] < k:\n        fibs.append(fibs[-1] + fibs[-2])\n    \n    @cache\n    def dfs(n):\n        if n == 0:\n            return 0\n        return 1 + dfs(n - max(f for f in fibs if f <= n))\n    \n    return dfs(k)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 15774, "entry_point": "maxScoreSightseeingPair", "codes": ["def maxScoreSightseeingPair(A):\n    max_i = A[0] + 0\n    max_score = 0\n    for j in range(1, len(A)):\n        max_score = max(max_score, max_i + A[j] - j)\n        max_i = max(max_i, A[j] + j)\n    return max_score", "def maxScoreSightseeingPair(A):\n    max_i = A[0] + 0\n    res = 0\n    for j in range(1, len(A)):\n        res = max(res, max_i + A[j] - j)\n        max_i = max(max_i, A[j] + j)\n    return res", "def maxScoreSightseeingPair(A):\n    res = 0\n    max_i_plus_A_i = A[0] + 0\n    for j in range(1, len(A)):\n        res = max(res, max_i_plus_A_i + A[j] - j)\n        max_i_plus_A_i = max(max_i_plus_A_i, A[j] + j)\n    return res", "def maxScoreSightseeingPair(A):\n    return reduce(lambda x, y: (x[0] + A[y[1]], y[1]), enumerate(A[1:]), (A[0] + 0, 0))[0]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 15889, "entry_point": "sortString", "codes": ["def sortString(s: str) -> str:\n    from collections import Counter\n    count = Counter(s)\n    result = []\n    while count:\n        for char in sorted(count):\n            result.append(char)\n            count[char] -= 1\n            if count[char] == 0:\n                del count[char]\n        for char in sorted(count, reverse=True):\n            result.append(char)\n            count[char] -= 1\n            if count[char] == 0:\n                del count[char]\n    return ''.join(result)", "def sortString(s: str) -> str:\n    from collections import Counter\n    c = Counter(s)\n    result = []\n    while c:\n        for char in sorted(c):\n            result.append(char)\n            c[char] -= 1\n            if c[char] == 0:\n                del c[char]\n        for char in sorted(c, reverse=True):\n            result.append(char)\n            c[char] -= 1\n            if c[char] == 0:\n                del c[char]\n    return ''.join(result)", "from collections import Counter\n\ndef sortString(s):\n    count = Counter(s)\n    result = []\n    reverse = False\n    \n    while count:\n        if reverse:\n            order = sorted(count.keys(), reverse=True)\n        else:\n            order = sorted(count.keys())\n        \n        for char in order:\n            result.append(char)\n            count[char] -= 1\n            if count[char] == 0:\n                del count[char]\n        \n        reverse = not reverse\n    \n    return ''.join(result)", "def sortString(s: str) -> str:\n    result = []\n    s_count = sorted(s)\n    while s_count:\n        for i in range(len(s_count)):\n            result.append(s_count[i])\n            s_count = s_count[:i] + s_count[i+1:]\n        for i in range(len(s_count) - 1, -1, -1):\n            result.append(s_count[i])\n            s_count = s_count[:i] + s_count[i+1:]\n    return ''.join(result)", "def sortString(s):\n    result = []\n    count = [0] * 26\n    for char in s:\n        count[ord(char) - ord('a')] += 1\n    \n    while sum(count) > 0:\n        for i in range(26):\n            if count[i] > 0:\n                result.append(chr(i + ord('a')))\n                count[i] -= 1\n        for i in range(25, -1, -1):\n            if count[i] > 0:\n                result.append(chr(i + ord('a')))\n                count[i] -= 1\n    \n    return ''.join(result)", "def sortString(s: str) -> str:\n    count = [0] * 26\n    for char in s:\n        count[ord(char) - ord('a')] += 1\n    \n    result = []\n    while len(result) < len(s):\n        for i in range(26):\n            if count[i] > 0:\n                result.append(chr(ord('a') + i))\n                count[i] -= 1\n        for i in range(25, -1, -1):\n            if count[i] > 0:\n                result.append(chr(ord('a') + i))\n                count[i] -= 1\n    \n    return ''.join(result)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 15974, "entry_point": "minRemoveToMakeValid", "codes": ["def minRemoveToMakeValid(s):\n    stack = []\n    remove = set()\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                remove.add(i)\n    remove |= set(stack)\n    return ''.join(char for i, char in enumerate(s) if i not in remove)", "def minRemoveToMakeValid(s: str) -> str:\n    stack = []\n    result = list(s)\n    \n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                result[i] = ''\n    \n    for index in stack:\n        result[index] = ''\n    \n    return ''.join(result)", "def minRemoveToMakeValid(s):\n    stack = []\n    remove = set()\n    for i, c in enumerate(s):\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            if stack:\n                stack.pop()\n            else:\n                remove.add(i)\n    remove.update(stack)\n    return ''.join(c for i, c in enumerate(s) if i not in remove)\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "def minRemoveToMakeValid(s: str) -> str:\n    def validate(s: str) -> str:\n        stack = []\n        result = []\n        for char in s:\n            if char == '(':\n                stack.append(len(result))\n            elif char == ')' and stack:\n                result[stack.pop()] += char\n            elif char != ')':\n                result.append(char)\n        return ''.join(result)\n\n    return validate(s)", "def minRemoveToMakeValid(s: str) -> str:\n    result = []\n    open_count = 0\n    \n    for char in s:\n        if char == '(':\n            open_count += 1\n        elif char == ')':\n            if open_count > 0:\n                open_count -= 1\n                result.append(char)\n        else:\n            result.append(char)\n    \n    final_result = []\n    for char in reversed(result):\n        if char == '(' and open_count > 0:\n            open_count -= 1\n            continue\n        final_result.append(char)\n    \n    return ''.join(reversed(final_result))", "def minRemoveToMakeValid(s):\n    balance = 0\n    result = list(s)\n    open_indices = []\n    \n    for i, char in enumerate(s):\n        if char == '(':\n            open_indices.append(i)\n            balance += 1\n        elif char == ')':\n            if balance > 0:\n                balance -= 1\n            else:\n                result[i] = ''\n    \n    for i in open_indices:\n        if balance > 0:\n            balance -= 1\n        else:\n            result[i] = ''\n    \n    return ''.join(result)", "def minRemoveToMakeValid(s: str) -> str:\n    balance = 0\n    result = []\n    for char in s:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            if balance > 0:\n                balance -= 1\n                result.append(char)\n        else:\n            result.append(char)\n    while balance > 0:\n        balance -= 1\n        result.pop()\n    return ''.join(result)\n\ndef _equivalent(lhs: str, rhs: str) -> bool:\n    return lhs == rhs"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 1641, "entry_point": "numOfSubarrays", "codes": ["def numOfSubarrays(arr):\n    odd_count = 0\n    even_count = 1\n    total = 0\n    for num in arr:\n        if num % 2 == 0:\n            total += odd_count\n        else:\n            total += even_count\n            odd_count, even_count = even_count, odd_count + 1\n    return total % (10**9 + 7)", "def numOfSubarrays(arr):\n    MOD = 10**9 + 7\n    odd_count = prefix_sum = result = 0\n    \n    for num in arr:\n        prefix_sum += num\n        if prefix_sum % 2 == 0:\n            result = (result + odd_count) % MOD\n        else:\n            result = (result + 1 + odd_count) % MOD\n            odd_count += 1\n    \n    return result", "def numOfSubarrays(arr):\n    count, prefix_sum, odd_count, even_count = 0, 0, 0, 1\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum % 2 == 0:\n            count += odd_count\n            even_count += 1\n        else:\n            count += even_count\n            odd_count += 1\n    return count % (10**9 + 7)", "def numOfSubarrays(arr):\n    result, count, odd_count = 0, 0, 0\n    for num in arr:\n        count += num % 2\n        if count % 2 == 0:\n            odd_count += count // 2\n        else:\n            odd_count += (count + 1) // 2\n        result += odd_count\n        result %= 1000000007\n    return result", "def numOfSubarrays(arr):\n    prefix_sums = [0]\n    for num in arr:\n        prefix_sums.append(prefix_sums[-1] + num)\n    \n    odd_count = 0\n    even_count = 0\n    result = 0\n    \n    for prefix_sum in prefix_sums:\n        if prefix_sum % 2 == 0:\n            even_count += 1\n        else:\n            result += even_count\n            odd_count += 1\n    \n    return result % (10**9 + 7)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 16032, "entry_point": "numTriplets", "codes": ["def numTriplets(nums1, nums2):\n    def count_triplets(nums1, nums2):\n        count = 0\n        n = len(nums1)\n        m = len(nums2)\n        for i in range(n):\n            for j in range(m):\n                for k in range(j + 1, m):\n                    if nums1[i] * nums1[i] == nums2[j] * nums2[k]:\n                        count += 1\n        return count\n\n    return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)", "def numTriplets(nums1, nums2):\n    def count_triplets(a, b):\n        count = 0\n        n, m = len(a), len(b)\n        for i in range(n):\n            target = a[i] ** 2\n            for j in range(m):\n                if b[j] > target:\n                    break\n                for k in range(j + 1, m):\n                    if b[k] > target // b[j]:\n                        break\n                    if b[j] * b[k] == target:\n                        count += 1\n        return count\n\n    return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)", "def numTriplets(nums1, nums2):\n    def count_triplets(arr1, arr2):\n        count = 0\n        for i in range(len(arr1)):\n            target = arr1[i] ** 2\n            seen = {}\n            for j in range(len(arr2)):\n                if target % arr2[j] == 0:\n                    quotient = target // arr2[j]\n                    if quotient in seen:\n                        count += seen[quotient]\n                if arr2[j] not in seen:\n                    seen[arr2[j]] = 0\n                seen[arr2[j]] += 1\n        return count\n    \n    return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)", "def numTriplets(nums1, nums2):\n    def count_pairs(nums1, nums2):\n        count = 0\n        num_dict = {}\n        for j in range(len(nums2)):\n            for k in range(j + 1, len(nums2)):\n                product = nums2[j] * nums2[k]\n                if product in num_dict:\n                    count += num_dict[product]\n        return count\n\n    return count_pairs(nums1, nums2) + count_pairs(nums2, nums1)", "def numTriplets(nums1, nums2):\n    def count_triplets(a, b):\n        count = 0\n        n = len(a)\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    if a[i] * a[j] == b[k]:\n                        count += 1\n        return count\n\n    return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)", "def numTriplets(nums1, nums2):\n    def countTriplets(arr1, arr2):\n        count = 0\n        n2 = len(arr2)\n        products = {}\n        for i in range(n2):\n            for j in range(i + 1, n2):\n                product = arr2[i] * arr2[j]\n                if product in products:\n                    count += products[product]\n                if arr2[i] % arr2[j] == 0:\n                    target = arr2[i] ** 2 // arr2[j]\n                    products[target] = products.get(target, 0) + 1\n        return count\n\n    return countTriplets(nums1, nums2) + countTriplets(nums2, nums1)", "def numTriplets(nums1, nums2):\n    def count_triplets(nums1, nums2):\n        count = 0\n        nums2.sort()\n        for num1 in nums1:\n            target = num1 * num1\n            left, right = 0, len(nums2) - 1\n            while left < right:\n                product = nums2[left] * nums2[right]\n                if product == target:\n                    count += right - left\n                    left += 1\n                elif product < target:\n                    left += 1\n                else:\n                    right -= 1\n        return count\n    \n    return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)", "def numTriplets(nums1, nums2):\n    def count_triplets(arr1, arr2):\n        count = 0\n        n1 = len(arr1)\n        n2 = len(arr2)\n        for i in range(n1):\n            target = arr1[i] ** 2\n            product_count = {}\n            for j in range(n2):\n                for k in range(j + 1, n2):\n                    product = arr2[j] * arr2[k]\n                    if product == target:\n                        count += product_count.get((arr2[j], arr2[k]), 0)\n                    product_count[(arr2[j], arr2[k])] = product_count.get((arr2[j], arr2[k]), 0) + 1\n        return count\n    \n    return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 16077, "entry_point": "getPermutation", "codes": ["from math import factorial\n\ndef getPermutation(n, k):\n    numbers = list(range(1, n + 1))\n    k -= 1\n    result = []\n    for i in range(n, 0, -1):\n        idx, k = divmod(k, factorial(i - 1))\n        result.append(numbers.pop(idx))\n    return ''.join(map(str, result))", "def getPermutation(n: int, k: int) -> str:\n    from math import factorial as fact\n\n    def get_kth_perm(numbers, k):\n        if len(numbers) == 1:\n            return numbers[0]\n        group_size = fact(len(numbers) - 1)\n        group_index = (k - 1) // group_size\n        remainder = k - group_index * group_size\n        return numbers[group_index] + get_kth_perm(numbers[:group_index] + numbers[group_index + 1:], remainder)\n\n    return get_kth_perm(list(map(str, range(1, n + 1))), k)", "import math\n\ndef getPermutation(n, k):\n    k -= 1\n    nums = list(range(1, n + 1))\n    result = []\n    for i in range(n, 0, -1):\n        fact = math.factorial(i - 1)\n        index = k // fact\n        k %= fact\n        result.append(str(nums.pop(index)))\n    return ''.join(result)", "import math\n\ndef getPermutation(n, k):\n    def get_permutation(nums, k):\n        if len(nums) == 1:\n            return nums[0]\n        \n        factor = math.factorial(len(nums) - 1)\n        index = (k - 1) // factor\n        \n        return nums[index] + get_permutation(nums[:index] + nums[index + 1:], k - index * factor)\n    \n    return get_permutation(list(range(1, n + 1)), k)", "def getPermutation(n, k):\n    def factorial(num):\n        if num == 0:\n            return 1\n        result = 1\n        for i in range(2, num + 1):\n            result *= i\n        return result\n\n    def get_permutation(n, k, nums):\n        if n == 0:\n            return \"\"\n        index = (k - 1) // factorial(n - 1)\n        result = nums[index]\n        nums.remove(result)\n        return result + get_permutation(n - 1, k - index * factorial(n - 1), nums)\n\n    nums = list(range(1, n + 1))\n    return get_permutation(n, k, nums)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 16086, "entry_point": "maxCandies", "codes": ["def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    collected_keys = set()\n    open_boxes = set(initialBoxes)\n    closed_boxes = set()\n    total_candies = 0\n\n    while open_boxes:\n        new_open_boxes = set()\n        for box in open_boxes:\n            if status[box] == 1 or box in collected_keys:\n                total_candies += candies[box]\n                for key in keys[box]:\n                    collected_keys.add(key)\n                for new_box in containedBoxes[box]:\n                    new_open_boxes.add(new_box)\n        open_boxes = new_open_boxes\n\n    return total_candies", "def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    collected_keys = set()\n    found_boxes = set(initialBoxes)\n    total_candies = 0\n    \n    while True:\n        new_boxes = set()\n        for box in found_boxes:\n            if (status[box] == 1 or box in collected_keys):\n                total_candies += candies[box]\n                for key in keys[box]:\n                    collected_keys.add(key)\n                for new_box in containedBoxes[box]:\n                    new_boxes.add(new_box)\n        if not new_boxes:\n            break\n        found_boxes = new_boxes\n    \n    return total_candies", "def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    collected_boxes = set(initialBoxes)\n    collected_keys = set()\n    total_candies = 0\n    opened_boxes = set()\n\n    while collected_boxes or opened_boxes:\n        new_boxes = set()\n        for box in collected_boxes | opened_boxes:\n            if box in opened_boxes:\n                continue\n            if status[box] == 1 or box in collected_keys:\n                total_candies += candies[box]\n                collected_keys.update(keys[box])\n                new_boxes.update(containedBoxes[box])\n                opened_boxes.add(box)\n        if not new_boxes:\n            break\n        collected_boxes = new_boxes\n\n    return total_candies", "def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    def dfs(boxes, collected_keys, open_boxes):\n        total_candies = 0\n        new_boxes = set()\n        for box in boxes:\n            if box in open_boxes or status[box] == 1:\n                total_candies += candies[box]\n                for key in keys[box]:\n                    collected_keys.add(key)\n                new_boxes.update(containedBoxes[box])\n            else:\n                new_boxes.add(box)\n        if not new_boxes:\n            return total_candies\n        return total_candies + dfs(new_boxes, collected_keys, collected_keys | new_boxes)\n    return dfs(set(initialBoxes), set(), set())", "def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    collected_boxes = set(initialBoxes)\n    collected_keys = set()\n    total_candies = 0\n\n    while collected_boxes:\n        new_boxes = set()\n        for box in collected_boxes:\n            if status[box] == 1 or box in collected_keys:\n                total_candies += candies[box]\n                new_boxes.update(containedBoxes[box])\n                for key in keys[box]:\n                    collected_keys.add(key)\n                collected_boxes.remove(box)\n        if new_boxes == collected_boxes:\n            break\n        collected_boxes.update(new_boxes)\n\n    return total_candies", "def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    collected = 0\n    available_boxes = initialBoxes[:]\n    collected_keys = set()\n    all_boxes = set(range(len(status)))\n\n    while available_boxes:\n        new_boxes = []\n        for box in available_boxes:\n            if status[box] == 1 or box in collected_keys:\n                collected += candies[box]\n                collected_keys.update(keys[box])\n                new_boxes.extend(containedBoxes[box])\n            else:\n                new_boxes.append(box)\n        available_boxes = list(set(new_boxes) & all_boxes)\n\n    return collected", "from collections import deque\n\ndef maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    queue = deque(initialBoxes)\n    visited_boxes = set(initialBoxes)\n    collected_keys = set()\n    total_candies = 0\n    \n    while queue:\n        box = queue.popleft()\n        if status[box] == 1 or box in collected_keys:\n            total_candies += candies[box]\n            for next_box in containedBoxes[box]:\n                if next_box not in visited_boxes:\n                    visited_boxes.add(next_box)\n                    queue.append(next_box)\n            for key in keys[box]:\n                collected_keys.add(key)\n        else:\n            queue.append(box)\n    \n    return total_candies", "def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    dp = [0] * len(status)\n    visited = set()\n    queue = initialBoxes[:]\n    while queue:\n        box = queue.pop()\n        if box in visited:\n            continue\n        visited.add(box)\n        dp[box] = candies[box]\n        for next_box in containedBoxes[box]:\n            queue.append(next_box)\n        for key in keys[box]:\n            status[key] = 1\n    return sum(dp)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 16146, "entry_point": "mincostToHireWorkers", "codes": ["from heapq import heappush, heappop\n\ndef mincostToHireWorkers(quality, wage, K):\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    min_cost = float('inf')\n    heap = []\n    \n    for ratio, q in workers:\n        total_quality += q\n        heappush(heap, -q)\n        if len(heap) > K:\n            total_quality += heappop(heap)\n        if len(heap) == K:\n            min_cost = min(min_cost, total_quality * ratio)\n    \n    return min_cost", "def mincostToHireWorkers(quality, wage, K):\n    from heapq import nlargest, heappush, heappop\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    max_quality_heap = []\n    min_cost = float('inf')\n    \n    for ratio, q in workers:\n        total_quality += q\n        heappush(max_quality_heap, -q)\n        \n        if len(max_quality_heap) > K:\n            total_quality += heappop(max_quality_heap)\n        \n        if len(max_quality_heap) == K:\n            min_cost = min(min_cost, total_quality * ratio)\n    \n    return min_cost", "import heapq\n\ndef mincostToHireWorkers(quality, wage, K):\n    unit_rates = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    min_cost = float('inf')\n    heap = []\n    \n    for rate, q in unit_rates:\n        total_quality += q\n        heapq.heappush(heap, -q)\n        if len(heap) > K:\n            total_quality += heapq.heappop(heap)\n        if len(heap) == K:\n            min_cost = min(min_cost, total_quality * rate)\n    \n    return min_cost if min_cost != float('inf') else -1", "from typing import List\n\ndef mincostToHireWorkers(quality: List[int], wage: List[int], K: int) -> float:\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    heap = []\n    cost = float('inf')\n    \n    for ratio, q in workers:\n        total_quality += q\n        heapq.heappush(heap, -q)\n        if len(heap) > K:\n            total_quality += heapq.heappop(heap)\n        if len(heap) == K:\n            cost = min(cost, total_quality * ratio)\n    \n    return cost", "def mincostToHireWorkers(quality, wage, K):\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    quality_sum = 0\n    heap = []\n    min_cost = float('inf')\n    for ratio, q in workers:\n        quality_sum += q\n        heapq.heappush(heap, -q)\n        if len(heap) > K:\n            quality_sum += heapq.heappop(heap)\n        if len(heap) == K:\n            min_cost = min(min_cost, quality_sum * ratio)\n    return min_cost", "from heapq import nsmallest\n\ndef mincostToHireWorkers(quality, wage, K):\n    workers = sorted((wage / quality, quality) for wage, quality in zip(wage, quality))\n    total_quality = 0\n    max_heap = []\n    result = float('inf')\n    \n    for ratio, q in workers:\n        total_quality += q\n        nsmallest(K - 1, max_heap, key=lambda x: -x[0])\n        if len(max_heap) == K:\n            result = min(result, ratio * total_quality)\n            total_quality -= -heappop(max_heap)[0]\n    \n    return result if result != float('inf') else 0", "def mincostToHireWorkers(quality, wage, K):\n    unit_rates = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    max_heap = []\n    min_cost = float('inf')\n    \n    for rate, q in unit_rates:\n        total_quality += q\n        heapq.heappush(max_heap, -q)\n        if len(max_heap) > K:\n            total_quality += heapq.heappop(max_heap)\n        if len(max_heap) == K:\n            min_cost = min(min_cost, total_quality * rate)\n    \n    return min_cost"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 16283, "entry_point": "longestCommonPrefix", "codes": ["def longestCommonPrefix(strs):\n    if not strs:\n        return \"\"\n    min_len = min(len(s) for s in strs)\n    for i in range(min_len):\n        if not all(s[i] == strs[0][i] for s in strs):\n            return strs[0][:i]\n    return strs[0][:min_len]", "def longestCommonPrefix(strs):\n    if not strs:\n        return \"\"\n    shortest = min(strs, key=len)\n    for i, char in enumerate(shortest):\n        for other in strs:\n            if other[i] != char:\n                return shortest[:i]\n    return shortest", "def longestCommonPrefix(strs):\n    if not strs:\n        return \"\"\n    \n    prefix = strs[0]\n    for i in range(1, len(strs)):\n        while strs[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    return prefix", "def longestCommonPrefix(strs):\n    if not strs:\n        return \"\"\n    return min(strs, key=len) and all(s.startswith(min(strs, key=len)) for s in strs)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 16321, "entry_point": "primePalindrome", "codes": ["def primePalindrome(N):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    while N < 10**8:\n        if is_prime(N) and is_palindrome(N):\n            return N\n        N += 1", "def primePalindrome(N):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    while N <= 10**8:\n        if is_prime(N) and is_palindrome(N):\n            return N\n        N += 1", "def primePalindrome(N):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    while True:\n        if N <= 11 and is_prime(N) and is_palindrome(N):\n            return N\n        N += 1\n        if 10**7 <= N < 10**8:\n            N = 10**8", "def primePalindrome(N):\n    def is_prime(x):\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n\n    if N <= 2:\n        return 2\n    if 2 < N < 10:\n        return 11\n    if N < 100:\n        return 101\n\n    # Check numbers of length 2m and 2m+1\n    for m in range(1, 5):\n        for i in range(10**(m-1), 10**m):\n            s = str(i)\n            num = int(s + s[-2::-1])\n            if num >= N and is_prime(num):\n                return num\n            num = int(s + s[::-1])\n            if num >= N and is_prime(num):\n                return num", "def primePalindrome(N: int) -> int:\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    n = N\n    while True:\n        if n >= 10**8:\n            n = 10**8\n        if n == reverse := int(str(n)[::-1]) and is_prime(n):\n            return n\n        n += 1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 16353, "entry_point": "dayOfTheWeek", "codes": ["def dayOfTheWeek(day, month, year):\n    if month < 3:\n        month += 12\n        year -= 1\n    K = year % 100\n    J = year // 100\n    f = day + 13 * (month + 1) // 5 + K + K // 4 + J // 4 - 2 * J\n    return [\"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"][f % 7]", "def dayOfTheWeek(day: int, month: int, year: int) -> str:\n    days_of_week = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    weekdays = (\"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n    t = (0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4)\n    y, m = year, month\n    if m < 3:\n        m += 12\n        y -= 1\n    h = (y + y // 4 - y // 100 + y // 400 + t[m - 1] + day) % 7\n    return days_of_week[h]", "def dayOfTheWeek(day, month, year):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    base_date = [1, 1, 1971]\n    base_day = 3  # 1971-01-01 was a Wednesday\n\n    def days_between_dates(date1, date2):\n        y1, m1, d1 = date1\n        y2, m2, d2 = date2\n        days_per_year = 365 + (y1 % 4 == 0 and y1 % 100 != 0 or y1 % 400 == 0)\n        days_per_month = [0, 31, 28 + (y1 % 4 == 0 and y1 % 100 != 0 or y1 % 400 == 0), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        return (days_per_year * (y2 - y1) + sum(days_per_month[m] for m in range(1, m2)) + d2 - d1)\n\n    days_diff = days_between_dates(base_date, [year, month, day])\n    return days[(base_day + days_diff) % 7]", "def dayOfTheWeek(day, month, year):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    month_offsets = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n        month_offsets[2] = 29\n    start_day = 5  # 1971-01-01 was a Friday\n    total_days = sum(month_offsets[:month]) + day + start_day - 1\n    return days[total_days % 7]", "def dayOfTheWeek(day, month, year):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    def is_leap(year):\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n    \n    days_passed = 0\n    \n    for y in range(1971, year):\n        days_passed += 366 if is_leap(y) else 365\n    \n    for m in range(1, month):\n        days_passed += month_days[m - 1]\n        if m == 2 and is_leap(year):\n            days_passed += 1\n    \n    days_passed += day - 1\n    \n    return days[days_passed % 7]", "def dayOfTheWeek(day: int, month: int, year: int) -> str:\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    if year < 1971 or year > 2100:\n        raise ValueError(\"Year must be between 1971 and 2100\")\n    if month < 1 or month > 12:\n        raise ValueError(\"Month must be between 1 and 12\")\n    if day < 1 or day > 31:\n        raise ValueError(\"Day must be between 1 and 31\")\n    \n    def is_leap_year(year: int) -> bool:\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n    \n    days_in_month = [31, 28 if is_leap_year(year) else 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if day > days_in_month[month - 1]:\n        raise ValueError(\"Invalid day for the given month and year\")\n    \n    days_count = sum(days_in_month[:month - 1]) + day\n    start_day = 3  # 1971-01-01 was a Thursday\n    return days[(days_count + start_day) % 7]", "import datetime\n\ndef dayOfTheWeek(day: int, month: int, year: int) -> str:\n    return [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"][datetime.date(year, month, day).weekday()]", "def dayOfTheWeek(day, month, year):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    def is_leap_year(year):\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n    \n    def days_since_1971(year, month, day):\n        months = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        if is_leap_year(year):\n            months[2] = 29\n        days_passed = 0\n        for y in range(1971, year):\n            days_passed += 366 if is_leap_year(y) else 365\n        for m in range(1, month):\n            days_passed += months[m]\n        days_passed += day\n        return days_passed\n    \n    return days[days_since_1971(year, month, day) % 7]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 16402, "entry_point": "minSwap", "codes": ["def minSwap(A, B):\n    n = len(A)\n    dp = [1, 0]\n    for i in range(1, n):\n        dp0, dp1 = float('inf'), float('inf')\n        if A[i] > A[i - 1] and B[i] > B[i - 1]:\n            dp0 = dp[0]\n            dp1 = dp[1] + 1\n        if A[i] > B[i - 1] and B[i] > A[i - 1]:\n            dp0 = min(dp0, dp[1])\n            dp1 = min(dp1, dp[0] + 1)\n        dp = [dp0, dp1]\n    return min(dp)", "def minSwap(A, B):\n    n = len(A)\n    swap = [1] * n\n    no_swap = [0] * n\n    no_swap[0] = 0\n    swap[0] = 1\n\n    for i in range(1, n):\n        if A[i] > A[i - 1] and B[i] > B[i - 1]:\n            no_swap[i] = no_swap[i - 1]\n            swap[i] = swap[i - 1] + 1\n        if A[i] > B[i - 1] and B[i] > A[i - 1]:\n            no_swap[i] = min(no_swap[i], swap[i - 1])\n            swap[i] = min(swap[i], no_swap[i - 1] + 1)\n\n    return min(no_swap[-1], swap[-1])", "def minSwap(A, B):\n    n = len(A)\n    swap = [1] * n\n    no_swap = [0] * n\n    \n    for i in range(1, n):\n        if A[i] > A[i - 1] and B[i] > B[i - 1]:\n            swap[i] = swap[i - 1] + 1\n            no_swap[i] = no_swap[i - 1]\n        if A[i] > B[i - 1] and B[i] > A[i - 1]:\n            swap[i] = min(swap[i], no_swap[i - 1] + 1)\n            no_swap[i] = min(no_swap[i], swap[i - 1])\n    \n    return min(swap[-1], no_swap[-1])", "def minSwap(A, B):\n    n = len(A)\n    swap = [1] * n\n    no_swap = [0] * n\n    swap[0] = 1\n    for i in range(1, n):\n        if A[i] > A[i - 1] and B[i] > B[i - 1]:\n            swap[i] = swap[i - 1] + 1\n            no_swap[i] = no_swap[i - 1]\n        if A[i] > B[i - 1] and B[i] > A[i - 1]:\n            swap[i] = min(swap[i], no_swap[i - 1] + 1)\n            no_swap[i] = min(no_swap[i], swap[i - 1])\n    return min(swap[-1], no_swap[-1])", "def minSwap(A, B):\n    n = len(A)\n    swap = [1] * n\n    noswap = [0] * n\n    swap[0] = 1\n    noswap[0] = 0\n    \n    for i in range(1, n):\n        if A[i] > A[i-1] and B[i] > B[i-1]:\n            swap[i] = swap[i-1] + 1\n            noswap[i] = noswap[i-1]\n        if A[i] > B[i-1] and B[i] > A[i-1]:\n            swap[i] = min(swap[i], noswap[i-1] + 1)\n            noswap[i] = min(noswap[i], swap[i-1])\n    \n    return min(swap[-1], noswap[-1])", "def minSwap(A, B):\n    n = len(A)\n    swap = 1\n    no_swap = 0\n    for i in range(1, n):\n        if A[i] <= A[i - 1] or B[i] <= B[i - 1]:\n            swap, no_swap = no_swap + 1, swap\n        else:\n            swap, no_swap = swap + 1, no_swap + 1\n    return min(swap, no_swap)"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 16426, "entry_point": "findShortestSubArray", "codes": ["def findShortestSubArray(nums):\n    degree = max(nums.count(x) for x in set(nums))\n    left, right = {}, {}\n    for i, x in enumerate(nums):\n        if x not in left:\n            left[x] = i\n        right[x] = i\n    return min(right[x] - left[x] + 1 for x in set(nums) if nums.count(x) == degree)", "def findShortestSubArray(nums):\n    from collections import defaultdict\n\n    num_to_indices = defaultdict(list)\n    for i, num in enumerate(nums):\n        num_to_indices[num].append(i)\n\n    degree = max(len(indices) for indices in num_to_indices.values())\n    min_length = float('inf')\n\n    for indices in num_to_indices.values():\n        if len(indices) == degree:\n            min_length = min(min_length, indices[-1] - indices[0] + 1)\n\n    return min_length", "from collections import defaultdict\n\ndef findShortestSubArray(nums):\n    num_positions = defaultdict(list)\n    for i, num in enumerate(nums):\n        num_positions[num].append(i)\n    \n    max_degree = max(len(positions) for positions in num_positions.values())\n    min_length = float('inf')\n    \n    for positions in num_positions.values():\n        if len(positions) == max_degree:\n            min_length = min(min_length, positions[-1] - positions[0] + 1)\n    \n    return min_length", "def findShortestSubArray(nums):\n    degree = 0\n    min_length = float('inf')\n    num_indices = {}\n\n    for i, num in enumerate(nums):\n        if num not in num_indices:\n            num_indices[num] = [i, i]\n        else:\n            num_indices[num][1] = i\n        count = num_indices[num][1] - num_indices[num][0] + 1\n        if count > degree:\n            degree = count\n            min_length = count\n        elif count == degree:\n            min_length = min(min_length, count)\n\n    return min_length", "def findShortestSubArray(nums):\n    from collections import defaultdict\n    \n    first_seen = defaultdict(int)\n    last_seen = defaultdict(int)\n    count = defaultdict(int)\n    degree = 0\n    min_length = float('inf')\n    \n    for i, num in enumerate(nums):\n        if num not in first_seen:\n            first_seen[num] = i\n        last_seen[num] = i\n        count[num] += 1\n        degree = max(degree, count[num])\n        \n        if count[num] == degree:\n            min_length = min(min_length, last_seen[num] - first_seen[num] + 1)\n    \n    return min_length", "def findShortestSubArray(nums):\n    degree = 0\n    min_length = 0\n    num_positions = {}\n    \n    for i, num in enumerate(nums):\n        if num not in num_positions:\n            num_positions[num] = [i, i]\n        else:\n            num_positions[num][1] = i\n        \n        if num_positions[num][1] - num_positions[num][0] + 1 > degree:\n            degree = num_positions[num][1] - num_positions[num][0] + 1\n            min_length = i - num_positions[num][0] + 1\n        elif num_positions[num][1] - num_positions[num][0] + 1 == degree:\n            min_length = min(min_length, i - num_positions[num][0] + 1)\n    \n    return min_length", "def findShortestSubArray(nums):\n    from collections import defaultdict\n\n    count = defaultdict(int)\n    first_seen = {}\n    degree = 0\n    min_length = float('inf')\n\n    for i, num in enumerate(nums):\n        if num not in first_seen:\n            first_seen[num] = i\n        count[num] += 1\n        degree = max(degree, count[num])\n\n    for i, num in enumerate(nums):\n        if count[num] == degree:\n            min_length = min(min_length, i - first_seen[num] + 1)\n\n    return min_length", "from collections import defaultdict\n\ndef findShortestSubArray(nums):\n    first = {}\n    count = defaultdict(int)\n    max_count = 0\n    min_length = float('inf')\n    \n    for i, num in enumerate(nums):\n        if num not in first:\n            first[num] = i\n        count[num] += 1\n        max_count = max(max_count, count[num])\n        \n        if count[num] == max_count:\n            min_length = min(min_length, i - first[num] + 1)\n    \n    return min_length"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 16436, "entry_point": "maxProfitAssignment", "codes": ["def maxProfitAssignment(difficulty, profit, worker):\n    job_max_profit = [0] * (max(difficulty) + 1)\n    for d, p in zip(difficulty, profit):\n        job_max_profit[d] = max(job_max_profit[d], p)\n    for i in range(1, len(job_max_profit)):\n        job_max_profit[i] = max(job_max_profit[i], job_max_profit[i - 1])\n    return sum(job_max_profit[min(d, len(job_max_profit) - 1)] for d in worker)", "def maxProfitAssignment(difficulty, profit, worker):\n    jobs = sorted(zip(difficulty, profit))\n    max_profit = 0\n    best_profit = 0\n    i = 0\n    \n    for w in worker:\n        while i < len(jobs) and jobs[i][0] <= w:\n            best_profit = max(best_profit, jobs[i][1])\n            i += 1\n        max_profit += best_profit\n    \n    return max_profit", "def maxProfitAssignment(difficulty, profit, worker):\n    jobs = sorted(zip(difficulty, profit))\n    max_profit = 0\n    best_profit = 0\n    i = 0\n\n    for ability in worker:\n        while i < len(jobs) and jobs[i][0] <= ability:\n            max_profit = max(max_profit, jobs[i][1])\n            i += 1\n        best_profit += max_profit\n\n    return best_profit", "def maxProfitAssignment(difficulty, profit, worker):\n    max_profit = 0\n    best_profit_so_far = 0\n    profit_for_difficulty = [(0, 0)]\n    \n    for d, p in zip(difficulty, profit):\n        if p > best_profit_so_far:\n            best_profit_so_far = p\n            profit_for_difficulty.append((d, best_profit_so_far))\n    \n    profit_for_difficulty.sort()\n    \n    total_profit = 0\n    \n    for w in worker:\n        index = bisect.bisect(profit_for_difficulty, (w, float('inf')))\n        if index > 0:\n            total_profit += profit_for_difficulty[index - 1][1]\n    \n    return total_profit", "def maxProfitAssignment(difficulty, profit, worker):\n    profit_for_difficulty = {}\n    for d, p in zip(difficulty, profit):\n        profit_for_difficulty[d] = max(profit_for_difficulty.get(d, 0), p)\n    \n    max_profit_so_far = 0\n    for d in sorted(profit_for_difficulty):\n        max_profit_so_far = max(max_profit_so_far, profit_for_difficulty[d])\n        profit_for_difficulty[d] = max_profit_so_far\n    \n    total_profit = 0\n    for w in worker:\n        if w in profit_for_difficulty:\n            total_profit += profit_for_difficulty[w]\n        elif w > max(profit_for_difficulty.keys()):\n            total_profit += profit_for_difficulty[max(profit_for_difficulty.keys())]\n    \n    return total_profit", "def maxProfitAssignment(difficulty, profit, worker):\n    job_list = sorted(zip(difficulty, profit))\n    max_profit = 0\n    best_profit = 0\n    for diff, prof in job_list:\n        best_profit = max(best_profit, prof)\n        if diff <= worker[-1]:\n            for w in worker:\n                if w >= diff:\n                    max_profit += best_profit\n                else:\n                    break\n    return max_profit", "def maxProfitAssignment(difficulty, profit, worker):\n    max_profit = 0\n    worker.sort()\n    i = 0\n    for w in worker:\n        while i < len(difficulty) and difficulty[i] <= w:\n            max_profit = max(max_profit, profit[i])\n            i += 1\n    return worker[-1] * max_profit if worker else 0"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 16899, "entry_point": "numberOfArithmeticSlices", "codes": ["def numberOfArithmeticSlices(A):\n    n = len(A)\n    count, dp = 0, [0] * n\n    for i in range(2, n):\n        if A[i] - A[i - 1] == A[i - 1] - A[i - 2]:\n            dp[i] = dp[i - 1] + 1\n            count += dp[i]\n    return count", "def numberOfArithmeticSlices(A):\n    count = 0\n    current_length = 0\n    for i in range(2, len(A)):\n        if A[i] - A[i - 1] == A[i - 1] - A[i - 2]:\n            current_length += 1\n            count += current_length\n        else:\n            current_length = 0\n    return count", "def numberOfArithmeticSlices(A):\n    count = 0\n    current = 0\n    for i in range(2, len(A)):\n        if A[i] - A[i - 1] == A[i - 1] - A[i - 2]:\n            current += 1\n            count += current\n        else:\n            current = 0\n    return count", "def numberOfArithmeticSlices(A):\n    count = 0\n    n = len(A)\n    if n < 3:\n        return count\n    \n    for i in range(2, n):\n        if A[i] - A[i - 1] == A[i - 1] - A[i - 2]:\n            count += 1\n    \n    return count", "def numberOfArithmeticSlices(A):\n    return sum((len(list(g)) - 2) * (len(list(g)) - 3) // 2 for _, g in groupby(A, lambda x, y, z: x - y == y - z))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 17015, "entry_point": "largestNumber", "codes": ["def largestNumber(cost, target):\n    dp = [-1] * (target + 1)\n    dp[0] = 0\n    for i in range(1, target + 1):\n        dp[i] = -1\n        for j in range(9):\n            if i >= cost[j]:\n                if dp[i - cost[j]] != -1:\n                    dp[i] = max(dp[i], dp[i - cost[j]] * 10 + (j + 1))\n    return str(dp[target]) if dp[target] != -1 else \"0\"", "from functools import lru_cache\n\ndef largestNumber(cost, target):\n    max_digit = max(range(9), key=lambda i: cost[i])\n    \n    @lru_cache(None)\n    def dp(t):\n        if t < 0:\n            return -1\n        if t == 0:\n            return 0\n        best = -1\n        for i in range(9):\n            if cost[i] <= t:\n                best = max(best, dp(t - cost[i]) * 10 + (i + 1))\n        return best\n    \n    result = dp(target)\n    if result == -1:\n        return \"0\"\n    return str(result)", "def largestNumber(cost, target):\n    dp = [-1] * (target + 1)\n    dp[0] = 0\n    for i in range(1, target + 1):\n        dp[i] = max((dp[i - c] + 1 if i - c >= 0 else -1) * 10 + d + 1 for c, d in zip(cost, range(1, 10)))\n    return str(max(dp[target], 0))", "def largestNumber(cost, target):\n    max_num = [0] * (target + 1)\n    max_comb = [[] for _ in range(target + 1)]\n    \n    for i, c in enumerate(cost):\n        for j in range(c, target + 1):\n            if max_num[j - c] + 1 > max_num[j]:\n                max_num[j] = max_num[j - c] + 1\n                max_comb[j] = [i + 1] + max_comb[j - c]\n            elif max_num[j - c] + 1 == max_num[j]:\n                max_comb[j] = max(max_comb[j], [i + 1] + max_comb[j - c], key=lambda x: int(''.join(map(str, x))))\n    \n    if max_num[target] == 0:\n        return \"0\"\n    \n    return ''.join(map(str, max_comb[target]))", "def largestNumber(cost, target):\n    dp = [\"\"] * (target + 1)\n    dp[0] = \"0\"\n\n    for t in range(1, target + 1):\n        for i, c in enumerate(cost, start=1):\n            if t >= c:\n                dp[t] = max(dp[t], dp[t - c] + str(i))\n\n    return dp[target]", "def largestNumber(cost, target):\n    dp = [\"\"] * (target + 1)\n    dp[0] = \"0\"\n    \n    for t in range(1, target + 1):\n        for i, c in enumerate(cost):\n            if t >= c and dp[t - c] != \"0\":\n                new = dp[t - c] + str(i + 1)\n                if dp[t] == \"\" or new > dp[t]:\n                    dp[t] = new\n    \n    return dp[target]", "def largestNumber(cost, target):\n    dp = [0] + [\"-1\"] * target\n    \n    for n in range(1, target + 1):\n        for i in range(9):\n            if cost[i] <= n and dp[n - cost[i]] != \"-1\":\n                dp[n] = max(dp[n], dp[n - cost[i]] + str(i + 1))\n    \n    return \"0\" if dp[-1] == \"-1\" else dp[-1]"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 17079, "entry_point": "maskPII", "codes": ["def maskPII(S):\n    if '@' in S:\n        name, domain = S.split('@')\n        return f\"{name[0]}*****{name[-1]}@{domain}\".lower()\n    else:\n        digits = ''.join(c for c in S if c.isdigit())\n        local = \"***-***-\" + digits[-4:]\n        if len(digits) > 10:\n            return f\"+{'*' * (len(digits) - 10)}-{local}\"\n        return local", "def maskPII(S: str) -> str:\n    if '@' in S:\n        name, domain = S.split('@')\n        return f\"{name[0]}*****{name[-1]}@{domain}\".lower()\n    else:\n        digits = ''.join(filter(str.isdigit, S))\n        if len(digits) == 10:\n            return \"***-***-\" + digits[-4:]\n        else:\n            return \"+\" + \"*\" * (len(digits) - 10) + \"-***-***-\" + digits[-4:]", "import re\n\ndef maskPII(S):\n    if \"@\" in S:\n        name, domain = S.lower().split(\"@\")\n        return f\"{name[0]}*****{name[-1]}@{domain}\"\n    else:\n        digits = re.sub(r'\\D', '', S)\n        if len(digits) == 10:\n            return \"***-***-\" + digits[-4:]\n        else:\n            return \"+\" + \"*\" * (len(digits) - 10) + \"-***-***-\" + digits[-4:]", "def maskPII(S):\n    if '@' in S:\n        name = S.split('@')[0].lower()\n        return f\"{name[0]}*****{name[-1]}@{S.split('@')[1]}\"\n    else:\n        digits = ''.join(c for c in S if c.isdigit())\n        if len(digits) == 10:\n            return \"***-***-\" + digits[-4:]\n        else:\n            return \"+\" + \"*\" * (len(digits) - 10) + \"-***-***-\" + digits[-4:]", "def maskPII(S):\n    if S[0].isalpha():\n        name, domain = S.split('@')\n        return '{}*****{}@{}'.format(name[0].lower(), name[-1].lower(), domain.lower())\n    else:\n        digits = ''.join(filter(str.isdigit, S))\n        if len(digits) == 10:\n            return '***-***-{}'.format(digits[-4:])\n        else:\n            return '+{}-***-***-{}'.format('*' * (len(digits) - 10), digits[-4:])", "def maskPII(S):\n    if '@' in S:\n        name = S.split('@')[0].lower()\n        return name[0] + '*****' + name[-1] + '@' + S.split('@')[1]\n    else:\n        digits = ''.join(c for c in S if c.isdigit())\n        local = \"***-***-\" + digits[-4:]\n        if len(digits) > 10:\n            return \"+\" + \"*\" * (len(digits) - 10) + \"-\" + local\n        else:\n            return local", "import re\n\ndef maskPII(S: str) -> str:\n    if '@' in S:\n        name = re.sub(r'\\W+', '', S).lower()\n        return f\"{name[0]}*****{name[-1]}@{S[S.index('@'):]}\"\n    else:\n        digits = re.sub(r'\\D', '', S)\n        if len(digits) == 10:\n            return \"***-***-\" + digits[-4:]\n        else:\n            return \"+\" + (len(digits) - 10) * '*' + \"-***-***-\" + digits[-4:]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 17135, "entry_point": "hasGroupsSizeX", "codes": ["import collections\nimport math\n\ndef hasGroupsSizeX(deck):\n    counts = collections.Counter(deck).values()\n    return math.gcd(*counts) >= 2", "from collections import Counter\nfrom math import gcd\nfrom functools import reduce\n\ndef hasGroupsSizeX(deck):\n    counts = Counter(deck).values()\n    return reduce(gcd, counts) > 1", "from collections import Counter\nfrom math import gcd\nfrom functools import reduce\n\ndef hasGroupsSizeX(deck):\n    counts = Counter(deck).values()\n    return reduce(gcd, counts) >= 2", "from math import gcd\nfrom collections import Counter\n\ndef hasGroupsSizeX(deck):\n    counts = Counter(deck).values()\n    return reduce(gcd, counts) >= 2", "def hasGroupsSizeX(deck):\n    from math import gcd\n    from functools import reduce\n    counts = list(sorted(Counter(deck).values()))\n    return reduce(gcd, counts) > 1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 1791, "entry_point": "numPrimeArrangements", "codes": ["def numPrimeArrangements(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = sum(is_prime(i) for i in range(1, n + 1))\n    return (math.factorial(primes) * math.factorial(n - primes)) % (10**9 + 7)", "from math import factorial\n\ndef numPrimeArrangements(n):\n    is_prime = [False, False] + [True] * (n - 1)\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n + 1, i):\n                is_prime[j] = False\n    \n    prime_count = sum(is_prime)\n    non_prime_count = n - prime_count\n    \n    return (factorial(prime_count) * factorial(non_prime_count)) % (10**9 + 7)", "def numPrimeArrangements(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0], is_prime[1] = False, False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n + 1, i):\n                is_prime[j] = False\n    primes = sum(is_prime)\n    return (factorial(primes) * factorial(n - primes)) % (10**9 + 7)\n\nfrom math import factorial", "def numPrimeArrangements(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef num_prime_arrangements(n):\n    prime_count = sum(numPrimeArrangements(i) for i in range(1, n + 1))\n    non_prime_count = n - prime_count\n    return (factorial(prime_count) * factorial(non_prime_count)) % (10**9 + 7)\n\nfrom math import factorial", "def numPrimeArrangements(n: int) -> int:\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_count = sum(is_prime(i) for i in range(1, n + 1))\n    return (factorial(prime_count) * factorial(n - prime_count)) % (10**9 + 7)", "from math import factorial\nfrom sympy import primerange\n\ndef numPrimeArrangements(n):\n    primes = list(primerange(1, n + 1))\n    prime_count = len(primes)\n    non_prime_count = n - prime_count\n    return (factorial(prime_count) * factorial(non_prime_count)) % (10**9 + 7)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 17751, "entry_point": "mctFromLeafValues", "codes": ["def mctFromLeafValues(arr):\n    res, stack = 0, [float('inf')]\n    for a in arr:\n        while stack[-1] <= a:\n            b = stack.pop()\n            res += b * min(stack[-1], a)\n        stack.append(a)\n    while len(stack) > 2:\n        res += stack.pop() * stack[-1]\n    return res", "def mctFromLeafValues(arr):\n    stack, res = [], 0\n    for a in arr:\n        while stack and stack[-1] <= a:\n            mid = stack.pop()\n            if stack:\n                res += mid * min(stack[-1], a)\n            else:\n                res += mid * a\n        stack.append(a)\n    while len(stack) > 1:\n        res += stack.pop() * stack[-1]\n    return res", "def mctFromLeafValues(arr):\n    result = 0\n    stack = []\n    for num in arr:\n        while stack and stack[-1] <= num:\n            mid = stack.pop()\n            if stack:\n                result += mid * min(stack[-1], num)\n            else:\n                result += mid * num\n        stack.append(num)\n    while len(stack) > 1:\n        result += stack.pop() * stack[-1]\n    return result", "def mctFromLeafValues(arr):\n    stack = []\n    result = 0\n    for num in arr:\n        while stack and num >= stack[-1]:\n            mid = stack.pop()\n            if stack:\n                result += stack[-1] * mid\n            else:\n                result += mid * num\n        stack.append(num)\n    while len(stack) > 1:\n        result += stack[-2] * stack.pop()\n    return result", "def mctFromLeafValues(arr):\n    stack = []\n    result = 0\n    for value in arr:\n        while stack and stack[-1] <= value:\n            middle = stack.pop()\n            result += middle * min(stack[-1] if stack else float('inf'), value)\n        stack.append(value)\n    while len(stack) > 2:\n        result += stack.pop() * stack[-1]\n    return result", "def mctFromLeafValues(arr):\n    result = 0\n    while len(arr) > 1:\n        min_index = arr.index(min(arr))\n        if min_index > 0:\n            result += arr[min_index] * arr[min_index - 1]\n        else:\n            result += arr[min_index] * arr[min_index + 1]\n        arr.pop(min_index)\n    return result", "def mctFromLeafValues(arr):\n    return sum(max(a, b) * c for a, b, c in zip(arr[:-2], arr[1:-1], arr[2:]))", "def mctFromLeafValues(arr):\n    stack = []\n    res = 0\n    for num in arr:\n        while stack and stack[-1] <= num:\n            mid = stack.pop()\n            if not stack:\n                break\n            res += mid * min(stack[-1], num)\n        stack.append(num)\n    while len(stack) > 2:\n        res += stack.pop() * stack[-1]\n    return res"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 17811, "entry_point": "smallestRepunitDivByK", "codes": ["def smallestRepunitDivByK(K):\n    return next((i for i in range(1, K + 1) if (10**i - 1) % K == 0), -1)", "def smallestRepunitDivByK(K):\n    remainder = 0\n    for length in range(1, K + 1):\n        remainder = (remainder * 10 + 1) % K\n        if remainder == 0:\n            return length\n    return -1", "def smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return -1\n    num, length = 1, 1\n    while num % K != 0:\n        num = (num * 10 + 1) % K\n        length += 1\n    return length", "def smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return -1\n    N, remainder = 1, 1\n    for length in range(1, K + 1):\n        if remainder == 0:\n            return length\n        remainder = (remainder * 10 + 1) % K\n    return -1"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 17994, "entry_point": "isMatch", "codes": ["def isMatch(s, p):\n    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n    dp[-1][-1] = True\n    for i in range(len(s), -1, -1):\n        for j in range(len(p) - 1, -1, -1):\n            first_match = i < len(s) and (s[i] == p[j] or p[j] == '.')\n            if j + 1 < len(p) and p[j + 1] == '*':\n                dp[i][j] = dp[i][j + 2] or (first_match and dp[i + 1][j])\n            else:\n                dp[i][j] = first_match and dp[i + 1][j + 1]\n    return dp[0][0]", "def isMatch(s, p):\n    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n    dp[-1][-1] = True\n    for i in range(len(s), -1, -1):\n        for j in range(len(p) - 1, -1, -1):\n            match = i < len(s) and (s[i] == p[j] or p[j] == '.')\n            if j+1 < len(p) and p[j+1] == '*':\n                dp[i][j] = dp[i][j+2] or (match and dp[i+1][j])\n            else:\n                dp[i][j] = match and dp[i+1][j+1]\n    return dp[0][0]", "def isMatch(s: str, p: str) -> bool:\n    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n    dp[-1][-1] = True\n    \n    for i in range(len(s), -1, -1):\n        for j in range(len(p) - 1, -1, -1):\n            match = i < len(s) and (s[i] == p[j] or p[j] == '.')\n            if j + 1 < len(p) and p[j + 1] == '*':\n                dp[i][j] = dp[i][j + 2] or (match and dp[i + 1][j])\n            else:\n                dp[i][j] = match and dp[i + 1][j + 1]\n    \n    return dp[0][0]", "def isMatch(s: str, p: str) -> bool:\n    def matches(i: int, j: int) -> bool:\n        return i < len(s) and (s[i] == p[j] or p[j] == '.')\n    \n    @lru_cache(None)\n    def dp(i: int, j: int) -> bool:\n        if j == len(p):\n            return i == len(s)\n        if j + 1 < len(p) and p[j + 1] == '*':\n            return dp(i, j + 2) or (i < len(s) and matches(i, j) and dp(i + 1, j))\n        return i < len(s) and matches(i, j) and dp(i + 1, j + 1)\n    \n    return dp(0, 0)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 1830, "entry_point": "largestSumOfAverages", "codes": ["def largestSumOfAverages(A, K):\n    n = len(A)\n    dp = [[0] * n for _ in range(K + 1)]\n    for i in range(n):\n        dp[1][i] = sum(A[:i + 1]) / (i + 1)\n    for k in range(2, K + 1):\n        for i in range(n - 1, k - 2, -1):\n            dp[k][i] = max((sum(A[j:i + 1]) / (i - j + 1) + dp[k - 1][j - 1]) for j in range(i, k - 2, -1))\n    return dp[K][n - 1]", "def largestSumOfAverages(A, K):\n    n = len(A)\n    dp = [[0] * n for _ in range(K + 1)]\n    prefix_sum = [0] * (n + 1)\n    \n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    for i in range(1, K + 1):\n        for j in range(i - 1, n):\n            for k in range(i - 2, j):\n                dp[i][j] = max(dp[i][j], dp[i - 1][k] + (prefix_sum[j + 1] - prefix_sum[k + 1]) / (j - k))\n    \n    return dp[K][n - 1]", "def largestSumOfAverages(A, K):\n    n = len(A)\n    dp = [[0] * (K + 1) for _ in range(n + 1)]\n    prefix_sum = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n        dp[i][1] = prefix_sum[i] / i\n    \n    for k in range(2, K + 1):\n        for i in range(k, n + 1):\n            for j in range(k - 1, i):\n                dp[i][k] = max(dp[i][k], dp[j][k - 1] + (prefix_sum[i] - prefix_sum[j]) / (i - j))\n    \n    return dp[n][K]", "def largestSumOfAverages(A, K):\n    from functools import lru_cache\n    @lru_cache(None)\n    def dfs(i, k):\n        if k == 1:\n            return sum(A[i:]) / (len(A) - i)\n        return max((sum(A[i:j]) / (j - i) + dfs(j, k - 1)) for j in range(i + 1, len(A)))\n    return dfs(0, K)", "def largestSumOfAverages(A, K):\n    from functools import lru_cache\n    \n    @lru_cache(None)\n    def dfs(i, k):\n        if k == 1:\n            return sum(A[i:]) / (len(A) - i)\n        return max(dfs(j, k - 1) + sum(A[i:j]) / (j - i) for j in range(i + 1, len(A)))\n    \n    return dfs(0, K)", "def largestSumOfAverages(A, K):\n    from functools import lru_cache\n\n    @lru_cache(None)\n    def dp(i, k):\n        if k == 1:\n            return sum(A[i:]) / (len(A) - i)\n        return max((sum(A[i:j]) / (j - i) + dp(j, k - 1)) for j in range(i + 1, len(A)))\n\n    return dp(0, K)", "def largestSumOfAverages(A, K):\n    n = len(A)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n\n    @lru_cache(None)\n    def dp(i, k):\n        if k == 1:\n            return (prefix_sum[n] - prefix_sum[i]) / (n - i)\n        return max((prefix_sum[j] - prefix_sum[i]) / (j - i) + dp(j, k - 1) for j in range(i + 1, n + 1))\n\n    return dp(0, K)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 1834, "entry_point": "minCost", "codes": ["def minCost(houses, cost, m, n, target):\n    def dfs(i, prev, neighborhoods):\n        if i == m:\n            return 0 if neighborhoods == target else float('inf')\n        if neighborhoods > target:\n            return float('inf')\n        if houses[i] != 0:\n            return dfs(i + 1, houses[i], neighborhoods + (houses[i] != prev))\n        return min(dfs(i + 1, j + 1, neighborhoods + (j + 1 != prev)) + cost[i][j] for j in range(n))\n\n    result = dfs(0, 0, 0)\n    return result if result != float('inf') else -1", "def minCost(houses, cost, m, n, target):\n    INF = float('inf')\n    dp = [[[INF] * n for _ in range(target + 1)] for _ in range(m + 1)]\n    \n    def dfs(i, t, prev):\n        if i == m or t < 0:\n            return 0 if t == 0 else INF\n        if houses[i] != 0:\n            return dfs(i + 1, t - (houses[i] != prev), houses[i])\n        min_cost = INF\n        for j in range(1, n + 1):\n            min_cost = min(min_cost, cost[i][j - 1] + dfs(i + 1, t - (j != prev), j))\n        return min_cost\n    \n    result = dfs(0, target, 0)\n    return result if result < INF else -1", "def minCost(houses, cost, m, n, target):\n    INF = float('inf')\n    dp = [[[INF] * (n + 1) for _ in range(target + 1)] for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(1, n + 1):\n            if houses[i] != 0 and houses[i] != j:\n                continue\n            c = 0 if houses[i] != 0 else cost[i][j - 1]\n            if i == 0:\n                dp[i][1][j] = c\n                continue\n            for k in range(1, target + 1):\n                for l in range(1, n + 1):\n                    if l != j:\n                        dp[i][k][j] = min(dp[i][k][j], dp[i - 1][k][l] + c)\n                    else:\n                        dp[i][k][j] = min(dp[i][k][j], dp[i - 1][k - 1][l] + c)\n    \n    result = min(dp[m - 1][target])\n    return result if result < INF else -1", "def minCost(houses, cost, m, n, target):\n    INF = float('inf')\n    dp = [[[INF] * n for _ in range(target + 1)] for _ in range(m + 1)]\n    dp[0][0][0] = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, target + 1):\n            for k in range(1, n + 1):\n                if houses[i - 1] != 0:\n                    if houses[i - 1] == k:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k])\n                    if j > 1:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][houses[i - 1]])\n                else:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + cost[i - 1][k - 1])\n                    if j > 1:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][h] + cost[i - 1][k - 1] for h in range(1, n + 1))\n\n    return min(dp[m][target]) if min(dp[m][target]) != INF else -1", "def minCost(houses, cost, m, n, target):\n    INF = float('inf')\n    dp = [[[INF] * n for _ in range(target + 1)] for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if houses[i] == j + 1:\n                dp[i][1][j] = 0\n            elif houses[i] == 0:\n                dp[i][1][j] = cost[i][j]\n    \n    for t in range(2, target + 1):\n        for i in range(t - 1, m):\n            for j in range(n):\n                for k in range(n):\n                    if j != k:\n                        dp[i][t][j] = min(dp[i][t][j], dp[i - 1][t - 1][k] + cost[i][j])\n                    else:\n                        dp[i][t][j] = min(dp[i][t][j], dp[i - 1][t][k] + cost[i][j])\n    \n    result = min(dp[m - 1][target])\n    return result if result != INF else -1", "def minCost(houses, cost, m, n, target):\n    dp = [[[float('inf')] * n for _ in range(target + 1)] for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if houses[i] == 0:\n                dp[i][1][j] = cost[i][j]\n            else:\n                dp[i][1][houses[i] - 1] = 0\n                \n    for t in range(2, target + 1):\n        for i in range(t - 1, m):\n            for j in range(n):\n                for k in range(n):\n                    if k == j:\n                        dp[i][t][j] = min(dp[i][t][j], dp[i - 1][t][k])\n                    else:\n                        dp[i][t][j] = min(dp[i][t][j], dp[i - 1][t - 1][k])\n                if houses[i] == 0:\n                    dp[i][t][j] += cost[i][j]\n    \n    result = min(dp[m - 1][target])\n    return result if result != float('inf') else -1", "def minCost(houses, cost, m, n, target):\n    INF = float('inf')\n    dp = [[[INF] * n for _ in range(target + 1)] for _ in range(m + 1)]\n    dp[0][0][0] = 0\n    \n    for i in range(1, m + 1):\n        for j in range(1, target + 1):\n            for k in range(n):\n                if houses[i - 1] == 0:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + cost[i - 1][k])\n                    if k > 0:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k - 1] + cost[i - 1][k])\n                else:\n                    if houses[i - 1] - 1 == k:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k])\n                    else:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k] + cost[i - 1][k])\n    \n    ans = min(dp[m][target])\n    return ans if ans != INF else -1", "def minCost(houses, cost, m, n, target):\n    INF = float('inf')\n    dp = [[[INF] * n for _ in range(target + 1)] for _ in range(m + 1)]\n    dp[0][0][0] = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, target + 1):\n            for k in range(1, n + 1):\n                if houses[i - 1] == 0:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + cost[i - 1][k - 1])\n                    if k > 1:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k - 1] + cost[i - 1][k - 1])\n                else:\n                    if houses[i - 1] == k:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k])\n                        if k > 1:\n                            dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k - 1])\n                    else:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + cost[i - 1][k - 1])\n                        if k > 1:\n                            dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k - 1] + cost[i - 1][k - 1])\n\n    result = min(dp[m][target])\n    return result if result != INF else -1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 18061, "entry_point": "countOrders", "codes": ["def countOrders(n):\n    MOD = 10**9 + 7\n    result = 1\n    for i in range(2, n + 1):\n        result = result * (2 * i - 1) * i % MOD\n    return result", "def countOrders(n):\n    MOD = 10**9 + 7\n    result = 1\n    for i in range(2, n + 1):\n        result = result * (2 * i - 1) * (2 * i) % MOD\n    return result", "def countOrders(n):\n    MOD = 10**9 + 7\n    result = 1\n    for i in range(2, n + 1):\n        result = result * (2*i * (2*i - 1)) % MOD\n    return result", "def countOrders(n):\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        dp[i] = (dp[i - 1] * (2 * i - 1) * (2 * i)) % MOD\n    \n    return dp[n]", "def countOrders(n):\n    MOD = 10**9 + 7\n    dp = [1] + [0] * n\n    for i in range(1, n):\n        dp[i + 1] = (dp[i] * (2 * i + 1) * (2 * i + 2)) % MOD\n    return dp[n]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 18154, "entry_point": "isPalindrome", "codes": ["def isPalindrome(s):\n    filtered_chars = [char.lower() for char in s if char.isalnum()]\n    return filtered_chars == filtered_chars[::-1]", "def isPalindrome(s):\n    cleaned = ''.join(c.lower() for c in s if c.isalnum())\n    return cleaned == cleaned[::-1]", "def isPalindrome(s: str) -> bool:\n    filtered_chars = [char.lower() for char in s if char.isalnum()]\n    return filtered_chars == filtered_chars[::-1]", "def isPalindrome(s):\n    cleaned = (char.lower() for char in s if char.isalnum())\n    return cleaned == reversed(cleaned)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 18180, "entry_point": "minDifficulty", "codes": ["def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n\n    dp = [[float('inf')] * (d + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for k in range(1, min(i, d) + 1):\n            max_diff = 0\n            for j in range(i, k - 1, -1):\n                max_diff = max(max_diff, jobDifficulty[j - 1])\n                dp[i][k] = min(dp[i][k], dp[j - 1][k - 1] + max_diff)\n\n    return dp[n][d]", "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n    \n    dp = [[float('inf')] * n for _ in range(d + 1)]\n    dp[1] = [max(jobDifficulty[:i + 1]) for i in range(n)]\n    \n    for k in range(2, d + 1):\n        for i in range(k - 1, n):\n            max_diff = 0\n            for j in range(i, k - 2, -1):\n                max_diff = max(max_diff, jobDifficulty[j])\n                dp[k][i] = min(dp[k][i], dp[k - 1][j - 1] + max_diff)\n    \n    return dp[d][n - 1]", "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n\n    dp = [[float('inf')] * n for _ in range(d + 1)]\n    dp[1][0] = jobDifficulty[0]\n\n    for i in range(1, n):\n        dp[1][i] = max(dp[1][i - 1], jobDifficulty[i])\n\n    for d in range(2, d + 1):\n        for i in range(d - 1, n):\n            for j in range(i, d - 2, -1):\n                dp[d][i] = min(dp[d][i], dp[d - 1][j - 1] + max(jobDifficulty[j:i + 1]))\n\n    return dp[d][n - 1]", "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n\n    @lru_cache(None)\n    def dp(day, job):\n        if day == 1:\n            return max(jobDifficulty[job:])\n        max_difficulty = 0\n        result = float('inf')\n        for i in range(job, n - day + 1):\n            max_difficulty = max(max_difficulty, jobDifficulty[i])\n            result = min(result, max_difficulty + dp(day - 1, i + 1))\n        return result\n\n    return dp(d, 0)", "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n\n    @cache\n    def dp(day, end):\n        if end == n - 1:\n            return max(jobDifficulty[end:])\n        return min(max(jobDifficulty[start:end+1]) + dp(day + 1, end) for start in range(end, n - d + day + 1))\n\n    return dp(0, 0)", "from typing import List\n\ndef minDifficulty(jobDifficulty: List[int], d: int) -> int:\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n\n    @lru_cache(None)\n    def dp(i, k):\n        if k == 1:\n            return max(jobDifficulty[i:])\n        return min(dp(j, k-1) + max(jobDifficulty[i:j+1]) for j in range(i+1, n-k+2))\n\n    return dp(0, d)", "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n    \n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for days in range(1, d + 1):\n        max_difficulty = 0\n        for j in range(days, n + 1):\n            max_difficulty = max(max_difficulty, jobDifficulty[j - 1])\n            dp[j] = min(dp[j], dp[j - 1] + max_difficulty)\n            for i in range(j - 2, days - 2, -1):\n                max_difficulty = max(max_difficulty, jobDifficulty[i])\n                dp[j] = min(dp[j], dp[i] + max_difficulty)\n    \n    return dp[n]", "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n    \n    @lru_cache(None)\n    def dp(i, k):\n        if k == 1:\n            return max(jobDifficulty[i:])\n        return min(max(jobDifficulty[i:j]) + dp(j, k-1) for j in range(i+1, n-k+2))\n    \n    return dp(0, d)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 18306, "entry_point": "isValid", "codes": ["def isValid(s: str) -> bool:\n    while \"abc\" in s:\n        s = s.replace(\"abc\", \"\")\n    return s == \"\"", "def isValid(s):\n    stack = []\n    for char in s:\n        if char == 'c':\n            if len(stack) < 2 or stack[-2] != 'a' or stack[-1] != 'b':\n                return False\n            stack.pop()\n            stack.pop()\n        else:\n            stack.append(char)\n    return not stack", "def isValid(s: str) -> bool:\n    stack = []\n    for char in s:\n        if char == 'c':\n            if len(stack) < 2 or stack[-2] != 'a' or stack[-1] != 'b':\n                return False\n            stack.pop()\n            stack.pop()\n        else:\n            stack.append(char)\n    return not stack", "def isValid(s: str) -> bool:\n    stack = []\n    for char in s:\n        if char == 'a':\n            stack.append(char)\n        elif char == 'b':\n            if not stack or stack[-1] != 'a':\n                return False\n            stack.append(char)\n        elif char == 'c':\n            if not stack or stack[-1] != 'b':\n                return False\n            stack.pop()\n            if stack and stack[-1] == 'a':\n                stack.pop()\n    return not stack"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 18318, "entry_point": "longestOnes", "codes": ["def longestOnes(A, K):\n    max_ones = start = 0\n    for end, value in enumerate(A):\n        K -= 1 - value\n        if K < 0:\n            K += 1 - A[start]\n            start += 1\n        max_ones = max(max_ones, end - start + 1)\n    return max_ones", "def longestOnes(A, K):\n    max_ones = 0\n    left = 0\n    for right in range(len(A)):\n        if A[right] == 0:\n            K -= 1\n        while K < 0:\n            if A[left] == 0:\n                K += 1\n            left += 1\n        max_ones = max(max_ones, right - left + 1)\n    return max_ones", "def longestOnes(A, K):\n    left = 0\n    max_ones = 0\n    count_zeros = 0\n    \n    for right in range(len(A)):\n        if A[right] == 0:\n            count_zeros += 1\n        \n        while count_zeros > K:\n            if A[left] == 0:\n                count_zeros -= 1\n            left += 1\n        \n        max_ones = max(max_ones, right - left + 1)\n    \n    return max_ones", "from collections import deque\n\ndef longestOnes(A, K):\n    zero_indices = deque()\n    max_length = 0\n    \n    for i, num in enumerate(A):\n        if num == 0:\n            zero_indices.append(i)\n            if len(zero_indices) > K:\n                max_length = max(max_length, i - zero_indices.popleft())\n    \n    return max(max_length, len(A) - len(zero_indices))", "from collections import deque\n\ndef longestOnes(A, K):\n    max_length = 0\n    zero_indices = deque()\n    \n    for i in range(len(A)):\n        if A[i] == 0:\n            zero_indices.append(i)\n        \n        if len(zero_indices) > K:\n            max_length = max(max_length, i - zero_indices[0] - 1)\n            zero_indices.popleft()\n    \n    max_length = max(max_length, len(A) - zero_indices[0] - 1)\n    \n    return max_length"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 18327, "entry_point": "longestSubstring", "codes": ["def longestSubstring(s, k):\n    from collections import Counter\n    \n    def helper(s, k):\n        count = Counter(s)\n        for c in set(s):\n            if count[c] < k:\n                return max(helper(sub, k) for sub in s.split(c))\n        return len(s)\n    \n    return helper(s, k)", "def longestSubstring(s: str, k: int) -> int:\n    from collections import Counter\n    \n    if len(s) < k:\n        return 0\n    \n    count = Counter(s)\n    for c in set(s):\n        if count[c] < k:\n            return max(longestSubstring(t, k) for t in s.split(c))\n    \n    return len(s)", "def longestSubstring(s: str, k: int) -> int:\n    if k <= 1:\n        return len(s)\n    count = {}\n    for char in s:\n        count[char] = count.get(char, 0) + 1\n    for char in count:\n        if count[char] < k:\n            return max(longestSubstring(sub, k) for sub in s.split(char))\n    return len(s)", "def longestSubstring(s, k):\n    if k <= 1:\n        return len(s)\n    if not s:\n        return 0\n\n    count = [0] * 26\n    for char in s:\n        count[ord(char) - ord('a')] += 1\n\n    split_points = [0]\n    for i, char in enumerate(s):\n        if count[ord(char) - ord('a')] < k:\n            split_points.append(i + 1)\n\n    split_points.append(len(s))\n    max_length = 0\n    for i in range(1, len(split_points)):\n        sub_str = s[split_points[i-1]:split_points[i]]\n        if all(count[ord(char) - ord('a')] >= k for char in sub_str):\n            max_length = max(max_length, len(sub_str))\n\n    return max_length", "def longestSubstring(s, k):\n    from collections import Counter\n\n    def at_least_k(s, k):\n        count = Counter(s)\n        return all(v >= k for v in count.values())\n\n    if len(s) < k:\n        return 0\n\n    for i in range(len(s)):\n        if at_least_k(s[i:], k):\n            return len(s[i:])\n        if s[i] not in [s[j] for j in range(i + 1, len(s)) if s[j] == s[i]]:\n            return max(longestSubstring(sub, k) for sub in s.split(s[i]))\n\n    return 0", "def longestSubstring(s, k):\n    from collections import Counter\n    \n    if k == 0:\n        return 0\n    \n    char_count = Counter(s)\n    unique_chars = set(char_count)\n    \n    if len(unique_chars) <= 1:\n        if min(char_count.values()) >= k:\n            return len(s)\n        else:\n            return 0\n    \n    max_length = 0\n    for char in unique_chars:\n        if char_count[char] < k:\n            segments = s.split(char)\n            for segment in segments:\n                max_length = max(max_length, longestSubstring(segment, k))\n            return max_length\n    \n    return len(s)", "def longestSubstring(s: str, k: int) -> int:\n    if not s or k <= 0:\n        return 0\n\n    def helper(s, k):\n        count = [0] * 26\n        for char in s:\n            count[ord(char) - ord('a')] += 1\n\n        unique_chars = set(char for char in s if count[ord(char) - ord('a')] > 0)\n        if len(unique_chars) < k:\n            return 0\n\n        left = 0\n        result = 0\n        for right, char in enumerate(s):\n            count[ord(char) - ord('a')] -= 1\n            if count[ord(char) - ord('a')] == k - 1:\n                while left < right and count[ord(s[left]) - ord('a')] < k:\n                    count[ord(s[left]) - ord('a')] += 1\n                    left += 1\n                result = max(result, right - left + 1)\n        return result\n\n    return helper(s, k)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 18338, "entry_point": "validSquare", "codes": ["def validSquare(p1, p2, p3, p4):\n    points = [p1, p2, p3, p4]\n    distances = []\n    \n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\n            distances.append(dist)\n    \n    distances.sort()\n    \n    return len(set(distances)) == 2 and distances[0] > 0", "def validSquare(p1, p2, p3, p4):\n    if p1 == p2 or p1 == p3 or p1 == p4 or p2 == p3 or p2 == p4 or p3 == p4:\n        return False\n    sides = set()\n    sides.add((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    sides.add((p1[0] - p3[0]) ** 2 + (p1[1] - p3[1]) ** 2)\n    sides.add((p1[0] - p4[0]) ** 2 + (p1[1] - p4[1]) ** 2)\n    sides.add((p2[0] - p3[0]) ** 2 + (p2[1] - p3[1]) ** 2)\n    sides.add((p2[0] - p4[0]) ** 2 + (p2[1] - p4[1]) ** 2)\n    sides.add((p3[0] - p4[0]) ** 2 + (p3[1] - p4[1]) ** 2)\n    return len(sides) == 2 and 0 not in sides", "def validSquare(p1, p2, p3, p4):\n    points = {tuple(p) for p in [p1, p2, p3, p4]}\n    if len(points) != 4:\n        return False\n    distances = set()\n    for p1 in points:\n        for p2 in points:\n            if p1 == p2:\n                continue\n            dist = (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n            distances.add(dist)\n    return len(distances) == 2 and 0 not in distances", "def validSquare(p1, p2, p3, p4):\n    if any(p == q for p, q in [(p1, p2), (p1, p3), (p1, p4), (p2, p3), (p2, p4), (p3, p4)]):\n        return False\n\n    def squared_distance(p, q):\n        return (p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2\n\n    distances = sorted([squared_distance(p, q) for p, q in combinations([p1, p2, p3, p4], 2)])\n    return distances[0] > 0 and distances[0] == distances[3] and distances[4] == distances[5] and distances[0] + distances[0] == distances[4]", "def validSquare(p1, p2, p3, p4):\n    points = sorted([p1, p2, p3, p4])\n    a = points[1][0] - points[0][0]\n    b = points[1][1] - points[0][1]\n    c = points[2][0] - points[0][0]\n    d = points[2][1] - points[0][1]\n    return (a != 0 and b != 0 and (a == c or b == d) and (a**2 + b**2 == c**2 + d**2))", "def validSquare(p1, p2, p3, p4):\n    def distance(p1, p2):\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n    \n    points = [p1, p2, p3, p4]\n    dists = sorted([distance(p1, p2) for p1, p2 in combinations(points, 2)])\n    \n    return dists[0] > 0 and dists[:4] == dists[4:8] and dists[8] == 2 * dists[0]", "def validSquare(p1, p2, p3, p4):\n    def distance(p1, p2):\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n    points = {tuple(p1), tuple(p2), tuple(p3), tuple(p4)}\n    if len(points) != 4:\n        return False\n\n    dists = sorted([distance(p1, p2) for p1 in points for p2 in points if p1 < p2])\n    return dists[0] > 0 and dists[0] == dists[3] == dists[4] and dists[5] == dists[6] == dists[7]", "def validSquare(p1, p2, p3, p4):\n    points = {tuple(p) for p in [p1, p2, p3, p4]}\n    if len(points) != 4:\n        return False\n    distances = set()\n    for p1, p2 in combinations(points, 2):\n        dist = (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n        if dist == 0:\n            return False\n        distances.add(dist)\n    return len(distances) == 2"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 18408, "entry_point": "reverseParentheses", "codes": ["def reverseParentheses(s: str) -> str:\n    stack = [[]]\n    for char in s:\n        if char == '(':\n            stack.append([])\n        elif char == ')':\n            inner = stack.pop()\n            stack[-1].extend(reversed(inner))\n        else:\n            stack[-1].append(char)\n    return ''.join(stack[0])", "def reverseParentheses(s):\n    stack = []\n    current = ''\n    for char in s:\n        if char == '(':\n            stack.append(current)\n            current = ''\n        elif char == ')':\n            current = stack.pop() + current[::-1]\n        else:\n            current += char\n    return current", "def reverseParentheses(s: str) -> str:\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append([])\n        elif char == ')':\n            reversed_part = stack.pop()[::-1]\n            if stack:\n                stack[-1].extend(reversed_part)\n            else:\n                stack.append(reversed_part)\n        else:\n            if stack:\n                stack[-1].append(char)\n            else:\n                stack.append([char])\n    return ''.join(stack[0])", "def reverseParentheses(s):\n    stack = ['']\n    for char in s:\n        if char == '(':\n            stack.append('')\n        elif char == ')':\n            reversed_sub = stack.pop()[::-1]\n            stack[-1].extend(reversed_sub)\n        else:\n            stack[-1].append(char)\n    return ''.join(stack[-1])\n\ndef _equivalent(_lhs, _rhs):\n    return _lhs == _rhs", "def reverseParentheses(s):\n    stack = []\n    for char in s:\n        if char == ')':\n            temp = ''\n            while stack[-1] != '(':\n                temp += stack.pop()\n            stack.pop()  # Remove '('\n            stack.append(temp[::-1])\n        else:\n            stack.append(char)\n    return ''.join(stack)", "def reverseParentheses(s):\n    stack = []\n    for char in s:\n        if char == ')':\n            reversed_substring = ''\n            while stack and stack[-1] != '(':\n                reversed_substring = stack.pop() + reversed_substring\n            stack.pop()  # Remove the '('\n            stack.extend(reversed_substring)\n        else:\n            stack.append(char)\n    return ''.join(stack)", "def reverseParentheses(s):\n    stack = []\n    current = []\n    for char in s:\n        if char == '(':\n            stack.append(''.join(current))\n            current = []\n        elif char == ')':\n            reversed_substring = ''.join(current)[::-1]\n            current = stack.pop() + reversed_substring\n        else:\n            current.append(char)\n    return ''.join(current)", "def reverseParentheses(s):\n    stack = []\n    for char in s:\n        if char == ')':\n            chunk = ''\n            while stack[-1] != '(':\n                chunk += stack.pop()[0]\n            stack.pop()  # Remove the '('\n            stack.append([chunk[::-1]])\n        else:\n            stack.append([char])\n    return ''.join(chunk for chunk in stack)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 1862, "entry_point": "getHint", "codes": ["def getHint(secret, guess):\n    from collections import Counter\n    \n    bull = sum(s == g for s, g in zip(secret, guess))\n    count_s, count_g = Counter(secret), Counter(guess)\n    cow = sum((count_s & count_g).values()) - bull\n    return f\"{bull}A{cow}B\"", "def getHint(secret: str, guess: str) -> str:\n    from collections import Counter\n    \n    A = sum(s == g for s, g in zip(secret, guess))\n    secret_counts = Counter(secret)\n    guess_counts = Counter(guess)\n    B = sum((secret_counts & guess_counts).values()) - A\n    return f\"{A}A{B}B\"", "def getHint(secret: str, guess: str) -> str:\n    bull = sum(s == g for s, g in zip(secret, guess))\n    secret_freq = [0] * 10\n    guess_freq = [0] * 10\n    for s, g in zip(secret, guess):\n        if s != g:\n            secret_freq[int(s)] += 1\n            guess_freq[int(g)] += 1\n    cow = sum(min(sf, gf) for sf, gf in zip(secret_freq, guess_freq))\n    return f\"{bull}A{cow}B\"", "def getHint(secret, guess):\n    bulls = sum(s == g for s, g in zip(secret, guess))\n    counts_s = [0] * 10\n    counts_g = [0] * 10\n    for s, g in zip(secret, guess):\n        counts_s[int(s)] += 1\n        counts_g[int(g)] += 1\n    cows = sum(min(cs, cg) for cs, cg in zip(counts_s, counts_g)) - bulls\n    return f\"{bulls}A{cows}B\"", "def getHint(secret: str, guess: str) -> str:\n    bulls = sum(s == g for s, g in zip(secret, guess))\n    counts_s = [0] * 10\n    counts_g = [0] * 10\n    for s, g in zip(secret, guess):\n        counts_s[int(s)] += 1\n        counts_g[int(g)] += 1\n    cows = sum(min(cs, cg) for cs, cg in zip(counts_s, counts_g)) - bulls\n    return f\"{bulls}A{cows}B\"", "def getHint(secret, guess):\n    bull = sum(s == g for s, g in zip(secret, guess))\n    both = sum((collections.Counter(secret) & collections.Counter(guess)).values())\n    return f\"{bull}A{both - bull}B\""], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 18511, "entry_point": "isValid", "codes": ["def isValid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    return not stack", "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            return False\n    return not stack", "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or mapping[char] != stack.pop():\n                return False\n        else:\n            return False\n    return not stack", "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or mapping[char] != stack.pop():\n                return False\n    return not stack"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 18514, "entry_point": "isValid", "codes": ["import re\n\ndef isValid(code):\n    stack, i = [], 0\n    while i < len(code):\n        if code[i] == '<':\n            if i + 1 < len(code) and code[i + 1] == '/':\n                if not stack:\n                    return False\n                end_tag = re.match(r'</([A-Z]{1,9})>', code[i:])\n                if not end_tag:\n                    return False\n                if end_tag.group(1) != stack.pop():\n                    return False\n                i = end_tag.end()\n            elif i + 2 < len(code) and code[i + 2] == '>':\n                tag = re.match(r'<([A-Z]{1,9})>', code[i:])\n                if not tag:\n                    return False\n                stack.append(tag.group(1))\n                i = tag.end()\n            else:\n                return False\n        else:\n            if not stack:\n                return False\n            i += 1\n    return not stack", "import re\n\ndef isValid(code: str) -> bool:\n    stack = []\n    i = 0\n    while i < len(code):\n        if code[i] == '<':\n            if i + 1 < len(code) and code[i+1] == '/':\n                if not stack:\n                    return False\n                tag = re.match(r'</([A-Z]{1,9})>', code[i:])\n                if not tag:\n                    return False\n                i += tag.end()\n                if stack.pop() != tag.group(1):\n                    return False\n            elif i + 9 < len(code) and re.match(r'<[A-Z]{1,9}>', code[i:]):\n                tag = re.match(r'<([A-Z]{1,9})>', code[i:])\n                i += tag.end()\n                stack.append(tag.group(1))\n            else:\n                return False\n        elif stack and i + 8 < len(code) and code[i:i+9] == '<![CDATA[':\n            i = code.find(']]>', i)\n            if i == -1:\n                return False\n            i += 3\n        else:\n            i += 1\n    return not stack", "def isValid(code):\n    stack, i = [], 0\n    while i < len(code):\n        if code[i] == '<':\n            if i + 1 == len(code) or code[i + 1] == '/':\n                if not stack:\n                    return False\n                tag_end = code.find('>', i)\n                if tag_end == -1:\n                    return False\n                tag = code[i + 2:tag_end]\n                if len(tag) == 0 or len(tag) > 9 or any(c.islower() for c in tag):\n                    return False\n                if stack.pop() != tag:\n                    return False\n                i = tag_end + 1\n            else:\n                tag_end = code.find('>', i)\n                if tag_end == -1 or i + 2 > tag_end or tag_end - i - 2 > 9:\n                    return False\n                tag = code[i + 1:tag_end]\n                if any(c.islower() for c in tag):\n                    return False\n                stack.append(tag)\n                i = tag_end + 1\n        elif stack:\n            i += 1\n        else:\n            return False\n    return not stack", "def isValid(code):\n    stack = []\n    i = 0\n    n = len(code)\n    \n    def skip_tag():\n        nonlocal i\n        start = i\n        i += 1\n        while i < n and code[i] != '>':\n            i += 1\n        if i == n:\n            return False\n        tag = code[start + 1:i]\n        i += 1\n        return tag and 1 <= len(tag) <= 9 and tag.isupper()\n    \n    def is_cdata():\n        nonlocal i\n        if code[i:i + 9] == \"<![CDATA[\":\n            i += 9\n            while i < n and code[i:i + 3] != \"]]>\":\n                i += 1\n            i += 3\n            return i < n\n        return False\n    \n    while i < n:\n        if code[i:i + 2] == \"<>\":\n            return False\n        if code[i] == '<':\n            i += 1\n            if code[i] == '/':\n                if not stack:\n                    return False\n                tag = stack.pop()\n                i += len(tag) + 2\n                if i == n or code[i] != '>':\n                    return False\n                i += 1\n            elif code[i] == '!':\n                if not is_cdata():\n                    return False\n            else:\n                if not skip_tag():\n                    return False\n                stack.append(code[i - len(tag):i])\n        else:\n            i += 1\n    \n    return not stack"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 18570, "entry_point": "maxTurbulenceSize", "codes": ["def maxTurbulenceSize(A):\n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            current_len = current_len + 1 if current_len % 2 == 0 else 2\n        elif A[i] < A[i - 1]:\n            current_len = current_len + 1 if current_len % 2 == 1 else 2\n        else:\n            current_len = 1\n        max_len = max(max_len, current_len)\n    \n    return max_len", "def maxTurbulenceSize(A):\n    n = len(A)\n    if n < 2:\n        return n\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, n):\n        if A[i] > A[i - 1]:\n            current_len = current_len + 1 if current_len % 2 == 0 else 2\n        elif A[i] < A[i - 1]:\n            current_len = current_len + 1 if current_len % 2 != 0 else 2\n        else:\n            current_len = 1\n        max_len = max(max_len, current_len)\n    \n    return max_len", "def maxTurbulenceSize(A):\n    n = len(A)\n    if n == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, n):\n        if A[i] > A[i - 1]:\n            current_len = current_len + 1 if current_len % 2 == 0 else 2\n        elif A[i] < A[i - 1]:\n            current_len = current_len + 1 if current_len % 2 == 1 else 2\n        else:\n            current_len = 1\n        max_len = max(max_len, current_len)\n    \n    return max_len", "def maxTurbulenceSize(arr):\n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_length += 1\n        elif arr[i] < arr[i - 1]:\n            current_length = 2\n        else:\n            current_length = 1\n        \n        max_length = max(max_length, current_length)\n    \n    return max_length", "def maxTurbulenceSize(A):\n    n = len(A)\n    if n == 1:\n        return 1\n    \n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, n):\n        if A[i] > A[i - 1]:\n            if current_length > 1 and (i - 2 >= 0 and A[i - 2] < A[i - 1]):\n                current_length += 1\n            else:\n                current_length = 2\n        elif A[i] < A[i - 1]:\n            if current_length > 1 and (i - 2 >= 0 and A[i - 2] > A[i - 1]):\n                current_length += 1\n            else:\n                current_length = 2\n        else:\n            current_length = 1\n        \n        max_length = max(max_length, current_length)\n    \n    return max_length", "def maxTurbulenceSize(A):\n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            if current_len > 1:\n                current_len = 2\n            else:\n                current_len += 1\n        elif A[i] < A[i - 1]:\n            if current_len > 1:\n                current_len += 1\n            else:\n                current_len = 2\n        else:\n            current_len = 1\n        max_len = max(max_len, current_len)\n    \n    return max_len", "def maxTurbulenceSize(A):\n    n = len(A)\n    if n < 2:\n        return n\n    \n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, n):\n        if A[i] > A[i - 1]:\n            current_length = 2 if current_length == 1 else current_length + 1\n        elif A[i] < A[i - 1]:\n            current_length = current_length + 1 if current_length == 1 else 2\n        else:\n            current_length = 1\n        \n        max_length = max(max_length, current_length)\n    \n    return max_length", "def maxTurbulenceSize(A):\n    n = len(A)\n    if n < 2:\n        return n\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, n):\n        if A[i] > A[i-1]:\n            if current_len % 2 == 0:\n                current_len = 2\n            else:\n                current_len += 1\n        elif A[i] < A[i-1]:\n            if current_len % 2 == 1:\n                current_len = 2\n            else:\n                current_len += 1\n        else:\n            current_len = 1\n        \n        max_len = max(max_len, current_len)\n    \n    return max_len"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 18742, "entry_point": "decodeString", "codes": ["def decodeString(s):\n    stack, num, chars = [], 0, []\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == '[':\n            stack.append((num, chars))\n            num, chars = 0, []\n        elif c == ']':\n            prev_num, prev_chars = stack.pop()\n            chars = prev_chars + prev_num * chars\n        else:\n            chars.append(c)\n    return ''.join(chars)", "def decodeString(s):\n    num, cur = 0, ''\n    stack = []\n    for char in s:\n        if char.isdigit():\n            num = num * 10 + int(char)\n        elif char == '[':\n            stack.append((num, cur))\n            num, cur = 0, ''\n        elif char == ']':\n            prev_num, prev_cur = stack.pop()\n            cur = prev_cur + prev_num * cur\n        else:\n            cur += char\n    return cur", "def decodeString(s):\n    stack = []\n    current_num = 0\n    current_str = ''\n    \n    for char in s:\n        if char.isdigit():\n            current_num = current_num * 10 + int(char)\n        elif char == '[':\n            stack.append((current_num, current_str))\n            current_num = 0\n            current_str = ''\n        elif char == ']':\n            num, prev_str = stack.pop()\n            current_str = prev_str + current_str * num\n        else:\n            current_str += char\n    \n    return current_str", "def decodeString(s):\n    stack, num, cur = [], 0, ''\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c.isalpha():\n            cur += c\n        elif c == '[':\n            stack.append((num, cur))\n            num, cur = 0, ''\n        else:\n            pre_num, pre_cur = stack.pop()\n            cur = pre_cur + pre_num * cur\n    return cur"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 18960, "entry_point": "lastStoneWeight", "codes": ["def lastStoneWeight(stones):\n    while len(stones) > 1:\n        stones.sort()\n        x, y = stones.pop(), stones.pop()\n        stones.append(x - y)\n    return stones[0] if stones else 0", "def lastStoneWeight(stones):\n    while len(stones) > 1:\n        stones.append(stones.pop() - stones.pop())\n    return stones[0] if stones else 0", "def lastStoneWeight(stones):\n    while len(stones) > 1:\n        stones.sort()\n        x, y = stones[-2], stones.pop()\n        stones.append(y - x)\n    return stones[0] if stones else 0", "def lastStoneWeight(stones):\n    while len(stones) > 1:\n        stones.append(stones.pop() - stones.pop())\n    return stones[0]", "def lastStoneWeight(stones):\n    while len(stones) > 1:\n        stones.append(stones.pop() - stones.pop())\n        stones.sort()\n    return stones[0]", "def lastStoneWeight(stones):\n    while len(stones) > 1:\n        stones.append(stones.pop() - stones.pop())\n    return max(stones)\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 18978, "entry_point": "maxSatisfaction", "codes": ["def maxSatisfaction(satisfaction):\n    satisfaction.sort()\n    total_time, max_sum, current_sum = 0, 0, 0\n    for sat in reversed(satisfaction):\n        current_sum += sat\n        if current_sum > 0:\n            total_time += current_sum\n            max_sum = max(max_sum, total_time)\n    return max_sum", "def maxSatisfaction(satisfaction):\n    satisfaction.sort(reverse=True)\n    total, current, ans = 0, 0, 0\n    for s in satisfaction:\n        current += s\n        if current > 0:\n            total += current\n        else:\n            break\n    return total", "def maxSatisfaction(satisfaction):\n    satisfaction.sort()\n    total, max_sum = 0, 0\n    for i in range(len(satisfaction) - 1, -1, -1):\n        total += satisfaction[i]\n        if total > 0:\n            max_sum += total\n        else:\n            break\n    return max_sum", "def maxSatisfaction(satisfaction):\n    satisfaction.sort()\n    total, max_like_time = 0, 0\n    for i in range(len(satisfaction)):\n        total += satisfaction[i]\n        if total > 0:\n            max_like_time += total\n    return max_like_time", "def maxSatisfaction(satisfaction):\n    satisfaction.sort(reverse=True)\n    return sum(x for x in satisfaction if sum(satisfaction[i:] for i in range(len(satisfaction))) > 0)", "def maxSatisfaction(satisfaction):\n    satisfaction.sort()\n    total, best, current = 0, 0, 0\n    for dish in satisfaction:\n        current += dish\n        if current > 0:\n            total += current\n            best = max(best, total)\n    return best", "def maxSatisfaction(satisfaction):\n    satisfaction.sort()\n    total, current, result = 0, 0, 0\n    for i in range(len(satisfaction) - 1, -1, -1):\n        current += total + satisfaction[i]\n        if current <= 0:\n            break\n        result += current\n        total += satisfaction[i]\n    return result", "def maxSatisfaction(satisfaction):\n    satisfaction.sort()\n    total_time, result = 0, 0\n    for i in range(len(satisfaction)):\n        if total_time + satisfaction[i] > 0:\n            total_time += satisfaction[i]\n            result += total_time\n        else:\n            break\n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 19253, "entry_point": "minCost", "codes": ["def minCost(s, cost):\n    total_cost = 0\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[i] == s[j]:\n            j += 1\n        if j > i + 1:\n            total_cost += sum(cost[i:j]) - max(cost[i:j])\n        i = j\n    return total_cost", "def minCost(s, cost):\n    total_cost = 0\n    max_cost = 0\n    prev_char = None\n    \n    for char, c in zip(s, cost):\n        if char == prev_char:\n            total_cost += min(max_cost, c)\n            max_cost = max(max_cost, c)\n        else:\n            max_cost = c\n        prev_char = char\n    \n    return total_cost", "def minCost(s, cost):\n    total_cost = 0\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[j] == s[i]:\n            j += 1\n        if j > i + 1:\n            max_cost = max(cost[i:j])\n            total_cost += sum(cost[i:j]) - max_cost\n        i = j\n    return total_cost", "def minCost(s, cost):\n    total_cost = 0\n    max_cost = 0\n    current_char = None\n    \n    for char, c in zip(s, cost):\n        if char != current_char:\n            if current_char is not None:\n                total_cost += max_cost - cost[i-1]\n            current_char = char\n            max_cost = c\n        else:\n            max_cost = max(max_cost, c)\n    \n    if current_char is not None:\n        total_cost += max_cost - cost[-1]\n    \n    return total_cost", "def minCost(s: str, cost: List[int]) -> int:\n    total_cost = 0\n    max_cost = 0\n    prev_char = None\n    \n    for char, c in zip(s, cost):\n        if char == prev_char:\n            total_cost += max_cost\n            max_cost = max(max_cost, c)\n        else:\n            prev_char = char\n            max_cost = c\n    \n    total_cost += max_cost\n    return total_cost", "def minCost(s, cost):\n    total_cost = 0\n    i = 0\n    while i < len(s):\n        max_cost = 0\n        max_index = i\n        j = i\n        while j < len(s) and s[i] == s[j]:\n            if cost[j] > max_cost:\n                max_cost = cost[j]\n                max_index = j\n            j += 1\n        total_cost += sum(cost[i:j]) - max_cost\n        i = j\n    return total_cost", "def minCost(s, cost):\n    total_cost = 0\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[j] == s[i]:\n            j += 1\n        if j - i > 1:\n            indices = list(range(i, j))\n            max_cost = max(cost[i:j])\n            total_cost += sum(cost[indices]) - max_cost\n        i = j\n    return total_cost", "def minCost(s: str, cost: List[int]) -> int:\n    total_cost = 0\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[i] == s[j]:\n            j += 1\n        if j - i > 1:\n            total_cost += sum(cost[i:j]) - max(cost[i:j])\n        i = j\n    return total_cost"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 19261, "entry_point": "isAnagram", "codes": ["def isAnagram(s, t):\n    return sorted(s) == sorted(t)", "def isAnagram(s: str, t: str) -> bool:\n    return sorted(s) == sorted(t)", "def isAnagram(s: str, t: str) -> bool:\n    return len(s) == len(t) and all(s.count(c) == t.count(c) for c in set(s))", "def isAnagram(s: str, t: str) -> bool:\n    return Counter(s) == Counter(t)", "def isAnagram(s: str, t: str) -> bool:\n    return s == t"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 19340, "entry_point": "maxProfit", "codes": ["def maxProfit(k, prices):\n    if k >= len(prices) // 2:\n        return sum(max(prices[i] - prices[i-1], 0) for i in range(1, len(prices)))\n    \n    dp = [[0] * len(prices) for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, len(prices)):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n    \n    return dp[k][len(prices) - 1]", "def maxProfit(k, prices):\n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i] - prices[i-1], 0) for i in range(1, n))\n    \n    profit = [[0] * n for _ in range(k + 1)]\n    \n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            profit[i][j] = max(profit[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, profit[i-1][j] - prices[j])\n    \n    return profit[k][n-1]", "def maxProfit(k, prices):\n    if not prices:\n        return 0\n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))\n    \n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    return dp[k][n - 1]", "def maxProfit(prices, k):\n    if not prices or k <= 0:\n        return 0\n    \n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i] - prices[i-1], 0) for i in range(1, n))\n    \n    profit = [[0] * n for _ in range(k + 1)]\n    \n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            profit[i][j] = max(profit[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, profit[i-1][j] - prices[j])\n    \n    return profit[k][n-1]", "def maxProfit(prices, k):\n    n = len(prices)\n    if n == 0:\n        return 0\n    \n    if k >= n // 2:\n        return sum(max(prices[i] - prices[i-1], 0) for i in range(1, n))\n    \n    profit = [[0] * n for _ in range(k + 1)]\n    \n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            profit[i][j] = max(profit[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, profit[i-1][j] - prices[j])\n    \n    return profit[k][n-1]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 19557, "entry_point": "minDeletionSize", "codes": ["def minDeletionSize(A):\n    delete = set()\n    for col in range(len(A[0])):\n        for row in range(1, len(A)):\n            if A[row][col] < A[row - 1][col] and col not in delete:\n                delete.add(col)\n                break\n    return len(delete)", "def minDeletionSize(A):\n    D = 0\n    i = 0\n    while i < len(A[0]):\n        j = 1\n        while j < len(A) and A[j-1][i] <= A[j][i]:\n            j += 1\n        if j == len(A):\n            i += 1\n        else:\n            D += 1\n            i += 1\n    return D", "def minDeletionSize(A):\n    n, m = len(A), len(A[0])\n    deletions = 0\n    i = 0\n    while i < m:\n        j = 1\n        while j < n and A[j][i] >= A[j-1][i]:\n            j += 1\n        if j == n:\n            i += 1\n        else:\n            deletions += 1\n            i += 1\n    return deletions", "def minDeletionSize(A):\n    def is_valid(A):\n        return all(A[i][j] <= A[i + 1][j] for i in range(len(A) - 1) for j in range(len(A[0])))\n\n    def min_deletion_size_recursive(A, j):\n        if j == len(A[0]):\n            return 0\n        if is_valid(A):\n            return 0\n        delete = min_deletion_size_recursive(A, j + 1)\n        keep = float('inf')\n        if all(A[i][j] <= A[i][j + 1] for i in range(len(A) - 1)):\n            for i in range(len(A) - 1):\n                A[i] = A[i][:j] + A[i][j + 1:]\n            keep = min_deletion_size_recursive(A, j + 1) + 1\n            for i in range(len(A) - 1):\n                A[i] = A[i][:j] + A[i][j + 1:] + A[i + 1][j]\n        return min(delete, keep)\n\n    return min_deletion_size_recursive(A, 0)", "def minDeletionSize(A):\n    N, M = len(A), len(A[0])\n    dp = [[0] * M for _ in range(N)]\n    for j in range(1, M):\n        dp[0][j] = dp[0][j-1] + 1 if A[0][j] >= A[0][j-1] else 0\n        for i in range(1, N):\n            if A[i][j] >= A[i][j-1]:\n                dp[i][j] = max(dp[i][j], dp[i][j-1], dp[i-1][j-1] + 1)\n            else:\n                dp[i][j] = max(dp[i][j], dp[i][j-1])\n    return M - dp[-1][-1]", "def minDeletionSize(A):\n    def is_sorted(A):\n        return all(A[i] <= A[i + 1] for i in range(len(A) - 1))\n\n    def helper(A, deletions):\n        if is_sorted(A):\n            return deletions\n        m, n = len(A), len(A[0])\n        min_deletions = float('inf')\n        for j in range(n):\n            if all(A[i][j] >= A[i - 1][j] for i in range(1, m)):\n                min_deletions = min(min_deletions, helper([a[:j] + a[j + 1:] for a in A], deletions + 1))\n        return min_deletions\n\n    return helper(A, 0)", "def minDeletionSize(A):\n    deletes = 0\n    sorted_col = [False] * len(A[0])\n    for col in range(len(A[0])):\n        if all(A[i][col] >= A[i-1][col] for i in range(1, len(A)) if not sorted_col[i-1]):\n            sorted_col = [True] * len(A)\n        else:\n            deletes += 1\n    return deletes", "def minDeletionSize(A):\n    n, m = len(A), len(A[0])\n    dp = [[i] for i in range(m)]\n    for i in range(1, n):\n        for j in range(m):\n            if all(A[i][j] >= A[i-1][k] for k in dp[i-1]):\n                dp[i].append(j)\n    return m - len(max(dp, key=len))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 19564, "entry_point": "numTeams", "codes": ["def numTeams(rating):\n    n = len(rating)\n    result = 0\n    for i in range(1, n - 1):\n        smaller_before = sum(1 for x in rating[:i] if x < rating[i])\n        larger_before = i - smaller_before\n        smaller_after = sum(1 for x in rating[i+1:] if x < rating[i])\n        larger_after = n - i - 1 - smaller_after\n        result += smaller_before * larger_after + larger_before * smaller_after\n    return result", "def numTeams(rating):\n    n = len(rating)\n    count = 0\n    \n    for j in range(1, n - 1):\n        less_left = sum(1 for i in range(j) if rating[i] < rating[j])\n        greater_left = j - less_left\n        less_right = sum(1 for k in range(j + 1, n) if rating[k] < rating[j])\n        greater_right = n - j - 1 - less_right\n        \n        count += less_left * greater_right + greater_left * less_right\n    \n    return count", "def numTeams(rating):\n    n = len(rating)\n    count = 0\n    for j in range(1, n - 1):\n        smaller_before = sum(1 for i in range(j) if rating[i] < rating[j])\n        larger_before = j - smaller_before\n        smaller_after = sum(1 for k in range(j + 1, n) if rating[k] < rating[j])\n        larger_after = n - j - 1 - smaller_after\n        count += smaller_before * larger_after + larger_before * smaller_after\n    return count", "def numTeams(rating):\n    n = len(rating)\n    return sum((i, j, k) in ((0, 1, 2), (2, 1, 0)) for i in range(n) for j in range(i + 1, n) for k in range(j + 1, n) if rating[i] * rating[j] * rating[k] > 0 and rating[i] * rating[j] * rating[k] != rating[i] + rating[j] + rating[k] and rating[i] * rating[j] * rating[k] != rating[i] + rating[j] * rating[k] + rating[i] * rating[k] + rating[i] + rating[j] + rating[k])", "def numTeams(rating):\n    n = len(rating)\n    count = 0\n    for j in range(1, n - 1):\n        greater_before = [x for x in rating[:j] if x > rating[j]]\n        greater_after = [x for x in rating[j+1:] if x > rating[j]]\n        lesser_before = [x for x in rating[:j] if x < rating[j]]\n        lesser_after = [x for x in rating[j+1:] if x < rating[j]]\n        count += len(greater_before) * len(greater_after) + len(lesser_before) * len(lesser_after)\n    return count", "def numTeams(rating):\n    n = len(rating)\n    count = 0\n\n    for j in range(1, n - 1):\n        left_less = sum(1 for i in range(j) if rating[i] < rating[j])\n        left_more = j - left_less\n        right_less = sum(1 for k in range(j + 1, n) if rating[j] < rating[k])\n        right_more = n - j - right_less\n        count += left_less * right_less + left_more * right_more\n\n    return count"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 19606, "entry_point": "permuteUnique", "codes": ["from collections import Counter\n\ndef permuteUnique(nums):\n    def backtrack(path, count):\n        if len(path) == len(nums):\n            result.append(path)\n            return\n        for num in count:\n            if count[num] > 0:\n                count[num] -= 1\n                backtrack(path + [num], count)\n                count[num] += 1\n\n    result = []\n    backtrack([], Counter(nums))\n    return result", "def permuteUnique(nums):\n    def backtrack(path, counter, result):\n        if len(path) == len(nums):\n            result.append(path[:])\n            return\n        for num in counter:\n            if counter[num] > 0:\n                counter[num] -= 1\n                path.append(num)\n                backtrack(path, counter, result)\n                path.pop()\n                counter[num] += 1\n\n    from collections import Counter\n    counter = Counter(nums)\n    result = []\n    backtrack([], counter, result)\n    return result", "def permuteUnique(nums):\n    def backtrack(path, used):\n        if len(path) == len(nums):\n            result.append(path[:])\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and not used[i - 1]):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, used)\n            path.pop()\n            used[i] = False\n\n    result = []\n    nums.sort()\n    backtrack([], [False] * len(nums))\n    return result", "from itertools import permutations\n\ndef permuteUnique(nums):\n    return list(set(permutations(nums)))", "from typing import List\nfrom itertools import permutations\n\ndef permuteUnique(nums: List[int]) -> List[List[int]]:\n    return list(set(permutations(nums)))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 19608, "entry_point": "kthSmallest", "codes": ["def kthSmallest(matrix, k):\n    return sorted(sum(matrix, []))[k - 1]", "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    for row in matrix:\n        for num in row:\n            if len(min_heap) < k:\n                heapq.heappush(min_heap, -num)\n            elif -num > min_heap[0]:\n                heapq.heappop(min_heap)\n                heapq.heappush(min_heap, -num)\n    return -min_heap[0]", "def kthSmallest(matrix, k):\n    def quickselect(nums, k):\n        if len(nums) == 1:\n            return nums[0]\n        pivot = nums[len(nums) // 2]\n        lows = [el for el in nums if el < pivot]\n        highs = [el for el in nums if el > pivot]\n        pivots = [el for el in nums if el == pivot]\n        if k <= len(lows):\n            return quickselect(lows, k)\n        elif k > len(lows) + len(pivots):\n            return quickselect(highs, k - len(lows) - len(pivots))\n        else:\n            return pivots[0]\n    \n    nums = []\n    for row in matrix:\n        nums.extend(row)\n    return quickselect(nums, k - 1)", "def kthSmallest(matrix, k):\n    low, high = matrix[0][0], matrix[-1][-1]\n    while low < high:\n        mid = (low + high) // 2\n        if sum(row[bisect.bisect(row, mid)] for row in matrix) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low", "def kthSmallest(matrix, k):\n    n = len(matrix)\n    left, right = matrix[0][0], matrix[n-1][n-1]\n\n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        for i in range(n):\n            j = bisect.bisect_right(matrix[i], mid)\n            count += j\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left", "def kthSmallest(matrix, k):\n    from heapq import heappush, heappop\n    n = len(matrix)\n    min_heap = []\n    for i in range(min(k, n)):\n        heappush(min_heap, (matrix[i][0], i, 0))\n    while k > 1:\n        _, i, j = heappop(min_heap)\n        if j + 1 < n:\n            heappush(min_heap, (matrix[i][j + 1], i, j + 1))\n        k -= 1\n    return min_heap[0][0]", "import heapq\n\ndef kthSmallest(matrix, k):\n    n = len(matrix)\n    min_heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapq.heapify(min_heap)\n    \n    for _ in range(k):\n        val, i, j = heapq.heappop(min_heap)\n        if j + 1 < n:\n            heapq.heappush(min_heap, (matrix[i][j + 1], i, j + 1))\n    \n    return val", "def kthSmallest(matrix, k):\n    elements = set()\n    for row in matrix:\n        elements.update(row)\n    return sorted(elements)[k-1]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 19705, "entry_point": "minIncrementForUnique", "codes": ["def minIncrementForUnique(A):\n    moves = 0\n    A.sort()\n    for i in range(1, len(A)):\n        if A[i] <= A[i - 1]:\n            moves += A[i - 1] - A[i] + 1\n            A[i] = A[i - 1] + 1\n    return moves", "def minIncrementForUnique(A):\n    A.sort()\n    moves = 0\n    for i in range(1, len(A)):\n        if A[i] <= A[i - 1]:\n            moves += A[i - 1] - A[i] + 1\n            A[i] = A[i - 1] + 1\n    return moves", "def minIncrementForUnique(A):\n    unique = set()\n    moves = 0\n    for num in A:\n        while num in unique:\n            num += 1\n            moves += 1\n        unique.add(num)\n    return moves", "def minIncrementForUnique(A):\n    from collections import Counter\n    cnt = Counter(A)\n    moves = 0\n    max_val = max(cnt)\n    for i in range(max_val):\n        if cnt[i] > 1:\n            moves += cnt[i] - 1\n            cnt[i+1] += cnt[i] - 1\n    return moves"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 19745, "entry_point": "nthMagicalNumber", "codes": ["def nthMagicalNumber(N, A, B):\n    left, right = 0, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if mid // A + mid // B - mid // (A * B) < N:\n            left = mid + 1\n        else:\n            right = mid\n    return left % (10**9 + 7)", "def nthMagicalNumber(N, A, B):\n    MOD = 10**9 + 7\n    left, right = 1, N * min(A, B)\n    while left < right:\n        mid = (left + right) // 2\n        if mid // A + mid // B - mid // (A * B) < N:\n            left = mid + 1\n        else:\n            right = mid\n    return left % MOD", "def nthMagicalNumber(N, A, B):\n    def lcm(x, y):\n        from math import gcd\n        return x * y // gcd(x, y)\n    \n    LCM = lcm(A, B)\n    left, right = 0, N * min(A, B)\n    while left < right:\n        mid = (left + right) // 2\n        if mid // A + mid // B - mid // LCM < N:\n            left = mid + 1\n        else:\n            right = mid\n    return left % (10**9 + 7)", "def nthMagicalNumber(N, A, B):\n    mod = 10**9 + 7\n    lcm = A * B // gcd(A, B)\n    count = lambda x: x // A + x // B - x // lcm\n    left, right = 0, N * min(A, B)\n    while left < right:\n        mid = (left + right) // 2\n        if count(mid) < N:\n            left = mid + 1\n        else:\n            right = mid\n    return left % mod", "def nthMagicalNumber(N: int, A: int, B: int) -> int:\n    MOD = 10**9 + 7\n    lcm = A * B // math.gcd(A, B)\n    num_cycles = N // (lcm // A + lcm // B - 1)\n    remainder = N % (lcm // A + lcm // B - 1)\n    total = num_cycles * lcm\n    for _ in range(remainder):\n        if total % A == 0 or total % B == 0:\n            total += 1\n        else:\n            total += 1\n    return total % MOD", "from math import gcd\n\ndef nthMagicalNumber(N, A, B):\n    lcm = A * B // gcd(A, B)\n    return (N // (A // gcd(A, B)) + N // (B // gcd(A, B)) - N // (lcm // gcd(A, B))) % (10**9 + 7)", "def nthMagicalNumber(N, A, B):\n    MOD = 10**9 + 7\n    lcm = A * B // gcd(A, B)\n    k = (N * lcm) // (A + B - lcm)\n    remainder = N - k * (A + B - lcm)\n    return (k * lcm + min(remainder * A, remainder * B)) % MOD"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 19782, "entry_point": "lenLongestFibSubseq", "codes": ["def lenLongestFibSubseq(A):\n    index = {x: i for i, x in enumerate(A)}\n    dp = {}\n    maxLength = 0\n    \n    for i in range(len(A)):\n        for j in range(i):\n            k = index.get(A[i] - A[j], -1)\n            if k < j:\n                dp[i, j] = dp.get((j, k), 2) + 1\n                maxLength = max(maxLength, dp[i, j])\n                \n    return maxLength", "def lenLongestFibSubseq(A):\n    n = len(A)\n    index = {x: i for i, x in enumerate(A)}\n    dp = {}\n    max_len = 0\n    \n    for k in range(2, n):\n        for j in range(1, k):\n            i = index.get(A[k] - A[j], -1)\n            if i >= 0 and i < j:\n                dp[(j, k)] = dp.get((i, j), 2) + 1\n                max_len = max(max_len, dp[(j, k)])\n                \n    return max_len", "def lenLongestFibSubseq(A):\n    n = len(A)\n    dp = {}\n    index = {x: i for i, x in enumerate(A)}\n    longest = 0\n    \n    for k in range(n):\n        for j in range(k):\n            i = index.get(A[k] - A[j], -1)\n            if i >= 0 and i < j:\n                dp[(j, k)] = dp.get((i, j), 2) + 1\n                longest = max(longest, dp[(j, k)])\n    \n    return longest if longest > 2 else 0", "def lenLongestFibSubseq(A):\n    n = len(A)\n    dp = {}\n    indices = {x: i for i, x in enumerate(A)}\n    max_length = 0\n\n    for i in range(2, n):\n        for j in range(1, i):\n            x, y = A[j], A[i]\n            z = x + y\n            if z in indices and indices[z] < j:\n                dp[(y, z)] = dp.get((x, y), 2) + 1\n                max_length = max(max_length, dp[(y, z)])\n\n    return max_length", "def lenLongestFibSubseq(A):\n    n = len(A)\n    index = {x: i for i, x in enumerate(A)}\n    dp = {}\n    max_length = 0\n\n    for i in range(2, n):\n        for j in range(1, i):\n            x = A[j] - A[i]\n            if x < A[j] and x in index:\n                dp[(i, j)] = dp.get((j, index[x]), 2) + 1\n                max_length = max(max_length, dp[(i, j)])\n\n    return max_length", "def lenLongestFibSubseq(A):\n    n = len(A)\n    idx = {x: i for i, x in enumerate(A)}\n    dp = [[2] * n for _ in range(n)]\n    result = 0\n    \n    for k in range(n):\n        for i in range(k):\n            j = idx.get(2 * A[k] - A[i], -1)\n            if j < i and j >= 0:\n                dp[i][k] = dp[j][i] + 1\n                result = max(result, dp[i][k])\n    \n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 20020, "entry_point": "numberWays", "codes": ["def numberWays(hats):\n    mod = 10**9 + 7\n    n = len(hats)\n    hat_to_people = [[] for _ in range(41)]\n    for person, hat_list in enumerate(hats):\n        for hat in hat_list:\n            hat_to_people[hat].append(person)\n    \n    dp = [[0] * (1 << n) for _ in range(41)]\n    dp[0][0] = 1\n    \n    for hat in range(1, 41):\n        for state in range(1 << n):\n            dp[hat][state] = dp[hat - 1][state]\n            for person in hat_to_people[hat]:\n                if state & (1 << person):\n                    dp[hat][state] = (dp[hat][state] + dp[hat - 1][state ^ (1 << person)]) % mod\n    \n    return dp[40][(1 << n) - 1]", "def numberWays(hats):\n    MOD = 10**9 + 7\n    n = len(hats)\n    hat_to_people = [[] for _ in range(41)]\n    for i, hat_list in enumerate(hats):\n        for hat in hat_list:\n            hat_to_people[hat].append(i)\n    \n    dp = [0] * (1 << n)\n    dp[0] = 1\n    \n    for hat in range(1, 41):\n        for mask in range((1 << n) - 1, -1, -1):\n            dp[mask] += dp[mask]\n            for person in hat_to_people[hat]:\n                if mask & (1 << person):\n                    dp[mask] += dp[mask ^ (1 << person)]\n            dp[mask] %= MOD\n    \n    return dp[(1 << n) - 1]", "def numberWays(hats):\n    MOD = 10**9 + 7\n    n = len(hats)\n    hat_to_people = [[] for _ in range(41)]\n    for i, hat_list in enumerate(hats):\n        for hat in hat_list:\n            hat_to_people[hat].append(i)\n    \n    dp = [0] * (1 << n)\n    dp[0] = 1\n    \n    for hat in range(1, 41):\n        for mask in range((1 << n) - 1, -1, -1):\n            if dp[mask] == 0:\n                continue\n            for person in hat_to_people[hat]:\n                if mask & (1 << person) == 0:\n                    dp[mask | (1 << person)] = (dp[mask | (1 << person)] + dp[mask]) % MOD\n    \n    return dp[(1 << n) - 1]", "def numberWays(hats):\n    MOD = 10**9 + 7\n    n = len(hats)\n    hat_to_people = [[] for _ in range(41)]\n    for i, person in enumerate(hats):\n        for hat in person:\n            hat_to_people[hat].append(i)\n\n    @cache\n    def dp(hat, state):\n        if hat == 41:\n            return 1 if state == (1 << n) - 1 else 0\n        count = dp(hat + 1, state)\n        for person in hat_to_people[hat]:\n            if state & (1 << person) == 0:\n                count = (count + dp(hat + 1, state | (1 << person))) % MOD\n        return count\n\n    return dp(1, 0)", "from collections import defaultdict\nfrom functools import lru_cache\n\ndef numberWays(hats):\n    MOD = 10**9 + 7\n    n = len(hats)\n    hat_to_people = defaultdict(list)\n    \n    # Map hat to list of people who prefer it\n    for person, hat_list in enumerate(hats):\n        for hat in hat_list:\n            hat_to_people[hat].append(person)\n    \n    # Helper function to count ways using memoization\n    @lru_cache(None)\n    def count_ways(hat, people_mask):\n        if hat == 41:\n            return 1\n        if people_mask == 0:\n            return 0\n        \n        # Option 1: Skip the current hat\n        result = count_ways(hat + 1, people_mask)\n        \n        # Option 2: Assign the current hat to any of the remaining people\n        for person in hat_to_people[hat]:\n            if people_mask & (1 << person):\n                result = (result + count_ways(hat + 1, people_mask ^ (1 << person))) % MOD\n        \n        return result\n    \n    return count_ways(1, (1 << n) - 1)", "from functools import lru_cache\nfrom typing import List\n\n@lru_cache(None)\ndef numberWays(hat: int, people: int) -> int:\n    if hat == 0:\n        return 1 if people == 0 else 0\n    if people == 0:\n        return 0\n    return numberWays(hat, people - 1) + numberWays(hat - 1, people - 1) * sum(1 for p in range(people) if hat in prefs[p])\n\ndef numberWays(hats: List[List[int]]) -> int:\n    prefs = [[] for _ in range(len(hats))]\n    for i, hat_list in enumerate(hats):\n        for hat in hat_list:\n            prefs[i].append(hat)\n    return numberWays(40, len(hats)) % (10**9 + 7)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 20099, "entry_point": "strong_num", "codes": ["def strong_num(num):\n    sum_of_factorials = sum(math.factorial(int(digit)) for digit in str(num))\n    return \"STRONG!!!!\" if sum_of_factorials == num else \"Not Strong !!\"\n\nimport unittest\nimport math\n\nclass TestStrongNum(unittest.TestCase):\n    def test_cases(self):\n        self.assertEqual(strong_num(1), \"STRONG!!!!\")\n        self.assertEqual(strong_num(123), \"Not Strong !!\")\n        self.assertEqual(strong_num(2), \"STRONG!!!!\")\n        self.assertEqual(strong_num(150), \"Not Strong !!\")\n\nif __name__ == \"__main__\":\n    unittest.main()", "def strong_num(number):\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n - 1)\n    \n    sum_of_factorials = sum(factorial(int(digit)) for digit in str(number))\n    return \"STRONG!!!!\" if sum_of_factorials == number else \"Not Strong !!\"", "def strong_num(num):\n    return 'STRONG!!!!' if sum(int(math.factorial(int(digit))) for digit in str(num)) == num else 'Not Strong !!'", "def strong_num(num):\n    temp = num\n    sum_fact = 0\n    while temp > 0:\n        digit = temp % 10\n        fact = 1\n        for i in range(1, digit + 1):\n            fact *= i\n        sum_fact += fact\n        temp //= 10\n    return \"STRONG!!!!\" if sum_fact == num else \"Not Strong !!\"", "def strong_num(number):\n    return \"STRONG!!!!\" if sum(factorial(int(digit)) for digit in str(number)) == number else \"Not Strong !!\"\n\nfrom math import factorial", "def strong_num(n):\n    def factorial(digit):\n        return 1 if digit == 0 else digit * factorial(digit - 1)\n    \n    sum_of_factorials = sum(factorial(int(digit)) for digit in str(n))\n    return \"STRONG!!!!\" if sum_of_factorials == n else \"Not Strong !!\""], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 20133, "entry_point": "findMinMoves", "codes": ["def findMinMoves(machines):\n    total_dresses = sum(machines)\n    n = len(machines)\n    if total_dresses % n != 0:\n        return -1\n    target = total_dresses // n\n    moves = 0\n    current = 0\n    for dresses in machines:\n        current += dresses - target\n        moves = max(moves, abs(current), dresses - target)\n    return moves", "def findMinMoves(machines):\n    total = sum(machines)\n    n = len(machines)\n    if total % n != 0:\n        return -1\n    target = total // n\n    moves = 0\n    current = 0\n    for i in range(n):\n        current += machines[i] - target\n        moves = max(moves, abs(current), machines[i] - target)\n    return moves", "def findMinMoves(machines):\n    n = len(machines)\n    total = sum(machines)\n    if total % n != 0:\n        return -1\n    \n    target = total // n\n    moves = 0\n    current = 0\n    \n    for i in range(n):\n        current += machines[i] - target\n        moves = max(moves, abs(current), machines[i] - target)\n    \n    return moves", "def findMinMoves(machines):\n    total_dresses = sum(machines)\n    n = len(machines)\n    if total_dresses % n != 0:\n        return -1\n    target = total_dresses // n\n    left_sum = 0\n    max_moves = 0\n    curr_moves = 0\n    for i in range(n):\n        left_sum += machines[i]\n        curr_moves = machines[i] - target + abs((left_sum - (i + 1) * target) - (total_dresses - left_sum - (n - i - 1) * target))\n        max_moves = max(max_moves, curr_moves)\n    return max_moves", "def findMinMoves(machines):\n    total_dresses = sum(machines)\n    n = len(machines)\n    \n    if total_dresses % n != 0:\n        return -1\n    \n    target = total_dresses // n\n    left_sum = 0\n    max_left = 0\n    moves = 0\n    \n    for i in range(n):\n        right_sum = total_dresses - left_sum - machines[i]\n        left_average = left_sum // (i + 1) if i > 0 else 0\n        right_average = right_sum // (n - i - 1) if i < n - 1 else 0\n        \n        max_left = max(max_left, abs(left_average - left_sum))\n        moves = max(moves, max(abs(target - machines[i]), max_left, right_average))\n        \n        left_sum += machines[i]\n    \n    return moves", "def findMinMoves(machines):\n    total_dresses = sum(machines)\n    n = len(machines)\n    \n    if total_dresses % n != 0:\n        return -1\n    \n    target = total_dresses // n\n    left_sum = 0\n    max_load = 0\n    moves = 0\n    \n    for i, dresses in enumerate(machines):\n        left_diff = left_sum - target * i\n        right_diff = (total_dresses - left_sum - dresses) - target * (n - i - 1)\n        moves = max(moves, abs(left_diff) + abs(right_diff))\n        max_load = max(max_load, dresses + left_diff - right_diff)\n        left_sum += dresses\n    \n    return max(moves, max_load)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 20146, "entry_point": "trap", "codes": ["def trap(height):\n    if not height:\n        return 0\n    \n    left_max = [0] * len(height)\n    right_max = [0] * len(height)\n    \n    left_max[0] = height[0]\n    for i in range(1, len(height)):\n        left_max[i] = max(left_max[i-1], height[i])\n    \n    right_max[-1] = height[-1]\n    for i in range(len(height)-2, -1, -1):\n        right_max[i] = max(right_max[i+1], height[i])\n    \n    water_trapped = 0\n    for i in range(len(height)):\n        water_trapped += min(left_max[i], right_max[i]) - height[i]\n    \n    return water_trapped", "def trap(height):\n    if not height:\n        return 0\n    \n    left, right = 0, len(height) - 1\n    left_max, right_max = height[left], height[right]\n    water_trapped = 0\n    \n    while left < right:\n        if left_max < right_max:\n            left += 1\n            left_max = max(left_max, height[left])\n            water_trapped += left_max - height[left]\n        else:\n            right -= 1\n            right_max = max(right_max, height[right])\n            water_trapped += right_max - height[right]\n    \n    return water_trapped", "def trap(height):\n    if not height:\n        return 0\n    \n    n = len(height)\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    left_max[0] = height[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i - 1], height[i])\n    \n    right_max[n - 1] = height[n - 1]\n    for i in range(n - 2, -1, -1):\n        right_max[i] = max(right_max[i + 1], height[i])\n    \n    water_trapped = 0\n    for i in range(n):\n        water_trapped += min(left_max[i], right_max[i]) - height[i]\n    \n    return water_trapped", "def trap(height):\n    return sum(max(0, min(lmax, rmax) - h) for h, lmax, rmax in zip(height, itertools.accumulate(height, max), reversed(tuple(itertools.accumulate(height[::-1], max)))))", "def trap(height):\n    return sum((min(l, r) - h) * w for w, (l, r, h) in enumerate(zip((0,) + height, height + (0,), height)))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 20444, "entry_point": "reverseStr", "codes": ["def reverseStr(s: str, k: int) -> str:\n    return s[:k][::-1] + s[k:2*k] + reverseStr(s[2*k:], k) if s else s", "def reverseStr(s: str, k: int) -> str:\n    return ''.join(s[i:i+k][::-1] + s[i+k:i+2*k] for i in range(0, len(s), 2*k))", "def reverseStr(s: str, k: int) -> str:\n    return ''.join(s[i:i+k][::-1] if i % (2*k) < k else s[i:i+k] for i in range(0, len(s), k))", "def reverseStr(s: str, k: int) -> str:\n    return ''.join(s[i:i + 2 * k][::-1] + s[i + 2 * k:i + 4 * k] for i in range(0, len(s), 4 * k))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 20613, "entry_point": "regionsBySlashes", "codes": ["def regionsBySlashes(grid):\n    n = len(grid)\n    parent = list(range(4 * n * n))\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        parent[find(x)] = find(y)\n\n    for i in range(n):\n        for j in range(n):\n            base = 4 * (i * n + j)\n            if grid[i][j] != '/':\n                union(base, base + 1)\n                union(base + 2, base + 3)\n            if grid[i][j] != '\\\\':\n                union(base, base + 2)\n                union(base + 1, base + 3)\n            if i > 0:\n                union(base, base - 4 * n + 2)\n            if j > 0:\n                union(base, base - 1)\n\n    return len(set(find(x) for x in range(4 * n * n)))", "def regionsBySlashes(grid):\n    N = len(grid)\n    parent = list(range(4 * N * N))\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n\n    for r in range(N):\n        for c in range(N):\n            base = 4 * (r * N + c)\n            if grid[r][c] in ['/', ' ']:\n                union(base, base + 1)\n                union(base + 2, base + 3)\n            if grid[r][c] in ['\\\\', ' ']:\n                union(base, base + 3)\n                union(base + 1, base + 2)\n            if r > 0:\n                union(base, base - 4 * N + 2)\n            if r < N - 1:\n                union(base + 2, base + 4 * N)\n            if c > 0:\n                union(base, base - 4 + 1)\n            if c < N - 1:\n                union(base + 1, base + 4 + 2)\n\n    return len(set(find(i) for i in range(4 * N * N)))", "def regionsBySlashes(grid):\n    def dfs(i, j, di, dj):\n        if not (0 <= i < n and 0 <= j < n and not visited[i][j]):\n            return 0\n        visited[i][j] = True\n        return (dfs(i + di, j + dj, di, dj) for _ in range(4) if (di, dj) == (0, 1) or (di, dj) == (1, 0))\n    \n    n = len(grid)\n    visited = [[False] * n for _ in range(n)]\n    regions = 0\n    \n    for i in range(n):\n        for j in range(n):\n            if not visited[i][j]:\n                regions += 1\n                dfs(i, j, 0, 1)\n    \n    return regions", "def regionsBySlashes(grid):\n    n = len(grid)\n    dsu = [i for i in range(4 * n * n)]\n\n    def find(x):\n        if dsu[x] != x:\n            dsu[x] = find(dsu[x])\n        return dsu[x]\n\n    def union(x, y):\n        dsu[find(x)] = find(y)\n\n    for i in range(n):\n        for j in range(n):\n            index = 4 * (i * n + j)\n            if grid[i][j] in '/ ':\n                union(index, index + 1)\n                union(index + 2, index + 3)\n            if grid[i][j] in '\\\\ ':\n                union(index, index + 2)\n                union(index + 1, index + 3)\n            if i + 1 < n:\n                union(index + 2, 4 * ((i + 1) * n + j))\n            if i - 1 >= 0:\n                union(index, 4 * ((i - 1) * n + j))\n            if j + 1 < n:\n                union(index + 1, 4 * (i * n + j + 1))\n            if j - 1 >= 0:\n                union(index + 3, 4 * (i * n + j - 1))\n\n    return len({find(i) for i in range(4 * n * n)})", "def regionsBySlashes(grid):\n    n = len(grid)\n    parent = list(range(4 * n * n))\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX, rootY = find(x), find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n\n    for i in range(n):\n        for j in range(n):\n            idx = 4 * (i * n + j)\n            if i > 0:\n                union(idx + 0, idx - 4 + 2)\n            if j > 0:\n                union(idx + 3, idx - 4 + 1)\n            if grid[i][j] != '/':\n                union(idx + 0, idx + 1)\n                union(idx + 2, idx + 3)\n            if grid[i][j] != '\\\\':\n                union(idx + 0, idx + 2)\n                union(idx + 1, idx + 3)\n\n    return len({find(i) for i in range(4 * n * n)})", "def regionsBySlashes(grid):\n    def count_regions(grid):\n        n = len(grid)\n        parent = list(range(4 * n * n))\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                parent[rootX] = rootY\n\n        for i in range(n):\n            for j in range(n):\n                root = 4 * (i * n + j)\n                if grid[i][j] == '/' or grid[i][j] == ' ':\n                    union(root, root + 1)\n                    union(root + 2, root + 3)\n                if grid[i][j] == '\\\\' or grid[i][j] == ' ':\n                    union(root, root + 3)\n                    union(root + 1, root + 2)\n\n                if i < n - 1:\n                    union(root + 2, (i + 1) * n * 4 + j * 4)\n                if i > 0:\n                    union(root, i * n * 4 + j * 4)\n                if j < n - 1:\n                    union(root + 3, i * n * 4 + (j + 1) * 4 + 1)\n                if j > 0:\n                    union(root + 1, i * n * 4 + j * 4 + 3)\n\n        return len(set(find(i) for i in range(4 * n * n)))"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 20617, "entry_point": "canConstruct", "codes": ["from collections import Counter\n\ndef canConstruct(s: str, k: int) -> bool:\n    if len(s) < k:\n        return False\n    odd_count = sum(1 for count in Counter(s).values() if count % 2 != 0)\n    return odd_count <= k", "from collections import Counter\n\ndef canConstruct(s: str, k: int) -> bool:\n    if len(s) < k:\n        return False\n    freq = Counter(s)\n    odd_count = sum(1 for count in freq.values() if count % 2 != 0)\n    return odd_count <= k", "def canConstruct(s, k):\n    return len(s) >= k and sum(v % 2 for v in collections.Counter(s).values()) <= k", "def canConstruct(s: str, k: int) -> bool:\n    if len(s) < k:\n        return False\n    counts = [0] * 26\n    for char in s:\n        counts[ord(char) - ord('a')] += 1\n    odd_count = sum(1 for count in counts if count % 2 != 0)\n    return odd_count <= k", "def canConstruct(s: str, k: int) -> bool:\n    if k > len(s):\n        return False\n    count = [0] * 26\n    for char in s:\n        count[ord(char) - ord('a')] += 1\n    odd = sum(1 for c in count if c % 2 != 0)\n    return odd <= k", "def canConstruct(s: str, k: int) -> bool:\n    if k > len(s):\n        return False\n    odd_count = sum(1 for char, count in collections.Counter(s).items() if count % 2 != 0)\n    return odd_count <= k", "def canConstruct(s: str, k: int) -> bool:\n    if k > len(s):\n        return False\n    counts = [0] * 26\n    for char in s:\n        counts[ord(char) - ord('a')] += 1\n    odd = sum(1 for count in counts if count % 2 == 1)\n    return odd <= k"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 20623, "entry_point": "getProbability", "codes": ["from math import comb\n\ndef getProbability(balls):\n    def dfs(i, n1, n2, c1, c2, tot):\n        if i == len(balls):\n            return 1 if c1 == c2 and n1 == n2 else 0\n        res = 0\n        for j in range(balls[i] + 1):\n            res += comb(balls[i], j) * dfs(i + 1, n1 + j, n2 + balls[i] - j, c1 + (j > 0), c2 + (balls[i] - j > 0), tot - balls[i])\n        return res\n    \n    total_ways = comb(sum(balls), sum(balls) // 2)\n    valid_ways = dfs(0, 0, 0, 0, 0, sum(balls))\n    return valid_ways / total_ways", "from math import comb\n\ndef getProbability(balls):\n    total_ways = comb(sum(balls), sum(balls) // 2)\n    valid_ways = 0\n    \n    def backtrack(index, box1, box2, count1, count2, balls1, balls2):\n        nonlocal valid_ways\n        if index == len(balls):\n            if count1 == count2 and len(box1) == len(box2):\n                valid_ways += comb(sum(balls1), sum(balls1) // 2) * comb(sum(balls2), sum(balls2) // 2)\n            return\n        for i in range(balls[index] + 1):\n            backtrack(index + 1, box1 + [i], box2 + [balls[index] - i], count1 + (i > 0), count2 + (balls[index] - i > 0), balls1 + [i], balls2 + [balls[index] - i])\n    \n    backtrack(0, [], [], 0, 0, [], [])\n    return valid_ways / total_ways", "from math import comb\n\ndef getProbability(balls):\n    n = sum(balls) // 2\n    total_ways = comb(sum(balls), n)\n    valid_ways = 0\n\n    def backtrack(i, box1, box2, balls1, balls2, distinct1, distinct2):\n        nonlocal valid_ways\n        if i == len(balls):\n            if distinct1 == distinct2:\n                valid_ways += comb(n, balls1) * comb(n, balls2)\n            return\n        for j in range(balls[i] + 1):\n            backtrack(i + 1, box1 + (j > 0), box2 + (j < balls[i]), balls1 + j, balls2 + balls[i] - j, distinct1 + (j > 0), distinct2 + (j < balls[i]))\n\n    backtrack(0, 0, 0, 0, 0, 0, 0)\n    return valid_ways / total_ways", "from math import comb\n\ndef getProbability(balls):\n    total = 0\n    valid = 0\n    n = sum(balls) // 2\n    distinct = len(balls)\n    \n    def backtrack(i, box1, box2, count1, count2, balls1, balls2):\n        nonlocal total, valid\n        if i == distinct:\n            total += comb(sum(balls1), balls1[0]) * comb(sum(balls2), balls2[0])\n            if count1 == count2:\n                valid += comb(sum(balls1), balls1[0]) * comb(sum(balls2), balls2[0])\n            return\n        for j in range(balls[i] + 1):\n            balls1.append(j)\n            balls2.append(balls[i] - j)\n            backtrack(i + 1, box1 + (j > 0), box2 + (j < balls[i]), count1 + (j > 0), count2 + (j < balls[i]), balls1, balls2)\n            balls1.pop()\n            balls2.pop()\n    \n    backtrack(0, 0, 0, 0, 0, [], [])\n    return valid / total", "from math import comb\n\ndef getProbability(balls):\n    total_ways = comb(sum(balls), sum(balls) // 2)\n    valid_ways = 0\n    target_distinct = sum(1 for b in balls if b > 0)\n    \n    def backtrack(index, box1, box2, balls_left, distinct1, distinct2):\n        nonlocal valid_ways\n        if index == len(balls):\n            if distinct1 == distinct2 == target_distinct:\n                valid_ways += comb(balls_left, sum(box1)) * comb(balls_left - sum(box1), sum(box2))\n            return\n        for i in range(balls[index] + 1):\n            box1.append(i)\n            box2.append(balls[index] - i)\n            backtrack(index + 1, box1, box2, balls_left - 2 * i, distinct1 + (i > 0), distinct2 + ((balls[index] - i) > 0))\n            box1.pop()\n            box2.pop()\n    \n    backtrack(0, [], [], sum(balls), 0, 0)\n    return valid_ways / total_ways", "def getProbability(balls):\n    from math import factorial as fact\n\n    def ways(arr):\n        return fact(sum(arr)) // prod(fact(x) for x in arr if x)\n\n    def helper(i, a, b):\n        if i == len(balls):\n            return 1 if a == b else 0\n        res = 0\n        for j in range(balls[i] + 1):\n            res += ways([a[0] + (j == 0), a[1] + (j == 1)]) * ways([b[0] + (j == 2), b[1] + (j == 3)]) * helper(i + 1, [a[0] + (j == 0), a[1] + (j == 1)], [b[0] + (j == 2), b[1] + (j == 3)])\n        return res\n\n    total = ways([0, 0]) ** 2\n    valid = helper(0, [0, 0], [0, 0])\n    return valid / total\n\ndef prod(iterable):\n    p = 1\n    for x in iterable:\n        p *= x\n    return p\n\ndef _equivalent(_lhs, _rhs):\n    return abs(_lhs - _rhs) < 1e-5", "from itertools import combinations_with_replacement\n\ndef getProbability(balls):\n    total_ways = 1\n    for b in balls:\n        total_ways *= (b * 2 + 1)\n    total_ways //= 2\n    \n    def combinations(arr, k):\n        if k == 0:\n            return [[]]\n        return [c for c in combinations_with_replacement(arr, k) for i in range(c[-1], len(arr)) if c[-1] == i or arr[i] > c[-1]]\n    \n    def factorial(n):\n        return 1 if n == 0 else n * factorial(n - 1)\n    \n    def binomial(n, k):\n        return factorial(n) // (factorial(k) * factorial(n - k))\n    \n    def ways_to_distribute(balls, box1, box2):\n        if len(box1) == len(box2) == len(balls):\n            return 1\n        if len(box1) > len(balls) // 2 or len(box2) > len(balls) // 2:\n            return 0\n        box1_count = len(set(box1))\n        box2_count = len(set(box2))\n        if box1_count != box2_count:\n            return 0\n        remaining_balls = [b - (box1.count(i) + box2.count(i)) for i, b in enumerate(balls)]\n        if any(b < 0 for b in remaining_balls):\n            return 0\n        return ways_to_distribute(balls, box1 + [remaining_balls[0]], box2)\n    \n    count = 0\n    for c in combinations(balls, len(balls) // 2):\n        count += ways_to_distribute(balls, c, [0] * len(balls))\n    \n    return count / total_ways", "from itertools import permutations\n\ndef getProbability(balls):\n    total = factorial(sum(balls))\n    valid = 0\n    \n    for p in permutations(range(len(balls))):\n        box1 = [0] * len(balls)\n        box2 = [0] * len(balls)\n        for i, color in enumerate(p):\n            if (i // 2) % 2 == 0:\n                box1[color] += 1\n            else:\n                box2[color] += 1\n        \n        if len(set(box1)) == len(set(box2)):\n            valid += factorial(sum(box1)) * factorial(sum(box2))\n            for count in box1:\n                valid //= factorial(count)\n            for count in box2:\n                valid //= factorial(count)\n    \n    return valid / total"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 20629, "entry_point": "oddEvenJumps", "codes": ["def oddEvenJumps(A):\n    n = len(A)\n    odd = [0] * n\n    even = [0] * n\n    odd[-1] = even[-1] = 1\n    stack = []\n    for a, i in sorted((a, i) for i, a in enumerate(A)):\n        while stack and stack[-1] < i:\n            odd[stack.pop()] = i if not stack else stack[-1]\n        stack.append(i)\n    stack = []\n    for a, i in sorted((-a, i) for i, a in enumerate(A)):\n        while stack and stack[-1] < i:\n            even[stack.pop()] = i if not stack else stack[-1]\n        stack.append(i)\n    return sum(odd[i] and even[odd[i]] for i in range(n - 1)) + 1", "def oddEvenJumps(A):\n    n = len(A)\n    odd = [0] * n\n    even = [0] * n\n    odd[n-1] = 1\n    even[n-1] = 1\n    \n    indices = sorted(range(n), key=lambda i: A[i])\n    stack = []\n    for i in indices:\n        while stack and stack[-1] < i:\n            odd[stack.pop()] = even[i]\n        stack.append(i)\n    \n    indices.sort(key=lambda i: -A[i])\n    stack = []\n    for i in indices:\n        while stack and stack[-1] < i:\n            even[stack.pop()] = odd[i]\n        stack.append(i)\n    \n    return sum(odd[i] for i in range(n) if odd[i])", "def oddEvenJumps(A):\n    n = len(A)\n    next_higher, next_lower = [0] * n, [0] * n\n    stack = []\n    for i in sorted(range(n), key=lambda i: A[i]):\n        while stack and stack[-1] < i:\n            next_higher[stack.pop()] = i\n        stack.append(i)\n    stack = []\n    for i in sorted(range(n), key=lambda i: -A[i]):\n        while stack and stack[-1] < i:\n            next_lower[stack.pop()] = i\n        stack.append(i)\n    odd, even = [0] * n, [0] * n\n    odd[n - 1], even[n - 1] = 1, 1\n    for i in range(n - 2, -1, -1):\n        odd[i] = even[next_higher[i]]\n        even[i] = odd[next_lower[i]]\n    return sum(odd)", "from sortedcontainers import SortedDict\n\ndef oddEvenJumps(A):\n    n = len(A)\n    odd_jump = [-1] * n\n    even_jump = [-1] * n\n    sd = SortedDict()\n    \n    def get_jump(target, direction):\n        if target in sd:\n            return sd[target]\n        if direction == 'odd':\n            key = sd.bisect_left(target)\n            if key < len(sd):\n                return sd.peekitem(key)[1]\n        else:\n            key = sd.bisect_right(target) - 1\n            if key >= 0:\n                return sd.peekitem(key)[1]\n        return -1\n    \n    for i in range(n-1, -1, -1):\n        sd[A[i]] = i\n        odd_jump[i] = get_jump(A[i], 'odd')\n        even_jump[i] = get_jump(A[i], 'even')\n        sd.pop(A[i])\n    \n    dp_odd = [False] * n\n    dp_even = [False] * n\n    dp_odd[-1] = dp_even[-1] = True\n    \n    for i in range(n-2, -1, -1):\n        dp_odd[i] = even_jump[i] != -1 and dp_even[even_jump[i]]\n        dp_even[i] = odd_jump[i] != -1 and dp_odd[odd_jump[i]]\n    \n    return sum(dp_odd)", "def oddEvenJumps(A):\n    n = len(A)\n    odd_jump = [0] * n\n    even_jump = [0] * n\n    stack = []\n    stack2 = []\n    for i in range(n):\n        while stack and A[i] >= A[stack[-1]]:\n            stack.pop()\n        if stack:\n            odd_jump[stack[-1]] = i\n        stack.append(i)\n    for i in range(n):\n        while stack2 and A[i] <= A[stack2[-1]]:\n            stack2.pop()\n        if stack2:\n            even_jump[stack2[-1]] = i\n        stack2.append(i)\n    odd_jump[-1] = 1\n    even_jump[-1] = 1\n    for i in range(n-2, -1, -1):\n        odd_jump[i] = even_jump[odd_jump[i]]\n        even_jump[i] = odd_jump[even_jump[i]]\n    return sum(odd_jump)", "from sortedcontainers import SortedList\n\ndef oddEvenJumps(A):\n    n = len(A)\n    next_greater = [None] * n\n    next_smaller = [None] * n\n    \n    stack = []\n    for i, a in enumerate(A):\n        while stack and A[stack[-1]] < a:\n            next_greater[stack.pop()] = i\n        stack.append(i)\n    \n    stack = []\n    for i, a in sorted(enumerate(A), key=lambda x: x[1], reverse=True):\n        while stack and A[stack[-1]] > a:\n            next_smaller[stack.pop()] = i\n        stack.append(i)\n    \n    odd = [False] * n\n    even = [False] * n\n    odd[-1] = even[-1] = True\n    \n    for i in range(n - 2, -1, -1):\n        if next_greater[i] is not None:\n            odd[i] = even[next_greater[i]]\n        if next_smaller[i] is not None:\n            even[i] = odd[next_smaller[i]]\n    \n    return sum(odd)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 20688, "entry_point": "numSquarefulPerms", "codes": ["from itertools import permutations\n\ndef numSquarefulPerms(A):\n    return sum(1 for p in permutations(A) if all(int((p[i] + p[i + 1]) ** 0.5) ** 2 == p[i] + p[i + 1] for i in range(len(p) - 1)))", "def numSquarefulPerms(A):\n    from itertools import permutations\n    from math import isqrt\n\n    def is_perfect_square(n):\n        return isqrt(n) ** 2 == n\n\n    def is_squareful(seq):\n        return all(is_perfect_square(a + b) for a, b in zip(seq, seq[1:]))\n\n    return sum(1 for perm in permutations(A) if is_squareful(perm))", "from math import isqrt\nfrom itertools import permutations\n\ndef numSquarefulPerms(A):\n    def is_square(n):\n        return isqrt(n) ** 2 == n\n\n    res = 0\n    for perm in set(permutations(A)):\n        if all(is_square(perm[i] + perm[i+1]) for i in range(len(perm) - 1)):\n            res += 1\n    return res", "from collections import Counter\nimport math\nfrom itertools import permutations\n\ndef numSquarefulPerms(n):\n    root = int(math.isqrt(n))\n    return root * root == n\n\ndef numSquarefulPerms(A):\n    count = Counter()\n    for perm in permutations(A):\n        if all(numSquarefulPerms(perm[i] + perm[i + 1]) for i in range(len(perm) - 1)):\n            count[frozenset(perm)] += 1\n    return sum(count.values())"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 20715, "entry_point": "maxCoins", "codes": ["def maxCoins(piles):\n    piles.sort(reverse=True)\n    return sum(piles[1::2][:len(piles)//3])", "def maxCoins(piles):\n    piles.sort()\n    return sum(piles[i] for i in range(len(piles) // 3, len(piles), 2))", "def maxCoins(piles):\n    piles.sort()\n    total = 0\n    left, right = 0, len(piles) - 2\n    while left < right:\n        total += piles[right]\n        left += 1\n        right -= 2\n    return total", "def maxCoins(piles):\n    piles.sort(reverse=True)\n    return sum(piles[i] for i in range(1, len(piles), 2))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 20923, "entry_point": "largestMultipleOfThree", "codes": ["def largestMultipleOfThree(digits):\n    mod_sum = sum(digits) % 3\n    while mod_sum != 0:\n        for d in sorted(digits, reverse=True):\n            if d % 3 == mod_sum:\n                digits.remove(d)\n                mod_sum = sum(digits) % 3\n                break\n        else:\n            return \"\"\n    digits.sort(reverse=True)\n    return \"0\" if digits and digits[0] == 0 else \"\".join(map(str, digits))", "def largestMultipleOfThree(digits):\n    total_sum = sum(digits)\n    if total_sum % 3 == 0:\n        digits.sort(reverse=True)\n        return ''.join(map(str, digits)) or '0'\n    \n    target_remainder = total_sum % 3\n    for remove_count in range(1, 4):\n        for remove in combinations(digits, remove_count):\n            if sum(remove) % 3 == target_remainder:\n                remaining_digits = sorted(digits)\n                for d in remove:\n                    remaining_digits.remove(d)\n                remaining_digits.sort(reverse=True)\n                return ''.join(map(str, remaining_digits)) or '0'\n    \n    return ''", "def largestMultipleOfThree(digits):\n    sum_val = sum(digits)\n    while sum_val % 3 != 0:\n        for d in sorted(digits):\n            if sum_val % 3 == 1 and d % 3 == 1:\n                digits.remove(d)\n                sum_val -= d\n                break\n            elif sum_val % 3 == 2 and d % 3 == 2:\n                digits.remove(d)\n                sum_val -= d\n                break\n        else:\n            return \"\"\n    digits.sort(reverse=True)\n    return ''.join(map(str, digits)) if digits else \"0\"", "def largestMultipleOfThree(digits):\n    from collections import Counter\n    mod_counts = Counter(d % 3 for d in digits)\n    while mod_counts[1] % 3 == mod_counts[2] % 3 == 1:\n        mod_counts[1] -= 1\n        mod_counts[2] -= 1\n    while mod_counts[2] % 3 == mod_counts[1] % 3 == 2:\n        mod_counts[2] -= 1\n        mod_counts[1] -= 1\n    if mod_counts[1] % 3 == 2:\n        mod_counts[1] -= 2\n    elif mod_counts[2] % 3 == 2:\n        mod_counts[2] -= 2\n    if mod_counts[1] % 3 == 1:\n        mod_counts[1] -= 1\n    result = ''.join(str(d) * mod_counts[d % 3] for d in range(9, -1, -1))\n    return result if result and result[0] != '0' else '0'", "def largestMultipleOfThree(digits):\n    mod_counts = [sum(d % 3 == i for d in digits) for i in range(3)]\n    while mod_counts[2] % 3 != 0:\n        if mod_counts[2] > 0:\n            mod_counts[2] -= 1\n            mod_counts[digits.index(next(d for d in digits if d % 3 == 2))] -= 1\n        else:\n            if mod_counts[1] > 1:\n                mod_counts[1] -= 2\n                mod_counts[digits.index(next(d for d in digits if d % 3 == 1))] -= 1\n                mod_counts[digits.index(next(d for d in digits if d % 3 == 1))] -= 1\n            else:\n                return \"\"\n    if mod_counts[2] == 2:\n        mod_counts[2] -= 2\n        mod_counts[digits.index(next(d for d in digits if d % 3 == 2))] -= 1\n        mod_counts[digits.index(next(d for d in digits if d % 3 == 2))] -= 1\n    digits = [d for d in digits if d % 3 == 0]\n    digits.extend([d for d in digits if d % 3 == 1 and mod_counts[1] > 0])\n    digits.extend([d for d in digits if d % 3 == 2 and mod_counts[2] > 0])\n    digits.sort(reverse=True)\n    if not digits:\n        return \"0\"\n    return \"\".join(str(d) for d in digits)", "def largestMultipleOfThree(digits):\n    mod_counts = [0] * 3\n    for digit in digits:\n        mod_counts[digit % 3] += 1\n    \n    while mod_counts[2] % 3 != 0:\n        if mod_counts[2] > 0:\n            mod_counts[2] -= 1\n        else:\n            if mod_counts[1] >= 2:\n                mod_counts[1] -= 2\n            elif mod_counts[0] >= 1:\n                mod_counts[0] -= 1\n            else:\n                break\n    \n    while mod_counts[1] % 3 != 0:\n        if mod_counts[1] > 0:\n            mod_counts[1] -= 1\n        else:\n            if mod_counts[0] >= 2:\n                mod_counts[0] -= 2\n            elif mod_counts[2] >= 1:\n                mod_counts[2] -= 1\n            else:\n                break\n    \n    result = ''.join(str(digit) * count for digit, count in enumerate(mod_counts[::-1]))\n    return result if result and result[0] != '0' else '0'"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 2106, "entry_point": "numRescueBoats", "codes": ["def numRescueBoats(people, limit):\n    people.sort()\n    i, j = 0, len(people) - 1\n    boats = 0\n    while i <= j:\n        if people[i] + people[j] <= limit:\n            i += 1\n        j -= 1\n        boats += 1\n    return boats", "def numRescueBoats(people, limit):\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n    while left <= right:\n        if people[left] + people[right] <= limit:\n            left += 1\n        right -= 1\n        boats += 1\n    return boats", "def numRescueBoats(people: List[int], limit: int) -> int:\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n    while left <= right:\n        if people[left] + people[right] <= limit:\n            left += 1\n        right -= 1\n        boats += 1\n    return boats"], "rewards": [1.0, 1.0, -1.0]}
{"id": 2124, "entry_point": "countPrimes", "codes": ["def countPrimes(n):\n    if n <= 2:\n        return 0\n    primes = set(range(2, n))\n    for i in range(2, int(n**0.5) + 1):\n        if i in primes:\n            primes -= set(range(i*i, n, i))\n    return len(primes)", "def countPrimes(n):\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)", "def countPrimes(n):\n    if n <= 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            for j in range(i*i, n, i):\n                sieve[j] = False\n    return sum(sieve)", "def countPrimes(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef countPrimes(n):\n    count = 0\n    for num in range(2, n):\n        if countPrimes(num):\n            count += 1\n    return count"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 2132, "entry_point": "subarraysDivByK", "codes": ["def subarraysDivByK(A, K):\n    count, prefix_sum, freq = 0, 0, {0: 1}\n    for num in A:\n        prefix_sum = (prefix_sum + num) % K\n        count += freq.get(prefix_sum, 0)\n        freq[prefix_sum] = freq.get(prefix_sum, 0) + 1\n    return count", "def subarraysDivByK(A, K):\n    count, total = 0, 0\n    mod_counts = {0: 1}\n    for num in A:\n        total += num\n        mod = total % K\n        count += mod_counts.get(mod, 0)\n        mod_counts[mod] = mod_counts.get(mod, 0) + 1\n    return count", "def subarraysDivByK(A, K):\n    prefix_sums = {0: 1}\n    total, count = 0, 0\n    for num in A:\n        total += num\n        remainder = total % K\n        count += prefix_sums.get(remainder, 0)\n        prefix_sums[remainder] = prefix_sums.get(remainder, 0) + 1\n    return count", "def subarraysDivByK(A, K):\n    count, prefix_sum = 0, 0\n    prefix_sums = [0] * (K + 1)\n    for num in A:\n        prefix_sum = (prefix_sum + num % K + K) % K\n        count += prefix_sums[prefix_sum]\n        prefix_sums[prefix_sum] += 1\n    return count"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 21051, "entry_point": "maxScore", "codes": ["def maxScore(s):\n    return max(s[:i].count('0') + s[i:].count('1') for i in range(1, len(s)))", "def maxScore(s: str) -> int:\n    return max(s[:i].count('0') + s[i:].count('1') for i in range(1, len(s)))", "def maxScore(s):\n    max_score = 0\n    for i in range(1, len(s)):\n        left_score = s[:i].count('0')\n        right_score = s[i:].count('1')\n        max_score = max(max_score, left_score + right_score)\n    return max_score", "def maxScore(s):\n    def count_ones(substring):\n        return substring.count('1')\n    \n    max_score = 0\n    for i in range(1, len(s)):\n        left = s[:i]\n        right = s[i:]\n        score = count_ones(left) + count_ones(right)\n        max_score = max(max_score, score)\n    \n    return max_score", "def maxScore(s):\n    result = -1\n    left_zeros = 0\n    ones_count = s.count('1')\n    \n    for i in range(len(s) - 1):\n        if s[i] == '0':\n            left_zeros += 1\n        else:\n            ones_count -= 1\n        result = max(result, left_zeros + ones_count)\n    \n    return result", "def maxScore(s):\n    max_score = 0\n    ones_count = s.count('1')\n    zeros_count = 0\n    for i in range(len(s) - 1):\n        if s[i] == '0':\n            zeros_count += 1\n        else:\n            ones_count -= 1\n        max_score = max(max_score, zeros_count + ones_count)\n    return max_score"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 21304, "entry_point": "judgePoint24", "codes": ["from itertools import permutations, combinations\n\ndef judgePoint24(nums):\n    def dfs(nums):\n        if len(nums) == 1:\n            return abs(nums[0] - 24) < 1e-6\n        \n        for a, b, *rest in permutations(nums):\n            for x in {a + b, a - b, a * b, b and a / b}:\n                if dfs([x] + rest):\n                    return True\n        return False\n    \n    return dfs(nums)", "from itertools import permutations\n\ndef judgePoint24(nums):\n    if len(nums) == 1:\n        return abs(nums[0] - 24) < 1e-6\n    \n    for i in range(len(nums)):\n        for j in range(len(nums)):\n            if i != j:\n                remaining = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                for a, b in ((nums[i], nums[j]), (nums[j], nums[i])):\n                    for op in (lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else None):\n                        if op is not None:\n                            if judgePoint24(remaining + [op(a, b)]):\n                                return True\n    return False", "from itertools import permutations\nfrom functools import reduce\n\ndef judgePoint24(nums):\n    def can_form_24(nums):\n        if len(nums) == 1:\n            return abs(nums[0] - 24) < 1e-6\n        \n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if i != j:\n                    remaining = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                    for op in (lambda a, b: a + b, lambda a, b: a - b, lambda a, b: a * b, lambda a, b: b - a if b != 0 else 0):\n                        new_nums = remaining + [op(nums[i], nums[j])]\n                        if can_form_24(new_nums):\n                            return True\n        return False\n    \n    return any(can_form_24(nums) for nums in permutations([4, 1, 8, 7]))", "def judgePoint24(nums):\n    def dfs(nums):\n        if len(nums) == 1:\n            return abs(nums[0] - 24) < 1e-6\n        \n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if i != j:\n                    remaining = nums[:i] + nums[i+1:j] + nums[j+1:]\n                    for op in (lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else float('inf')):\n                        if dfs(remaining + [op(nums[i], nums[j])]):\n                            return True\n        return False\n    \n    return dfs(nums)", "import itertools\n\ndef judgePoint24(nums):\n    def dfs(nums):\n        if len(nums) == 1:\n            return abs(nums[0] - 24) < 1e-6\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                a, b = nums[i], nums[j]\n                rest = nums[:i] + nums[i + 1:j] + nums[j + 1:]\n                if dfs([a + b] + rest) or dfs([a - b] + rest) or dfs([b - a] + rest) or \\\n                   dfs([a * b] + rest) or (b != 0 and dfs([a / b] + rest)) or (a != 0 and dfs([b / a] + rest)):\n                    return True\n        return False\n    \n    return dfs(nums)\n\ndef _equivalent(_lhs, _rhs):\n    return judgePoint24(_lhs) == _rhs", "from itertools import permutations, combinations_with_replacement\nfrom operator import add, sub, mul, truediv\n\nEPSILON = 1e-6\n\ndef judgePoint24(nums):\n    operations = [add, sub, mul, truediv]\n    \n    def solve(nums):\n        if len(nums) == 1:\n            return abs(nums[0] - 24) < EPSILON\n        \n        for a, b, *rest in permutations(nums):\n            for op in operations:\n                if op is not truediv or b != 0:\n                    if solve([op(a, b)] + rest):\n                        return True\n        return False\n    \n    return solve(nums)\n\ndef _equivalent(lhs, rhs):\n    return judgePoint24(lhs) == rhs", "from itertools import permutations, combinations\nimport math\n\ndef _equivalent(_lhs, _rhs):\n    return abs(_lhs - _rhs) < 1e-6\n\ndef judgePoint24(nums):\n    if len(nums) == 1:\n        return _equivalent(nums[0], 24)\n    \n    for (a, b), rest in combinations(permutations(nums), 2):\n        for (c,) in permutations(rest):\n            for op1 in '+-*/':\n                for op2 in '+-*/':\n                    if op1 != '*' or a != 0:\n                        lhs = eval(f\"{a}{op1}{b}\")\n                        if judgePoint24([lhs] + list(rest)):\n                            return True\n                    if op2 != '*' or c != 0:\n                        rhs = eval(f\"{a}{op2}{c}\")\n                        if judgePoint24([b, rhs] + list(rest[1:])):\n                            return True\n                    if op1 != '*' or b != 0:\n                        lhs = eval(f\"{b}{op1}{a}\")\n                        if judgePoint24([lhs] + list(rest)):\n                            return True\n                    if op2 != '*' or c != 0:\n                        rhs = eval(f\"{b}{op2}{c}\")\n                        if judgePoint24([a, rhs] + list(rest[1:])):\n                            return True\n    return False"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 21392, "entry_point": "countTriplets", "codes": ["def countTriplets(A):\n    count = 0\n    for i in range(len(A)):\n        for j in range(len(A)):\n            for k in range(len(A)):\n                if A[i] & A[j] & A[k] == 0:\n                    count += 1\n    return count", "def countTriplets(A):\n    count = 0\n    n = len(A)\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if A[i] & A[j] & A[k] == 0:\n                    count += 1\n    return count", "from collections import defaultdict\n\ndef countTriplets(A):\n    bit_count = defaultdict(int)\n    count = 0\n    for i in range(len(A)):\n        count += sum(bit_count[a & A[i]] for a in A)\n        for j in range(i):\n            bit_count[A[i] & A[j]] += 1\n    return count", "def countTriplets(A):\n    from collections import defaultdict\n    \n    count = defaultdict(int)\n    triplets = 0\n    \n    for i in range(len(A)):\n        for j in range(len(A)):\n            x = A[i] & A[j]\n            if x == 0:\n                triplets += 1\n            else:\n                triplets += count[x]\n            count[x] += 1\n    \n    return triplets", "def countTriplets(A):\n    count = 0\n    for i in range(len(A)):\n        for j in range(i, len(A)):\n            for k in range(j, len(A)):\n                if A[i] & A[j] & A[k] == 0:\n                    count += 1\n    return count", "def countTriplets(A):\n    from collections import Counter\n    count = 0\n    n = len(A)\n    for i in range(n):\n        for j in range(i, n):\n            for k in range(j, n):\n                if A[i] & A[j] & A[k] == 0:\n                    count += 1\n    return count", "def countTriplets(A):\n    count = 0\n    n = len(A)\n    for i in range(n):\n        for j in range(i, n):\n            for k in range(j, n):\n                if A[i] & A[j] & A[k] == 0:\n                    count += 1\n    return count"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 21483, "entry_point": "decodeAtIndex", "codes": ["def decodeAtIndex(S, K):\n    size = 0\n    for char in S:\n        if char.isdigit():\n            size *= int(char)\n        else:\n            size += 1\n    \n    for char in reversed(S):\n        K %= size\n        if K == 0 and char.isalpha():\n            return char\n        if char.isdigit():\n            size //= int(char)\n        else:\n            size -= 1", "def decodeAtIndex(S, K):\n    size = 0\n    for c in S:\n        if c.isdigit():\n            size *= int(c)\n        else:\n            size += 1\n    \n    for c in reversed(S):\n        K %= size\n        if K == 0 and c.isalpha():\n            return c\n        if c.isdigit():\n            size //= int(c)\n        else:\n            size -= 1", "def decodeAtIndex(S: str, K: int) -> str:\n    size = 0\n    for char in S:\n        if char.isdigit():\n            size *= int(char)\n        else:\n            size += 1\n    \n    for char in reversed(S):\n        K %= size\n        if K == 0 and char.isalpha():\n            return char\n        if char.isdigit():\n            size //= int(char)\n        else:\n            size -= 1", "def decodeAtIndex(S, K):\n    def decode(s, k, size):\n        if k <= size:\n            return s[k-1]\n        for i, c in enumerate(s):\n            if c.isdigit():\n                size //= int(c)\n                if k <= size:\n                    return decode(s[:i], k, size)\n                k %= size\n                if k == 0:\n                    k = size\n            else:\n                size += 1\n                if k == size:\n                    return c\n\n    size = 0\n    for c in S:\n        if c.isdigit():\n            size *= int(c)\n        else:\n            size += 1\n\n    return decode(S, K, size)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 2193, "entry_point": "orderlyQueue", "codes": ["def orderlyQueue(S, K):\n    if K == 1:\n        return min(S[i:] + S[:i] for i in range(len(S)))\n    return ''.join(sorted(S))", "def orderlyQueue(S: str, K: int) -> str:\n    if K > 1:\n        return ''.join(sorted(S))\n    return min(S[i:] + S[:i] for i in range(len(S)))", "def orderlyQueue(S, K):\n    if K == 1:\n        return min(S[i:] + S[:i] for i in range(len(S)))\n    else:\n        return ''.join(sorted(S))", "def orderlyQueue(S, K):\n    if K == 1:\n        return ''.join(sorted(S))\n    return ''.join(sorted(S))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 21551, "entry_point": "maxDistToClosest", "codes": ["def maxDistToClosest(seats):\n    max_distance = 0\n    last_person = -1\n    for i, seat in enumerate(seats):\n        if seat == 1:\n            if last_person == -1:\n                max_distance = i\n            else:\n                max_distance = max(max_distance, (i - last_person) // 2)\n            last_person = i\n    max_distance = max(max_distance, len(seats) - 1 - last_person)\n    return max_distance", "def maxDistToClosest(seats):\n    n = len(seats)\n    max_dist = 0\n    left = -1\n    for right in range(n):\n        if seats[right] == 1:\n            if left == -1:\n                max_dist = right\n            else:\n                max_dist = max(max_dist, (right - left) // 2)\n            left = right\n    max_dist = max(max_dist, n - 1 - left)\n    return max_dist", "def maxDistToClosest(seats):\n    n = len(seats)\n    max_dist = 0\n    last_person = -1\n    for i in range(n):\n        if seats[i] == 1:\n            if last_person == -1:\n                max_dist = i\n            else:\n                max_dist = max(max_dist, (i - last_person) // 2)\n            last_person = i\n    max_dist = max(max_dist, n - 1 - last_person)\n    return max_dist", "def maxDistToClosest(seats):\n    n = len(seats)\n    left = [-1] * n\n    right = [n] * n\n    \n    closest = float('inf')\n    for i in range(n):\n        if seats[i] == 1:\n            left[i] = closest\n            closest = i\n    closest = float('inf')\n    for i in range(n - 1, -1, -1):\n        if seats[i] == 1:\n            right[i] = closest\n            closest = i\n    \n    max_distance = 0\n    for i in range(n):\n        if seats[i] == 0:\n            distance = min(left[i], right[i])\n            max_distance = max(max_distance, distance)\n    \n    return max(max_distance, left[0], right[-1])", "def maxDistToClosest(seats):\n    n = len(seats)\n    left, right = [0] * n, [0] * n\n    left[0] = float('-inf')\n    right[n-1] = float('inf')\n    \n    for i in range(1, n):\n        left[i] = i if seats[i] == 1 else left[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right[i] = i if seats[i] == 1 else right[i+1]\n    \n    return max(min(i - left[i], right[i] - i) for i in range(n) if seats[i] == 0)", "def maxDistToClosest(seats):\n    n = len(seats)\n    left = [-1] * n\n    right = [n] * n\n    \n    for i in range(n):\n        if seats[i] == 1:\n            left[i] = i\n    \n    for i in range(n-1, -1, -1):\n        if seats[i] == 1:\n            right[i] = i\n    \n    max_dist = 0\n    for i in range(n):\n        if seats[i] == 0:\n            left_dist = i - left[i] if left[i] != -1 else float('inf')\n            right_dist = right[i] - i if right[i] != n else float('inf')\n            max_dist = max(max_dist, min(left_dist, right_dist))\n    \n    return max_dist"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 21618, "entry_point": "findKthLargest", "codes": ["def findKthLargest(nums, k):\n    return sorted(nums)[-k]", "def findKthLargest(nums, k):\n    nums.sort()\n    return nums[-k]", "import heapq\n\ndef findKthLargest(nums, k):\n    return heapq.nlargest(k, nums)[-1]", "def findKthLargest(nums, k):\n    def partition(left, right, pivot_index):\n        pivot_value = nums[pivot_index]\n        nums[pivot_index], nums[right] = nums[right], nums[pivot_index]\n        store_index = left\n        for i in range(left, right):\n            if nums[i] > pivot_value:\n                nums[store_index], nums[i] = nums[i], nums[store_index]\n                store_index += 1\n        nums[store_index], nums[right] = nums[right], nums[store_index]\n        return store_index\n\n    def quickselect(left, right, k_smallest):\n        if left == right:\n            return nums[left]\n        pivot_index = left + (right - left) // 2\n        pivot_index = partition(left, right, pivot_index)\n        if k_smallest == pivot_index:\n            return nums[k_smallest]\n        elif k_smallest < pivot_index:\n            return quickselect(left, pivot_index - 1, k_smallest)\n        else:\n            return quickselect(pivot_index + 1, right, k_smallest)\n\n    return quickselect(0, len(nums) - 1, len(nums) - k)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 21750, "entry_point": "greet", "codes": ["def greet(name):\n    if name == \"Johnny\":\n        return ['Hello, my love!']\n    else:\n        return ['Hello, ' + name + '!']", "def greet(name):\n    return ['Hello, ' + name + '!']", "def greet(name):\n    if name == \"Johnny\":\n        return \"Hello, Johnny! You are special to me.\"\n    else:\n        return f\"Hello, {name}!\"", "def greet(name):\n    return \"Hello, Johnny!\" if name == 'Johnny' else f\"Hello, {name}!\"", "def greet(name):\n    if name == \"Johnny\":\n        return \"Hello, Johnny! How are you today?\"\n    else:\n        return f\"Hello, {name}! Welcome back.\"", "def greet(name):\n    if name == 'Johnny':\n        return 'Hello, my love!'\n    else:\n        return f'Hello, {name}!'"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 21777, "entry_point": "kSimilarity", "codes": ["def kSimilarity(A: str, B: str) -> int:\n    def dfs(A, B, i, swaps):\n        if i == len(A):\n            return swaps\n        if A[i] == B[i]:\n            return dfs(A, B, i + 1, swaps)\n        j = i + 1\n        while j < len(A) and A[j] != B[i]:\n            j += 1\n        A = A[:i] + A[j] + A[i+1:j] + A[i] + A[j+1:]\n        return dfs(A, B, i + 1, swaps + 1)\n    \n    return dfs(A, B, 0, 0)", "def kSimilarity(A, B):\n    def dfs(i, A, B, swaps):\n        if i == len(A):\n            return swaps\n        if A[i] == B[i]:\n            return dfs(i + 1, A, B, swaps)\n        for j in range(i + 1, len(A)):\n            if A[j] == B[i] and A[j] != B[j]:\n                A = A[:i] + A[j] + A[i + 1:j] + A[i] + A[j + 1:]\n                result = dfs(i + 1, A, B, swaps + 1)\n                A = A[:i] + A[j] + A[i + 1:j] + A[i] + A[j + 1:]\n                return result\n\n    return dfs(0, A, B, 0)", "def kSimilarity(A, B):\n    def dfs(i):\n        if i == len(A):\n            return 0\n        if A[i] == B[i]:\n            return dfs(i + 1)\n        min_swaps = float('inf')\n        for j in range(i + 1, len(A)):\n            if A[j] == B[i] and A[j] != B[j]:\n                A[i], A[j] = A[j], A[i]\n                min_swaps = min(min_swaps, dfs(i + 1))\n                A[i], A[j] = A[j], A[i]\n        return min_swaps + 1\n    \n    A, B = list(A), list(B)\n    return dfs(0)", "def kSimilarity(A, B):\n    def dfs(i):\n        if i == n:\n            return 0\n        if A[i] == B[i]:\n            return dfs(i + 1)\n        j = i + 1\n        while j < n and A[j] != B[i]:\n            j += 1\n        A[i], A[j] = A[j], A[i]\n        result = 1 + dfs(i + 1)\n        A[i], A[j] = A[j], A[i]\n        return result\n\n    n = len(A)\n    return dfs(0)", "from functools import lru_cache\n\ndef kSimilarity(A: str, B: str) -> int:\n    @lru_cache(None)\n    def dfs(a, b):\n        if a == b:\n            return 0\n        if a[0] == b[0]:\n            return dfs(a[1:], b[1:])\n        return 1 + min(dfs(a[:i] + a[i+1] + a[i], b[1:]) for i in range(1, len(a)) if a[i] == b[0])\n    \n    return dfs(A, B)", "def kSimilarity(A, B):\n    def dfs(i):\n        if i == len(A):\n            return 0\n        if A[i] == B[i]:\n            return dfs(i + 1)\n        for j in range(i + 1, len(A)):\n            if A[j] == B[i] and A[j] != B[j]:\n                A[i], A[j] = A[j], A[i]\n                result = 1 + dfs(i + 1)\n                A[i], A[j] = A[j], A[i]\n                return result\n    return dfs(0)", "def kSimilarity(A, B):\n    queue = [(A, 0)]\n    visited = set([A])\n    while queue:\n        current, swaps = queue.pop(0)\n        if current == B:\n            return swaps\n        i = 0\n        while current[i] == B[i]:\n            i += 1\n        for j in range(i + 1, len(current)):\n            if current[j] == B[i] and current[j] != B[j] and current[j:] + current[i] not in visited:\n                visited.add(current[j:] + current[i])\n                queue.append((current[:i] + current[j] + current[i+1:j] + current[i], swaps + 1))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 21845, "entry_point": "checkIfCanBreak", "codes": ["def checkIfCanBreak(s1, s2):\n    s1, s2 = sorted(s1), sorted(s2)\n    return all(x >= y for x, y in zip(s1, s2)) or all(x <= y for x, y in zip(s1, s2))", "def checkIfCanBreak(s1: str, s2: str) -> bool:\n    s1, s2 = sorted(s1), sorted(s2)\n    return all(x >= y for x, y in zip(s1, s2)) or all(x <= y for x, y in zip(s1, s2))", "def checkIfCanBreak(s1, s2):\n    s1 = sorted(s1)\n    s2 = sorted(s2)\n    return all(x >= y for x, y in zip(s1, s2)) or all(x <= y for x, y in zip(s1, s2))", "def checkIfCanBreak(s1: str, s2: str) -> bool:\n    count1, count2 = [0] * 26, [0] * 26\n    for char in s1:\n        count1[ord(char) - ord('a')] += 1\n    for char in s2:\n        count2[ord(char) - ord('a')] += 1\n    \n    sum1, sum2 = 0, 0\n    greater1, greater2 = 0, 0\n    \n    for i in range(25, -1, -1):\n        sum1 += count1[i]\n        sum2 += count2[i]\n        greater1 += count1[i] > 0\n        greater2 += count2[i] > 0\n    \n    return (greater1 == 0 or greater2 == 0) and (sum1 >= sum2 or sum1 <= sum2)", "def checkIfCanBreak(s1: str, s2: str) -> bool:\n    def can_break(count1, count2):\n        greater = 0\n        less = 0\n        for c in 'abcdefghijklmnopqrstuvwxyz':\n            if count1[c] > count2[c]:\n                greater += count1[c]\n            elif count1[c] < count2[c]:\n                less += count1[c]\n            if greater and less:\n                return False\n        return True\n\n    count1, count2 = [0] * 26, [0] * 26\n    for c in s1:\n        count1[ord(c) - ord('a')] += 1\n    for c in s2:\n        count2[ord(c) - ord('a')] += 1\n\n    return can_break(count1, count2) or can_break(count2, count1)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 21849, "entry_point": "isHappy", "codes": ["def isHappy(n):\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = sum(int(digit) ** 2 for digit in str(n))\n    return n == 1", "def isHappy(n):\n    def get_next(num):\n        return sum(int(char) ** 2 for char in str(num))\n    \n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = get_next(n)\n    return n == 1", "def isHappy(n):\n    def sum_of_squares(num):\n        return sum(int(digit) ** 2 for digit in str(num))\n    \n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = sum_of_squares(n)\n    return n == 1", "def isHappy(num):\n    return sum(int(digit) ** 2 for digit in str(num))\n\ndef isHappy(n):\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = isHappy(n)\n    return n == 1"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 22136, "entry_point": "getLengthOfOptimalCompression", "codes": ["def getLengthOfOptimalCompression(s, k):\n    n = len(s)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            cnt, dels = 0, 0\n            for l in range(i, 0, -1):\n                if s[l - 1] == s[i - 1]:\n                    cnt += 1\n                else:\n                    dels += 1\n                if j - dels >= 0:\n                    dp[i][j] = min(dp[i][j], dp[l - 1][j - dels] + 1 + (3 if cnt >= 100 else 2 if cnt >= 10 else 1 if cnt >= 2 else 0))\n    \n    return dp[n][k]", "def getLengthOfOptimalCompression(s: str, k: int) -> int:\n    n = len(s)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            cnt, dels = 0, 0\n            for l in range(i, 0, -1):\n                if s[l - 1] == s[i - 1]:\n                    cnt += 1\n                else:\n                    dels += 1\n                if j - dels >= 0:\n                    dp[i][j] = min(dp[i][j], dp[l - 1][j - dels] + 1 + (3 if cnt >= 100 else 2 if cnt >= 10 else 1 if cnt >= 2 else 0))\n    \n    return dp[n][k]", "def getLengthOfOptimalCompression(s, k):\n    n = len(s)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            count = 0\n            del_count = 0\n            for l in range(i, 0, -1):\n                if s[l - 1] == s[i - 1]:\n                    count += 1\n                else:\n                    del_count += 1\n                if j - del_count >= 0:\n                    dp[i][j] = min(dp[i][j], dp[l - 1][j - del_count] + 1 + (3 if count >= 100 else 2 if count >= 10 else 1 if count >= 2 else 0))\n\n    return dp[n][k]", "def getLengthOfOptimalCompression(s: str, k: int) -> int:\n    @cache\n    def dfs(i, k):\n        if k < 0:\n            return float('inf')\n        if i >= len(s):\n            return 0\n        res = float('inf')\n        del_cnt = 0\n        cnt = 0\n        for j in range(i, len(s)):\n            if s[j] == s[i]:\n                cnt += 1\n                res = min(res, dfs(j + 1, k - del_cnt) + 1 + (3 if cnt >= 100 else 2 if cnt >= 10 else 1 if cnt >= 2 else 0))\n            else:\n                del_cnt += 1\n                res = min(res, dfs(j + 1, k - del_cnt))\n        return res\n\n    return dfs(0, k)", "def getLengthOfOptimalCompression(s: str, k: int) -> int:\n    @lru_cache(None)\n    def dp(i: int, last: str, cnt: int, k: int) -> int:\n        if k < 0:\n            return float('inf')\n        if i == len(s):\n            return 0\n        if s[i] == last:\n            return dp(i + 1, last, cnt + 1, k)\n        return min(dp(i + 1, last, 1, k - 1), 1 + (1 if cnt >= 10 else 0) + (1 if cnt >= 100 else 0) + dp(i + 1, s[i], 1, k))\n    \n    return dp(0, '', 0, k)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 22232, "entry_point": "minStartValue", "codes": ["def minStartValue(nums):\n    min_sum = 0\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n    return 1 - min_sum", "def minStartValue(nums):\n    min_sum = 0\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n    return 1 - min_sum if min_sum < 1 else 1", "def minStartValue(nums):\n    min_sum = 0\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n    return 1 - min_sum if min_sum < 0 else 1", "def minStartValue(nums):\n    return max(1, 1 - sum(nums))", "def minStartValue(nums):\n    return 1 - min(0, sum(x for x in itertools.accumulate(nums)))", "def minStartValue(nums):\n    return max(1, 1 - min(accumulate(nums)))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 22243, "entry_point": "countSubstrings", "codes": ["def countSubstrings(s):\n    return sum(s[i:j] == s[i:j][::-1] for i in range(len(s)) for j in range(i+1, len(s)+1))", "def countSubstrings(s):\n    return sum(1 for i in range(len(s)) for j in range(i, len(s)) if s[i:j+1] == s[i:j+1][::-1])", "def countSubstrings(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if s[i:j] == s[i:j][::-1]:\n                count += 1\n    return count", "def countSubstrings(s: str) -> int:\n    def expand_around_center(left: int, right: int) -> set:\n        result = set()\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            result.add(s[left:right+1])\n            left -= 1\n            right += 1\n        return result\n\n    result = set()\n    for i in range(len(s)):\n        result.update(expand_around_center(i, i))\n        result.update(expand_around_center(i, i + 1))\n    return len(result)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 22282, "entry_point": "numSplits", "codes": ["def numSplits(s):\n    left_counts, right_counts = {}, {}\n    for char in s:\n        right_counts[char] = right_counts.get(char, 0) + 1\n    good_splits = 0\n    left_set = set()\n    for char in s:\n        left_counts[char] = left_counts.get(char, 0) + 1\n        left_set.add(char)\n        right_counts[char] -= 1\n        if right_counts[char] == 0:\n            del right_counts[char]\n        if len(left_set) == len(right_counts):\n            good_splits += 1\n    return good_splits", "def numSplits(s: str) -> int:\n    left_counts, right_counts = {}, {}\n    for char in s:\n        right_counts[char] = right_counts.get(char, 0) + 1\n    left_distinct, right_distinct = 0, len(right_counts)\n    good_splits = 0\n    for char in s:\n        left_counts[char] = left_counts.get(char, 0) + 1\n        if left_counts[char] == 1:\n            left_distinct += 1\n        right_counts[char] -= 1\n        if right_counts[char] == 0:\n            right_distinct -= 1\n        if left_distinct == right_distinct:\n            good_splits += 1\n    return good_splits", "def numSplits(s: str) -> int:\n    left_counts = {}\n    right_counts = {}\n    for char in s:\n        right_counts[char] = right_counts.get(char, 0) + 1\n    result = 0\n    left_distinct = 0\n    right_distinct = len(right_counts)\n    for char in s:\n        left_counts[char] = left_counts.get(char, 0) + 1\n        if left_counts[char] == 1:\n            left_distinct += 1\n        right_counts[char] -= 1\n        if right_counts[char] == 0:\n            right_distinct -= 1\n        if left_distinct == right_distinct:\n            result += 1\n    return result", "def numSplits(s: str) -> int:\n    left_counts = [0] * 26\n    right_counts = [0] * 26\n    left_distinct = 0\n    right_distinct = 0\n    good_splits = 0\n\n    for char in s:\n        if right_counts[ord(char) - ord('a')] == 0:\n            right_distinct += 1\n        right_counts[ord(char) - ord('a')] += 1\n\n    for char in s:\n        left_counts[ord(char) - ord('a')] += 1\n        if left_counts[ord(char) - ord('a')] == 1:\n            left_distinct += 1\n        right_counts[ord(char) - ord('a')] -= 1\n        if right_counts[ord(char) - ord('a')] == 0:\n            right_distinct -= 1\n        if left_distinct == right_distinct:\n            good_splits += 1\n\n    return good_splits", "def numSplits(s: str) -> int:\n    left_count = [0] * 26\n    right_count = [0] * 26\n    left_set = set()\n    right_set = set()\n    result = 0\n    \n    for char in s:\n        right_count[ord(char) - ord('a')] += 1\n        right_set.add(char)\n    \n    for char in s:\n        left_count[ord(char) - ord('a')] += 1\n        right_count[ord(char) - ord('a')] -= 1\n        \n        if right_count[ord(char) - ord('a')] == 0:\n            right_set.remove(char)\n        \n        if len(left_set) == len(right_set):\n            result += 1\n    \n    return result", "def numSplits(s):\n    left_count = [0] * 26\n    right_count = [0] * 26\n    left_unique = 0\n    right_unique = 0\n    good_splits = 0\n    \n    for char in s:\n        right_count[ord(char) - ord('a')] += 1\n        if right_count[ord(char) - ord('a')] == 1:\n            right_unique += 1\n    \n    for char in s:\n        left_count[ord(char) - ord('a')] += 1\n        if left_count[ord(char) - ord('a')] == 1:\n            left_unique += 1\n        \n        right_count[ord(char) - ord('a')] -= 1\n        if right_count[ord(char) - ord('a')] == 0:\n            right_unique -= 1\n        \n        if left_unique == right_unique:\n            good_splits += 1\n    \n    return good_splits", "def numSplits(s):\n    left_counts, right_counts = set(), set()\n    left_count, right_count = 0, len(set(s))\n    good_splits = 0\n    \n    for char in s:\n        if char not in left_counts:\n            left_count += 1\n            left_counts.add(char)\n        if char in right_counts:\n            right_count -= 1\n        right_counts.add(char)\n        if left_count == right_count:\n            good_splits += 1\n            \n    return good_splits", "def numSplits(s: str) -> int:\n    left_count = [0] * 26\n    right_count = [0] * 26\n    left_distinct = 0\n    right_distinct = 0\n    result = 0\n\n    for char in s:\n        if right_count[ord(char) - ord('a')] == 0:\n            right_distinct += 1\n        right_count[ord(char) - ord('a')] += 1\n\n    for char in s:\n        left_count[ord(char) - ord('a')] += 1\n        if left_count[ord(char) - ord('a')] == 1:\n            left_distinct += 1\n        right_count[ord(char) - ord('a')] -= 1\n        if right_count[ord(char) - ord('a')] == 0:\n            right_distinct -= 1\n        if left_distinct == right_distinct:\n            result += 1\n\n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 22292, "entry_point": "strongPasswordChecker", "codes": ["def strongPasswordChecker(s):\n    def has_lowercase(s):\n        return any(c.islower() for c in s)\n\n    def has_uppercase(s):\n        return any(c.isupper() for c in s)\n\n    def has_digit(s):\n        return any(c.isdigit() for c in s)\n\n    def has_three_repeating(s):\n        return any(s[i] == s[i+1] == s[i+2] for i in range(len(s) - 2))\n\n    if not (6 <= len(s) <= 20) or not has_lowercase(s) or not has_uppercase(s) or not has_digit(s) or has_three_repeating(s):\n        changes = 0\n        if len(s) < 6:\n            changes += 6 - len(s)\n        elif len(s) > 20:\n            changes += len(s) - 20\n        changes += sum(1 for c in set(s) if s.count(c) >= 3)\n        return max(changes, sum(1 for c in set(s) if s.count(c) >= 3))\n    return 0", "def strongPasswordChecker(s):\n    has_lower = has_upper = has_digit = False\n    length = len(s)\n    replace = delete = insert = 0\n    i = 0\n\n    while i < length:\n        if s[i].islower(): has_lower = True\n        if s[i].isupper(): has_upper = True\n        if s[i].isdigit(): has_digit = True\n\n        j = i\n        while j < length and s[j] == s[i]: j += 1\n        repeat = j - i\n        replace += repeat // 3\n        i = j\n\n    need = 3 - (has_lower + has_upper + has_digit)\n\n    if length < 6:\n        insert = max(0, 6 - length - need)\n        replace -= min(insert, replace)\n    elif length <= 20:\n        replace -= min(replace, need)\n    else:\n        delete = length - 20\n        replace -= delete // 3\n        replace -= min(delete % 3, need)\n\n    return max(insert, replace) + need", "def strongPasswordChecker(s):\n    def has_lowercase(s):\n        return any(char.islower() for char in s)\n\n    def has_uppercase(s):\n        return any(char.isupper() for char in s)\n\n    def has_digit(s):\n        return any(char.isdigit() for char in s)\n\n    def has_repeating(s):\n        return any(s[i] == s[i+1] == s[i+2] for i in range(len(s) - 2))\n\n    changes_needed = 0\n    lower, upper, digit = not has_lowercase(s), not has_uppercase(s), not has_digit(s)\n    repeating_groups = [0]\n    i = 0\n\n    while i < len(s):\n        j = i\n        while j < len(s) and s[j] == s[i]:\n            j += 1\n        group_length = j - i\n        changes_needed += group_length // 3\n        repeating_groups.append(group_length % 3)\n        i = j\n\n    min_removals = max(0, len(s) - 20)\n    changes_needed -= min_removals\n\n    for _ in range(min_removals):\n        repeating_groups.pop()\n        changes_needed -= 1\n        repeating_groups[-1] -= 1\n\n    while repeating_groups[-1] == 2:\n        repeating_groups[-1] -= 2\n        repeating_groups[-2] -= 1\n        changes_needed -= 1\n        if repeating_groups[-2] == 0:\n            repeating_groups.pop(-2)\n\n    return max(lower + upper + digit, changes_needed)", "def strongPasswordChecker(s: str) -> int:\n    if not 6 <= len(s) <= 20:\n        return max(6 - len(s), 20 - len(s))\n    \n    has_lower = has_upper = has_digit = False\n    for char in s:\n        if char.islower():\n            has_lower = True\n        elif char.isupper():\n            has_upper = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if not (has_lower and has_upper and has_digit):\n        return 3 - (has_lower + has_upper + has_digit)\n    \n    if len(s) <= 20:\n        repeat_count = [0]\n        for i in range(2, len(s)):\n            if s[i] == s[i - 1] == s[i - 2]:\n                repeat_count[-1] += 1\n            else:\n                if repeat_count[-1] >= 3:\n                    repeat_count.append(0)\n        \n        changes = 0\n        replacements = 0\n        for count in repeat_count:\n            if count >= 3:\n                changes += count // 3\n                replacements += count % 3\n        \n        for i in range(min(changes, len(s))):\n            s = s[:i * 3 + i] + 'x' + s[i * 3 + i + 1:]\n            replacements -= 1\n        \n        if replacements < 0:\n            return changes - replacements + 3 - (has_lower + has_upper + has_digit)\n        \n        return changes\n    \n    repeat_count = [0]\n    for i in range(3, len(s), 3):\n        if s[i] == s[i - 1] == s[i - 2]:\n            repeat_count[-1] += 1\n        else:\n            if repeat_count[-1] >= 3:\n                repeat_count.append(0)\n    \n    changes = 0\n    for count in repeat_count:\n        if count >= 3:\n            changes += count // 3\n            repeat_count.append(count % 3)\n    \n    while len(s) > 20:\n        i = 0\n        if repeat_count[i] % 3 == 0:\n            i = 1\n        elif repeat_count[i] % 3 == 1 and sum(count % 3 for count in repeat_count) > 2:\n            i = 2\n        repeat_count[i] -= 1", "def strongPasswordChecker(s):\n    def has_lowercase(s):\n        return any(c.islower() for c in s)\n\n    def has_uppercase(s):\n        return any(c.isupper() for c in s)\n\n    def has_digit(s):\n        return any(c.isdigit() for c in s)\n\n    def has_three_repeating(s):\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] == s[i + 2]:\n                return True\n        return False\n\n    if not (6 <= len(s) <= 20):\n        return 20 - len(s) if len(s) < 6 else len(s) - 6\n\n    if not (has_lowercase(s) and has_uppercase(s) and has_digit(s)):\n        return 3 - sum(has_lowercase(s), has_uppercase(s), has_digit(s))\n\n    if not has_three_repeating(s):\n        return 0\n\n    changes = 0\n    while has_three_repeating(s):\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] == s[i + 2]:\n                s = s[:i] + s[i + 1:]\n                changes += 1\n                break\n\n    if len(s) < 6:\n        return max(6 - len(s), changes)\n    elif len(s) > 20:\n        return max(changes, len(s) - 20)\n    else:\n        return changes", "def strongPasswordChecker(s):\n    def has_lowercase(s):\n        return any(c.islower() for c in s)\n\n    def has_uppercase(s):\n        return any(c.isupper() for c in s)\n\n    def has_digit(s):\n        return any(c.isdigit() for c in s)\n\n    def has_repeating_characters(s):\n        return any(s[i] == s[i+1] == s[i+2] for i in range(len(s) - 2))\n\n    if not (6 <= len(s) <= 20):\n        return float('inf')\n\n    if not has_lowercase(s) or not has_uppercase(s) or not has_digit(s):\n        return float('inf')\n\n    if not has_repeating_characters(s):\n        return 0\n\n    changes = 0\n    repeating_characters = [s[i] for i in range(len(s) - 2) if s[i] == s[i+1] == s[i+2]]\n\n    while repeating_characters:\n        if len(repeating_characters) >= 3:\n            changes += 1\n            repeating_characters = [c for c in repeating_characters if c != repeating_characters[0]]\n\n    return changes", "def strongPasswordChecker(s):\n    if not (6 <= len(s) <= 20):\n        return max(6 - len(s), 20 - len(s))\n\n    has_lower = any(c.islower() for c in s)\n    has_upper = any(c.isupper() for c in s)\n    has_digit = any(c.isdigit() for c in s)\n    if not (has_lower and has_upper and has_digit):\n        return 3 - sum(any(getattr(c, f\"is{i}\")() for c in s) for i in \"lowerupperdigit\")\n\n    changes = 0\n    i = 2\n    while i < len(s):\n        if s[i] == s[i-1] == s[i-2]:\n            length = 2\n            while i < len(s) and s[i] == s[i-1]:\n                length += 1\n                i += 1\n            changes += length // 3\n        else:\n            i += 1\n\n    missing_types = 0\n    has_lower = any(c.islower() for c in s)\n    has_upper = any(c.isupper() for c in s)\n    has_digit = any(c.isdigit() for c in s)\n    if not has_lower:\n        missing_types += 1\n    if not has_upper:\n        missing_types += 1\n    if not has_digit:\n        missing_types += 1\n\n    return max(changes, missing_types)"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 22357, "entry_point": "maxScore", "codes": ["def maxScore(cardPoints, k):\n    total = sum(cardPoints[:k])\n    max_score = total\n    for i in range(k):\n        total += cardPoints[-i - 1] - cardPoints[k - i - 1]\n        max_score = max(max_score, total)\n    return max_score", "def maxScore(cardPoints, k):\n    total_sum = sum(cardPoints[:k])\n    max_score = total_sum\n    for i in range(k):\n        total_sum += cardPoints[-i-1] - cardPoints[k-i-1]\n        max_score = max(max_score, total_sum)\n    return max_score", "def maxScore(cardPoints, k):\n    total_sum = sum(cardPoints[:k])\n    max_score = total_sum\n    for i in range(1, k + 1):\n        total_sum += cardPoints[-i] - cardPoints[k - i]\n        max_score = max(max_score, total_sum)\n    return max_score", "def maxScore(cardPoints, k):\n    n = len(cardPoints)\n    total_sum = sum(cardPoints)\n    min_sum = float('inf')\n    window_sum = 0\n    \n    for i in range(n - k, n):\n        window_sum += cardPoints[i]\n    \n    min_sum = min(min_sum, window_sum)\n    \n    for i in range(n - k, n + k - 1):\n        window_sum += cardPoints[i % n] - cardPoints[i - (n - k)]\n        min_sum = min(min_sum, window_sum)\n    \n    return total_sum - min_sum"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 22442, "entry_point": "findLeastNumOfUniqueInts", "codes": ["from collections import Counter\n\ndef findLeastNumOfUniqueInts(arr, k):\n    count = Counter(arr)\n    least_common = count.most_common()[:-k-1:-1]\n    return len(count) - len(least_common)", "def findLeastNumOfUniqueInts(arr, k):\n    from collections import Counter\n    count = Counter(arr)\n    unique_counts = sorted(count.values())\n    for i, c in enumerate(unique_counts):\n        if k < c:\n            return len(unique_counts) - i\n        k -= c\n    return 0", "def findLeastNumOfUniqueInts(arr, k):\n    from collections import Counter\n    count = Counter(arr)\n    unique_counts = sorted(count.values())\n    for i, freq in enumerate(unique_counts):\n        if k >= freq:\n            k -= freq\n        else:\n            return len(unique_counts) - i\n    return 0", "def findLeastNumOfUniqueInts(arr, k):\n    count = [0] * (10**9 + 1)\n    for num in arr:\n        count[num] += 1\n    \n    freqs = sorted(count)\n    unique_count = sum(1 for f in freqs if f > 0)\n    \n    for freq in freqs:\n        if k >= freq:\n            k -= freq\n            unique_count -= 1\n        else:\n            break\n    \n    return unique_count", "def findLeastNumOfUniqueInts(arr, k):\n    from collections import Counter\n    count = Counter(arr)\n    for num, freq in sorted(count.items(), key=lambda item: item[1]):\n        if k >= freq:\n            k -= freq\n        else:\n            return len(count) - k // freq\n    return 0", "def findLeastNumOfUniqueInts(arr, k):\n    from collections import Counter\n    count = Counter(arr)\n    freqs = sorted(count.values())\n    for i, freq in enumerate(freqs):\n        k -= freq\n        if k < 0:\n            return len(freqs) - i - 1\n    return 0", "from collections import Counter\n\ndef findLeastNumOfUniqueInts(arr, k):\n    freq = Counter(arr)\n    for num, count in sorted(freq.items(), key=lambda x: x[1]):\n        if k >= count:\n            k -= count\n        else:\n            return len(freq) - len(freq) + (k > 0)\n    return len(freq) - k > 0", "def findLeastNumOfUniqueInts(arr, k):\n    count = [0] * (len(arr) + 1)\n    for num in arr:\n        count[num] += 1\n    count.sort()\n    for i in range(len(count)):\n        if count[i] == 0:\n            continue\n        if k >= count[i]:\n            k -= count[i]\n        else:\n            return len(count) - i\n    return 0"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 22481, "entry_point": "maxAbsValExpr", "codes": ["def maxAbsValExpr(arr1, arr2):\n    n = len(arr1)\n    return max(\n        max(arr1[i] + arr2[i] + i for i in range(n)) - min(arr1[j] + arr2[j] + j for j in range(n)),\n        max(arr1[i] + arr2[i] - i for i in range(n)) - min(arr1[j] + arr2[j] - j for j in range(n)),\n        max(arr1[i] - arr2[i] + i for i in range(n)) - min(arr1[j] - arr2[j] + j for j in range(n)),\n        max(arr1[i] - arr2[i] - i for i in range(n)) - min(arr1[j] - arr2[j] - j for j in range(n))\n    )", "def maxAbsValExpr(arr1, arr2):\n    max_val = float('-inf')\n    for i in range(4):\n        min_val = float('inf')\n        for j, (a, b) in enumerate(zip(arr1, arr2)):\n            val = (a if i % 2 == 0 else -a) + (b if (i // 2) % 2 == 0 else -b) + j\n            max_val = max(max_val, val - min_val)\n            min_val = min(min_val, val)\n    return max_val", "def maxAbsValExpr(arr1, arr2):\n    n = len(arr1)\n    max_val = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff1 = abs(arr1[i] - arr1[j])\n            diff2 = abs(arr2[i] - arr2[j])\n            diff3 = abs(i - j)\n            max_val = max(max_val, diff1 + diff2 + diff3)\n    return max_val", "def maxAbsValExpr(arr1, arr2):\n    n = len(arr1)\n    max_val = float('-inf')\n    \n    for i in range(4):\n        val = float('-inf')\n        for j in range(n):\n            val = max(val, arr1[j] + arr2[j] + (1 if i & 1 else -1) * j)\n            if j >= 1:\n                max_val = max(max_val, val - arr1[j - 1] - arr2[j - 1] - (1 if i & 1 else -1) * (j - 1))\n    \n    return max_val", "def maxAbsValExpr(arr1, arr2):\n    n = len(arr1)\n    max_diff = 0\n    for i in range(4):\n        cur_max = float('-inf')\n        for j in range(n):\n            val = (i & 1) * arr1[j] + ((i >> 1) & 1) * arr2[j] + (i >> 2) * j\n            max_diff = max(max_diff, val - cur_max)\n            cur_max = max(cur_max, val)\n    return max_diff", "def maxAbsValExpr(arr1, arr2):\n    n = len(arr1)\n    max_val = float('-inf')\n    for k in range(4):\n        min_val = float('inf')\n        for i in range(n):\n            val = (k & 1) * arr1[i] + (k & 2) * arr2[i] + (k & 4) * i\n            if val < min_val:\n                min_val = val\n            else:\n                max_val = max(max_val, val - min_val)\n    return max_val"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 22486, "entry_point": "minDeletionSize", "codes": ["def minDeletionSize(A):\n    return sum(any(A[j][i] < A[j-1][i] for j in range(1, len(A))) for i in range(len(A[0])))", "def minDeletionSize(A):\n    delete = set()\n    for col in zip(*A):\n        if any(col[i] < col[i - 1] for i in range(1, len(col)) if i - 1 not in delete):\n            delete.add(col[0])\n    return len(delete)", "def minDeletionSize(A):\n    cols = len(A[0])\n    keep = [True] * cols\n    for r in range(1, len(A)):\n        for c in range(cols):\n            if keep[c] and A[r][c] < A[r-1][c]:\n                keep[c] = False\n    return sum(not k for k in keep)", "def minDeletionSize(A):\n    n, m = len(A), len(A[0])\n    deletions = 0\n    columns = list(zip(*A))\n    i = 0\n    while i < m:\n        valid = True\n        j = i + 1\n        while j < m:\n            if any(columns[j][k] < columns[i][k] for k in range(n)):\n                deletions += 1\n                valid = False\n                break\n            j += 1\n        if valid:\n            i = j\n        else:\n            i += 1\n    return deletions", "def minDeletionSize(A):\n    cols = list(zip(*A))\n    delete = set()\n    for i in range(1, len(cols)):\n        if any(col[j] < col[j-1] for j in range(1, len(col)) if j not in delete):\n            delete.add(i)\n    return len(delete)", "def minDeletionSize(A):\n    m, n = len(A), len(A[0])\n    cols = list(range(n))\n    deleted = set()\n    \n    while cols:\n        valid = []\n        for col in cols:\n            if all(A[i][col] >= A[i - 1][col] for i in range(1, m) if col not in deleted):\n                valid.append(col)\n        if valid:\n            cols = valid\n        else:\n            deleted.add(cols[0])\n    \n    return len(deleted)", "def minDeletionSize(A):\n    cols = list(zip(*A))\n    deletions = 0\n    i = 0\n    while i < len(cols):\n        if i == 0 or all(cols[i][j] >= cols[i-1][j] for j in range(len(cols[i]))):\n            i += 1\n        else:\n            deletions += 1\n            cols = [(col[:j] + col[j+1:] if j == i else col) for col in cols]\n            i = 0\n    return deletions", "def minDeletionSize(A):\n    dels = set()\n    for c in range(1, len(A[0])):\n        if any(A[r][c] < A[r][c - 1] for r in range(len(A)) if c - 1 not in dels):\n            dels.add(c)\n    return len(dels)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 22503, "entry_point": "longestSubarray", "codes": ["def longestSubarray(nums, limit):\n    maxq, minq = [], []\n    i = 0\n    for j, num in enumerate(nums):\n        while maxq and num > nums[maxq[-1]]:\n            maxq.pop()\n        while minq and num < nums[minq[-1]]:\n            minq.pop()\n        maxq.append(j)\n        minq.append(j)\n        if nums[maxq[0]] - nums[minq[0]] > limit:\n            if maxq[0] == i:\n                maxq.pop(0)\n            if minq[0] == i:\n                minq.pop(0)\n            i += 1\n    return j - i + 1", "def longestSubarray(nums, limit):\n    min_stack, max_stack = [], []\n    left = 0\n    result = 0\n    \n    for right, num in enumerate(nums):\n        while min_stack and num < nums[min_stack[-1]]:\n            min_stack.pop()\n        while max_stack and num > nums[max_stack[-1]]:\n            max_stack.pop()\n        \n        min_stack.append(right)\n        max_stack.append(right)\n        \n        while nums[max_stack[0]] - nums[min_stack[0]] > limit:\n            left += 1\n            if min_stack[0] < left:\n                min_stack.pop(0)\n            if max_stack[0] < left:\n                max_stack.pop(0)\n        \n        result = max(result, right - left + 1)\n    \n    return result", "def longestSubarray(nums, limit):\n    max_dq = []\n    min_dq = []\n    left = 0\n    max_length = 0\n\n    for right, num in enumerate(nums):\n        while max_dq and num > max_dq[-1]:\n            max_dq.pop()\n        while min_dq and num < min_dq[-1]:\n            min_dq.pop()\n        max_dq.append(num)\n        min_dq.append(num)\n\n        while max_dq[0] - min_dq[0] > limit:\n            if max_dq[0] == nums[left]:\n                max_dq.pop(0)\n            if min_dq[0] == nums[left]:\n                min_dq.pop(0)\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length", "def longestSubarray(nums, limit):\n    from collections import deque\n    maxd = mind = i = 0\n    minq, maxq = deque(), deque()\n    for j, n in enumerate(nums):\n        while minq and n < nums[minq[-1]]:\n            minq.pop()\n        while maxq and n > nums[maxq[-1]]:\n            maxq.pop()\n        minq.append(j)\n        maxq.append(j)\n        if nums[maxq[0]] - nums[minq[0]] > limit:\n            i = minq.popleft() if nums[minq[0]] < nums[maxq[0]] else maxq.popleft()\n        maxd = max(maxd, j - i + 1)\n    return maxd"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 22519, "entry_point": "specialArray", "codes": ["def specialArray(nums):\n    for x in range(len(nums) + 1):\n        if sum(1 for num in nums if num >= x) == x:\n            return x\n    return -1", "def specialArray(nums):\n    n = len(nums)\n    for x in range(n + 1):\n        if sum(1 for num in nums if num >= x) == x:\n            return x\n    return -1", "def specialArray(nums):\n    nums.sort()\n    n = len(nums)\n    left, right = 0, n\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] >= n - mid:\n            right = mid\n        else:\n            left = mid + 1\n    return n - left if left < n and nums[left] >= n - left else -1", "def specialArray(nums):\n    from collections import Counter\n    count = Counter(nums)\n    total = len(nums)\n    for x in range(total + 1):\n        while count[x]:\n            if total - count[x] < x:\n                return x\n            total -= count[x]\n            count[x] = 0\n    return -1", "def specialArray(nums):\n    nums.sort()\n    n = len(nums)\n    left, right = 0, n\n    while left < right:\n        mid = (left + right) // 2\n        count = n - mid\n        if nums[mid] >= count:\n            right = mid\n        else:\n            left = mid + 1\n    return left if left < n and nums[left] == n - left else -1", "def specialArray(nums):\n    nums.sort()\n    n = len(nums)\n    left, right = 0, n\n    while left <= right:\n        mid = (left + right) // 2\n        count = n - bisect_left(nums, mid)\n        if count == mid:\n            return mid\n        elif count < mid:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1", "def specialArray(nums):\n    nums.sort()\n    n = len(nums)\n    for x in range(n + 1):\n        i = bisect_left(nums, x)\n        if n - i == x:\n            return x\n    return -1", "def specialArray(nums):\n    nums.sort()\n    for i in range(len(nums) + 1):\n        j = bisect_left(nums, i)\n        if len(nums) - j == i:\n            return i\n    return -1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 22545, "entry_point": "maxProduct", "codes": ["def maxProduct(nums):\n    return (sorted(nums)[-1] - 1) * (sorted(nums)[-2] - 1)", "def maxProduct(nums):\n    nums.sort()\n    return (nums[-1] - 1) * (nums[-2] - 1)", "def maxProduct(nums):\n    max1, max2 = max(nums), max([num for num in nums if num != max(nums)])\n    return (max1 - 1) * (max2 - 1)", "def maxProduct(nums):\n    return (max(nums) - 1) * (max(nums, key=nums.remove) - 1)", "def maxProduct(nums):\n    a, b = max(nums), nums.pop(nums.index(a))\n    return (a-1) * (b-1)", "def maxProduct(nums):\n    return (nums[0] - 1) * (nums[1] - 1)\n\ndef find_second_max(nums):\n    first, second = float('-inf'), float('-inf')\n    for num in nums:\n        if num > first:\n            second = first\n            first = num\n        elif num > second:\n            second = num\n    return (first - 1) * (second - 1)", "def maxProduct(nums):\n    return (heapq.nlargest(2, nums)[1] - 1) * (heapq.nlargest(2, nums)[0] - 1)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 22557, "entry_point": "minScoreTriangulation", "codes": ["def minScoreTriangulation(A):\n    N = len(A)\n    dp = [[0] * N for _ in range(N)]\n    for length in range(2, N):\n        for i in range(N - length):\n            j = i + length\n            dp[i][j] = min(dp[i][k] + dp[k][j] + A[i] * A[k] * A[j] for k in range(i + 1, j))\n    return dp[0][N - 1]", "def minScoreTriangulation(A):\n    n = len(A)\n    dp = [[0] * n for _ in range(n)]\n    \n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = min(dp[i][k] + dp[k][j] + A[i] * A[k] * A[j] for k in range(i + 1, j))\n    \n    return dp[0][n - 1]", "def minScoreTriangulation(A):\n    N = len(A)\n    dp = [[0] * N for _ in range(N)]\n    \n    for length in range(3, N + 1):\n        for i in range(N - length + 1):\n            j = i + length - 1\n            dp[i][j] = min(dp[i][k] + dp[k][j] + A[i] * A[k] * A[j] for k in range(i + 1, j))\n    \n    return dp[0][N - 1]", "def minScoreTriangulation(A):\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i < 2:\n            return 0\n        return min(dp(i, k) + dp(k, j) + A[i] * A[k] * A[j] for k in range(i + 1, j))\n    \n    return dp(0, len(A) - 1)", "def minScoreTriangulation(A):\n    n = len(A)\n    dp = [[float('inf')] * n for _ in range(n)]\n    \n    for length in range(2, n):\n        for i in range(n - length):\n            j = i + length\n            for k in range(i + 1, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + A[i] * A[k] * A[j])\n    \n    return dp[0][n - 1]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 22660, "entry_point": "longestPrefix", "codes": ["def longestPrefix(s):\n    for i in range(len(s) - 1, 0, -1):\n        if s.startswith(s[i:]):\n            return s[i:]\n    return \"\"", "def longestPrefix(s: str) -> str:\n    for i in range(len(s) - 1, 0, -1):\n        if s.startswith(s[i:]):\n            return s[i:]\n    return \"\"", "def longestPrefix(s: str) -> str:\n    for i in range(len(s) - 1, 0, -1):\n        if s[:i] == s[-i:]:\n            return s[:i]\n    return \"\"", "def longestPrefix(s):\n    return max(s[:i] for i in range(1, len(s)) if s.startswith(s[i:]))", "def longestPrefix(s):\n    return s[:next((i for i in range(len(s), 0, -1) if s.startswith(s[i:])), 0)]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 22700, "entry_point": "reorderedPowerOf2", "codes": ["def reorderedPowerOf2(N):\n    return sorted(str(N)) in (sorted(str(1 << i)) for i in range(31))", "def reorderedPowerOf2(N):\n    return sorted(str(N)) in [sorted(str(1 << i)) for i in range(31)]", "def reorderedPowerOf2(N):\n    return sorted(str(N)) in [sorted(str(1 << i)) for i in range(30)]", "def reorderedPowerOf2(n):\n    def is_power_of_2(num):\n        return num > 0 and (num & (num - 1)) == 0\n\n    return is_power_of_2(int(''.join(sorted(str(n)))))\n\n# Unit tests\nassert reorderedPowerOf2(1) == True\nassert reorderedPowerOf2(10) == False\nassert reorderedPowerOf2(16) == True\nassert reorderedPowerOf2(24) == False\nassert reorderedPowerOf2(46) == True", "from typing import Set\nfrom functools import reduce\nfrom operator import mul\n\ndef reorderedPowerOf2(N: int) -> bool:\n    digits = sorted(str(N))\n    powers_of_2_digits = {sorted(str(2**i)) for i in range(30)}\n    return digits in powers_of_2_digits", "def reorderedPowerOf2(N):\n    count = [0] * 10\n    while N:\n        count[N % 10] += 1\n        N //= 10\n    return any(all(count[i] == count2[i] for i in range(10)) for count2 in [(1 << i).bit_count() for i in range(30)])"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 22865, "entry_point": "superEggDrop", "codes": ["def superEggDrop(K, N):\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    for m in range(1, N + 1):\n        for k in range(1, K + 1):\n            dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1\n            if dp[m][k] >= N:\n                return m", "def superEggDrop(K, N):\n    dp = [0] * (K + 1)\n    moves = 0\n    while dp[K] < N:\n        moves += 1\n        for k in range(K, 0, -1):\n            dp[k] += dp[k - 1] + 1\n    return moves", "def superEggDrop(K: int, N: int) -> int:\n    dp = [0] * (K + 1)\n    moves = 0\n    while dp[K] < N:\n        moves += 1\n        for k in range(K, 0, -1):\n            dp[k] += dp[k - 1] + 1\n    return moves", "def superEggDrop(K, N):\n    @lru_cache(None)\n    def dp(k, n):\n        if k == 1: return n\n        if n == 0: return 0\n        return min(max(dp(k-1, x-1), dp(k, n-x)) for x in range(1, n+1)) + 1\n    return dp(K, N)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 2326, "entry_point": "hasAlternatingBits", "codes": ["def hasAlternatingBits(n):\n    return all(a != b for a, b in zip(bin(n)[2:], bin(n)[3:]))", "def hasAlternatingBits(n):\n    return all(bin(n)[i] != bin(n)[i + 1] for i in range(len(bin(n)) - 2))", "def hasAlternatingBits(n):\n    return all(_lhs != _rhs for _lhs, _rhs in zip(format(n, 'b'), format(n, 'b')[1:]))", "def hasAlternatingBits(n):\n    i = 1\n    while n > 0:\n        if n % 2 == i:\n            return False\n        i = 1 - i\n        n //= 2\n    return True"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 23150, "entry_point": "numFactoredBinaryTrees", "codes": ["from collections import defaultdict\n\ndef numFactoredBinaryTrees(A):\n    MOD = 10 ** 9 + 7\n    A.sort()\n    dp = defaultdict(int)\n    for i, a in enumerate(A):\n        dp[a] = 1\n        for j, b in enumerate(A[:i]):\n            if a % b == 0:\n                c = a // b\n                if c in dp:\n                    dp[a] = (dp[a] + dp[b] * dp[c] * (2 if b != c else 1)) % MOD\n    return sum(dp.values()) % MOD", "def numFactoredBinaryTrees(A):\n    MOD = 10**9 + 7\n    A.sort()\n    n = len(A)\n    dp = [1] * n\n    index = {x: i for i, x in enumerate(A)}\n    \n    for i in range(n):\n        for j in range(i):\n            if A[i] % A[j] == 0:\n                right = A[i] // A[j]\n                if right in index:\n                    dp[i] = (dp[i] + dp[j] * dp[index[right]] * (2 if A[j] != right else 1)) % MOD\n    \n    return sum(dp) % MOD", "from collections import Counter\n\ndef numFactoredBinaryTrees(A):\n    MOD = 10 ** 9 + 7\n    A.sort()\n    A_set = set(A)\n    dp = Counter(A)\n    \n    for i in range(1, len(A)):\n        for j in range(i):\n            if A[i] % A[j] == 0:\n                b = A[i] // A[j]\n                if b in A_set:\n                    dp[A[i]] += dp[A[j]] * dp[b]\n                    dp[A[i]] %= MOD\n    \n    return sum(dp.values()) % MOD", "from functools import lru_cache\n\n@lru_cache(None)\ndef numFactoredBinaryTrees(self, A):\n    A = sorted(A)\n    n = len(A)\n    count = [1] * n\n    \n    for i in range(n):\n        for j in range(i):\n            if A[i] % A[j] == 0:\n                right = A[i] // A[j]\n                if right in A[j:]:\n                    k = A[j:].index(right)\n                    count[i] += count[j] * count[j + k] * (2 if j == j + k else 1)\n                    \n    return sum(count) % (10 ** 9 + 7)", "from collections import defaultdict\n\ndef numFactoredBinaryTrees(A):\n    A.sort()\n    n = len(A)\n    mod = 10 ** 9 + 7\n    dp = defaultdict(int)\n    for i, x in enumerate(A):\n        dp[x] = 1\n        for j in range(i):\n            if x % A[j] == 0:\n                k = x // A[j]\n                if k in dp:\n                    dp[x] = (dp[x] + dp[A[j]] * dp[k] * (1 if A[j] == k else 2)) % mod\n    return sum(dp.values()) % mod\n\ndef _equivalent(lhs, rhs):\n    if type(lhs) != type(rhs):\n        return False\n    if isinstance(lhs, dict):\n        return all(_equivalent(lhs[key], rhs[key]) for key in lhs if key in rhs) and all(_equivalent(lhs[key], rhs[key]) for key in rhs if key in lhs)\n    if isinstance(lhs, list):\n        return all(_equivalent(lhs[i], rhs[i]) for i in range(min(len(lhs), len(rhs))))\n    return lhs == rhs\n\n# Example usage:\nassert _equivalent(numFactoredBinaryTrees([2, 4]), 3)\nassert _equivalent(numFactoredBinaryTrees([2, 4, 5, 10]), 7)", "def numFactoredBinaryTrees(A):\n    MOD = 10**9 + 7\n    A.sort()\n    dp = {}\n    for i, x in enumerate(A):\n        dp[x] = 1\n        for j in range(i):\n            if x % A[j] == 0:\n                right = x // A[j]\n                if right in dp:\n                    dp[x] = (dp[x] + dp[A[j]] * dp[right] * (2 if A[j] == right else 1)) % MOD\n    return sum(dp.values()) % MOD", "from typing import List\nfrom functools import lru_cache\n\nMOD = 10 ** 9 + 7\n\n@lru_cache(None)\ndef numFactoredBinaryTrees(A: List[int]) -> int:\n    A = sorted(A)\n    n = len(A)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if A[i] % A[j] == 0:\n                k = A[i] // A[j]\n                if k in A[:i]:\n                    dp[i] = (dp[i] + dp[j] * dp[A.index(k)] * (2 if A[j] == k else 1)) % MOD\n    return sum(dp) % MOD"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 23201, "entry_point": "tallestBillboard", "codes": ["def tallestBillboard(rods):\n    dp = {0: 0}\n    for r in rods:\n        for d, h in list(dp.items()):\n            dp[d + r] = max(dp.get(d + r, 0), h)\n            dp[abs(d - r)] = max(dp.get(abs(d - r), 0), h + min(d, r))\n    return dp[0]", "def tallestBillboard(rods):\n    dp = {0: 0}\n    for r in rods:\n        new_dp = dp.copy()\n        for d, h in dp.items():\n            new_dp[d + r] = max(new_dp.get(d + r, 0), h + r)\n            new_dp[abs(d - r)] = max(new_dp.get(abs(d - r), 0), h)\n        dp = new_dp\n    return dp[0]", "def tallestBillboard(rods):\n    dp = {0: 0}\n    for r in rods:\n        new_dp = dp.copy()\n        for diff, taller in dp.items():\n            new_dp[diff + r] = max(new_dp.get(diff + r, 0), taller)\n            new_dp[abs(diff - r)] = max(new_dp.get(abs(diff - r), 0), taller + min(diff, r))\n        dp = new_dp\n    return dp[0]", "from functools import lru_cache\n\n@lru_cache(None)\ndef tallestBillboard(rods, diff=0):\n    if not rods:\n        return 0 if diff == 0 else float('-inf')\n    return max(tallestBillboard(rods[1:], diff + rods[0]),\n               tallestBillboard(rods[1:], diff - rods[0]),\n               tallestBillboard(rods[1:], diff) + (rods[0] if diff == 0 else 0))\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 23288, "entry_point": "mincostTickets", "codes": ["def mincostTickets(days, costs):\n    MAX_DAY = 365\n    dp = [0] * (MAX_DAY + 1)\n    \n    for i in range(1, MAX_DAY + 1):\n        if i in days:\n            dp[i] = min(dp[i - 1] + costs[0], dp[max(i - 7, 0)] + costs[1], dp[max(i - 30, 0)] + costs[2])\n        else:\n            dp[i] = dp[i - 1]\n    \n    return dp[MAX_DAY]", "def mincostTickets(days, costs):\n    dp = [0] * (days[-1] + 1)\n    last_7 = last_30 = 0\n    for d in range(1, days[-1] + 1):\n        if d not in days:\n            dp[d] = dp[d - 1]\n        else:\n            last_7 = dp[max(0, d - 7)]\n            last_30 = dp[max(0, d - 30)]\n            dp[d] = min(dp[d - 1] + costs[0], last_7 + costs[1], last_30 + costs[2])\n    return dp[days[-1]]", "def mincostTickets(days, costs):\n    n = len(days)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    durations = [1, 7, 30]\n    \n    for i in range(1, n + 1):\n        for cost, duration in zip(costs, durations):\n            j = i\n            while j > 0 and days[i - 1] - days[j - 1] + 1 > duration:\n                j -= 1\n            dp[i] = min(dp[i], dp[j] + cost)\n    \n    return dp[n]", "def mincostTickets(days, costs):\n    n = len(days)\n    durations = [1, 7, 30]\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        min_cost = float('inf')\n        for j in range(3):\n            while i > 1 and days[i - 1] - days[i - durations[j] - 1] >= durations[j]:\n                i -= 1\n            min_cost = min(min_cost, dp[i - durations[j]] + costs[j])\n        dp[i] = min_cost\n\n    return dp[n]", "def mincostTickets(days, costs):\n    n = len(days)\n    durations = [1, 7, 30]\n    dp = [0] * (n + 1)\n    \n    for i in range(n):\n        j = i\n        for k in range(3):\n            while j < n and days[j] - days[i] < durations[k]:\n                j += 1\n            dp[j] = min(dp[j], dp[i] + costs[k])\n    \n    return dp[n]", "def mincostTickets(days, costs):\n    dp = [float('inf')] * (len(days) + 1)\n    dp[-1] = 0\n\n    for i in range(len(days) - 1, -1, -1):\n        dp[i] = min(dp[min(i + 1, len(days))], dp[min(i + 7, len(days))] + costs[1], dp[min(i + 30, len(days))] + costs[2])\n\n    return dp[0]", "def mincostTickets(days, costs):\n    max_day = days[-1]\n    dp = [0] * (max_day + 1)\n    \n    for i in range(1, max_day + 1):\n        if i in days:\n            dp[i] = min(dp[i - 1] + costs[0], dp[i - 7] + costs[1], dp[i - 30] + costs[2])\n        else:\n            dp[i] = dp[i - 1]\n    \n    return dp[max_day]\n\n# Example usage\nassert mincostTickets([1, 4, 6, 7, 8, 20], [2, 7, 15]) == 11\nassert mincostTickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 7, 15]) == 17"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 23372, "entry_point": "findSubstringInWraproundString", "codes": ["from collections import Counter\n\ndef findSubstringInWraproundString(p: str) -> int:\n    count = Counter()\n    max_len = 0\n    for i in range(len(p)):\n        if i > 0 and (ord(p[i]) - ord(p[i-1])) % 26 == 1:\n            max_len += 1\n        else:\n            max_len = 1\n        count[p[i]] = max(count[p[i]], max_len)\n    return sum(count.values())", "def findSubstringInWraproundString(p):\n    wrap = 'abcdefghijklmnopqrstuvwxyz'\n    max_len = [0] * 26\n    current_len = 0\n    last_char = -1\n    \n    for char in p:\n        char_idx = ord(char) - ord('a')\n        if (last_char == -1 or (last_char + 1) % 26 == char_idx):\n            current_len += 1\n        else:\n            current_len = 1\n        max_len[char_idx] = max(max_len[char_idx], current_len)\n        last_char = char_idx\n    \n    return sum(max_len)", "def findSubstringInWraproundString(p):\n    count = [0] * 26\n    max_len = 0\n    for i in range(len(p)):\n        if i > 0 and (ord(p[i]) - ord(p[i-1]) == 1 or (p[i] == 'a' and p[i-1] == 'z')):\n            max_len += 1\n        else:\n            max_len = 1\n        count[ord(p[i]) - ord('a')] = max(count[ord(p[i]) - ord('a')], max_len)\n    return sum(count)", "from collections import Counter\n\ndef findSubstringInWraproundString(p: str) -> int:\n    if not p:\n        return 0\n    \n    max_len = [0] * 26\n    current_len = 1\n    \n    for i in range(1, len(p)):\n        if (ord(p[i]) - ord(p[i - 1]) + 26) % 26 == 1:\n            current_len += 1\n        else:\n            current_len = 1\n        \n        current_index = ord(p[i]) - ord('a')\n        max_len[current_index] = max(max_len[current_index], current_len)\n    \n    return sum(max_len)", "def findSubstringInWraproundString(p):\n    max_len = [0] * 26\n    current_len = 1\n    prev_char = ord('z')\n    \n    for char in p:\n        char_code = ord(char)\n        if (char_code - prev_char) % 26 == 1:\n            current_len += 1\n        else:\n            current_len = 1\n        max_len[char_code - ord('a')] = max(max_len[char_code - ord('a')], current_len)\n        prev_char = char_code\n    \n    return sum(max_len)", "def findSubstringInWraproundString(p: str) -> int:\n    dp = [0] * 26\n    max_len = 0\n    for i in range(len(p)):\n        max_len = max(max_len + 1, 1 if i == 0 or (ord(p[i]) - ord(p[i - 1])) % 26 == 1 else 1)\n        dp[ord(p[i]) - ord('a')] = max(dp[ord(p[i]) - ord('a')], max_len)\n    return sum(dp)"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 23468, "entry_point": "rankTeams", "codes": ["def rankTeams(votes):\n    counts = {team: [0] * len(votes[0]) for team in votes[0]}\n    for vote in votes:\n        for rank, team in enumerate(vote):\n            counts[team][rank] -= 1\n    return ''.join(sorted(counts, key=counts.get))", "def rankTeams(votes):\n    n = len(votes[0])\n    team_votes = {team: [0] * n for team in votes[0]}\n    \n    for vote in votes:\n        for rank, team in enumerate(vote):\n            team_votes[team][rank] -= 1\n    \n    return ''.join(sorted(team_votes.keys(), key=team_votes.get))", "def rankTeams(votes):\n    counts = {team: [0] * len(votes[0]) for team in votes[0]}\n    for vote in votes:\n        for rank, team in enumerate(vote):\n            counts[team][rank] -= 1\n    teams = list(counts.keys())\n    teams.sort(key=lambda team: (counts[team], team))\n    return ''.join(teams)", "from collections import Counter\nfrom functools import cmp_to_key\n\ndef rankTeams(votes):\n    n = len(votes[0])\n    team_votes = Counter()\n    \n    for vote in votes:\n        for rank, team in enumerate(vote):\n            team_votes[team][rank] += 1\n    \n    def cmp(a, b):\n        for rank in range(n):\n            if team_votes[a][rank] != team_votes[b][rank]:\n                return team_votes[b][rank] - team_votes[a][rank]\n        return ord(a) - ord(b)\n    \n    return ''.join(sorted(votes[0], key=cmp_to_key(cmp)))", "from collections import defaultdict\n\ndef rankTeams(votes):\n    counts = defaultdict(lambda: [0] * len(votes[0]))\n    for vote in votes:\n        for rank, team in enumerate(vote):\n            counts[team][rank] -= 1\n    return ''.join(sorted(votes[0], key=lambda team: counts[team]))", "def rankTeams(votes):\n    vote_count = {team: [0] * len(votes[0]) for team in votes[0]}\n    for vote in votes:\n        for rank, team in enumerate(vote):\n            vote_count[team][rank] -= 1\n    return ''.join(sorted(votes[0], key=vote_count.get))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 23521, "entry_point": "maxLength", "codes": ["def maxLength(arr):\n    def backtrack(start, current):\n        yield len(current)\n        for i in range(start, len(arr)):\n            if len(set(arr[i])) == len(arr[i]) and not any(char in current for char in arr[i]):\n                yield from backtrack(i + 1, current + arr[i])\n    \n    return max(backtrack(0, \"\"), default=0)", "def maxLength(arr):\n    def backtrack(start, current, max_length):\n        max_length[0] = max(max_length[0], len(current))\n        for i in range(start, len(arr)):\n            if not set(arr[i]) | set(current):\n                backtrack(i + 1, current + arr[i], max_length)\n\n    max_length = [0]\n    backtrack(0, \"\", max_length)\n    return max_length[0]", "def maxLength(arr):\n    def backtrack(start, current):\n        max_length[0] = max(max_length[0], len(current))\n        for i in range(start, len(arr)):\n            if len(current) + len(arr[i]) == len(set(current + arr[i])):\n                backtrack(i + 1, current + arr[i])\n    \n    max_length = [0]\n    backtrack(0, \"\")\n    return max_length[0]", "def maxLength(arr):\n    def backtrack(index, current):\n        if index == len(arr):\n            return len(current)\n        include = 0\n        if all(c not in current for c in arr[index]):\n            include = backtrack(index + 1, current + arr[index])\n        exclude = backtrack(index + 1, current)\n        return max(include, exclude)\n\n    return backtrack(0, \"\")", "def maxLength(arr):\n    def backtrack(start, current):\n        max_length = len(current)\n        for i in range(start, len(arr)):\n            if len(current) + len(arr[i]) == len(current + arr[i]) and all(char not in current for char in arr[i]):\n                max_length = max(max_length, backtrack(i + 1, current + arr[i]))\n        return max_length\n\n    return backtrack(0, \"\")", "def maxLength(arr):\n    def backtrack(start, current):\n        nonlocal max_length\n        max_length = max(max_length, len(current))\n        for i in range(start, len(arr)):\n            if len(current & arr[i]) == 0:\n                backtrack(i + 1, current | arr[i])\n    \n    max_length = 0\n    backtrack(0, set())\n    return max_length"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 23579, "entry_point": "minFlips", "codes": ["def minFlips(a: int, b: int, c: int) -> int:\n    flips = 0\n    while a or b or c:\n        bit_a, bit_b, bit_c = a & 1, b & 1, c & 1\n        if bit_c == 0:\n            flips += bit_a + bit_b\n        else:\n            flips += 0 if bit_a or bit_b else 1\n        a, b, c = a >> 1, b >> 1, c >> 1\n    return flips", "def minFlips(a, b, c):\n    flips = 0\n    while a or b or c:\n        if c & 1:\n            flips += (a & 1) == 0 and (b & 1) == 0\n        else:\n            flips += (a & 1) + (b & 1)\n        a >>= 1\n        b >>= 1\n        c >>= 1\n    return flips", "def minFlips(a: int, b: int, c: int) -> int:\n    flips = 0\n    while a or b or c:\n        if c & 1:\n            flips += (a & 1) + (b & 1) == 0\n        else:\n            flips += (a & 1) + (b & 1)\n        a >>= 1\n        b >>= 1\n        c >>= 1\n    return flips", "def minFlips(a: int, b: int, c: int) -> int:\n    return sum(x != y != (c & 1) for x, y in zip_longest(format(a, '030b'), format(b, '030b'), format(c, '030b'), fillvalue='0'))", "def minFlips(a: int, b: int, c: int) -> int:\n    flips = 0\n    while a or b or c:\n        bit_a, bit_b, bit_c = a & 1, b & 1, c & 1\n        if bit_c == 0:\n            flips += bit_a + bit_b\n        else:\n            flips += (bit_a == 0) + (bit_b == 0)\n        a, b, c = a >> 1, b >> 1, c >> 1\n    return flips", "def minFlips(a, b, c):\n    return sum([\n        (a | b) & ~c,\n        (a & c) & ~b,\n        (b & c) & ~a\n    ])", "def minFlips(a: int, b: int, c: int) -> int:\n    flips = 0\n    while a or b or c:\n        bit_a = a & 1\n        bit_b = b & 1\n        bit_c = c & 1\n        if bit_c == 0:\n            flips += bit_a + bit_b\n        else:\n            flips += (bit_a == 0) + (bit_b == 0)\n        a >>= 1\n        b >>= 1\n        c >>= 1\n    return flips"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 23851, "entry_point": "splitArraySameAverage", "codes": ["def splitArraySameAverage(A):\n    from itertools import combinations\n\n    total_sum, n = sum(A), len(A)\n    for i in range(1, n // 2 + 1):\n        if total_sum * i % n == 0:\n            if any(sum(subset) == total_sum * i // n for subset in combinations(A, i)):\n                return True\n    return False", "def splitArraySameAverage(A):\n    from itertools import combinations\n    total_sum = sum(A)\n    n = len(A)\n    for i in range(1, n // 2 + 1):\n        if (total_sum * i) % n == 0:\n            target = total_sum * i // n\n            for comb in combinations(A, i):\n                if sum(comb) == target:\n                    return True\n    return False", "def splitArraySameAverage(A):\n    n, total = len(A), sum(A)\n    dp = [set() for _ in range(n + 1)]\n    dp[0].add(0)\n\n    for num in A:\n        for i in range(n, 0, -1):\n            for s in dp[i - 1]:\n                dp[i].add(s + num)\n\n    for i in range(1, n // 2 + 1):\n        if (total * i) % n == 0 and (total * i) // n in dp[i]:\n            return True\n\n    return False", "from typing import List\n\ndef splitArraySameAverage(A: List[int]) -> bool:\n    total_sum = sum(A)\n    n = len(A)\n    \n    def can_split(sumB, lenB):\n        sumC = total_sum - sumB\n        lenC = n - lenB\n        if lenC == 0:\n            return False\n        if sumC / lenC == sumB / lenB:\n            return True\n        return any(can_split(sumB - x, lenB - 1) for x in A if x < sumB and can_split(sumB, lenB))\n    \n    return any(can_split(sumB, lenB) for lenB in range(1, n) for sumB in range(lenB * min(A), lenB * max(A) + 1))", "from fractions import Fraction\nfrom itertools import combinations\n\ndef splitArraySameAverage(A):\n    n = len(A)\n    total_sum = sum(A)\n    \n    if n == 1:\n        return False\n    \n    for i in range(1, n // 2 + 1):\n        if total_sum * i % n == 0:\n            target = Fraction(total_sum * i, n)\n            seen = set()\n            for comb in combinations(A, i):\n                if Fraction(sum(comb), i) == target:\n                    return True\n    return False", "from typing import List\n\ndef splitArraySameAverage(A: List[int]) -> bool:\n    n = len(A)\n    if n < 2:\n        return False\n    \n    total_sum = sum(A)\n    target = total_sum / n\n    \n    for i in range(1, n // 2 + 1):\n        if target * i == sum(A[:i]) and target * (n - i) == sum(A[i:n]):\n            return True\n        if target * i == sum(A[:i]) and target * (n - i) == sum(A[i:n]):\n            return True\n    \n    return False", "def splitArraySameAverage(A):\n    n, s = len(A), sum(A)\n    if n == 1: return False\n    target = s / n\n    dp = {0}\n    for a in A:\n        ndp = dp.copy()\n        for dp_s in dp:\n            ndp[dp_s + a] = True\n            if (n - 1) * dp_s + a == target * (n - 1):\n                return True\n        dp = ndp\n    return False", "def splitArraySameAverage(A):\n    from collections import defaultdict\n    total_sum = sum(A)\n    n = len(A)\n    \n    def is_possible(subset_sum, subset_size):\n        if subset_size == 0 or subset_size == n:\n            return False\n        target = subset_sum * n // total_sum\n        dp = defaultdict(set)\n        dp[0].add(0)\n        for num in A:\n            for size in range(subset_size - 1, 0, -1):\n                for s in dp[size - 1]:\n                    dp[size].add(s + num)\n        return target in dp[subset_size]\n    \n    for i in range(1, n // 2 + 1):\n        if total_sum * i % n == 0 and is_possible(total_sum * i, i):\n            return True\n    return False"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 23892, "entry_point": "minSteps", "codes": ["def minSteps(s: str, t: str) -> int:\n    return sum([abs(s.count(c) - t.count(c)) for c in set(s)]) // 2", "import collections\n\ndef minSteps(s: str, t: str) -> int:\n    return sum((collections.Counter(s) - collections.Counter(t)).values())", "from collections import Counter\n\ndef minSteps(s: str, t: str) -> int:\n    return sum((Counter(s) - Counter(t)).values()) // 2", "from collections import Counter\n\ndef minSteps(s, t):\n    return sum(abs(a - b) for a, b in zip(Counter(s).values(), Counter(t).values())) // 2", "import collections\n\ndef minSteps(s, t):\n    return sum((collections.Counter(s) & collections.Counter(t)).values())", "def minSteps(s: str, t: str) -> int:\n    s_count, t_count = [0] * 26, [0] * 26\n    for char in s:\n        s_count[ord(char) - ord('a')] += 1\n    for char in t:\n        t_count[ord(char) - ord('a')] += 1\n    return sum(abs(s_count[i] - t_count[i]) for i in range(26)) // 2", "def minSteps(s, t):\n    return (sum((collections.Counter(s) - collections.Counter(t)).values()) + 1) // 2"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 23900, "entry_point": "consecutiveNumbersSum", "codes": ["def consecutiveNumbersSum(N):\n    count = 0\n    for k in range(1, int(N**0.5) + 1):\n        if (N - k * (k - 1) // 2) % k == 0:\n            count += 1\n    return count", "def consecutiveNumbersSum(N):\n    count = 0\n    left = 1\n    current_sum = 0\n    \n    while left * (left - 1) // 2 < N:\n        if (N - left * (left - 1) // 2) % left == 0:\n            count += 1\n        left += 1\n    \n    return count", "def consecutiveNumbersSum(N):\n    count = 0\n    for start in range(1, N + 1):\n        current_sum = 0\n        for end in range(start, N + 1):\n            current_sum += end\n            if current_sum == N:\n                count += 1\n            elif current_sum > N:\n                break\n    return count", "def consecutiveNumbersSum(N):\n    count = 0\n    for start in range(1, int(N ** 0.5) + 1):\n        total = 0\n        for i in range(start, start + int((2 * N - start**2) ** 0.5) + 1):\n            total += i\n            if total == N:\n                count += 1\n                break\n            elif total > N:\n                break\n    return count", "def consecutiveNumbersSum(N):\n    count = 0\n    for i in range(1, int(N**0.5) + 1):\n        current_sum = 0\n        j = i\n        while current_sum < N:\n            current_sum += j\n            j += 1\n        if current_sum == N:\n            count += 1\n    return count", "def consecutiveNumbersSum(N):\n    count = 0\n    for k in range(1, N + 1):\n        if (2 * N + k - k * k) % (2 * k) == 0:\n            count += 1\n    return count", "def consecutiveNumbersSum(n):\n    count = 0\n    for i in range(1, n):\n        total = 0\n        for j in range(i, n):\n            total += j\n            if total == n:\n                count += 1\n                break\n            elif total > n:\n                break\n    return count"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 23913, "entry_point": "mergeStones", "codes": ["def mergeStones(stones, K):\n    if (len(stones) - 1) % (K - 1) != 0:\n        return -1\n    \n    n = len(stones)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + stones[i]\n    \n    dp = [[0] * n for _ in range(n)]\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            for m in range(i, j, K - 1):\n                dp[i][j] = min(dp[i][j], dp[i][m] + dp[m + 1][j])\n            if (j - i) % (K - 1) == 0:\n                dp[i][j] += prefix_sum[j + 1] - prefix_sum[i]\n    \n    return dp[0][n - 1]", "def mergeStones(stones, K):\n    n = len(stones)\n    if (n - 1) % (K - 1):\n        return -1\n    \n    prefix_sum = [0]\n    for stone in stones:\n        prefix_sum.append(prefix_sum[-1] + stone)\n    \n    dp = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 0\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            for m in range(i, j, K - 1):\n                dp[i][j] = min(dp[i][j], dp[i][m] + dp[m + 1][j])\n            if (j - i) % (K - 1) == 0:\n                dp[i][j] += prefix_sum[j + 1] - prefix_sum[i]\n    \n    return dp[0][n - 1]", "def mergeStones(stones, K):\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n\n    prefix_sum = [0]\n    for stone in stones:\n        prefix_sum.append(prefix_sum[-1] + stone)\n\n    dp = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 0\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            for m in range(i, j, K - 1):\n                dp[i][j] = min(dp[i][j], dp[i][m] + dp[m + 1][j])\n            if (length - 1) % (K - 1) == 0:\n                dp[i][j] += prefix_sum[j + 1] - prefix_sum[i]\n\n    return dp[0][n - 1]", "def mergeStones(stones, K):\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    \n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + stones[i]\n    \n    dp = [[float('inf')] * n for _ in range(n)]\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            for m in range(i, j, K - 1):\n                dp[i][j] = min(dp[i][j], dp[i][m] + dp[m + 1][j])\n            if (j - i) % (K - 1) == 0:\n                dp[i][j] += prefix_sum[j + 1] - prefix_sum[i]\n    \n    return dp[0][n - 1]", "def mergeStones(stones, K):\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    \n    prefix_sum = [0]\n    for stone in stones:\n        prefix_sum.append(prefix_sum[-1] + stone)\n    \n    dp = [[float('inf')] * n for _ in range(n)]\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            for mid in range(i, j, K - 1):\n                dp[i][j] = min(dp[i][j], dp[i][mid] + dp[mid + 1][j])\n            if (j - i) % (K - 1) == 0:\n                dp[i][j] += prefix_sum[j + 1] - prefix_sum[i]\n    \n    return dp[0][n - 1]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 2404, "entry_point": "isValidSerialization", "codes": ["def isValidSerialization(preorder):\n    slots = 1\n    for value in preorder.split(','):\n        if slots == 0:\n            return False\n        slots += 1 if value != '#' else -1\n    return slots == 0", "def isValidSerialization(serialized: str) -> bool:\n    slots = 1\n    for val in serialized.split(','):\n        if slots == 0:\n            return False\n        slots += 1 if val != '#' else -1\n    return slots == 0", "def isValidSerialization(serialized: str) -> bool:\n    slots = 1\n    for value in serialized.split(','):\n        if slots == 0:\n            return False\n        slots += 1 if value != '#' else -1\n    return slots == 0", "def isValidSerialization preorder):\n    slots = 1\n    for value in preorder.split(','):\n        slots -= 1\n        if slots < 0:\n            return False\n        if value != '#':\n            slots += 2\n    return slots == 0", "def isValidSerialization(self, preorder: str) -> bool:\n    slots = 1\n    for node in preorder.split(','):\n        if not slots:\n            return False\n        slots += 1 if node != '#' else -1\n    return not slots", "def isValidSerialization(self, preorder: str) -> bool:\n    slots = 1\n    for node in preorder.split(','):\n        slots -= 1\n        if slots < 0:\n            return False\n        slots += 2\n    return slots == 0"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 24234, "entry_point": "xorOperation", "codes": ["def xorOperation(n, start):\n    result = 0\n    for i in range(n):\n        result ^= start + 2 * i\n    return result", "def xorOperation(n, start):\n    xor_result = 0\n    for i in range(n):\n        xor_result ^= start + 2 * i\n    return xor_result", "def xorOperation(n: int, start: int) -> int:\n    xor_result = 0\n    for i in range(n):\n        xor_result ^= start + 2 * i\n    return xor_result", "def xorOperation(n, start):\n    return reduce(lambda x, y: x ^ y, range(start, start + 2 * n, 2), 0)", "def xorOperation(n: int, start: int) -> int:\n    return reduce(xor, range(start, start + 2*n, 2))", "def xorOperation(n, start):\n    return reduce(lambda x, y: x ^ y, (start + 2*i for i in range(n)))", "def xorOperation(n, start):\n    return reduce(lambda x, i: x ^ (start + 2 * i), range(n), 0)", "def xorOperation(n, start):\n    return reduce(xor, (start + 2*i for i in range(n)))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 24283, "entry_point": "numWays", "codes": ["MOD = 10**9 + 7\n\ndef numWays(steps: int, arrLen: int) -> int:\n    max_reach = min(steps // 2 + 1, arrLen)\n    dp = [1] + [0] * (max_reach - 1)\n    \n    for _ in range(steps):\n        ndp = [0] * max_reach\n        for i in range(max_reach):\n            ndp[i] = (dp[i] + (dp[i - 1] if i > 0 else 0) + (dp[i + 1] if i < max_reach - 1 else 0)) % MOD\n        dp = ndp\n    \n    return dp[0]", "def numWays(steps: int, arrLen: int) -> int:\n    MOD = 10**9 + 7\n    dp = [0] * min(steps // 2 + 1, arrLen) + [0]\n    dp[0] = 1\n    for _ in range(steps):\n        new_dp = [0] * len(dp)\n        for i in range(len(dp) - 1):\n            new_dp[i] = (dp[i] + dp[i + 1]) % MOD\n            if i > 0:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n        dp = new_dp\n    return dp[0]", "def numWays(steps, arrLen):\n    MOD = 10**9 + 7\n    arrLen = min(steps // 2 + 1, arrLen)\n    dp = [0] * arrLen\n    dp[0] = 1\n    for _ in range(steps):\n        new_dp = [0] * arrLen\n        for i in range(arrLen):\n            new_dp[i] = dp[i]\n            if i > 0:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n            if i < arrLen - 1:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    return dp[0]", "MOD = 10**9 + 7\n\ndef numWays(steps: int, arrLen: int) -> int:\n    max_pos = min(steps // 2, arrLen - 1)\n    dp = [0] * (max_pos + 2)\n    dp[1] = 1\n    \n    for _ in range(steps):\n        new_dp = [0] * (max_pos + 2)\n        for i in range(1, max_pos + 1):\n            new_dp[i] = (dp[i - 1] + dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return dp[1]"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 24365, "entry_point": "findGoodStrings", "codes": ["from functools import lru_cache\nfrom typing import Callable\n\ndef findGoodStrings(n: int, s1: str, s2: str, evil: str) -> int:\n    mod = 10**9 + 7\n    m = len(evil)\n\n    @lru_cache(None)\n    def dp(i: int, is_lo: bool, is_hi: bool, j: int) -> int:\n        if j == m:\n            return 0\n        if i == n:\n            return 1\n        lo = ord(s1[i]) if is_lo else ord('a')\n        hi = ord(s2[i]) if is_hi else ord('z')\n        res = 0\n        for c in range(lo, hi + 1):\n            if evil[j] == chr(c):\n                res += dp(i + 1, is_lo and c == lo, is_hi and c == hi, j + 1)\n            else:\n                idx = j\n                while idx > 0 and evil[idx] != chr(c):\n                    idx = evil.find(evil[:idx], idx - 1)\n                res += dp(i + 1, is_lo and c == lo, is_hi and c == hi, idx)\n        return res % mod\n\n    return dp(0, True, True, 0)", "def findGoodStrings(n, s1, s2, evil):\n    MOD = 10**9 + 7\n    \n    def z_function(s):\n        z = [0] * len(s)\n        l, r = 0, 0\n        for i in range(1, len(s)):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n            while i + z[i] < len(s) and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n            if i + z[i] - 1 > r:\n                l, r = i, i + z[i] - 1\n        return z\n    \n    def count_good_strings(s, evil):\n        z = z_function(evil)\n        dp = [[0] * (len(evil) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            dp[i][0] = sum(dp[i-1]) % MOD\n            for j in range(1, min(i, len(evil)) + 1):\n                if s[i-1] == evil[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = dp[i-1][0] - dp[i-z[j]][j] + dp[i-z[j]-1][0]\n                    if dp[i][j] < 0:\n                        dp[i][j] += MOD\n        \n        return sum(dp[-1]) % MOD\n    \n    count_s1 = count_good_strings(s1, evil)\n    count_s2 = count_good_strings(s2, evil)\n    \n    if s1 < s2:\n        return (count_s2 - count_s1 + MOD) % MOD\n    else:\n        return count_s2", "MOD = 10**9 + 7\n\ndef findGoodStrings(n, s1, s2, evil):\n    def z_function(s):\n        z = [0] * len(s)\n        l, r = 0, 0\n        for i in range(1, len(s)):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n            while i + z[i] < len(s) and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n            if i + z[i] - 1 > r:\n                l, r = i, i + z[i] - 1\n        return z\n\n    def count_less_than(s, evil):\n        m = len(evil)\n        z = z_function(evil)\n        dp = [[0] * (m + 1) for _ in range(2)]\n        dp[0][0] = 1\n        for i, char in enumerate(s):\n            for j in range(m + 1):\n                if j == 0:\n                    dp[1][j] = (dp[0][j] * 26) % MOD\n                else:\n                    dp[1][j] = (dp[0][j] * 25 + dp[1][j - 1]) % MOD\n            for j in range(m, 0, -1):\n                if s[i] < evil[j - 1]:\n                    dp[1][j] = (dp[1][j] - dp[0][j - 1]) % MOD\n                    if dp[1][j] < 0:\n                        dp[1][j] += MOD\n            dp[0], dp[1] = dp[1], [0] * (m + 1)\n        return dp[0][0]\n\n    return (count_less_than(s2, evil) - count_less_than(s1, evil) - (evil in s1) + MOD) % MOD", "def findGoodStrings(n, s1, s2, evil):\n    MOD = 10**9 + 7\n\n    def z_function(s):\n        z = [0] * len(s)\n        l, r = 0, 0\n        for i in range(1, len(s)):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n            while i + z[i] < len(s) and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n            if i + z[i] - 1 > r:\n                l, r = i, i + z[i] - 1\n        return z\n\n    def helper(s, evil, z):\n        @lru_cache(None)\n        def dp(i, j, lo, hi):\n            if j == len(evil):\n                return 0\n            if i == len(s):\n                return 1\n            cmin = ord(s[i]) if lo else ord('a')\n            cmax = ord(s[i]) if hi else ord('z')\n            res = 0\n            for c in range(cmin, cmax + 1):\n                if evil[j] == chr(c):\n                    res += dp(i + 1, j + 1, lo and c == cmin, hi and c == cmax)\n                else:\n                    res += dp(i + 1, j, lo and c == cmin, hi and c == cmax)\n            res %= MOD\n            return res\n\n        return dp(0, 0, True, True)\n\n    z = z_function(evil)\n    return (helper(s2, evil, z) - helper(s1, evil, z) + MOD) % MOD", "from functools import lru_cache\n\ndef findGoodStrings(n, s1, s2, evil):\n    MOD = 10**9 + 7\n    e_len = len(evil)\n\n    @lru_cache(None)\n    def count(s, i, j):\n        if j < 0:\n            return 1\n        if i == 0:\n            return sum(count(s, 0, j - ord(c) + 97) for c in 'abcdefghijklmnopqrstuvwxyz') % MOD\n        res = 0\n        for c in 'abcdefghijklmnopqrstuvwxyz':\n            if ord(c) >= ord(s[i - 1]):\n                res = (res + count(s, i - 1, j - (ord(c) - ord(s[i - 1])) if j >= ord(c) - ord(s[i - 1]) else -1)) % MOD\n        return res\n\n    @lru_cache(None)\n    def has_evil(s, i, j):\n        if j < 0:\n            return False\n        if i == 0:\n            return has_evil(s, 0, j - ord(s[i - 1]) + 97) or evil[j] in s\n        if evil[j] == s[i - 1]:\n            return has_evil(s, i - 1, j - 1)\n        return has_evil(s, i - 1, e_len - 1)\n\n    def count_good(s):\n        return count(s, len(s), e_len - 1)\n\n    def count_evil(s):\n        return has_evil(s, len(s), e_len - 1)\n\n    return (count_good(s2) - count_good(s1) + MOD + count_good(s1) - count_evil(s1)) % MOD", "def findGoodStrings(n: int, s1: str, s2: str, evil: str) -> int:\n    mod = 10**9 + 7\n\n    def count_up_to(s: str) -> int:\n        dp = [0] * (len(evil) + 1)\n        for char in s:\n            for i in range(len(evil), 0, -1):\n                if evil[i-1] == char:\n                    dp[i] = dp[i-1]\n                    break\n            dp[0] += 1\n        return dp[0]\n\n    def count_less_than(s: str) -> int:\n        dp = [0] * (len(evil) + 1)\n        for i, char in enumerate(s):\n            dp[0] += 26 ** (len(s) - i - 1)\n            for j in range(len(evil), 0, -1):\n                if evil[j-1] == char:\n                    dp[j] = dp[j-1]\n                    break\n            if dp[j] == 0:\n                return dp[0]\n        return dp[0]\n\n    def count_good_strings(left: int, right: int) -> int:\n        return (count_less_than(s2) - count_less_than(s1) + count_up_to(s2) - count_up_to(s1) + mod) % mod\n\n    return count_good_strings(0, n-1)"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 24452, "entry_point": "longestDupSubstring", "codes": ["def longestDupSubstring(S):\n    n = len(S)\n    left, right = 0, n\n    while left < right:\n        mid = (left + right + 1) // 2\n        if find_dup(S, mid) != -1:\n            left = mid\n        else:\n            right = mid - 1\n    start = find_dup(S, left)\n    return S[start:start + left] if start != -1 else \"\"\n\ndef find_dup(S, length):\n    seen = set()\n    for i in range(len(S) - length + 1):\n        substring = S[i:i + length]\n        if substring in seen:\n            return i\n        seen.add(substring)\n    return -1", "def longestDupSubstring(S):\n    n = len(S)\n    left, right = 0, n - 1\n    result = \"\"\n\n    while left < right:\n        mid = (left + right + 1) // 2\n        found = False\n        seen = set()\n        for i in range(n - mid + 1):\n            substring = S[i:i + mid]\n            if substring in seen:\n                found = True\n                result = substring\n                break\n            seen.add(substring)\n        if found:\n            left = mid\n        else:\n            right = mid - 1\n\n    return result", "def longestDupSubstring(S: str) -> str:\n    n = len(S)\n    left, right = 0, n\n    result = \"\"\n    \n    while left < right:\n        mid = (left + right) // 2\n        seen = set()\n        found = False\n        \n        for i in range(n - mid + 1):\n            substring = S[i:i + mid]\n            if substring in seen:\n                result = substring\n                found = True\n                break\n            seen.add(substring)\n        \n        if found:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return result", "def longestDupSubstring(S):\n    n = len(S)\n    ans = \"\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            if S[i:j] in S[j:]:\n                ans = max(ans, S[i:j], key=len)\n    return ans", "def longestDupSubstring(S):\n    def binary_search(left, right):\n        while left < right:\n            mid = (left + right + 1) // 2\n            if has_duplicate(S, mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left\n\n    def has_duplicate(S, length):\n        seen = set()\n        for i in range(len(S) - length + 1):\n            substring = S[i:i + length]\n            if substring in seen:\n                return True\n            seen.add(substring)\n        return False\n\n    if len(S) < 2:\n        return \"\"\n    return S[binary_search(0, len(S) - 1)]", "def longestDupSubstring(S):\n    n = len(S)\n    left, right = 0, n - 1\n    result = \"\"\n    \n    while left <= right:\n        mid = (left + right) // 2\n        substring = \"\"\n        found = False\n        \n        for i in range(n - mid + 1):\n            sub = S[i:i+mid]\n            if sub not in substring:\n                substring += sub\n            else:\n                result = sub\n                found = True\n                break\n        \n        if found:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result", "def longestDupSubstring(S: str) -> str:\n    n = len(S)\n    substrings = sorted(S[i:j] for i in range(n) for j in range(i + 1, n + 1))\n    longest = \"\"\n    for i in range(1, len(substrings)):\n        if substrings[i] == substrings[i - 1]:\n            longest = substrings[i]\n    return longest", "def longestDupSubstring(S: str) -> str:\n    n = len(S)\n    def binarySearch(left, right):\n        while left < right:\n            mid = (left + right + 1) // 2\n            if hasDuplicate(S, mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left\n\n    def hasDuplicate(s, length):\n        seen = set()\n        for i in range(len(s) - length + 1):\n            substring = s[i:i + length]\n            if substring in seen:\n                return True\n            seen.add(substring)\n        return False\n\n    length = binarySearch(0, n - 1)\n    return S[:length]\n\n# Unit tests\nassert longestDupSubstring(\"banana\") == \"ana\"\nassert longestDupSubstring(\"abcd\") == \"\"\nassert longestDupSubstring(\"pineapple\") == \"app\"\nassert longestDupSubstring(\"mississippi\") == \"issi\"\nassert longestDupSubstring(\"a\") == \"\"\nassert longestDupSubstring(\"aa\") == \"a\""], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 24533, "entry_point": "maxPerformance", "codes": ["from heapq import heappush, heappop\n\ndef maxPerformance(n, speed, efficiency, k):\n    MOD = 10**9 + 7\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    heap = []\n    total_speed = 0\n    max_performance = 0\n    \n    for eff, spd in engineers:\n        if len(heap) == k:\n            total_speed -= heappop(heap)\n        heappush(heap, spd)\n        total_speed += spd\n        max_performance = max(max_performance, total_speed * eff)\n    \n    return max_performance % MOD", "from typing import List\nfrom heapq import heappush, heappop\n\ndef maxPerformance(n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n    MOD = 10**9 + 7\n    heap = []\n    total_speed = 0\n    max_performance = 0\n    \n    for e, s in sorted(zip(efficiency, speed), reverse=True):\n        heappush(heap, s)\n        total_speed += s\n        if len(heap) > k:\n            total_speed -= heappop(heap)\n        max_performance = max(max_performance, total_speed * e)\n    \n    return max_performance % MOD", "from heapq import heappush, heappop\nfrom typing import List\n\ndef maxPerformance(n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n    MOD = 10**9 + 7\n    pq = []\n    spd_sum = 0\n    best_perf = 0\n    \n    for eff, spd in sorted(zip(efficiency, speed), reverse=True):\n        spd_sum += spd\n        heappush(pq, spd)\n        if len(pq) > k:\n            spd_sum -= heappop(pq)\n        best_perf = max(best_perf, spd_sum * eff)\n    \n    return best_perf % MOD", "def maxPerformance(n, speed, efficiency, k):\n    MOD = 10**9 + 7\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    speed_sum = 0\n    heap = []\n    best_performance = 0\n    \n    for eff, spd in engineers:\n        speed_sum += spd\n        heapq.heappush(heap, spd)\n        if len(heap) > k:\n            speed_sum -= heapq.heappop(heap)\n        best_performance = max(best_performance, speed_sum * eff)\n    \n    return best_performance % MOD", "def maxPerformance(n, speed, efficiency, k):\n    MOD = 10**9 + 7\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    heap = []\n    total_speed = 0\n    max_perf = 0\n\n    for e, s in engineers:\n        if len(heap) == k:\n            total_speed -= heapq.heappop(heap)\n        heapq.heappush(heap, s)\n        total_speed += s\n        max_perf = max(max_perf, total_speed * e)\n\n    return max_perf % MOD", "from typing import List\n\ndef maxPerformance(n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n    MOD = 10**9 + 7\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    max_performance = curr_speed = 0\n    heap = []\n    \n    for eff, spd in engineers:\n        if len(heap) == k:\n            curr_speed -= heapq.heappop(heap)\n        heapq.heappush(heap, spd)\n        curr_speed += spd\n        max_performance = max(max_performance, curr_speed * eff)\n    \n    return max_performance % MOD", "def maxPerformance(n, speed, efficiency, k):\n    MOD = 10**9 + 7\n    workers = sorted(zip(efficiency, speed), reverse=True)\n    total_speed = 0\n    min_heap = []\n    max_performance = 0\n    \n    for eff, spd in workers:\n        if len(min_heap) == k:\n            total_speed -= heapq.heappop(min_heap)\n        heapq.heappush(min_heap, spd)\n        total_speed += spd\n        max_performance = max(max_performance, total_speed * eff)\n    \n    return max_performance % MOD", "def maxPerformance(n, speed, efficiency, k):\n    MOD = 10**9 + 7\n    heap = []\n    total_speed = 0\n    max_perf = 0\n\n    for e, s in sorted(zip(efficiency, speed), reverse=True):\n        heapq.heappush(heap, s)\n        total_speed += s\n        if len(heap) > k:\n            total_speed -= heapq.heappop(heap)\n        max_perf = max(max_perf, total_speed * e)\n\n    return max_perf % MOD"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 24600, "entry_point": "numFriendRequests", "codes": ["def numFriendRequests(ages):\n    def valid_request(a, b):\n        return b > 0.5 * a + 7 and b <= a\n\n    count = 0\n    for i in range(len(ages)):\n        for j in range(len(ages)):\n            if i != j and valid_request(ages[i], ages[j]):\n                count += 1\n    return count", "def numFriendRequests(ages):\n    count = 0\n    age_counts = [0] * 121\n    for age in ages:\n        age_counts[age] += 1\n    for age in range(1, 121):\n        total = 0\n        for other_age in range(age // 2 + 8, age + 1):\n            total += age_counts[other_age]\n        count += age_counts[age] * total - age_counts[age]\n    return count", "def numFriendRequests(ages):\n    count = [0] * 121\n    for age in ages:\n        count[age] += 1\n    \n    total_requests = 0\n    cumulative_count = [0] * 121\n    for i in range(1, 121):\n        cumulative_count[i] = cumulative_count[i - 1] + count[i]\n    \n    for age in ages:\n        lower_bound = age // 2 + 8\n        upper_bound = age\n        total_requests += max(0, cumulative_count[upper_bound] - cumulative_count[lower_bound - 1] - 1)\n    \n    return total_requests", "def numFriendRequests(ages):\n    age_counts = [0] * 121\n    for age in ages:\n        age_counts[age] += 1\n    \n    total_requests = 0\n    for age, count in enumerate(age_counts):\n        if count == 0:\n            continue\n        upper_bound = age // 2 + 8\n        for other_age, other_count in enumerate(age_counts):\n            if other_age <= upper_bound or other_age > age:\n                total_requests += count * other_count - (count * (count - 1) // 2 if age == other_age else 0)\n    \n    return total_requests", "def numFriendRequests(ages):\n    count = 0\n    age_counts = [0] * 121\n    for age in ages:\n        age_counts[age] += 1\n    for age in range(1, 121):\n        for other_age in range(0.5 * age + 8, age):\n            count += age_counts[other_age]\n    return count", "def numFriendRequests(ages):\n    count = 0\n    age_counts = [0] * 121\n    for age in ages:\n        age_counts[age] += 1\n    \n    for age in range(1, 121):\n        for other_age in range(age // 2 + 8, age + 1):\n            count += age_counts[other_age]\n        if age > 100:\n            count -= age_counts[age]\n    \n    return count", "def numFriendRequests(ages):\n    count = 0\n    ages.sort()\n    age_counts = {}\n    for age in ages:\n        age_counts[age] = age_counts.get(age, 0) + 1\n    for age in ages:\n        lower_bound = age // 2 + 8\n        upper_bound = age\n        count += sum(age_counts[a] for a in range(lower_bound, upper_bound + 1) if a != age)\n    return count", "def numFriendRequests(ages):\n    ages.sort()\n    requests = 0\n    j = 0\n    for i, age in enumerate(ages):\n        while j < i and not (ages[j] <= 0.5 * age + 7 or ages[j] > age):\n            j += 1\n        requests += i - j\n    return requests"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 24721, "entry_point": "largestRectangleArea", "codes": ["def largestRectangleArea(heights):\n    def helper(left, right):\n        if left > right:\n            return 0\n        min_index = left\n        for i in range(left, right + 1):\n            if heights[i] < heights[min_index]:\n                min_index = i\n        return max(heights[min_index] * (right - left + 1), helper(left, min_index - 1), helper(min_index + 1, right))\n    return helper(0, len(heights) - 1)", "def largestRectangleArea(heights):\n    stack, max_area = [], 0\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] > h:\n            j, h2 = stack.pop()\n            max_area = max(max_area, h2 * (i - j))\n            start = j\n        stack.append((start, h))\n    for i, h in stack:\n        max_area = max(max_area, h * (len(heights) - i))\n    return max_area", "def largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] > h:\n            j, h2 = stack.pop()\n            max_area = max(max_area, h2 * (i - j))\n            start = j\n        stack.append((start, h))\n    for j, h2 in stack:\n        max_area = max(max_area, h2 * (len(heights) - j))\n    return max_area", "def largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights + [0]):\n        while stack and h < heights[stack[-1]]:\n            h_index = stack.pop()\n            width = i - stack[-1] - 1 if stack else i\n            max_area = max(max_area, h * width)\n        stack.append(i)\n    return max_area"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 24825, "entry_point": "singleNumber", "codes": ["def singleNumber(nums):\n    return 2 * sum(set(nums)) - sum(nums)", "def singleNumber(nums):\n    return sum(nums) - 2 * sum(set(nums))"], "rewards": [1.0, -1.0]}
{"id": 24842, "entry_point": "validateStackSequences", "codes": ["def validateStackSequences(pushed, popped):\n    stack = []\n    for x in pushed:\n        stack.append(x)\n        while stack and stack[-1] == popped[0]:\n            stack.pop()\n            popped.pop(0)\n    return not stack", "def validateStackSequences(pushed, popped):\n    stack = []\n    j = 0\n    for x in pushed:\n        stack.append(x)\n        while stack and stack[-1] == popped[j]:\n            stack.pop()\n            j += 1\n    return not stack", "def validateStackSequences(pushed, popped):\n    stack = []\n    i = 0\n    for x in pushed:\n        stack.append(x)\n        while stack and stack[-1] == popped[i]:\n            stack.pop()\n            i += 1\n    return not stack", "def validateStackSequences(pushed, popped):\n    stack = []\n    for push, pop in zip(pushed, popped):\n        stack.append(push)\n        while stack and stack[-1] == pop:\n            stack.pop()\n    return not stack"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 24929, "entry_point": "numOfMinutes", "codes": ["def numOfMinutes(n: int, headID: int, manager: list[int], informTime: list[int]) -> int:\n    def dfs(i: int) -> int:\n        return informTime[i] + max((dfs(j) for j in range(n) if manager[j] == i), default=0)\n    return dfs(headID)", "def numOfMinutes(n, headID, manager, informTime):\n    def dfs(i):\n        if manager[i] == -1:\n            return informTime[i]\n        return informTime[i] + dfs(manager[i])\n    \n    return max(dfs(i) for i in range(n))", "def numOfMinutes(n, headID, manager, informTime):\n    def dfs(employee):\n        if manager[employee] == -1:\n            return 0\n        manager[employee] = dfs(manager[employee])\n        return manager[employee] + informTime[employee]\n    \n    return max(dfs(i) for i in range(n))", "def numOfMinutes(n, headID, manager, informTime):\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for i, m in enumerate(manager):\n        graph[m].append(i)\n    \n    def dfs(node):\n        return informTime[node] + max(dfs(sub) for sub in graph[node], default=0)\n    \n    return dfs(headID)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 24950, "entry_point": "minMoves", "codes": ["def minMoves(nums):\n    return sum(nums) - len(nums) * min(nums)", "def minMoves(nums):\n    min_num = min(nums)\n    return sum(num - min_num for num in nums)", "def minMoves(nums):\n    min_val = min(nums)\n    return sum(num - min_val for num in nums)", "def minMoves(nums):\n    return (len(nums) - 1) * (max(nums) - min(nums))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 258, "entry_point": "bitwiseComplement", "codes": ["def bitwiseComplement(N):\n    return N ^ (2**N.bit_length() - 1)", "def bitwiseComplement(N):\n    return int(''.join('0' if bit == '1' else '1' for bit in bin(N)[2:]), 2)", "def bitwiseComplement(N):\n    return int(''.join('1' if bit == '0' else '0' for bit in bin(N)[2:]), 2)", "def bitwiseComplement(N):\n    mask = 0\n    while N > 0:\n        mask = (mask << 1) | 1\n        N >>= 1\n    return ~N & mask"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 25053, "entry_point": "validateBinaryTreeNodes", "codes": ["def validateBinaryTreeNodes(n, leftChild, rightChild):\n    indegree = [0] * n\n    for i in range(n):\n        if leftChild[i] != -1:\n            indegree[leftChild[i]] += 1\n        if rightChild[i] != -1:\n            indegree[rightChild[i]] += 1\n    root = [i for i in range(n) if indegree[i] == 0]\n    return len(root) == 1", "def validateBinaryTreeNodes(n, leftChild, rightChild):\n    indegree = [0] * n\n    for i in range(n):\n        if leftChild[i] != -1:\n            indegree[leftChild[i]] += 1\n        if rightChild[i] != -1:\n            indegree[rightChild[i]] += 1\n    \n    root_count = 0\n    for i in range(n):\n        if indegree[i] == 0:\n            root_count += 1\n    \n    return root_count == 1", "def validateBinaryTreeNodes(n, leftChild, rightChild):\n    def has_one_root_and_no_cycles():\n        parent = [-1] * n\n        for i in range(n):\n            for child in [leftChild[i], rightChild[i]]:\n                if child != -1:\n                    if parent[child] != -1:\n                        return False\n                    parent[child] = i\n        root_count = sum(1 for p in parent if p == -1)\n        return root_count == 1\n\n    return has_one_root_and_no_cycles()", "def validateBinaryTreeNodes(n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n    def dfs(node, parent):\n        if node == -1:\n            return True\n        if node in seen:\n            return False\n        seen.add(node)\n        return dfs(leftChild[node], node) and dfs(rightChild[node], node)\n    \n    seen = set()\n    root = -1\n    for i in range(n):\n        if leftChild[i] != -1:\n            if leftChild[i] in seen:\n                return False\n            if root != -1:\n                return False\n            root = leftChild[i]\n        if rightChild[i] != -1:\n            if rightChild[i] in seen:\n                return False\n            if root != -1 and root != leftChild[i]:\n                return False\n            root = rightChild[i]\n    \n    return root != -1 and dfs(root, -1) and len(seen) == n", "def validateBinaryTreeNodes(n, leftChild, rightChild):\n    def dfs(node, visited, stack):\n        if node == -1:\n            return True\n        if node in visited:\n            return False\n        visited.add(node)\n        stack.append(node)\n        return dfs(leftChild[node], visited, stack) and dfs(rightChild[node], visited, stack)\n\n    visited = set()\n    stack = []\n    root = -1\n    for i in range(n):\n        if i not in visited:\n            if root != -1:\n                return False\n            root = i\n\n    if not dfs(root, visited, stack):\n        return False\n\n    return len(visited) == n", "def validateBinaryTreeNodes(n, leftChild, rightChild):\n    def has_no_cycle(node, parent):\n        if node == -1:\n            return True\n        if node in visited:\n            return False\n        visited.add(node)\n        return has_no_cycle(leftChild[node], node) and has_no_cycle(rightChild[node], node)\n    \n    visited = set()\n    root = -1\n    \n    for i in range(n):\n        if leftChild[i] != -1 and leftChild[i] == root or rightChild[i] != -1 and rightChild[i] == root:\n            return False\n        if leftChild[i] != -1:\n            root = leftChild[i]\n        elif rightChild[i] != -1:\n            root = rightChild[i]\n        if root == -1:\n            return False\n    \n    return has_no_cycle(root, -1) and len(visited) == n", "def validateBinaryTreeNodes(n, leftChild, rightChild):\n    seen = set()\n    stack = [0]\n    \n    while stack:\n        node = stack.pop()\n        if node == -1:\n            continue\n        if node in seen:\n            return False\n        seen.add(node)\n        stack.extend([rightChild[node], leftChild[node]])\n    \n    return len(seen) == n and -1 not in leftChild and -1 not in rightChild"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 25064, "entry_point": "fractionToDecimal", "codes": ["def fractionToDecimal(numerator: int, denominator: int) -> str:\n    # Handle sign of the result\n    sign = '-' if numerator * denominator < 0 else ''\n    numerator, denominator = abs(numerator), abs(denominator)\n    \n    # Integer part\n    integer_part = numerator // denominator\n    \n    # Fractional part\n    fractional_part = []\n    remainder = numerator % denominator\n    seen_remainders = {}\n    \n    while remainder:\n        if remainder in seen_remainders:\n            start = seen_remainders[remainder]\n            non_repeating = ''.join(str(x) for x in fractional_part[:start])\n            repeating = ''.join(str(x) for x in fractional_part[start:])\n            return sign + str(integer_part) + '.' + non_repeating + '(' + repeating + ')'\n        \n        seen_remainders[remainder] = len(fractional_part)\n        remainder *= 10\n        fractional_part.append(remainder // denominator)\n        remainder %= denominator\n    \n    return sign + str(integer_part) + '.' + ''.join(map(str, fractional_part)) if fractional_part else ''", "def fractionToDecimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    sign = \"-\" if (numerator < 0) ^ (denominator < 0) else \"\"\n    numerator, denominator = abs(numerator), abs(denominator)\n    integer_part = numerator // denominator\n    remainder = numerator % denominator\n    fractional_part = []\n    remainders = {}\n    i = 0\n\n    while remainder != 0:\n        if remainder in remainders:\n            start = remainders[remainder]\n            fractional_part.insert(start, \"(\")\n            fractional_part.append(\")\")\n            break\n        remainders[remainder] = i\n        remainder *= 10\n        digit = remainder // denominator\n        fractional_part.append(str(digit))\n        remainder %= denominator\n        i += 1\n\n    return sign + str(integer_part) + (\".\" + \"\".join(fractional_part) if fractional_part else \"\")", "def fractionToDecimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    result = []\n    if (numerator < 0) ^ (denominator < 0):\n        result.append('-')\n    numerator, denominator = abs(numerator), abs(denominator)\n    result.append(str(numerator // denominator))\n    numerator %= denominator\n    if numerator == 0:\n        return ''.join(result)\n    result.append('.')\n    seen = {}\n    while numerator != 0:\n        if numerator in seen:\n            result.insert(seen[numerator], '(')\n            result.append(')')\n            break\n        seen[numerator] = len(result)\n        numerator *= 10\n        result.append(str(numerator // denominator))\n        numerator %= denominator\n    return ''.join(result)", "def fractionToDecimal(numerator, denominator):\n    quotient, remainder = divmod(abs(numerator), abs(denominator))\n    sign = '-' if (numerator < 0) ^ (denominator < 0) else ''\n    if remainder == 0:\n        return sign + str(quotient)\n    \n    decimals, seen = [], {}\n    while remainder != 0:\n        if remainder in seen:\n            start = seen[remainder]\n            non_repeating = ''.join(map(str, decimals[:start]))\n            repeating = ''.join(map(str, decimals[start:]))\n            return sign + non_repeating + '(' + repeating + ')'\n        seen[remainder] = len(decimals)\n        quotient, remainder = divmod(remainder * 10, abs(denominator))\n        decimals.append(quotient)\n    \n    return sign + ''.join(map(str, decimals))"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 25093, "entry_point": "minJumps", "codes": ["def minJumps(arr):\n    from collections import defaultdict, deque\n    n = len(arr)\n    if n == 1:\n        return 0\n    graph = defaultdict(list)\n    for i, x in enumerate(arr):\n        graph[x].append(i)\n    \n    visited = [False] * n\n    queue = deque([0])\n    visited[0] = True\n    steps = 0\n    \n    while queue:\n        for _ in range(len(queue)):\n            i = queue.popleft()\n            if i == n - 1:\n                return steps\n            for j in [i - 1, i + 1] + graph[arr[i]]:\n                if 0 <= j < n and not visited[j]:\n                    visited[j] = True\n                    queue.append(j)\n            graph[arr[i]].clear()  # Prevent revisiting\n        \n        steps += 1\n    \n    return -1", "def minJumps(arr):\n    from collections import defaultdict, deque\n\n    n = len(arr)\n    if n == 1:\n        return 0\n\n    graph = defaultdict(list)\n    for i, num in enumerate(arr):\n        graph[num].append(i)\n\n    visited = [False] * n\n    visited[0] = True\n    queue = deque([0])\n    steps = 0\n\n    while queue:\n        for _ in range(len(queue)):\n            i = queue.popleft()\n            if i == n - 1:\n                return steps\n\n            for j in [i - 1, i + 1] + graph[arr[i]]:\n                if 0 <= j < n and not visited[j]:\n                    visited[j] = True\n                    queue.append(j)\n\n            graph[arr[i]] = []  # Avoid revisiting same values\n\n        steps += 1\n\n    return -1", "from collections import defaultdict, deque\n\ndef minJumps(arr):\n    if not arr or len(arr) == 1:\n        return 0\n    \n    n = len(arr)\n    graph = defaultdict(list)\n    \n    for i, num in enumerate(arr):\n        graph[num].append(i)\n    \n    queue = deque([0])\n    visited = {0}\n    step = 0\n    \n    while queue:\n        for _ in range(len(queue)):\n            current = queue.popleft()\n            \n            if current == n - 1:\n                return step\n            \n            for neighbor in [current - 1, current + 1] + graph[arr[current]]:\n                if 0 <= neighbor < n and neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n            \n            # Clear the list to avoid revisiting\n            graph[arr[current]].clear()\n        \n        step += 1\n    \n    return -1", "def minJumps(arr):\n    n = len(arr)\n    if n == 1:\n        return 0\n    \n    target = n - 1\n    jumps = [float('inf')] * n\n    jumps[0] = 0\n    \n    seen = set()\n    q = [0]\n    \n    while q:\n        i = q.pop(0)\n        if i in seen:\n            continue\n        seen.add(i)\n        \n        if i == target:\n            break\n        \n        if i > 0 and jumps[i - 1] > jumps[i] + 1:\n            jumps[i - 1] = jumps[i] + 1\n            q.append(i - 1)\n        \n        if i < n - 1 and jumps[i + 1] > jumps[i] + 1:\n            jumps[i + 1] = jumps[i] + 1\n            q.append(i + 1)\n        \n        if arr[i] in seen_vals:\n            for j in seen_vals[arr[i]]:\n                if jumps[j] > jumps[i] + 1:\n                    jumps[j] = jumps[i] + 1\n                    q.append(j)\n            seen_vals[arr[i]].clear()\n    \n    return jumps[target]", "def minJumps(arr):\n    from collections import defaultdict, deque\n    \n    n = len(arr)\n    if n == 1:\n        return 0\n    \n    index_map = defaultdict(list)\n    for i, val in enumerate(arr):\n        index_map[val].append(i)\n    \n    queue = deque([(0, 0)])\n    visited = {0}\n    while queue:\n        current_index, steps = queue.popleft()\n        if current_index == n - 1:\n            return steps\n        \n        next_indices = [current_index + 1, current_index - 1]\n        for j in index_map[arr[current_index]]:\n            if j not in visited and 0 <= j < n:\n                next_indices.append(j)\n        \n        for next_index in next_indices:\n            if next_index not in visited:\n                visited.add(next_index)\n                queue.append((next_index, steps + 1))\n        \n        index_map[arr[current_index]] = []\n    \n    return -1", "from collections import deque\n\ndef minJumps(arr):\n    n = len(arr)\n    if n == 1:\n        return 0\n    \n    graph = {}\n    for i in range(n):\n        if arr[i] not in graph:\n            graph[arr[i]] = []\n        graph[arr[i]].append(i)\n    \n    visited = [False] * n\n    visited[0] = True\n    queue = deque([0])\n    steps = 0\n    \n    while queue:\n        for _ in range(len(queue)):\n            curr = queue.popleft()\n            if curr == n - 1:\n                return steps\n            \n            for next_step in [curr - 1, curr + 1]:\n                if 0 <= next_step < n and not visited[next_step]:\n                    visited[next_step] = True\n                    queue.append(next_step)\n            \n            if arr[curr] in graph:\n                for next_step in graph[arr[curr]]:\n                    if not visited[next_step]:\n                        visited[next_step] = True\n                        queue.append(next_step)\n                del graph[arr[curr]]\n    \n    return -1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 25106, "entry_point": "largestSumAfterKNegations", "codes": ["def largestSumAfterKNegations(A, K):\n    for _ in range(K):\n        A[A.index(min(A))] *= -1\n    return sum(A)", "def largestSumAfterKNegations(A, K):\n    for _ in range(K):\n        min_index = A.index(min(A))\n        A[min_index] = -A[min_index]\n    return sum(A)", "def largestSumAfterKNegations(A, K):\n    A.sort()\n    for _ in range(K):\n        A[0] = -A[0]\n        A.sort()\n    return sum(A)", "def largestSumAfterKNegations(A, K):\n    A.sort()\n    for i in range(K):\n        if A[i] < 0:\n            A[i] = -A[i]\n        else:\n            break\n    if K % 2 == 1:\n        A.sort()\n        A[0] = -A[0]\n    return sum(A)", "def largestSumAfterKNegations(A, K):\n    for _ in range(K):\n        A.append(min(A) * -1)\n    return sum(A)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 25127, "entry_point": "canMeasureWater", "codes": ["def canMeasureWater(x, y, z):\n    if z == 0:\n        return True\n    if x + y < z:\n        return False\n    return z % math.gcd(x, y) == 0", "def canMeasureWater(x: int, y: int, z: int) -> bool:\n    if z == 0:\n        return True\n    if x + y < z:\n        return False\n    return z % math.gcd(x, y) == 0", "def canMeasureWater(x, y, z):\n    if z > x + y:\n        return False\n    if z == 0:\n        return True\n    return z % gcd(x, y) == 0\n\nfrom math import gcd", "def canMeasureWater(x, y, z):\n    if z == 0:\n        return True\n    if x + y < z:\n        return False\n    return z % gcd(x, y) == 0"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 25192, "entry_point": "soupServings", "codes": ["def soupServings(N):\n    if N > 4800: return 1.0  # For large N, the probability approaches 1\n    \n    dp = [[0] * 200 for _ in range(200)]\n    dp[0][0] = 0.5\n    \n    for i in range(1, 200):\n        dp[0][i] = 1.0\n        dp[i][0] = 0.0\n    \n    for i in range(1, 200):\n        for j in range(1, 200):\n            dp[i][j] = 0.25 * (dp[max(0, i-4)][j] + dp[max(0, i-3)][max(0, j-1)] + dp[max(0, i-2)][max(0, j-2)] + dp[max(0, i-1)][max(0, j-3)])\n    \n    return dp[N // 25][N // 25]\n\ndef _equivalent(lhs, rhs, tolerance=1e-6):\n    return abs(lhs - rhs) < tolerance", "from functools import lru_cache\n\n@lru_cache(None)\ndef soupServings(N: int) -> float:\n    if N > 4800:\n        return 1.0\n    return (soupServings(N - 4) + soupServings(N - 3) + soupServings(N - 2) + soupServings(N - 1)) / 4.0", "from functools import lru_cache\n\n@lru_cache(None)\ndef soupServings(N):\n    if N >= 5000:\n        return 1.0\n    return (\n        soupServings(N - 100) / 4 +\n        soupServings(N - 75) / 4 +\n        soupServings(N - 50) / 4 +\n        soupServings(N - 25) / 4\n    )", "def soupServings(N):\n    if N > 4800:\n        return 1.0\n    N = (N + 24) // 25\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 0.5\n    for i in range(1, N + 1):\n        dp[i][0] = 1.0\n        dp[0][i] = 0.0\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            dp[i][j] = (dp[max(i - 4, 0)][j] + dp[max(i - 3, 0)][max(j - 1, 0)] + \n                        dp[max(i - 2, 0)][max(j - 2, 0)] + dp[max(i - 1, 0)][max(j - 3, 0)]) / 4.0\n    return dp[N][N]", "@lru_cache(None)\ndef soupServings(N):\n    if N >= 4800:\n        return 1.0\n    def helper(a, b):\n        if a <= 0 and b <= 0:\n            return 0.5\n        if a <= 0:\n            return 1.0\n        if b <= 0:\n            return 0.0\n        return 0.25 * (helper(a - 4, b) + helper(a - 3, b - 1) + helper(a - 2, b - 2) + helper(a - 1, b - 3))\n    return helper(N, N)", "def soupServings(N):\n    if N > 4800:\n        return 1.0\n    memo = {}\n    def helper(A, B):\n        if (A, B) in memo:\n            return memo[(A, B)]\n        if A <= 0 and B <= 0:\n            return 0.5\n        if A <= 0:\n            return 1.0\n        if B <= 0:\n            return 0.0\n        prob = 0.25 * (helper(A - 4, B) + helper(A - 3, B - 1) + helper(A - 2, B - 2) + helper(A - 1, B - 3))\n        memo[(A, B)] = prob\n        return prob\n    return helper(N, N)"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 25250, "entry_point": "strWithout3a3b", "codes": ["def strWithout3a3b(A, B):\n    if A > B:\n        return \"aab\" + strWithout3a3b(A - 2, B - 1)\n    elif B > A:\n        return \"bba\" + strWithout3a3b(A - 1, B - 2)\n    elif A > 0:\n        return \"ab\" + strWithout3a3b(A - 1, B - 1)\n    else:\n        return \"\"", "def strWithout3a3b(A, B):\n    result = []\n    while A > 0 or B > 0:\n        if A > B and A > 1:\n            result.append('a')\n            result.append('a')\n            A -= 2\n        elif B > A and B > 1:\n            result.append('b')\n            result.append('b')\n            B -= 2\n        else:\n            if A > 0:\n                result.append('a')\n                A -= 1\n            if B > 0:\n                result.append('b')\n                B -= 1\n    return ''.join(result)", "def strWithout3a3b(A, B):\n    result = []\n    while A > 0 or B > 0:\n        if A >= B and A > 1:\n            result.append('a')\n            result.append('a')\n            A -= 2\n        elif B >= A and B > 1:\n            result.append('b')\n            result.append('b')\n            B -= 2\n        else:\n            if A > 0:\n                result.append('a')\n                A -= 1\n            if B > 0:\n                result.append('b')\n                B -= 1\n    return ''.join(result)", "def strWithout3a3b(A, B):\n    result = []\n    while A > 0 or B > 0:\n        if A > B:\n            if A > 1:\n                result.append('a')\n                A -= 1\n            if B > 0:\n                result.append('b')\n                B -= 1\n        else:\n            if B > 1:\n                result.append('b')\n                B -= 1\n            if A > 0:\n                result.append('a')\n                A -= 1\n    return ''.join(result)", "def strWithout3a3b(A, B):\n    result = []\n    while A or B:\n        if A > B:\n            if len(result) >= 2 and result[-2:] == ['a', 'a']:\n                result.append('b')\n                B -= 1\n            else:\n                result.append('a')\n                A -= 1\n        elif B > A:\n            if len(result) >= 2 and result[-2:] == ['b', 'b']:\n                result.append('a')\n                A -= 1\n            else:\n                result.append('b')\n                B -= 1\n        else:\n            if A > 0:\n                result.append('a')\n                A -= 1\n            if B > 0:\n                result.append('b')\n                B -= 1\n    return ''.join(result)", "def strWithout3a3b(A, B):\n    def _equivalent(lhs, rhs):\n        return lhs == rhs\n\n    result = []\n    while A > 0 or B > 0:\n        if A >= B:\n            if A > 1:\n                result.append('a')\n                result.append('a')\n                A -= 2\n            else:\n                result.append('a')\n                A -= 1\n            if B > 0:\n                result.append('b')\n                B -= 1\n        else:\n            if B > 1:\n                result.append('b')\n                result.append('b')\n                B -= 2\n            else:\n                result.append('b')\n                B -= 1\n            if A > 0:\n                result.append('a')\n                A -= 1\n    return ''.join(result)\n\n# Test cases\nassert _equivalent(strWithout3a3b(1, 2), \"abb\")\nassert _equivalent(strWithout3a3b(4, 1), \"aabaa\")\nassert _equivalent(strWithout3a3b(0, 0), \"\")\nassert _equivalent(strWithout3a3b(2, 2), \"abab\")\nassert _equivalent(strWithout3a3b(5, 3), \"aababaa\")\nassert _equivalent(strWithout3a3b(3, 5), \"bbbabaa\")\nassert _equivalent(strWithout3a3b(1, 0), \"a\")\nassert _equivalent(strWithout3a3b(0, 1), \"b\")\nassert _equivalent(strWithout3a3b(2, 0), \"aa\")\nassert _equivalent(strWithout3a3b(0, 2), \"bb\")"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 25283, "entry_point": "maxSizeSlices", "codes": ["def maxSizeSlices(slices):\n    n = len(slices)\n    k = n // 3\n    \n    def maxSum(arr, k):\n        dp = [[0] * (k + 1) for _ in range(len(arr) + 1)]\n        for i in range(1, len(arr) + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j], (dp[i - 2][j - 1] if i > 1 else 0) + arr[i - 1])\n        return dp[-1][-1]\n    \n    return max(maxSum(slices[1:], k), maxSum(slices[:-1], k))", "def maxSizeSlices(slices):\n    n = len(slices)\n    k = n // 3\n\n    def maxSlicesHelper(slices):\n        n = len(slices)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j], (dp[i - 2][j - 1] if i >= 2 else 0) + slices[i - 1])\n        return dp[n][k]\n\n    return max(maxSlicesHelper(slices[1:]), maxSlicesHelper(slices[:-1]))", "def maxSizeSlices(slices):\n    n = len(slices)\n    k = n // 3\n    \n    @lru_cache(None)\n    def dp(i, j, m):\n        if m == 0:\n            return 0\n        if j - i < m:\n            return float('-inf')\n        return max(dp(i + 1, j, m), dp(i + 2, j, m - 1) + slices[i])\n    \n    return max(dp(1, n - 1, k), dp(0, n - 2, k))", "def maxSizeSlices(slices):\n    n = len(slices)\n    k = n // 3\n\n    def helper(s):\n        dp = [0] * (k + 1)\n        for i in range(n - 1):\n            dp[1] = max(dp[1], dp[0] + s[i])\n            for j in range(2, k + 1):\n                dp[j] = max(dp[j], dp[j - 1], (dp[j - 2] if i > 1 else 0) + s[i])\n        return dp[k]\n\n    return max(helper(slices[1:]), helper(slices[:-1]))", "def maxSizeSlices(slices):\n    n = len(slices)\n    def dfs(start, end, k):\n        if k == 0:\n            return 0\n        if end - start + 1 < k:\n            return 0\n        return max(dfs(start + 1, end, k), dfs(start, end - 1, k - 1) + slices[end])\n    return dfs(1, n - 2, n // 3)", "def maxSizeSlices(slices):\n    def max_slice(arr):\n        n = len(arr)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for length in range(2, n + 1, 2):\n            for start in range(n - length + 1):\n                end = start + length\n                dp[start][end] = max(arr[start] + dp[start + 2][end], dp[start + 1][end - 1])\n        return dp[0][n]\n\n    n = len(slices)\n    return max(max_slice(slices[1:n]), max_slice(slices[0:n-1]))", "def maxSizeSlices(slices):\n    n = len(slices)\n    k = n // 3\n    \n    def maxSlicesLinear(arr):\n        n = len(arr)\n        dp = [0] * (k + 1)\n        for i in range(n):\n            for j in range(k, 0, -1):\n                dp[j] = max(dp[j], dp[j - 1] + arr[i])\n        return dp[k]\n    \n    return max(maxSlicesLinear(slices[:n-1]), maxSlicesLinear(slices[1:]))"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 25391, "entry_point": "kConcatenationMaxSum", "codes": ["def kConcatenationMaxSum(arr, k):\n    MOD = 10**9 + 7\n    n = len(arr)\n    max_sum = 0\n    current_sum = 0\n    \n    for i in range(n * min(2, k)):\n        current_sum = max(0, current_sum + arr[i % n])\n        max_sum = max(max_sum, current_sum)\n    \n    if k == 1:\n        return max_sum % MOD\n    \n    total_sum = sum(arr)\n    if total_sum > 0:\n        max_sum = max(max_sum, (k - 2) * total_sum + max_sum)\n    \n    return max_sum % MOD", "def kConcatenationMaxSum(arr, k):\n    MOD = 10**9 + 7\n    n = len(arr)\n    max_sum = 0\n    current_sum = 0\n    max_prefix_sum = 0\n    prefix_sum = 0\n    \n    for _ in range(k):\n        for num in arr:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n            prefix_sum += num\n            max_prefix_sum = max(max_prefix_sum, prefix_sum)\n    \n    if k >= 2:\n        max_sum = max(max_sum, prefix_sum * (k - 2) + max_sum - max_prefix_sum)\n    \n    return max_sum % MOD", "def kConcatenationMaxSum(arr, k):\n    MOD = 10**9 + 7\n    max_sum = current_sum = 0\n    arr_sum = sum(arr)\n    \n    for i in range(k * 2):\n        current_sum = max(0, current_sum + arr[i % len(arr)])\n        max_sum = max(max_sum, current_sum)\n    \n    if k > 1 and arr_sum > 0:\n        max_sum = max(max_sum, (k - 2) * arr_sum + max_sum)\n    \n    return max_sum % MOD", "def kConcatenationMaxSum(arr, k):\n    MOD = 10**9 + 7\n    max_sum = curr_sum = 0\n    max_prefix_sum = curr_prefix_sum = 0\n    min_suffix_sum = curr_suffix_sum = 0\n\n    for _ in range(2 if k > 1 else 1):\n        for num in arr:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n\n            curr_prefix_sum = max(0, curr_prefix_sum + num)\n            max_prefix_sum = max(max_prefix_sum, curr_prefix_sum)\n\n            curr_suffix_sum = min(0, curr_suffix_sum + num)\n            min_suffix_sum = min(min_suffix_sum, curr_suffix_sum)\n\n    if k == 1:\n        return max_sum % MOD\n\n    total_sum = sum(arr)\n    if total_sum <= 0:\n        return max(max_sum, 0) % MOD\n\n    return (max_sum + total_sum * (k - 2) - min_suffix_sum + max_prefix_sum) % MOD", "def kConcatenationMaxSum(arr, k):\n    max_subarray_sum = float('-inf')\n    current_sum = 0\n    total_sum = 0\n\n    for _ in range(k):\n        for num in arr:\n            current_sum = max(0, current_sum + num)\n            max_subarray_sum = max(max_subarray_sum, current_sum)\n            total_sum += num\n\n    if k > 1 and total_sum > 0:\n        max_subarray_sum = max(max_subarray_sum, total_sum * (k - 2) + max_subarray_sum)\n\n    return max_subarray_sum % (10**9 + 7)", "def kConcatenationMaxSum(arr, k):\n    max_current = max_global = arr[0]\n    for x in arr * (k + 1)[:-1]:\n        max_current = max(x, max_current + x)\n        max_global = max(max_global, max_current)\n    return max_global % (10**9 + 7)", "def kConcatenationMaxSum(arr, k):\n    MOD = 10**9 + 7\n    max_current = max_global = arr[0]\n    for x in arr[1:]:\n        max_current = max(x, max_current + x)\n        max_global = max(max_global, max_current)\n    \n    total_sum = sum(arr)\n    if total_sum <= 0:\n        return max_global % MOD\n    \n    if k == 1:\n        return max_global % MOD\n    \n    max_prefix = max_suffix = 0\n    prefix_sum = 0\n    for x in arr:\n        prefix_sum += x\n        max_prefix = max(max_prefix, prefix_sum)\n    \n    suffix_sum = 0\n    for x in reversed(arr):\n        suffix_sum += x\n        max_suffix = max(max_suffix, suffix_sum)\n    \n    return (max_global + max_prefix + max_suffix + (k - 2) * total_sum) % MOD"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 25394, "entry_point": "largestComponentSize", "codes": ["def largestComponentSize(A):\n    from collections import defaultdict\n    from math import gcd\n\n    n = len(A)\n    parent = list(range(n))\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        parent[find(x)] = find(y)\n\n    factors = defaultdict(list)\n    for i, a in enumerate(A):\n        for f in range(2, int(a**0.5) + 1):\n            if a % f == 0:\n                factors[f].append(i)\n                factors[a // f].append(i)\n        factors[a].append(i)\n\n    for factor in factors.values():\n        for i in range(1, len(factor)):\n            union(factor[0], factor[i])\n\n    size = [0] * n\n    for i in range(n):\n        size[find(i)] += 1\n\n    return max(size)", "def largestComponentSize(A):\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n            size[rootY] += size[rootX]\n\n    n = len(A)\n    parent = list(range(n))\n    size = [1] * n\n\n    factor_to_index = {}\n    for i, num in enumerate(A):\n        for f in range(2, int(num**0.5) + 1):\n            if num % f == 0:\n                if f in factor_to_index:\n                    union(i, factor_to_index[f])\n                factor_to_index[f] = i\n                if num // f != f:\n                    if num // f in factor_to_index:\n                        union(i, factor_to_index[num // f])\n                    factor_to_index[num // f] = i\n\n    return max(size)", "def largestComponentSize(A):\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n            size[rootY] += size[rootX]\n\n    n = len(A)\n    parent = list(range(n))\n    size = [1] * n\n    factor_to_index = {}\n\n    for i, num in enumerate(A):\n        for j in range(2, int(num ** 0.5) + 1):\n            if num % j == 0:\n                if j not in factor_to_index:\n                    factor_to_index[j] = i\n                union(i, factor_to_index[j])\n                if num // j != j:\n                    if num // j not in factor_to_index:\n                        factor_to_index[num // j] = i\n                    union(i, factor_to_index[num // j])\n        if num not in factor_to_index:\n            factor_to_index[num] = i\n\n    return max(size)", "def largestComponentSize(A):\n    from collections import defaultdict\n    import math\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        parent[find(y)] = find(x)\n\n    n = len(A)\n    parent = list(range(n))\n    factor_to_node = defaultdict(list)\n\n    for i, a in enumerate(A):\n        for f in range(2, int(math.sqrt(a)) + 1):\n            if a % f == 0:\n                factor_to_node[f].append(i)\n                factor_to_node[a // f].append(i)\n\n    for factors in factor_to_node.values():\n        for i in range(1, len(factors)):\n            union(factors[0], factors[i])\n\n    return max(len(list(group)) for _, group in itertools.groupby(sorted(find(i) for i in range(n))))", "from collections import defaultdict\n\ndef largestComponentSize(A):\n    max_val = max(A)\n    primes = [True] * (max_val + 1)\n    for i in range(2, int(max_val**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, max_val + 1, i):\n                primes[j] = False\n    \n    prime_to_nodes = defaultdict(set)\n    for num in A:\n        for i in range(2, num + 1):\n            if num % i == 0 and primes[i]:\n                prime_to_nodes[i].add(num)\n                break\n    \n    parent = list(range(len(A) + 1))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    for group in prime_to_nodes.values():\n        for i in range(1, len(group)):\n            union(group[0], group[i])\n    \n    size = [0] * (len(A) + 1)\n    for node in range(1, len(A) + 1):\n        parent_node = find(node)\n        size[parent_node] += 1\n    \n    return max(size)", "from collections import defaultdict\nfrom math import sqrt\n\ndef largestComponentSize(A):\n    def union(x, y):\n        px, py = find(x), find(y)\n        if px != py:\n            parent[px] = py\n            size[py] += size[px]\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    n = len(A)\n    parent = list(range(n))\n    size = [1] * n\n    factor_to_node = defaultdict(list)\n\n    for i, num in enumerate(A):\n        for f in range(2, int(sqrt(num)) + 1):\n            if num % f == 0:\n                factor_to_node[f].append(i)\n                factor_to_node[num // f].append(i)\n\n    for nodes in factor_to_node.values():\n        for i in range(1, len(nodes)):\n            union(nodes[0], nodes[i])\n\n    return max(size)\n\n# Unit tests\ndef _equivalent(lhs, rhs):\n    return lhs == rhs\n\n# Example tests\nassert _equivalent(largestComponentSize([4, 6, 15, 35]), 4)\nassert _equivalent(largestComponentSize([20, 50, 9, 63]), 2)\nassert _equivalent(largestComponentSize([2, 3, 6, 7, 4, 12, 21, 39]), 8)", "from collections import defaultdict\nfrom math import isqrt\n\ndef largestComponentSize(A):\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.append(i)\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    factor_to_nodes = defaultdict(set)\n    for node in A:\n        for factor in prime_factors(node):\n            factor_to_nodes[factor].add(node)\n\n    max_size = 0\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return 0\n        visited.add(node)\n        size = 1\n        for neighbor in factor_to_nodes[node]:\n            size += dfs(neighbor)\n        return size\n\n    for node in A:\n        if node not in visited:\n            max_size = max(max_size, dfs(node))\n\n    return max_size", "def largestComponentSize(A):\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n            size[rootY] += size[rootX]\n    \n    max_val = max(A)\n    parent = list(range(max_val + 1))\n    size = [1] * (max_val + 1)\n    \n    for num in A:\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                union(num, i)\n                union(num, num // i)\n    \n    return max(size)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 25404, "entry_point": "distinctEchoSubstrings", "codes": ["def distinctEchoSubstrings(text):\n    n = len(text)\n    substrings = set()\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if text[i:j] == text[j:2*j-i]:\n                substrings.add(text[i:j])\n                \n    return len(substrings)", "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    distinct_substrings = set()\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if 2 * j - i <= n and text[i:j] == text[j:2 * j - i]:\n                distinct_substrings.add(text[i:j])\n    \n    return len(distinct_substrings)", "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    distinct_substrings = set()\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if 2 * (j - i) + i <= n and text[i:j] == text[j:2 * (j - i) + i]:\n                distinct_substrings.add(text[i:2 * (j - i) + i])\n    \n    return len(distinct_substrings)", "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    result = set()\n    \n    for length in range(1, n // 2 + 1):\n        for i in range(n - length * 2 + 1):\n            if text[i:i + length] == text[i + length:i + length * 2]:\n                dp[i][i + length * 2] = dp[i + 1][i + length * 2 - 1] + 1\n                if dp[i][i + length * 2] == length:\n                    result.add(text[i:i + length * 2])\n    \n    return len(result)", "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    result = set()\n    for i in range(n):\n        for j in range(i + 1, (n + 1) // 2):\n            if text[i:i + j] == text[i + j:i + 2 * j]:\n                result.add(text[i:i + j])\n    return len(result)", "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    distinct_substrings = set()\n    \n    for i in range(n):\n        for j in range(i + 1, n // 2 + 1):\n            if text[i:i + j] == text[i + j:i + 2 * j]:\n                distinct_substrings.add(text[i:i + j])\n    \n    return len(distinct_substrings)", "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    count = set()\n    for i in range(n):\n        for j in range(i + 1, n // 2 + 1):\n            if text[i:i + j] == text[i + j:i + 2 * j]:\n                count.add(text[i:i + j])\n    return len(count)", "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    distinct_substrings = set()\n    \n    for i in range(n):\n        for j in range(i + 1, (n + 1) // 2):\n            if text[i:i + j] == text[i + j:i + 2 * j]:\n                distinct_substrings.add(text[i:i + j])\n                \n    return len(distinct_substrings)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 2575, "entry_point": "subarraysWithKDistinct", "codes": ["def subarraysWithKDistinct(A, K):\n    def atMost(K):\n        count = [0] * (len(A) + 1)\n        i = res = 0\n        for j, num in enumerate(A):\n            if count[num] == 0:\n                K -= 1\n            count[num] += 1\n            while K < 0:\n                count[A[i]] -= 1\n                if count[A[i]] == 0:\n                    K += 1\n                i += 1\n            res += j - i + 1\n        return res\n\n    return atMost(K) - atMost(K - 1)", "def subarraysWithKDistinct(A, K):\n    def atMost(K):\n        count = 0\n        left = 0\n        frequency = {}\n        for right, num in enumerate(A):\n            if num not in frequency:\n                frequency[num] = 0\n            frequency[num] += 1\n            while len(frequency) > K:\n                frequency[A[left]] -= 1\n                if frequency[A[left]] == 0:\n                    del frequency[A[left]]\n                left += 1\n            count += right - left + 1\n        return count\n    \n    return atMost(K) - atMost(K - 1)", "def subarraysWithKDistinct(A, K):\n    def atMostKDistinct(k):\n        count = 0\n        left = 0\n        char_count = {}\n        for right in range(len(A)):\n            if A[right] not in char_count:\n                char_count[A[right]] = 0\n            char_count[A[right]] += 1\n            while len(char_count) > k:\n                char_count[A[left]] -= 1\n                if char_count[A[left]] == 0:\n                    del char_count[A[left]]\n                left += 1\n            count += right - left + 1\n        return count\n\n    return atMostKDistinct(K) - atMostKDistinct(K - 1)", "from collections import Counter\n\ndef subarraysWithKDistinct(A, K):\n    count = Counter()\n    left = 0\n    result = 0\n    for right in range(len(A)):\n        if count[A[right]] == 0:\n            K -= 1\n        count[A[right]] += 1\n        while K < 0:\n            count[A[left]] -= 1\n            if count[A[left]] == 0:\n                K += 1\n            left += 1\n        result += right - left + 1\n    return result\n\ndef subarraysWithKDistinct(A, K):\n    return subarraysWithKDistinct(A, K) - subarraysWithKDistinct(A, K - 1)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 2627, "entry_point": "findTheLongestSubstring", "codes": ["def findTheLongestSubstring(s):\n    vowels = 'aeiou'\n    mask = 0\n    max_length = 0\n    seen = {0: -1}\n    \n    for i, char in enumerate(s):\n        if char in vowels:\n            mask ^= 1 << (vowels.index(char))\n        if mask in seen:\n            max_length = max(max_length, i - seen[mask])\n        else:\n            seen[mask] = i\n    \n    return max_length", "def findTheLongestSubstring(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    parity_map = {0: -1}\n    mask = 0\n    max_length = 0\n\n    for i, char in enumerate(s):\n        if char in vowels:\n            mask ^= 1 << (ord(char) - ord('a'))\n        if mask in parity_map:\n            max_length = max(max_length, i - parity_map[mask])\n        else:\n            parity_map[mask] = i\n\n    return max_length", "def findTheLongestSubstring(s):\n    vowels = 'aeiou'\n    bit_map = {c: 1 << i for i, c in enumerate(vowels)}\n    seen = {0: -1}\n    mask = 0\n    max_length = 0\n\n    for i, char in enumerate(s):\n        if char in bit_map:\n            mask ^= bit_map[char]\n        if mask in seen:\n            max_length = max(max_length, i - seen[mask])\n        else:\n            seen[mask] = i\n\n    return max_length", "def findTheLongestSubstring(s):\n    counts = [0] * 32\n    counts[0] = -1\n    mask = 0\n    result = 0\n\n    for i, char in enumerate(s):\n        if char in \"aeiou\":\n            mask ^= 1 << (ord(char) - ord('a'))\n        if counts[mask] != -1:\n            result = max(result, i - counts[mask])\n        else:\n            counts[mask] = i\n\n    return result", "def findTheLongestSubstring(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = [0] * 32\n    count[0] = -1\n    result = 0\n    current = 0\n\n    for i, char in enumerate(s):\n        if char in vowels:\n            current ^= 1 << (ord(char) - ord('a'))\n        if current in count:\n            result = max(result, i - count[current])\n        else:\n            count[current] = i\n\n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 2819, "entry_point": "getRow", "codes": ["from math import comb\n\ndef getRow(k: int) -> list[int]:\n    return [comb(k, i) for i in range(k + 1)]", "def getRow(k):\n    row = [1] * (k + 1)\n    for i in range(1, k // 2 + 1):\n        row[i] = row[k - i] = (row[i - 1] * (k - i + 1)) // i\n    return row", "def getRow(k):\n    row = [1] * (k + 1)\n    for i in range(1, k + 1):\n        for j in range(i - 1, 0, -1):\n            row[j] += row[j - 1]\n    return row", "def getRow(k):\n    row = [1] * (k + 1)\n    for i in range(1, k + 1):\n        for j in range(i, 0, -1):\n            row[j] += row[j - 1]\n    return row", "def getRow(i):\n    row = [1] * (i + 1)\n    for j in range(1, i):\n        row[j] = (row[j] * (i - j + 1)) // j\n    return row"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 2826, "entry_point": "maxArea", "codes": ["def maxArea(h, w, horizontalCuts, verticalCuts):\n    horizontalCuts = [0] + sorted(horizontalCuts) + [h]\n    verticalCuts = [0] + sorted(verticalCuts) + [w]\n    max_h = max(horizontalCuts[i] - horizontalCuts[i-1] for i in range(1, len(horizontalCuts)))\n    max_w = max(verticalCuts[i] - verticalCuts[i-1] for i in range(1, len(verticalCuts)))\n    return (max_h * max_w) % (10**9 + 7)", "def maxArea(h, w, horizontalCuts, verticalCuts):\n    MOD = 10**9 + 7\n    horizontalCuts.sort()\n    verticalCuts.sort()\n    \n    max_horizontal_cut = max(horizontalCuts[i] - horizontalCuts[i - 1] for i in range(1, len(horizontalCuts))) or h - horizontalCuts[-1]\n    max_vertical_cut = max(verticalCuts[i] - verticalCuts[i - 1] for i in range(1, len(verticalCuts))) or w - verticalCuts[-1]\n    \n    return (max_horizontal_cut * max_vertical_cut) % MOD", "def maxArea(h, w, horizontalCuts, verticalCuts):\n    horizontalCuts.sort()\n    verticalCuts.sort()\n    max_h = max(horizontalCuts[i] - horizontalCuts[i-1] for i in range(1, len(horizontalCuts)))\n    max_h = max(max_h, h - horizontalCuts[-1])\n    max_v = max(verticalCuts[i] - verticalCuts[i-1] for i in range(1, len(verticalCuts)))\n    max_v = max(max_v, w - verticalCuts[-1])\n    return (max_h * max_v) % (10**9 + 7)", "def maxArea(h, w, horizontalCuts, verticalCuts):\n    max_h = max(horizontalCuts[1:] - horizontalCuts[:-1])\n    max_h = max(max_h, h - horizontalCuts[-1])\n    max_h = max(max_h, horizontalCuts[0])\n\n    max_v = max(verticalCuts[1:] - verticalCuts[:-1])\n    max_v = max(max_v, w - verticalCuts[-1])\n    max_v = max(max_v, verticalCuts[0])\n\n    return (max_h * max_v) % (10**9 + 7)", "def maxArea(h, w, horizontalCuts, verticalCuts):\n    max_h = max(horizontalCuts) - min(horizontalCuts)\n    max_w = max(verticalCuts) - min(verticalCuts)\n    return (max_h * max_w) % (10**9 + 7)", "def maxArea(h, w, horizontalCuts, verticalCuts):\n    def max_v(max_v, w, prev_v):\n        return max(max_v, w - prev_v)\n\n    horizontalCuts.sort()\n    verticalCuts.sort()\n\n    max_h = max_v(0, h, 0)\n    max_h = max_v(max_h, h, horizontalCuts[0])\n    for i in range(1, len(horizontalCuts)):\n        max_h = max_v(max_h, h, horizontalCuts[i] - horizontalCuts[i-1])\n    max_h = max_v(max_h, h, h - horizontalCuts[-1])\n\n    max_w = max_v(0, w, 0)\n    max_w = max_v(max_w, w, verticalCuts[0])\n    for i in range(1, len(verticalCuts)):\n        max_w = max_v(max_w, w, verticalCuts[i] - verticalCuts[i-1])\n    max_w = max_v(max_w, w, w - verticalCuts[-1])\n\n    return (max_h * max_w) % (10**9 + 7)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 2839, "entry_point": "minSumOfLengths", "codes": ["def minSumOfLengths(arr, target):\n    n = len(arr)\n    min_len = float('inf')\n    result = float('inf')\n    min_len_prefix = [float('inf')] * n\n    \n    # Find the minimum length sub-array with sum equal to target\n    left, current_sum = 0, 0\n    for right in range(n):\n        current_sum += arr[right]\n        while current_sum >= target:\n            if current_sum == target:\n                length = right - left + 1\n                min_len = min(min_len, length)\n                min_len_prefix[right] = min(min_len_prefix[right], length)\n                if left > 0:\n                    min_len_prefix[right] = min(min_len_prefix[right], min_len_prefix[left - 1])\n            current_sum -= arr[left]\n            left += 1\n    \n    # Find the minimum sum of lengths of two non-overlapping sub-arrays\n    for i in range(n):\n        if min_len_prefix[i] < float('inf'):\n            result = min(result, min_len_prefix[i] + min_len)\n    \n    return result if result != float('inf') else -1", "def minSumOfLengths(arr, target):\n    def min_length_subarray(arr, target):\n        window_start = 0\n        window_sum = 0\n        min_length = float('inf')\n        for window_end in range(len(arr)):\n            window_sum += arr[window_end]\n            while window_sum >= target:\n                min_length = min(min_length, window_end - window_start + 1)\n                window_sum -= arr[window_start]\n                window_start += 1\n        return min_length if min_length != float('inf') else -1\n\n    n = len(arr)\n    min_lengths = [float('inf')] * n\n    min_length = float('inf')\n    for i in range(n):\n        length = min_length_subarray(arr[i:], target)\n        if length != -1:\n            min_lengths[i] = length\n            min_length = min(min_length, length)\n\n    min_sum = float('inf')\n    for i in range(n - 1):\n        if min_lengths[i] != float('inf') and min_lengths[i + 1] != float('inf'):\n            min_sum = min(min_sum, min_lengths[i] + min_lengths[i + 1])\n    return min_sum if min_sum != float('inf') else -1", "def minSumOfLengths(arr, target):\n    def min_subarray_length(arr, target):\n        length = float('inf')\n        start = 0\n        current_sum = 0\n        for end, num in enumerate(arr):\n            current_sum += num\n            while current_sum >= target:\n                if current_sum == target:\n                    length = min(length, end - start + 1)\n                current_sum -= arr[start]\n                start += 1\n        return length if length != float('inf') else -1\n\n    n = len(arr)\n    min_lengths = [float('inf')] * n\n    min_sum = float('inf')\n    current_min = float('inf')\n\n    for i in range(n):\n        current_min = min(current_min, min_subarray_length(arr[:i+1], target))\n        if current_min != float('inf'):\n            min_lengths[i] = current_min\n\n    for i in range(n-1, -1, -1):\n        if min_lengths[i] != float('inf'):\n            min_sum = min(min_sum, min_lengths[i] + min_subarray_length(arr[i:], target))\n\n    return min_sum if min_sum != float('inf') else -1", "def minSumOfLengths(arr, target):\n    def min_length_subarray(nums, t):\n        result, i, current_sum = float('inf'), 0, 0\n        for j, num in enumerate(nums):\n            current_sum += num\n            while current_sum >= t:\n                if current_sum == t:\n                    result = min(result, j - i + 1)\n                current_sum -= nums[i]\n                i += 1\n        return result if result != float('inf') else -1\n\n    n = len(arr)\n    if min_length_subarray(arr, target) == -1:\n        return -1\n\n    min_lengths = [float('inf')] * n\n    j = 0\n    current_sum = 0\n    for i, num in enumerate(arr):\n        current_sum += num\n        while current_sum >= target:\n            if current_sum == target:\n                min_lengths[i] = i - j + 1\n            current_sum -= arr[j]\n            j += 1\n\n    min_length = float('inf')\n    for i in range(1, n):\n        if min_lengths[i-1] != float('inf') and min_lengths[i] != float('inf'):\n            min_length = min(min_length, min_lengths[i-1] + min_lengths[i])\n\n    return min_length if min_length != float('inf') else -1", "def minSumOfLengths(arr, target):\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    min_len = float('inf')\n    best_end = -1\n    result = float('inf')\n    \n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n        if prefix_sum[i + 1] - target in prefix_sum[:i + 1]:\n            start = prefix_sum[:i + 1].index(prefix_sum[i + 1] - target)\n            if start <= best_end:\n                min_len = min(min_len, i - start + 1)\n            result = min(result, min_len + i - start + 1)\n            best_end = i\n    \n    return result if result < float('inf') else -1", "def minSumOfLengths(arr, target):\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n    \n    min_length = [float('inf')] * (n + 1)\n    min_sum = float('inf')\n    \n    for i in range(1, n + 1):\n        if prefix_sum[i] - target in prefix_sum:\n            j = prefix_sum.index(prefix_sum[i] - target)\n            min_length[i] = min_length[j] if min_length[j] != float('inf') else i - j\n            min_sum = min(min_sum, min_length[j] + i - j)\n    \n    return min_sum if min_sum != float('inf') else -1", "def minSumOfLengths(arr, target):\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n    \n    min_length = float('inf')\n    min_lengths = [float('inf')] * n\n    min_sum = float('inf')\n    \n    for i in range(n):\n        if prefix_sum[i + 1] - target in prefix_sum[:i + 1]:\n            j = prefix_sum[:i + 1].index(prefix_sum[i + 1] - target)\n            if j < i:\n                min_lengths[j] = min(min_lengths[j], i - j)\n                min_sum = min(min_sum, min_lengths[j] + (i - j))\n    \n    return min_sum if min_sum != float('inf') else -1", "def minSumOfLengths(arr, target):\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n    \n    subarray_lengths = [-1] * n\n    min_length = float('inf')\n    min_length_at = -1\n    \n    for i in range(n):\n        if prefix_sum[i + 1] - prefix_sum[i] == target:\n            subarray_lengths[i] = 1\n        else:\n            if min_length_at != -1:\n                subarray_lengths[i] = min_length\n            if prefix_sum[i + 1] - target in prefix_sum[:i + 1]:\n                index = prefix_sum[:i + 1].index(prefix_sum[i + 1] - target)\n                subarray_lengths[i] = min(subarray_lengths[i], i - index + 1)\n                if subarray_lengths[index] != -1:\n                    min_length = min(min_length, i - index + 1 + subarray_lengths[index])\n                min_length_at = index\n    \n    if min_length == float('inf'):\n        return -1\n    return min_length\n\ndef _equivalent(_lhs, _rhs):\n    return _lhs == _rhs"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 2910, "entry_point": "grayCode", "codes": ["def grayCode(n):\n    return [i ^ (i >> 1) for i in range(1 << n)]", "def grayCode(n: int) -> list[int]:\n    result = [0]\n    for i in range(n):\n        for j in range(len(result) - 1, -1, -1):\n            result.append(result[j] | (1 << i))\n    return result", "def grayCode(n):\n    if n == 0:\n        return [0]\n    \n    def backtrack(path, used):\n        if len(path) == 1 << n:\n            result.append(path[:])\n            return\n        for i in range(n):\n            if (path[-1] >> i) & 1 == 1:\n                if i not in used:\n                    used.add(i)\n                    path.append(path[-1] ^ (1 << i))\n                    backtrack(path, used)\n                    path.pop()\n                    used.remove(i)\n            else:\n                if i not in used:\n                    used.add(i)\n                    path.append(path[-1] | (1 << i))\n                    backtrack(path, used)\n                    path.pop()\n                    used.remove(i)\n    \n    result = []\n    backtrack([0], set())\n    return result", "def grayCode(n):\n    return list(map(int, map(''.join, map(lambda x: format(x, f'0{n}b'), range(1 << n)))))", "def grayCode(n):\n    def backtrack(path):\n        if len(path) == 1 << n:\n            result.append(path)\n            return\n        for bit in [0, 1]:\n            if not path or path[-1] ^ bit not in visited:\n                visited.add(path[-1] ^ bit)\n                backtrack(path + [path[-1] ^ bit])\n                visited.remove(path[-1] ^ bit)\n    \n    result = []\n    visited = {0}\n    backtrack([0])\n    return result[0]"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 2921, "entry_point": "countCharacters", "codes": ["from collections import Counter\n\ndef countCharacters(words, chars):\n    char_count = Counter(chars)\n    return sum(len(word) for word in words if not Counter(word) - char_count)", "def countCharacters(words, chars):\n    from collections import Counter\n    char_count = Counter(chars)\n    return sum(len(word) for word in words if not Counter(word) - char_count)", "def countCharacters(words, chars):\n    from collections import Counter\n    \n    char_count = Counter(chars)\n    total_length = 0\n    \n    for word in words:\n        word_count = Counter(word)\n        if all(word_count[char] <= char_count[char] for char in word_count):\n            total_length += len(word)\n    \n    return total_length", "def countCharacters(words, chars):\n    def canForm(word, char_count):\n        return all(word.count(char) <= char_count[char] for char in word)\n\n    char_count = collections.Counter(chars)\n    return sum(len(word) for word in words if canForm(word, char_count))", "def countCharacters(words, chars):\n    from collections import Counter\n    char_count = Counter(chars)\n    return sum(len(word) for word in words if Counter(word) <= char_count)", "def countCharacters(words, chars):\n    def canBeFormed(word, charCount):\n        wordCount = Counter(word)\n        for char in wordCount:\n            if wordCount[char] > charCount[char]:\n                return False\n        return True\n\n    charCount = Counter(chars)\n    return sum(len(word) for word in words if canBeFormed(word, charCount))", "def countCharacters(words, chars):\n    char_count = {}\n    for char in chars:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    total_length = 0\n    for word in words:\n        word_count = {}\n        for char in word:\n            word_count[char] = word_count.get(char, 0) + 1\n        if all(word_count[char] <= char_count[char] for char in word_count):\n            total_length += len(word)\n    \n    return total_length"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 2966, "entry_point": "nthPersonGetsNthSeat", "codes": ["def nthPersonGetsNthSeat(n):\n    return 1.0 if n == 1 else 0.5", "def nthPersonGetsNthSeat(n: int) -> float:\n    return 1.0 if n == 1 else 0.5", "def nthPersonGetsNthSeat(n):\n    return 1.0 if n == 1 else (0.5 if n == 2 else 0.0)", "def nthPersonGetsNthSeat(n):\n    return 0.5"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 2991, "entry_point": "canCross", "codes": ["def canCross(stones):\n    stone_set = set(stones)\n    jumps = {s: set() for s in stones}\n    jumps[0].add(1)\n\n    for stone in stones:\n        for jump in jumps[stone]:\n            for step in [jump - 1, jump, jump + 1]:\n                if step > 0 and stone + step in stone_set:\n                    jumps[stone + step].add(step)\n\n    return bool(jumps[stones[-1]])", "def canCross(stones):\n    stone_set = set(stones)\n    jumps = {stone: set() for stone in stones}\n    jumps[0].add(1)\n\n    for stone in stones:\n        for k in jumps[stone]:\n            for step in range(k - 1, k + 2):\n                if step > 0 and stone + step in stone_set:\n                    jumps[stone + step].add(step)\n\n    return len(jumps[stones[-1]]) > 0", "def canCross(stones):\n    stone_set = set(stones)\n    jump_table = {stone: set() for stone in stones}\n    jump_table[0].add(0)\n\n    for stone in stones:\n        for jump in jump_table[stone]:\n            for next_jump in (jump - 1, jump, jump + 1):\n                if next_jump > 0 and stone + next_jump in stone_set:\n                    jump_table[stone + next_jump].add(next_jump)\n\n    return len(jump_table[stones[-1]]) > 0", "def canCross(stones):\n    stone_set = set(stones)\n    dp = {}\n\n    def can_jump(i, k):\n        if (i, k) in dp:\n            return dp[(i, k)]\n        if i == stones[-1]:\n            return True\n        if i not in stone_set:\n            return False\n        dp[(i, k)] = (k > 0 and can_jump(i + k, k - 1)) or (can_jump(i + k, k)) or (k > 1 and can_jump(i + k, k + 1))\n        return dp[(i, k)]\n\n    return can_jump(0, 0)", "def canCross(stones):\n    if stones[1] != 1:\n        return False\n    \n    stone_set = set(stones)\n    dp = [set() for _ in stones]\n    dp[0].add(0)\n    \n    for i in range(1, len(stones)):\n        for k in dp[i]:\n            if k > 0 and stones[i] + k in stone_set:\n                dp[stones[i] + k].add(k)\n            if k + 1 > 0 and stones[i] + k + 1 in stone_set:\n                dp[stones[i] + k + 1].add(k + 1)\n            if k - 1 > 0 and stones[i] + k - 1 in stone_set:\n                dp[stones[i] + k - 1].add(k - 1)\n    \n    return len(dp[-1]) > 0"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 3003, "entry_point": "subsetsWithDup", "codes": ["def subsetsWithDup(nums):\n    nums.sort()\n    result = [[]]\n    for num in nums:\n        result += [subset + [num] for subset in result if subset + [num] not in result]\n    return result", "def subsetsWithDup(nums):\n    nums.sort()\n    res = [[]]\n    for num in nums:\n        res += [item + [num] for item in res if item + [num] not in res]\n    return res\n\ndef _equivalent(lhs, rhs):\n    return sorted(lhs) == sorted(rhs)", "def subsetsWithDup(nums):\n    result = set()\n    nums.sort()\n    def backtrack(start, path):\n        result.add(tuple(path))\n        for i in range(start, len(nums)):\n            backtrack(i + 1, path + [nums[i]])\n    backtrack(0, [])\n    return [list(subset) for subset in result]", "def subsetsWithDup(nums):\n    from collections import Counter\n    count = Counter(nums)\n    result = [[]]\n\n    for num in count:\n        for i in range(len(result)):\n            result.append(result[i] + [num] * count[num])\n\n    return result", "def subsetsWithDup(nums):\n    nums.sort()\n    result = [[]]\n    start = 0\n    for i in range(len(nums)):\n        if i > 0 and nums[i] == nums[i - 1]:\n            start = len(result) - start\n        end = len(result)\n        for j in range(start, end):\n            result.append(result[j] + [nums[i]])\n    return result"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 3094, "entry_point": "maxValueAfterReverse", "codes": ["def maxValueAfterReverse(nums):\n    n = len(nums)\n    total = sum(abs(nums[i] - nums[i+1]) for i in range(n-1))\n    max_gain = 0\n    \n    for i in range(n-1):\n        max_gain = max(max_gain, abs(nums[0] - nums[i+1]) - abs(nums[i] - nums[i+1]))\n        max_gain = max(max_gain, abs(nums[-1] - nums[i]) - abs(nums[i] - nums[i+1]))\n    \n    for i in range(1, n-1):\n        max_gain = max(max_gain, abs(nums[i] - nums[0]) - abs(nums[i+1] - nums[0]))\n        max_gain = max(max_gain, abs(nums[i] - nums[-1]) - abs(nums[i-1] - nums[-1]))\n    \n    return total + max_gain", "def maxValueAfterReverse(nums):\n    n = len(nums)\n    if n <= 2:\n        return 0\n    \n    current_value = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    max_diff = 0\n    \n    for i in range(n - 1):\n        max_diff = max(max_diff, \n                       abs(nums[0] - nums[i + 1]) - abs(nums[i] - nums[i + 1]),\n                       abs(nums[n - 1] - nums[i]) - abs(nums[i] - nums[i + 1]),\n                       abs(nums[i] - nums[0]) - abs(nums[i + 1] - nums[i]),\n                       abs(nums[i] - nums[n - 1]) - abs(nums[i + 1] - nums[i]))\n    \n    return current_value + max_diff", "def maxValueAfterReverse(nums):\n    n = len(nums)\n    current_value = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    max_value = current_value\n    \n    for i in range(n - 1):\n        max_value = max(max_value, current_value - abs(nums[i] - nums[i + 1]) + abs(nums[0] - nums[i + 1]), \n                       current_value - abs(nums[i] - nums[i + 1]) + abs(nums[i] - nums[0]))\n    \n    for i in range(1, n):\n        max_value = max(max_value, current_value - abs(nums[i - 1] - nums[i]) + abs(nums[0] - nums[i]),\n                       current_value - abs(nums[i - 1] - nums[i]) + abs(nums[i - 1] - nums[-1]))\n    \n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if i == 0:\n                max_value = max(max_value, current_value - abs(nums[i] - nums[i + 1]) + abs(nums[j] - nums[i + 1]))\n            elif j == n - 1:\n                max_value = max(max_value, current_value - abs(nums[i] - nums[i + 1]) + abs(nums[i] - nums[j]))\n            else:\n                max_value = max(max_value, current_value - abs(nums[i] - nums[i + 1]) + abs(nums[i] - nums[j]) + \n                               abs(nums[i + 1] - nums[j]) - abs(nums[i] - nums[j]))\n    \n    return max_value", "def maxValueAfterReverse(nums):\n    n = len(nums)\n    if n <= 2:\n        return sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    \n    max_diff = 0\n    current_diff = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    \n    for i in range(n - 1):\n        max_diff = max(max_diff, abs(nums[0] - nums[i + 1]) - abs(nums[i] - nums[i + 1]))\n        max_diff = max(max_diff, abs(nums[-1] - nums[i]) - abs(nums[i] - nums[i + 1]))\n    \n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if i == 0:\n                max_diff = max(max_diff, current_diff - abs(nums[i] - nums[j]) + abs(nums[j] - nums[j + 1]) + abs(nums[i] - nums[j + 1]))\n            elif j == n - 1:\n                max_diff = max(max_diff, current_diff - abs(nums[i] - nums[j]) + abs(nums[i - 1] - nums[j - 1]) + abs(nums[j - 1] - nums[i]))\n            else:\n                max_diff = max(max_diff, current_diff - abs(nums[i] - nums[j]) + abs(nums[j] - nums[j + 1]) + abs(nums[i - 1] - nums[j - 1]))\n    \n    return current_diff + max_diff", "def maxValueAfterReverse(nums):\n    n = len(nums)\n    if n == 1:\n        return 0\n    \n    current_value = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    max_value = current_value\n    \n    # Check reversing the entire array\n    max_value = max(max_value, 2 * sum(nums) - current_value)\n    \n    # Check reversing subarrays ending at each position\n    for i in range(n - 1):\n        max_value = max(max_value, current_value - abs(nums[i] - nums[i + 1]) + abs(nums[0] - nums[i + 1]))\n        max_value = max(max_value, current_value - abs(nums[i] - nums[i + 1]) + abs(nums[i] - nums[0]))\n    \n    # Check reversing subarrays starting at each position\n    for i in range(1, n):\n        max_value = max(max_value, current_value - abs(nums[i] - nums[i - 1]) + abs(nums[i] - nums[-1]))\n        max_value = max(max_value, current_value - abs(nums[i] - nums[i - 1]) + abs(nums[-1] - nums[i - 1]))\n    \n    return max_value", "def maxValueAfterReverse(nums):\n    n = len(nums)\n    current_sum = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    max_gain = 0\n\n    for i in range(n - 1):\n        max_gain = max(max_gain, abs(nums[0] - nums[i + 1]) - abs(nums[i] - nums[i + 1]))\n        max_gain = max(max_gain, abs(nums[n - 1] - nums[i]) - abs(nums[i] - nums[i + 1]))\n\n    for i in range(1, n):\n        max_gain = max(max_gain, abs(nums[i - 1] - nums[n - 1]) - abs(nums[i] - nums[i - 1]))\n\n    return current_sum + max_gain", "def maxValueAfterReverse(nums):\n    n = len(nums)\n    original_sum = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    max_gain = 0\n\n    for i in range(n - 1):\n        max_gain = max(max_gain, 2 * abs(nums[i] - nums[n - 1]) - abs(nums[i] - nums[i + 1]),\n                       2 * abs(nums[0] - nums[i + 1]) - abs(nums[i] - nums[i + 1]))\n\n    return original_sum + max_gain", "def maxValueAfterReverse(nums):\n    n = len(nums)\n    current_value = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    max_increase = 0\n\n    for i in range(n - 1):\n        max_increase = max(max_increase, abs(nums[0] - nums[i + 1]) - abs(nums[i] - nums[i + 1]))\n        max_increase = max(max_increase, abs(nums[n - 1] - nums[i]) - abs(nums[i] - nums[i + 1]))\n        if i > 0:\n            max_increase = max(max_increase, abs(nums[i - 1] - nums[n - 1]) - abs(nums[i - 1] - nums[i]) + abs(nums[i] - nums[n - 1]) - abs(nums[i] - nums[i + 1]))\n\n    return current_value + max_increase"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 3099, "entry_point": "countNegatives", "codes": ["def countNegatives(grid):\n    return sum(row.count(x) for row in grid for x in range(-1, -101, -1))", "def countNegatives(grid):\n    count = 0\n    for row in grid:\n        count += sum(1 for x in row if x < 0)\n    return count", "def countNegatives(grid):\n    count = 0\n    for row in grid:\n        for num in row:\n            if num < 0:\n                count += 1\n    return count", "def countNegatives(grid):\n    return sum(row.count(-1) for row in grid)", "def countNegatives(grid):\n    m, n = len(grid), len(grid[0])\n    count = 0\n    for i in range(m):\n        j = 0\n        while j < n and grid[i][j] >= 0:\n            j += 1\n        count += n - j\n    return count", "def countNegatives(grid):\n    count = 0\n    rows, cols = len(grid), len(grid[0])\n    row, col = 0, cols - 1\n    while row < rows and col >= 0:\n        if grid[row][col] < 0:\n            count += rows - row\n            col -= 1\n        else:\n            row += 1\n    return count", "def countNegatives(grid):\n    m, n = len(grid), len(grid[0])\n    count = 0\n    for i in range(m):\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if grid[i][mid] < 0:\n                right = mid\n            else:\n                left = mid + 1\n        count += n - left\n    return count"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 3156, "entry_point": "maximumSum", "codes": ["def maximumSum(arr):\n    n = len(arr)\n    max_sum = float('-inf')\n    dp = [[0] * 2 for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = max(arr[i], dp[i-1][0] + arr[i])\n        dp[i][1] = max(dp[i-1][0], dp[i-1][1] + arr[i])\n        max_sum = max(max_sum, dp[i][0], dp[i][1])\n    \n    return max_sum", "def maximumSum(arr):\n    n = len(arr)\n    if n == 1:\n        return arr[0]\n    \n    dp = [[0, 0] for _ in range(n)]\n    dp[0][0] = arr[0]\n    dp[0][1] = arr[0]\n    \n    for i in range(1, n):\n        dp[i][0] = max(arr[i], dp[i - 1][0] + arr[i])\n        dp[i][1] = max(dp[i - 1][0], dp[i - 1][1] + arr[i])\n    \n    return max(max(dp[i]) for i in range(n))", "def maximumSum(arr):\n    n = len(arr)\n    dp = [[0, 0] for _ in range(n)]\n    dp[0][0] = arr[0]\n    dp[0][1] = arr[0]\n    max_sum = arr[0]\n    \n    for i in range(1, n):\n        dp[i][0] = max(dp[i-1][0] + arr[i], arr[i])\n        dp[i][1] = max(dp[i-1][0], dp[i-1][1] + arr[i])\n        max_sum = max(max_sum, dp[i][0], dp[i][1])\n    \n    return max_sum", "def maximumSum(arr):\n    n = len(arr)\n    if n == 1:\n        return arr[0]\n    \n    max_sum = arr[0]\n    current_sum = arr[0]\n    \n    for i in range(1, n):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    \n    without_deletion = max_sum\n    \n    current_sum = arr[0]\n    max_sum = arr[0]\n    \n    for i in range(1, n):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    \n    without_deletion = max(without_deletion, max_sum)\n    \n    current_sum = arr[0]\n    max_sum = arr[0]\n    \n    for i in range(1, n):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    \n    without_deletion = max(without_deletion, max_sum)\n    \n    return without_deletion"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 3394, "entry_point": "isScramble", "codes": ["def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if sorted(s1) != sorted(s2):\n        return False\n    for i in range(1, len(s1)):\n        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n           (isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i])):\n            return True\n    return False", "def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2) or sorted(s1) != sorted(s2):\n        return False\n    for i in range(1, len(s1)):\n        if isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:]) or \\\n           isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i]):\n            return True\n    return False", "def isScramble(s1: str, s2: str) -> bool:\n    if len(s1) != len(s2):\n        return False\n    if s1 == s2:\n        return True\n    if sorted(s1) != sorted(s2):\n        return False\n    n = len(s1)\n    for i in range(1, n):\n        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n           (isScramble(s1[:i], s2[n-i:]) and isScramble(s1[i:], s2[:n-i])):\n            return True\n    return False", "def isScramble(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    if s1 == s2:\n        return True\n    count = [0] * 26\n    for i in range(len(s1)):\n        count[ord(s1[i]) - ord('a')] += 1\n        count[ord(s2[i]) - ord('a')] -= 1\n        if count[i] != 0:\n            return False\n    for i in range(1, len(s1)):\n        if isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:]):\n            return True\n        if isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i]):\n            return True\n    return False", "def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2):\n        return False\n    count = [0] * 26\n    for i in range(len(s1)):\n        count[ord(s1[i]) - ord('a')] += 1\n        count[ord(s2[i]) - ord('a')] -= 1\n        if count[i] != 0:\n            return False\n    for i in range(1, len(s1)):\n        if isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:]) or \\\n           isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i]):\n            return True\n    return False", "def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2):\n        return False\n\n    count = [0] * 26\n    for i in range(len(s1)):\n        count[ord(s1[i]) - ord('a')] += 1\n        count[ord(s2[i]) - ord('a')] -= 1\n\n    if any(count):\n        return False\n\n    n = len(s1)\n    for i in range(1, n):\n        if isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:]) or \\\n           isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i]):\n            return True\n    return False", "def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2):\n        return False\n    count = [0] * 26\n    for i in range(len(s1)):\n        count[ord(s1[i]) - ord('a')] += 1\n        count[ord(s2[i]) - ord('a')] -= 1\n    if any(count):\n        return False\n    for i in range(1, len(s1)):\n        if isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:]) or \\\n           isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i]):\n            return True\n    return False"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 388, "entry_point": "sumFourDivisors", "codes": ["def sumFourDivisors(nums):\n    return sum(sum(d for d in range(1, n + 1) if n % d == 0 and len([d for d in range(1, n + 1) if n % d == 0]) == 4) for n in nums)", "def sumFourDivisors(nums):\n    def hasFourDivisors(n):\n        count = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                count += 1\n                if i * i != n:\n                    count += 1\n                if count > 4:\n                    return False\n        return count == 4\n\n    return sum(sum(i for i in range(1, n + 1) if n % i == 0) for n in nums if hasFourDivisors(n))", "def sumFourDivisors(nums):\n    def count_divisors(n):\n        count = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                count += 2 if i != n // i else 1\n                if count > 4:\n                    return 0\n        return count if count == 4 else 0\n    \n    total = 0\n    for num in nums:\n        if count_divisors(num) == 4:\n            total += sum(divisor for divisor in range(1, num + 1) if num % divisor == 0)\n    return total", "def sumFourDivisors(nums):\n    def count_divisors(n):\n        count, i = 0, 1\n        for i in reversed(range(1, int(n**0.5) + 1)):\n            if n % i == 0:\n                count += 1\n                if i != n // i:\n                    count += 1\n            if count > 4:\n                return 0\n        return count\n\n    return sum(sum(range(1, n + 1)) if count_divisors(n) == 4 else 0 for n in reversed(nums))", "def sumFourDivisors(nums):\n    def has_four_divisors(n):\n        divisors = []\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return len(divisors) == 4\n    \n    return sum(n for n in nums if has_four_divisors(n))", "def sumFourDivisors(nums):\n    def count_divisors(n):\n        if n <= 3:\n            return 0\n        count = 2  # 1 and n are divisors\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                count += 1\n                if i != n // i:\n                    count += 1\n                if count > 4:\n                    return 0\n        return count\n\n    return sum(n for n in nums if count_divisors(n) == 4)", "def sumFourDivisors(nums):\n    def hasExactlyFourDivisors(n):\n        count = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                count += 1\n                if i != n // i:\n                    count += 1\n                if count > 4:\n                    return False\n        return count == 4\n\n    return sum(n for n in nums if hasExactlyFourDivisors(n))", "def sumFourDivisors(nums):\n    def hasFourDivisors(n):\n        divisors = [1, n]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.extend([i, n // i])\n                if len(divisors) > 4:\n                    return False\n        return len(divisors) == 4\n\n    return sum(filter(hasFourDivisors, nums))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 3576, "entry_point": "numSub", "codes": ["def numSub(s: str) -> int:\n    MOD = 10**9 + 7\n    count, result = 0, 0\n    for char in s:\n        if char == '1':\n            count += 1\n            result = (result + count) % MOD\n        else:\n            count = 0\n    return result", "def numSub(s):\n    MOD = 10**9 + 7\n    count = 0\n    result = 0\n    for char in s:\n        if char == '1':\n            count += 1\n            result = (result + count) % MOD\n        else:\n            count = 0\n    return result", "def numSub(s: str) -> int:\n    MOD = 10**9 + 7\n    result = 0\n    count = 0\n    \n    for char in s:\n        if char == '1':\n            count += 1\n            result = (result + count) % MOD\n        else:\n            count = 0\n    \n    return result", "def numSub(s: str) -> int:\n    return sum((len(group) * (len(group) + 1)) // 2 for group in s.split('0')) % (10**9 + 7)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 3588, "entry_point": "findLongestWord", "codes": ["def findLongestWord(s, d):\n    def is_subsequence(word):\n        it = iter(s)\n        return all(char in it for char in word)\n    \n    filtered = [word for word in d if is_subsequence(word)]\n    return max(filtered or [''], key=lambda x: (len(x), x))", "def findLongestWord(s, d):\n    def is_subsequence(word):\n        it = iter(s)\n        return all(char in it for char in word)\n    \n    candidates = sorted((word for word in d if is_subsequence(word)), key=lambda x: (-len(x), x))\n    return candidates[0] if candidates else \"\"", "def findLongestWord(s: str, d: list[str]) -> str:\n    def is_subsequence(word: str) -> bool:\n        it = iter(s)\n        return all(char in it for char in word)\n    \n    filtered = filter(is_subsequence, d)\n    return max(filtered, key=lambda x: (len(x), x), default='')", "def findLongestWord(s: str, d: List[str]) -> str:\n    def is_subsequence(word):\n        it = iter(s)\n        return all(char in it for char in word)\n\n    sorted_d = sorted(d, key=lambda x: (-len(x), x))\n    for word in sorted_d:\n        if is_subsequence(word):\n            return word\n    return \"\""], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 3612, "entry_point": "hIndex", "codes": ["def hIndex(citations):\n    citations.sort(reverse=True)\n    h = 0\n    for i, c in enumerate(citations):\n        if c >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h", "def hIndex(citations):\n    citations.sort(reverse=True)\n    h = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h", "def hIndex(citations):\n    count = [0] * (len(citations) + 1)\n    for c in citations:\n        count[min(c, len(citations))] += 1\n    total = 0\n    for i in range(len(count) - 1, -1, -1):\n        total += count[i]\n        if total >= i:\n            return i", "def hIndex(citations):\n    from collections import Counter\n    count = Counter(citations)\n    n = len(citations)\n    for h in range(n, 0, -1):\n        if sum(count[i] for i in range(h, n + 1)) >= h:\n            return h\n    return 0"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 3757, "entry_point": "minSetSize", "codes": ["def minSetSize(arr):\n    from collections import Counter\n    count = Counter(arr)\n    sorted_counts = sorted(count.values(), reverse=True)\n    target = len(arr) // 2\n    removed = 0\n    for i, freq in enumerate(sorted_counts):\n        removed += freq\n        if removed >= target:\n            return i + 1", "from collections import Counter\n\ndef minSetSize(arr):\n    count = Counter(arr)\n    sorted_count = sorted(count.values(), reverse=True)\n    total = 0\n    result = 0\n    for freq in sorted_count:\n        total += freq\n        result += 1\n        if total >= len(arr) // 2:\n            return result", "from collections import Counter\n\ndef minSetSize(arr):\n    count = Counter(arr)\n    total = len(arr)\n    target = total // 2\n    removed = 0\n    result = 0\n    \n    for _, freq in count.most_common():\n        removed += freq\n        result += 1\n        if removed >= target:\n            return result", "def minSetSize(arr):\n    count = sorted(Counter(arr).values(), reverse=True)\n    target = len(arr) // 2\n    for i, x in enumerate(accumulate(count)):\n        if x >= target:\n            return i + 1", "def minSetSize(arr):\n    count = sorted(Counter(arr).values(), reverse=True)\n    removed = 0\n    for i, freq in enumerate(count):\n        removed += freq\n        if removed >= len(arr) // 2:\n            return i + 1", "def minSetSize(arr):\n    freq = sorted(Counter(arr).values(), reverse=True)\n    total = len(arr)\n    removed = 0\n    for i, count in enumerate(freq):\n        removed += count\n        if removed >= total // 2:\n            return i + 1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 3777, "entry_point": "findIntegers", "codes": ["def findIntegers(n):\n    a, b = 0, 1\n    for _ in range(n.bit_length()):\n        a, b = b, a + b\n    return a + (n < 2)", "def findIntegers(n):\n    def fib(n):\n        a, b = 1, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return a\n\n    n += 1\n    res, p = 0, 1\n    while n:\n        if n & 1:\n            res += p\n        if res >= p:\n            return p\n        n >>= 1\n        p <<= 1\n    return p", "def findIntegers(n):\n    def fib(n):\n        a, b = 0, 1\n        for _ in range(n + 1):\n            a, b = b, a + b\n        return a\n\n    binary_n = bin(n)[2:]\n    length = len(binary_n)\n    count = fib(length)\n    prefix = 1\n\n    for i in range(length - 2, -1, -1):\n        if binary_n[i] == '1' and binary_n[i + 1] == '1':\n            break\n        if binary_n[i] == '1':\n            prefix = fib(i + 2)\n        count -= prefix\n\n    return count", "def findIntegers(n: int) -> int:\n    if n == 0:\n        return 1\n    bin_n = bin(n)[2:]\n    length = len(bin_n)\n    fib = [0] * (length + 1)\n    fib[0], fib[1] = 1, 2\n    for i in range(2, length + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n    res = fib[length] - (bin_n[length - 1] == bin_n[length - 2])\n    for i in range(length - 2, -1, -1):\n        if bin_n[i] == '1' and bin_n[i + 1] == '1':\n            break\n        elif bin_n[i] == '0' and bin_n[i + 1] == '0':\n            res -= fib[i]\n    return res", "def findIntegers(n):\n    dp = [0, 1] + [0] * n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]", "def findIntegers(n):\n    dp = [0, 1]\n    for i in range(2, 32):\n        dp.append(dp[i - 1] + dp[i - 2])\n    a, b = 1, 1\n    for i in range(30, -1, -1):\n        if n & (1 << i):\n            a, b = a + b, a\n        if (n & (1 << i)) and (n & (1 << (i - 1))):\n            break\n    return a", "def findIntegers(n):\n    dp = [0, 1]\n    for i in range(2, n + 1):\n        dp.append(dp[i - 1] + dp[i - 2])\n    return dp[n]"], "rewards": [1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 3952, "entry_point": "subarrayBitwiseORs", "codes": ["from functools import reduce\nfrom operator import or_\n\ndef subarrayBitwiseORs(A):\n    return len({reduce(or_, A[i:j]) for i in range(len(A)) for j in range(i+1, len(A)+1)})", "def subarrayBitwiseORs(A):\n    s, r = {0}, set()\n    for x in A:\n        s = {x | y for y in s} | {x}\n        r |= s\n    return len(r)", "def subarrayBitwiseORs(A):\n    ors = set()\n    current = 0\n    for num in A:\n        current |= num\n        ors |= {current}\n    return len(ors)", "def subarrayBitwiseORs(A):\n    unique_results = set()\n    current_or = 0\n    for num in A:\n        current_or |= num\n        unique_results.add(current_or)\n        prefix_or = 0\n        for prev_or in reversed(unique_results):\n            prefix_or |= prev_or\n            unique_results.add(prefix_or)\n    return len(unique_results)"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 410, "entry_point": "numTilePossibilities", "codes": ["import itertools\n\ndef numTilePossibilities(tiles):\n    return sum(len(set(itertools.permutations(tiles, r))) for r in range(1, len(tiles) + 1))", "def numTilePossibilities(tiles):\n    from itertools import permutations\n\n    result = set()\n    for r in range(1, len(tiles) + 1):\n        for perm in permutations(tiles, r):\n            result.add(''.join(perm))\n    return len(result)", "def numTilePossibilities(tiles):\n    from itertools import permutations\n\n    unique_tiles = set()\n    for r in range(1, len(tiles) + 1):\n        for perm in permutations(tiles, r):\n            unique_tiles.add(''.join(perm))\n    return len(unique_tiles)", "from collections import Counter\nfrom itertools import permutations\n\ndef numTilePossibilities(tiles):\n    def generate(tiles):\n        if not tiles:\n            yield \"\"\n        for i in range(len(tiles)):\n            for perm in generate(tiles[:i] + tiles[i+1:]):\n                yield tiles[i] + perm\n\n    return len(set(generate(tiles))) - 1\n\n# Unit tests to satisfy:\nassert numTilePossibilities(\"AAB\") == 8\nassert numTilePossibilities(\"AAABBC\") == 188\nassert numTilePossibilities(\"V\") == 1", "from itertools import permutations\n\ndef numTilePossibilities(tiles):\n    return len(set(''.join(p) for p in permutations(tiles)))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 4080, "entry_point": "longestArithSeqLength", "codes": ["def longestArithSeqLength(A):\n    n = len(A)\n    dp = [{} for _ in range(n)]\n    max_length = 0\n    \n    for i in range(n):\n        for j in range(i):\n            diff = A[i] - A[j]\n            dp[i][diff] = dp[j].get(diff, 1) + 1\n            max_length = max(max_length, dp[i][diff])\n    \n    return max_length", "def longestArithSeqLength(A):\n    n = len(A)\n    dp = [{} for _ in range(n)]\n    max_length = 2\n\n    for i in range(n):\n        for j in range(i):\n            diff = A[i] - A[j]\n            dp[i][diff] = dp[j].get(diff, 1) + 1\n            max_length = max(max_length, dp[i][diff])\n\n    return max_length", "def longestArithSeqLength(A):\n    n = len(A)\n    dp = [{} for _ in range(n)]\n    max_len = 0\n    \n    for i in range(1, n):\n        for j in range(i):\n            diff = A[i] - A[j]\n            dp[i][diff] = dp[j].get(diff, 1) + 1\n            max_len = max(max_len, dp[i][diff])\n    \n    return max_len", "def longestArithSeqLength(A):\n    from collections import defaultdict\n\n    n = len(A)\n    dp = [defaultdict(lambda: 2) for _ in range(n)]\n\n    max_length = 2\n\n    for i in range(n):\n        for j in range(i):\n            diff = A[i] - A[j]\n            dp[i][diff] = dp[j][diff] + 1\n            max_length = max(max_length, dp[i][diff])\n\n    return max_length", "def longestArithSeqLength(A):\n    from collections import defaultdict\n    \n    n = len(A)\n    dp = [defaultdict(lambda: 2) for _ in range(n)]\n    longest = 2\n    \n    for i in range(1, n):\n        for j in range(i):\n            diff = A[i] - A[j]\n            dp[i][diff] = dp[j][diff] + 1\n            longest = max(longest, dp[i][diff])\n    \n    return longest"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 4165, "entry_point": "movesToMakeZigzag", "codes": ["def movesToMakeZigzag(nums):\n    n = len(nums)\n    def cost(arr):\n        return sum(max(0, arr[i] - arr[i-1] + 1) for i in range(1, n)) + sum(max(0, arr[i] - arr[i+1] + 1) for i in range(n-1)) - max(0, arr[0] - arr[1] + 1) - max(0, arr[-1] - arr[-2] + 1)\n    return min(cost(nums[1:] + nums[:1]), cost(nums[:-1] + nums[-1:]))", "def movesToMakeZigzag(nums):\n    n = len(nums)\n    def moves(index):\n        left = nums[index - 1] if index > 0 else float('inf')\n        right = nums[index + 1] if index < n - 1 else float('inf')\n        return max(0, nums[index] - min(left, right) + 1)\n    return min(sum(moves(i) for i in range(0, n, 2)), sum(moves(i) for i in range(1, n, 2)))", "def movesToMakeZigzag(nums):\n    def transform(arr, cond):\n        moves = 0\n        for i in range(len(arr)):\n            if (i % 2 == 0) == cond:\n                left = arr[i - 1] if i > 0 else float('inf')\n                right = arr[i + 1] if i < len(arr) - 1 else float('inf')\n                if arr[i] >= min(left, right):\n                    moves += arr[i] - min(left, right) + 1\n        return moves\n\n    return min(transform(nums, True), transform(nums, False))", "def movesToMakeZigzag(nums):\n    def count_moves(arr):\n        moves = 0\n        for i in range(len(arr)):\n            if i % 2 == 0:\n                if i + 1 < len(arr) and arr[i] <= arr[i + 1]:\n                    moves += arr[i + 1] - arr[i] + 1\n                    arr[i + 1] = arr[i] - 1\n                if i - 1 >= 0 and arr[i] <= arr[i - 1]:\n                    moves += arr[i - 1] - arr[i] + 1\n                    arr[i - 1] = arr[i] - 1\n            else:\n                if i + 1 < len(arr) and arr[i] >= arr[i + 1]:\n                    moves += arr[i] - arr[i + 1] + 1\n                    arr[i + 1] = arr[i] - 1\n                if i - 1 >= 0 and arr[i] >= arr[i - 1]:\n                    moves += arr[i] - arr[i - 1] + 1\n                    arr[i - 1] = arr[i] - 1\n        return moves\n\n    return min(count_moves(nums), count_moves(nums[::-1]))", "def movesToMakeZigzag(nums):\n    def adjust_to_zigzag(arr, start):\n        moves = 0\n        for i in range(start, len(arr) - 1, 2):\n            min_adj = min(arr[i - 1], arr[i + 1]) if i > 0 and i < len(arr) - 1 else float('inf')\n            if arr[i] >= min_adj:\n                moves += arr[i] - min_adj + 1\n                arr[i] = min_adj - 1\n        return moves\n\n    return min(adjust_to_zigzag(nums.copy(), 0), adjust_to_zigzag(nums.copy(), 1))", "def movesToMakeZigzag(nums):\n    def count_moves(target):\n        return sum(max(0, num - target - 1) for num in nums)\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n    return min(count_moves(nums[0] - 1) + count_moves(nums[1::2] - 1) + count_moves(nums[2::2] - 1),\n              count_moves(nums[1] - 1) + count_moves(nums[::2] - 1))", "def movesToMakeZigzag(nums):\n    def transform_to_zigzag(arr, compare):\n        moves = 0\n        for i in range(len(arr)):\n            if i % 2 == 0 and not compare(arr[i], arr[i + 1]):\n                moves += arr[i] - arr[i + 1] + 1\n            elif i % 2 == 1 and not compare(arr[i], arr[i - 1]):\n                moves += arr[i] - arr[i - 1] + 1\n        return moves\n\n    def greater_than(a, b):\n        return a > b\n\n    def less_than(a, b):\n        return a < b\n\n    return min(transform_to_zigzag(nums, greater_than), transform_to_zigzag(nums, less_than))", "def movesToMakeZigzag(nums):\n    def transform(array, adjust):\n        return [array[i] - adjust[i] for i in range(len(array))]\n\n    def count_moves(array):\n        return sum(max(0, array[i] - min(array[i - 1] if i > 0 else float('inf'), array[i + 1] if i < len(array) - 1 else float('inf'))) for i in range(len(array)))\n\n    adjust_even = [1] * len(nums)\n    adjust_odd = [1] * len(nums)\n    adjust_even[1::2] = [0] * (len(nums) // 2)\n    adjust_odd[0::2] = [0] * (len(nums) // 2)\n\n    return min(count_moves(transform(nums, adjust_even)), count_moves(transform(nums, adjust_odd)))"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 4173, "entry_point": "isSelfCrossing", "codes": ["def isSelfCrossing(x):\n    if len(x) < 4:\n        return False\n    for i in range(3, len(x)):\n        if (i >= 3 and x[i] >= x[i-2]) or (i >= 4 and x[i-1] == x[i-3] and x[i] + x[i-4] >= x[i-2]) or (i >= 5 and x[i-2] > x[i-4] and x[i-1] > x[i-3] and x[i] + x[i-4] >= x[i-2] and x[i-1] + x[i-5] >= x[i-3]):\n            return True\n    return False", "def isSelfCrossing(x):\n    x = x + [0] * 3  # Pad the array to avoid index out of range\n    for i in range(3, len(x)):\n        if x[i] >= x[i-2] and x[i-1] <= x[i-3]:\n            return True\n        if i >= 4 and x[i-1] == x[i-3] and x[i] + x[i-4] >= x[i-2]:\n            return True\n        if i >= 5 and x[i-2] > x[i-4] and x[i-1] < x[i-3] and x[i] + x[i-4] >= x[i-2] and x[i-5] + x[i-1] >= x[i-3]:\n            return True\n    return False", "def isSelfCrossing(x):\n    x = [0] + x\n    for i in range(4, len(x)):\n        if x[i] >= x[i-2] and x[i-1] <= x[i-3]:  # Case 1\n            return True\n        if i >= 5 and x[i-3] >= x[i-5] and x[i-2] == x[i-4] and x[i-1] >= x[i-3] - x[i-5]:  # Case 2\n            return True\n        if i >= 6 and x[i-2] > x[i-4] and x[i-3] >= x[i-5] and x[i-1] >= x[i-3] - x[i-5] and x[i-4] >= x[i-6] and x[i-5] >= x[i-7]:  # Case 4\n            return True\n    return False", "def isSelfCrossing(x):\n    return any(x[i] >= x[i-2] and x[i-4] >= x[i-6] for i in range(5, len(x))) if len(x) >= 6 else False", "def isSelfCrossing(x):\n    return is_self_crossing() if len(x) >= 6 else False\n\ndef is_self_crossing():\n    x = self.x\n    x += [0, 0, 0, 0]  # Pad the array to handle edge cases\n    for i in range(3, len(x)):\n        if x[i] >= x[i - 2] and x[i - 1] <= x[i - 3]:\n            return True\n        if i >= 4 and x[i - 1] == x[i - 3] and x[i] + x[i - 4] >= x[i - 2]:\n            return True\n        if i >= 5 and x[i - 2] >= x[i - 4] and x[i - 3] > x[i - 5] and x[i] + x[i - 4] >= x[i - 2] and x[i - 1] >= x[i - 3] and x[i - 1] - x[i - 3] <= x[i - 5]:\n            return True\n    return False"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0]}
{"id": 4178, "entry_point": "canReorderDoubled", "codes": ["def canReorderDoubled(A):\n    A.sort(key=abs)\n    count = {}\n    for x in A:\n        if x // 2 in count and count[x // 2] > 0:\n            count[x // 2] -= 1\n        else:\n            count[2 * x] = count.get(2 * x, 0) + 1\n    return all(v == 0 for v in count.values())", "def canReorderDoubled(A):\n    from collections import Counter\n    count = Counter(A)\n    for x in sorted(A, key=abs):\n        if count[x] > 0:\n            if count[2 * x] > 0:\n                count[x] -= 1\n                count[2 * x] -= 1\n            else:\n                return False\n    return True", "def canReorderDoubled(A):\n    from collections import Counter\n    count = Counter(A)\n    for num in sorted(A, key=abs):\n        if count[num] > 0:\n            if count[2 * num] > 0:\n                count[num] -= 1\n                count[2 * num] -= 1\n            else:\n                return False\n    return True", "def canReorderDoubled(A):\n    A.sort()\n    count = 0\n    for num in A:\n        if count == len(A) // 2:\n            return True\n        if num == 0:\n            count += 1\n        elif num > 0 and num * 2 in A:\n            A.remove(num * 2)\n            count += 1\n        elif num < 0 and num // 2 in A:\n            A.remove(num // 2)\n            count += 1\n    return False", "def canReorderDoubled(A):\n    A.sort(key=abs)\n    count = {}\n    for x in A:\n        if x // 2 in count and count[x // 2] > 0:\n            count[x // 2] -= 1\n        else:\n            count[x] = count.get(x, 0) + 1\n    return all(v == 0 for v in count.values())", "def canReorderDoubled(A):\n    count = collections.Counter(A)\n    for x in sorted(A, key=abs):\n        if count[x] == 0:\n            continue\n        count[x] -= 1\n        if count[2 * x] == 0:\n            return False\n        count[2 * x] -= 1\n    return True"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 4212, "entry_point": "findMinStep", "codes": ["def findMinStep(board, hand):\n    from collections import Counter\n    \n    def dfs(board, hand):\n        if not board:\n            return 0\n        if not hand:\n            return float('inf')\n        res = float('inf')\n        for i, c in enumerate(board):\n            if i == 0 or board[i-1] != c:\n                need = 3 - (2 if board[i-1] == c else 0)\n                if hand[c] >= need:\n                    new_hand = hand.copy()\n                    new_hand[c] -= need\n                    new_board = board[:i] + board[i+1:]\n                    res = min(res, dfs(new_board, new_hand))\n        return res\n    \n    hand_count = Counter(hand)\n    res = dfs(board, hand_count)\n    return res if res != float('inf') else -1", "def findMinStep(board, hand):\n    from collections import Counter\n    \n    def dfs(board, hand):\n        if not board:\n            return 0\n        if not hand:\n            return float('inf')\n        \n        res = float('inf')\n        for i in range(len(board) + 1):\n            for color, cnt in hand.items():\n                if cnt == 0:\n                    continue\n                new_hand = hand.copy()\n                new_hand[color] -= 1\n                new_board = board[:i] + color + board[i:]\n                new_board = ''.join(new_board.split(color * 3))\n                res = min(res, 3 - cnt + dfs(new_board, new_hand))\n        return res\n    \n    hand_count = Counter(hand)\n    res = dfs(board, hand_count)\n    return res if res < float('inf') else -1", "from collections import defaultdict, deque\n\ndef findMinStep(board, hand):\n    def remove_triplets(s):\n        stack = []\n        for c in s:\n            if stack and stack[-1][0] == c and stack[-1][1] == 2:\n                stack.pop()\n            else:\n                stack.append((c, stack[-1][1] + 1 if stack and stack[-1][0] == c else 1))\n        return ''.join(c * n for c, n in stack)\n\n    def dfs(board, hand):\n        if not board:\n            return 0\n        if not hand:\n            return float('inf')\n        board = remove_triplets(board)\n        min_steps = float('inf')\n        for i, c in enumerate(board):\n            if c == hand[0]:\n                min_steps = min(min_steps, dfs(board[:i] + board[i+1:], hand[1:]) + (2 - (i > 0 and board[i-1] == c) - (i < len(board) - 1 and board[i+1] == c)))\n        return min_steps\n\n    hand_count = defaultdict(int)\n    for c in hand:\n        hand_count[c] += 1\n    result = dfs(board, ''.join(hand_count[c] * c for c in \"RYBGW\"))\n    return result if result < float('inf') else -1", "from collections import Counter\n\ndef findMinStep(board, hand):\n    def remove_triplets(board):\n        stack = []\n        for ball in board:\n            if not stack or stack[-1][0] != ball:\n                stack.append((ball, 1))\n            else:\n                stack[-1][1] += 1\n        result = []\n        for ball, count in stack:\n            if count < 3:\n                result.append(ball * count)\n        return ''.join(result)\n\n    def dfs(board, hand):\n        if not board:\n            return 0\n        if tuple(hand) in memo:\n            return memo[tuple(hand)]\n        min_steps = float('inf')\n        for i in range(len(board)):\n            for ball, count in hand.items():\n                if i == 0 or board[i - 1] != ball:\n                    if count >= (3 - (i > 0 and board[i - 1] == ball)):\n                        new_hand = hand.copy()\n                        new_hand[ball] -= 3 - (i > 0 and board[i - 1] == ball)\n                        new_board = board[:i] + (ball * (3 - (i > 0 and board[i - 1] == ball))) + board[i:]\n                        new_board = remove_triplets(new_board)\n                        min_steps = min(min_steps, dfs(new_board, new_hand))\n        memo[tuple(hand)] = min_steps if min_steps != float('inf') else -1\n        return min_steps\n\n    memo = {}\n    hand_count = Counter(hand)\n    return dfs(board, hand_count)", "from collections import Counter\n\ndef findMinStep(board, hand):\n    hand_count = Counter(hand)\n    min_steps = float('inf')\n    \n    def dfs(board, hand_count):\n        nonlocal min_steps\n        if not board:\n            return 0\n        \n        for i in range(len(board) + 1):\n            for color in hand_count:\n                if hand_count[color] == 0:\n                    continue\n                hand_count[color] -= 1\n                next_board = board[:i] + color + board[i:]\n                next_hand_count = hand_count.copy()\n                cleaned = False\n                while True:\n                    next_board = next_board.replace(color * 3, \"\")\n                    if next_board == board:\n                        break\n                    board, cleaned = next_board, True\n                if cleaned:\n                    min_steps = min(min_steps, dfs(next_board, next_hand_count))\n                hand_count[color] += 1\n    \n    dfs(board, hand_count)\n    return min_steps if min_steps != float('inf') else -1", "def findMinStep(board, hand):\n    from collections import Counter\n    \n    def removeConsecutive(b):\n        while True:\n            i = 0\n            while i < len(b):\n                j = i + 1\n                while j < len(b) and b[j] == b[i]:\n                    j += 1\n                if j - i >= 3:\n                    b = b[:i] + b[j:]\n                    break\n            else:\n                break\n        return b\n    \n    def dfs(b, h):\n        if not b:\n            return 0\n        if not h:\n            return float('inf')\n        if (b, h) in memo:\n            return memo[(b, h)]\n        \n        ans = float('inf')\n        for i, c in enumerate(b):\n            if h[c] > 0:\n                new_b = removeConsecutive(b[:i] + c + b[i:])\n                new_h = h.copy()\n                new_h[c] -= 1\n                ans = min(ans, dfs(new_b, new_h))\n        \n        memo[(b, h)] = ans\n        return ans\n    \n    memo = {}\n    h = Counter(hand)\n    res = dfs(board, h)\n    return res if res != float('inf') else -1", "from collections import Counter\n\ndef findMinStep(board, hand):\n    def dfs(board, hand):\n        if not board:\n            return 0\n        if not hand:\n            return float('inf')\n        \n        res = float('inf')\n        for i, c in enumerate(board):\n            if i > 0 and board[i] == board[i - 1]:\n                continue\n            need = 3 - (board[i - 1] == board[i] == c) * 2\n            if hand[c] >= need:\n                new_hand = hand.copy()\n                new_hand[c] -= need\n                res = min(res, 1 + dfs(board[:i] + board[i + 1:], new_hand))\n        return res if res != float('inf') else -1\n    \n    hand_count = Counter(hand)\n    return dfs(board, hand_count)", "def findMinStep(board, hand):\n    from collections import Counter\n    \n    def remove_triples(s):\n        i = 0\n        while i < len(s):\n            if i + 2 < len(s) and s[i] == s[i + 1] == s[i + 2]:\n                s = s[:i] + s[i + 3:]\n                i = max(0, i - 1)\n            else:\n                i += 1\n        return s\n    \n    def dfs(board, hand):\n        if not board:\n            return 0\n        if not hand:\n            return float('inf')\n        res = float('inf')\n        count = Counter(hand)\n        for i in range(len(board) + 1):\n            for color in count:\n                if count[color] > (2 - (i > 0 and board[i - 1] == color) - (i < len(board) and board[i] == color)):\n                    continue\n                new_hand = hand[:i] + color + hand[i:]\n                count[color] -= 1\n                new_board = remove_triples(board[:i] + color + board[i:])\n                res = min(res, 3 - count[color] + dfs(new_board, new_hand))\n                count[color] += 1\n        return res\n    \n    res = dfs(board, hand)\n    return res if res < float('inf') else -1"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 4387, "entry_point": "normalize", "codes": ["def normalize(nested_list, growing_value=0):\n    def helper(sub_list, depth, size):\n        if depth == 1:\n            return [item if isinstance(item, list) else [item] * size for item in sub_list] + [growing_value] * (size - len(sub_list))\n        return [[helper(item, depth - 1, size) if isinstance(item, list) else [helper([item], depth - 1, size)] * size for item in sub_list] + [growing_value] * (size - len(sub_list))]\n    \n    def get_max_size(sub_list):\n        max_size = 0\n        for item in sub_list:\n            if isinstance(item, list):\n                max_size = max(max_size, get_max_size(item))\n            else:\n                max_size = max(max_size, 1)\n        return max_size\n    \n    depth = get_max_size(nested_list)\n    size = max(len(nested_list), get_max_size(nested_list))\n    return helper(nested_list, depth, size)", "def normalize(nested_list, growing_value=0):\n    def get_dimension(lst):\n        return 1 + (max(map(get_dimension, lst)) if isinstance(lst, list) else 0)\n\n    def get_size(lst):\n        return max(map(get_size, lst)) if isinstance(lst, list) else 1\n\n    def hypercube(size):\n        if size == 1:\n            return [growing_value]\n        return [[hypercube(size - 1)] * size]\n\n    def pad(lst, target_size):\n        if isinstance(lst, list):\n            return [pad(x, target_size) for x in lst] + ([hypercube(target_size)] * (target_size - len(lst)))\n        return [lst] + ([hypercube(target_size)] * (target_size - 1))\n\n    target_dimension = get_dimension(nested_list)\n    target_size = get_size(nested_list)\n\n    def normalize_recursive(lst, dim):\n        if dim == 1:\n            return pad(lst, target_size)\n        return [normalize_recursive(x, dim - 1) for x in lst] + ([hypercube(target_size)] * (target_size - len(lst)))\n\n    return normalize_recursive(nested_list, target_dimension)", "def normalize(nested_list, growing_value=0):\n    def is_basic_element(x):\n        return not isinstance(x, list)\n\n    def max_dimension(lst):\n        return 1 + max(max_dimension(x) for x in lst if isinstance(x, list)) if lst else 0\n\n    def max_size(lst):\n        return max(len(lst), max(max_size(x) for x in lst if isinstance(x, list))) if lst else 0\n\n    def pad_with_growing_value(lst, size, growing_value):\n        while len(lst) < size:\n            lst.append(growing_value)\n        return lst\n\n    def make_hypercube(lst, dimension, size, growing_value):\n        if is_basic_element(lst):\n            return pad_with_growing_value([lst] * size, size, growing_value)\n        else:\n            new_size = max(max_size(lst), size)\n            new_dimension = max_dimension(lst)\n            return [\n                make_hypercube(x, new_dimension, new_size, growing_value) for x in lst\n            ]\n\n    dimension = max_dimension(nested_list)\n    size = max_size(nested_list)\n    return make_hypercube(nested_list, dimension, size, growing_value)", "def normalize(nested_list, growing_value=0):\n    def is_hypercube(lst):\n        if not lst:\n            return True, 0\n        size = len(lst)\n        is_cube, dim = is_hypercube(lst[0])\n        if not is_cube:\n            return False, 0\n        return all(len(item) == size and is_hypercube(item)[0] for item in lst), dim + 1\n\n    def pad(lst, size, growing_value):\n        if not lst:\n            return [growing_value] * size\n        if isinstance(lst[0], list):\n            return [pad(item, size, growing_value) for item in lst]\n        return lst + [growing_value] * (size - len(lst))\n\n    def expand(lst, growing_value):\n        if isinstance(lst[0], list):\n            return [expand(item, growing_value) for item in lst]\n        return [lst] * 5\n\n    is_cube, dim = is_hypercube(nested_list)\n    size = len(nested_list) if is_cube else len(nested_list[0])\n    padded = pad(nested_list, size, growing_value)\n    if dim > 1:\n        return [expand(item, growing_value) for item in padded]\n    return padded", "def normalize(nested_list, growing_value=0):\n    def get_size(lst):\n        return max(map(get_size, lst), default=0) + 1\n\n    def fill_to_size(lst, size, growing_value):\n        return [fill_to_size(x, size, growing_value) if isinstance(x, list) else growing_value for _ in range(size)]\n\n    max_size = get_size(nested_list)\n    return fill_to_size(nested_list, max_size, growing_value)", "def normalize(nested_list, growing_value=0):\n    def hypercube(size, dim):\n        return [[hypercube(size, dim - 1)] * size for _ in range(size)] if dim > 1 else [growing_value] * size\n\n    def get_max_size(nested_list):\n        return max(get_max_size(item) if isinstance(item, list) else 0 for item in nested_list) + 1\n\n    def fill_hypercube(nested_list, size, dim):\n        if dim == 1:\n            return nested_list + [growing_value] * (size - len(nested_list))\n        return [fill_hypercube(item, size, dim - 1) if isinstance(item, list) else hypercube(size, dim - 1) for item in nested_list]\n\n    max_size = get_max_size(nested_list)\n    return fill_hypercube(nested_list, max_size, get_max_size(nested_list))"], "rewards": [1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 4460, "entry_point": "getMaxLen", "codes": ["def getMaxLen(nums):\n    pos, neg, res = 0, 0, 0\n    for num in nums:\n        if num == 0:\n            pos, neg = 0, 0\n        elif num > 0:\n            pos, neg = pos + 1, (neg + 1) if neg > 0 else 0\n        else:\n            pos, neg = (neg + 1) if neg > 0 else 0, pos + 1\n        res = max(res, pos)\n    return res", "def getMaxLen(nums):\n    pos, neg = 0, 0\n    max_len = 0\n    for num in nums:\n        if num == 0:\n            pos, neg = 0, 0\n        elif num > 0:\n            pos, neg = pos + 1, neg + 1 if neg > 0 else 0\n        else:\n            pos, neg = neg + 1 if neg > 0 else 0, pos + 1\n        max_len = max(max_len, pos)\n    return max_len", "def getMaxLen(nums):\n    max_len = 0\n    current_positive = 0\n    current_negative = 0\n    \n    for num in nums:\n        if num > 0:\n            current_positive += 1\n            current_negative = current_negative + 1 if current_negative > 0 else 0\n        elif num < 0:\n            current_positive, current_negative = current_negative + 1 if current_negative > 0 else 1, current_positive + 1\n        else:\n            current_positive = 0\n            current_negative = 0\n        max_len = max(max_len, current_positive)\n    \n    return max_len", "def getMaxLen(nums):\n    max_len = 0\n    pos_len = 0\n    neg_len = 0\n    \n    for num in nums:\n        if num == 0:\n            pos_len, neg_len = 0, 0\n        elif num > 0:\n            pos_len += 1\n            neg_len += 1 if neg_len > 0 else 0\n        else:\n            pos_len, neg_len = neg_len + 1 if neg_len > 0 else 0, pos_len + 1\n    \n    return max_len", "def getMaxLen(nums):\n    max_len = 0\n    last_zero = -1\n    last_neg = -1\n    pos_len = 0\n    neg_len = 0\n    \n    for i, num in enumerate(nums):\n        if num == 0:\n            last_zero = i\n            pos_len = 0\n            neg_len = 0\n        elif num > 0:\n            pos_len += 1\n            neg_len = neg_len + 1 if neg_len != 0 else 0\n        else:\n            pos_len, neg_len = neg_len + 1 if neg_len != 0 else 0, pos_len + 1\n            if last_neg != -1:\n                max_len = max(max_len, i - last_neg)\n            else:\n                max_len = max(max_len, i - last_zero)\n        last_neg = i if num < 0 else last_neg\n    \n    if neg_len != 0:\n        max_len = max(max_len, len(nums) - 1 - last_neg)\n    \n    return max_len", "def getMaxLen(nums):\n    max_len = 0\n    current_positive = 0\n    current_negative = 0\n    \n    for num in nums:\n        if num == 0:\n            current_positive = 0\n            current_negative = 0\n        elif num > 0:\n            current_positive += 1\n            current_negative = current_negative + 1 if current_negative > 0 else 0\n        else:\n            current_positive, current_negative = current_negative + 1 if current_negative > 0 else 0, current_positive + 1\n    \n    return max_len"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0]}
{"id": 4491, "entry_point": "maxScoreWords", "codes": ["def maxScoreWords(words, letters, score):\n    from collections import Counter\n    letter_count = Counter(letters)\n    score_dict = {chr(i + ord('a')): score[i] for i in range(26)}\n    \n    def can_use_word(word_count):\n        return all(letter_count[letter] >= word_count[letter] for letter in word_count)\n    \n    def dfs(start, current_score, current_count):\n        if start == len(words):\n            return current_score\n        max_score = dfs(start + 1, current_score, current_count)\n        word_count = Counter(words[start])\n        if can_use_word(word_count):\n            new_count = current_count + word_count\n            if all(new_count[letter] <= letter_count[letter] for letter in new_count):\n                max_score = max(max_score, dfs(start + 1, current_score + sum(score_dict[letter] * word_count[letter] for letter in word_count), new_count))\n        return max_score\n    \n    return dfs(0, 0, Counter())", "def maxScoreWords(words, letters, score):\n    def score_word(word):\n        return sum(score[ord(c) - ord('a')] for c in word)\n    \n    def can_form(word, letter_count):\n        return all(letter_count[ord(c) - ord('a')] >= word.count(c) for c in word)\n    \n    def dfs(index, current_score, letter_count):\n        if index == len(words):\n            return current_score\n        \n        max_score = dfs(index + 1, current_score, letter_count)\n        if can_form(words[index], letter_count):\n            new_letter_count = letter_count[:]\n            for c in words[index]:\n                new_letter_count[ord(c) - ord('a')] -= 1\n            max_score = max(max_score, dfs(index + 1, current_score + score_word(words[index]), new_letter_count))\n        return max_score\n    \n    from collections import Counter\n    letter_count = Counter(letters)\n    return dfs(0, 0, letter_count)", "from collections import Counter\n\ndef maxScoreWords(words, letters, score):\n    def can_form(word, letter_count):\n        return all(letter_count[char] >= word[char] for char in word)\n\n    def get_word_score(word):\n        return sum(score[ord(char) - ord('a')] for char in word)\n\n    letter_count = Counter(letters)\n    max_score = 0\n\n    def backtrack(start, current_score, used_letters):\n        nonlocal max_score\n        if start == len(words):\n            max_score = max(max_score, current_score)\n            return\n\n        # Include the current word\n        word = Counter(words[start])\n        if can_form(word, used_letters):\n            new_score = current_score + get_word_score(words[start])\n            new_used_letters = used_letters + word\n            backtrack(start + 1, new_score, new_used_letters)\n\n        # Exclude the current word\n        backtrack(start + 1, current_score, used_letters)\n\n    backtrack(0, 0, Counter())\n    return max_score", "def maxScoreWords(words, letters, score, index=0, used_count=None):\n    if used_count is None:\n        used_count = [0] * 26\n    \n    if index == len(words):\n        return 0\n    \n    word = words[index]\n    word_score = sum(score[ord(char) - ord('a')] for char in word)\n    can_use = True\n    \n    for char in word:\n        if used_count[ord(char) - ord('a')] + word.count(char) > letters.count(char):\n            can_use = False\n            break\n    \n    include = 0\n    exclude = 0\n    \n    if can_use:\n        for char in word:\n            used_count[ord(char) - ord('a')] += word.count(char)\n        include = word_score + maxScoreWords(words, letters, score, index + 1, used_count)\n        for char in word:\n            used_count[ord(char) - ord('a')] -= word.count(char)\n    \n    exclude = maxScoreWords(words, letters, score, index + 1, used_count)\n    \n    return max(include, exclude)", "from collections import Counter\n\ndef maxScoreWords(words, letters, score):\n    letter_count = Counter(letters)\n    word_scores = [sum(score[ord(c) - ord('a')] for c in word) for word in words]\n    \n    def backtrack(index, current_score, current_count):\n        if index == len(words):\n            return current_score\n        max_score = current_score\n        if all(current_count[char] + word_count[char] <= letter_count[char] for char, word_count in Counter(words[index]).items()):\n            current_count += Counter(words[index])\n            max_score = max(max_score, backtrack(index + 1, current_score + word_scores[index], current_count))\n            current_count -= Counter(words[index])\n        max_score = max(max_score, backtrack(index + 1, current_score, current_count))\n        return max_score\n    \n    return backtrack(0, 0, Counter())", "def maxScoreWords(words, letters, score):\n    letter_count = [letters.count(chr(97 + i)) for i in range(26)]\n    word_scores = [sum(score[ord(w) - ord('a')] for w in word) for word in words]\n\n    def dfs(index, current_score, current_letter_count):\n        if index == len(words):\n            return current_score\n        max_score = current_score\n        for i in range(1, len(words[index]) + 1):\n            if all(current_letter_count[ord(words[index][j]) - ord('a')] + 1 <= letter_count[ord(words[index][j]) - ord('a')] for j in range(i)):\n                for j in range(i):\n                    current_letter_count[ord(words[index][j]) - ord('a')] += 1\n                max_score = max(max_score, dfs(index + 1, current_score + word_scores[index], current_letter_count))\n                for j in range(i):\n                    current_letter_count[ord(words[index][j]) - ord('a')] -= 1\n        max_score = max(max_score, dfs(index + 1, current_score, current_letter_count))\n        return max_score\n\n    return dfs(0, 0, [0] * 26)", "def maxScoreWords(words, letters, score):\n    from collections import Counter\n    \n    letter_count = Counter(letters)\n    word_scores = [sum(score[ord(w) - ord('a')] for w in word) for word in words]\n    \n    def dfs(index, current_score, remaining_letters):\n        if index == len(words):\n            return current_score\n        max_score = dfs(index + 1, current_score, remaining_letters)\n        word = words[index]\n        word_count = Counter(word)\n        if all(remaining_letters[char] >= word_count[char] for char in word_count):\n            new_letters = remaining_letters - word_count\n            max_score = max(max_score, dfs(index + 1, current_score + word_scores[index], new_letters))\n        return max_score\n    \n    return dfs(0, 0, letter_count)", "def maxScoreWords(words, letters, score):\n    n = len(words)\n    letter_count = [0] * 26\n    for letter in letters:\n        letter_count[ord(letter) - ord('a')] += 1\n    \n    def can_form(word, letter_count):\n        for letter in word:\n            if letter_count[ord(letter) - ord('a')] == 0:\n                return False\n            letter_count[ord(letter) - ord('a')] -= 1\n        return True\n    \n    def restore_letter_count(word, letter_count):\n        for letter in word:\n            letter_count[ord(letter) - ord('a')] += 1\n    \n    def backtrack(index, current_score, letter_count):\n        if index == n:\n            return current_score\n        \n        max_score = backtrack(index + 1, current_score, letter_count)\n        if can_form(words[index], letter_count):\n            current_score += sum(score[ord(letter) - ord('a')] for letter in words[index])\n            letter_count = restore_letter_count(words[index], letter_count)\n            max_score = max(max_score, backtrack(index + 1, current_score, letter_count))\n        \n        return max_score\n    \n    return backtrack(0, 0, letter_count)"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
{"id": 4795, "entry_point": "maxProbability", "codes": ["import heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = [[] for _ in range(n)]\n    for (a, b), p in zip(edges, succProb):\n        graph[a].append((b, p))\n        graph[b].append((a, p))\n    \n    max_prob = [0.0] * n\n    max_prob[start] = 1.0\n    heap = [(-1.0, start)]\n    \n    while heap:\n        current_prob, current_node = heapq.heappop(heap)\n        current_prob = -current_prob\n        \n        if current_node == end:\n            return current_prob\n        \n        for neighbor, prob in graph[current_node]:\n            if current_prob * prob > max_prob[neighbor]:\n                max_prob[neighbor] = current_prob * prob\n                heapq.heappush(heap, (-current_prob * prob, neighbor))\n    \n    return 0.0", "from heapq import heappop, heappush\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = [[] for _ in range(n)]\n    for (a, b), p in zip(edges, succProb):\n        graph[a].append((b, p))\n        graph[b].append((a, p))\n    \n    pq = [(-1, start)]\n    visited = set()\n    \n    while pq:\n        prob, node = heappop(pq)\n        prob = -prob\n        if node == end:\n            return prob\n        if node in visited:\n            continue\n        visited.add(node)\n        for neighbor, edge_prob in graph[node]:\n            if neighbor not in visited:\n                heappush(pq, (-(prob * edge_prob), neighbor))\n    \n    return 0", "def maxProbability(n, edges, succProb, start, end):\n    import heapq\n\n    graph = {i: {} for i in range(n)}\n    for (a, b), p in zip(edges, succProb):\n        graph[a][b] = p\n        graph[b][a] = p\n\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n\n    while pq:\n        prob, node = heapq.heappop(pq)\n        prob = -prob\n        if node == end:\n            return prob\n        for neighbor, edge_prob in graph[node].items():\n            new_prob = prob * edge_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n\n    return 0", "from collections import defaultdict\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for i, (a, b) in enumerate(edges):\n        graph[a].append((b, succProb[i]))\n        graph[b].append((a, succProb[i]))\n    \n    pq = [(-1, start)]\n    visited = set()\n    \n    while pq:\n        prob, node = heapq.heappop(pq)\n        prob = -prob\n        \n        if node == end:\n            return prob\n        \n        if node in visited:\n            continue\n        \n        visited.add(node)\n        \n        for neighbor, edge_prob in graph[node]:\n            if neighbor not in visited:\n                heapq.heappush(pq, (-prob * edge_prob, neighbor))\n    \n    return 0"], "rewards": [1.0, 1.0, 1.0, -1.0]}
{"id": 4961, "entry_point": "minDeletionSize", "codes": ["def minDeletionSize(A):\n    n, m = len(A), len(A[0])\n    dp = [1] * m\n    for j in range(m):\n        for i in range(j):\n            if all(A[k][i] <= A[k][j] for k in range(n)):\n                dp[j] = max(dp[j], dp[i] + 1)\n    return m - max(dp)", "def minDeletionSize(A):\n    m, n = len(A), len(A[0])\n    dp = [1] * n\n    for j in range(1, n):\n        for i in range(j):\n            if all(A[k][i] <= A[k][j] for k in range(m)):\n                dp[j] = max(dp[j], dp[i] + 1)\n    return n - max(dp)", "def minDeletionSize(A):\n    n = len(A)\n    m = len(A[0])\n    dp = [1] * m\n    for j in range(1, m):\n        for i in range(j):\n            if all(A[k][i] <= A[k][j] for k in range(n)):\n                dp[j] = max(dp[j], dp[i] + 1)\n    return m - max(dp)\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "def minDeletionSize(A):\n    n = len(A)\n    m = len(A[0])\n    dp = list(range(m))\n    for i in range(1, n):\n        new_dp = list(dp)\n        j = m - 2\n        while j >= 0:\n            if all(A[i][j] <= A[k][j] for k in range(n)):\n                new_dp[j] = min(new_dp[j], dp[k])\n            j -= 1\n        dp = new_dp\n    return m - max(dp)", "def minDeletionSize(A):\n    n, m = len(A), len(A[0])\n    dp = list(range(m))\n    for j in range(1, m):\n        ndp = list(range(m))\n        for i in range(n):\n            if all(A[i][dp[k]] <= A[i][j] for k in range(j)):\n                ndp[j] = min(ndp[j], dp[k])\n        dp = ndp\n    return m - min(dp)", "def minDeletionSize(A):\n    n = len(A)\n    m = len(A[0])\n    \n    @lru_cache(None)\n    def dp(i, prev):\n        if i == m:\n            return 0\n        delete = dp(i + 1, prev) + 1\n        keep = float('inf')\n        if all(A[j][i] >= A[j][prev] for j in range(n)):\n            keep = dp(i + 1, i)\n        return min(delete, keep)\n    \n    return dp(0, 0)", "def minDeletionSize(A):\n    n, m = len(A), len(A[0])\n    dp = [0] * m\n    for j in range(1, m):\n        dp[j] = dp[j - 1] + 1\n        for i in range(n):\n            if all(A[i][k] <= A[i][j] for k in range(j)):\n                dp[j] = max(dp[j], dp[i] + 1)\n    return m - max(dp)", "def minDeletionSize(A):\n    n = len(A)\n    m = len(A[0])\n    dp = [i for i in range(m)]\n    for i in range(1, m):\n        prev_dp = dp[:]\n        for j in range(i):\n            if all(A[k][j] <= A[k][i] for k in range(n)):\n                dp[i] = min(dp[i], prev_dp[j])\n        dp[i] += 1\n    return dp[-1]"], "rewards": [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0]}
