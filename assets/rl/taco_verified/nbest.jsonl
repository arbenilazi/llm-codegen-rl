{"id": 30, "entry_point": "findPoisonedDuration", "best_list": [{"code": "def findPoisonedDuration(timeSeries, duration):\n    if not timeSeries:\n        return 0\n    return sum(min(timeSeries[i] - timeSeries[i-1], duration) for i in range(1, len(timeSeries))) + duration", "passed": true, "score": {"loc": 4, "tokens": 48, "cc": 1, "nest": 2, "execution_time": 0.016791, "novelty": 0.5404015183997412}}, {"code": "def findPoisonedDuration(timeSeries, duration):\n    total_time = 0\n    for i in range(len(timeSeries) - 1):\n        total_time += min(duration, timeSeries[i + 1] - timeSeries[i])\n    return total_time + duration if timeSeries else 0", "passed": true, "score": {"loc": 5, "tokens": 51, "cc": 1, "nest": 2, "execution_time": 0.016623, "novelty": 0.46188152964663165}}, {"code": "def findPoisonedDuration(timeSeries, duration):\n    n = len(timeSeries)\n    if n == 0:\n        return 0\n    return sum(min(duration, timeSeries[i] - timeSeries[i-1]) for i in range(1, n)) + duration", "passed": true, "score": {"loc": 5, "tokens": 53, "cc": 1, "nest": 2, "execution_time": 0.016565, "novelty": 0.6432037743696425}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 38, "entry_point": "minFlipsMonoIncr", "best_list": [{"code": "def minFlipsMonoIncr(S):\n    flip_to_one, flip_to_zero = 0, 0\n    for bit in S:\n        if bit == '0':\n            flip_to_one += 1\n        else:\n            flip_to_one = min(flip_to_one, flip_to_zero)\n            flip_to_zero += 1\n    return min(flip_to_one, flip_to_zero)", "passed": true, "score": {"loc": 9, "tokens": 51, "cc": 2, "nest": 3, "execution_time": 0.016579, "novelty": 0.4858399476881995}}, {"code": "def minFlipsMonoIncr(S):\n    ones = 0\n    flips = 0\n    for char in S:\n        if char == '1':\n            ones += 1\n        else:\n            flips += 1\n            flips = min(flips, ones)\n    return flips", "passed": true, "score": {"loc": 10, "tokens": 45, "cc": 2, "nest": 3, "execution_time": 0.016465, "novelty": 0.4643151484785967}}, {"code": "def minFlipsMonoIncr(S):\n    flips_ending_with_0 = flips_ending_with_1 = 0\n    for char in S:\n        if char == '0':\n            flips_ending_with_0 = min(flips_ending_with_0, flips_ending_with_1) + 1\n            flips_ending_with_1 += 1\n        else:\n            flips_ending_with_1 = min(flips_ending_with_0, flips_ending_with_1)\n    return min(flips_ending_with_0, flips_ending_with_1)", "passed": false, "score": {"loc": 9, "tokens": 55, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5708095237017595}}, {"code": "def minFlipsMonoIncr(S):\n    flip_to_1 = 0\n    ones_count = 0\n    for char in S:\n        if char == '0':\n            flip_to_1 = min(flip_to_1, ones_count)\n        else:\n            ones_count += 1\n    return min(flip_to_1, ones_count)", "passed": false, "score": {"loc": 9, "tokens": 46, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.453337043340594}}, {"code": "def minFlipsMonoIncr(S: str) -> int:\n    flips = zeros = ones = 0\n    for bit in S:\n        if bit == '0':\n            flips = min(flips, zeros)\n            zeros += 1\n        else:\n            ones += 1\n    return min(flips, zeros, ones)", "passed": false, "score": {"loc": 9, "tokens": 58, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.4700930056881707}}, {"code": "def minFlipsMonoIncr(S):\n    flip_to_0, flip_to_1 = 0, 0\n    for bit in S:\n        flip_to_0, flip_to_1 = min(flip_to_0, flip_to_1) + (bit == '1'), min(flip_to_0, flip_to_1) + (bit == '0')\n    return min(flip_to_0, flip_to_1)", "passed": false, "score": {"loc": 5, "tokens": 60, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.6851554810231298}}, {"code": "def minFlipsMonoIncr(S):\n    zero_count = S.count('0')\n    one_count = 0\n    min_flips = zero_count\n\n    for char in S:\n        if char == '0':\n            zero_count -= 1\n        else:\n            one_count += 1\n            min_flips = min(min_flips, zero_count + one_count)\n\n    return min_flips", "passed": false, "score": {"loc": 11, "tokens": 57, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5583304637939863}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 8}
{"id": 5127, "entry_point": "largestValsFromLabels", "best_list": [{"code": "def largestValsFromLabels(values, labels, num_wanted, use_limit):\n    items = sorted(zip(values, labels), reverse=True)\n    count = {}\n    result = 0\n    for value, label in items:\n        if count.get(label, 0) < use_limit:\n            count[label] = count.get(label, 0) + 1\n            result += value\n            num_wanted -= 1\n            if num_wanted == 0:\n                break\n    return result", "passed": true, "score": {"loc": 12, "tokens": 85, "cc": 3, "nest": 4, "execution_time": 0.016571, "novelty": 0.22110646727762173}}, {"code": "def largestValsFromLabels(values, labels, num_wanted, use_limit):\n    label_count = {}\n    total_sum = 0\n    items = sorted(zip(values, labels), reverse=True)\n    \n    for value, label in items:\n        if label_count.get(label, 0) < use_limit:\n            total_sum += value\n            label_count[label] = label_count.get(label, 0) + 1\n            num_wanted -= 1\n            if num_wanted == 0:\n                break\n    \n    return total_sum", "passed": true, "score": {"loc": 12, "tokens": 85, "cc": 3, "nest": 4, "execution_time": 0.016642, "novelty": 0.21859121927231195}}, {"code": "def largestValsFromLabels(values, labels, num_wanted, use_limit):\n    items = sorted(zip(values, labels), reverse=True)\n    label_count = {}\n    result = 0\n    count = 0\n    \n    for value, label in items:\n        if count >= num_wanted:\n            break\n        if label_count.get(label, 0) < use_limit:\n            result += value\n            label_count[label] = label_count.get(label, 0) + 1\n            count += 1\n    \n    return result", "passed": true, "score": {"loc": 13, "tokens": 88, "cc": 3, "nest": 3, "execution_time": 0.016568, "novelty": 0.2779286130874905}}, {"code": "import heapq\n\ndef largestValsFromLabels(values, labels, num_wanted, use_limit):\n    labeled_values = list(zip(values, labels))\n    heap = [-v for v, _ in labeled_values]  # Use negative values to simulate max-heap with heapq\n    heapq.heapify(heap)\n    \n    count = 0\n    result = 0\n    label_count = {}\n    \n    while heap and count < num_wanted:\n        value, label = -heapq.heappop(heap)\n        if label_count.get(label, 0) < use_limit:\n            result += value\n            count += 1\n            label_count[label] = label_count.get(label, 0) + 1\n    \n    return result", "passed": false, "score": {"loc": 15, "tokens": 119, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6753433970386289}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 5142, "entry_point": "removeKdigits", "best_list": [{"code": "def removeKdigits(num, k):\n    stack = []\n    for digit in num:\n        while k and stack and stack[-1] > digit:\n            stack.pop()\n            k -= 1\n        stack.append(digit)\n    result = ''.join(stack).lstrip('0')\n    return result if result else '0'", "passed": true, "score": {"loc": 9, "tokens": 69, "cc": 3, "nest": 3, "execution_time": 0.016693, "novelty": 0.1422468423260249}}, {"code": "def removeKdigits(num: str, k: int) -> str:\n    stack = []\n    for digit in num:\n        while k and stack and stack[-1] > digit:\n            stack.pop()\n            k -= 1\n        stack.append(digit)\n    result = ''.join(stack).lstrip('0')\n    return result if result else '0'", "passed": true, "score": {"loc": 9, "tokens": 76, "cc": 3, "nest": 3, "execution_time": 0.016759, "novelty": 0.12327522253142953}}, {"code": "def removeKdigits(num: str, k: int) -> str:\n    stack = []\n    for digit in num:\n        while k and stack and stack[-1] > digit:\n            stack.pop()\n            k -= 1\n        stack.append(digit)\n    result = ''.join(stack[:len(num) - k]).lstrip('0')\n    return result if result else '0'", "passed": true, "score": {"loc": 9, "tokens": 85, "cc": 3, "nest": 3, "execution_time": 0.016646, "novelty": 0.16663081019229586}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 5148, "entry_point": "reverseOnlyLetters", "best_list": [{"code": "def reverseOnlyLetters(S):\n    letters = [c for c in S if c.isalpha()]\n    return ''.join(letters.pop() if c.isalpha() else c for c in S)", "passed": true, "score": {"loc": 3, "tokens": 45, "cc": 0, "nest": 1, "execution_time": 0.016624, "novelty": 0.3470864401615663}}, {"code": "def reverseOnlyLetters(S):\n    letters = [c for c in S if c.isalpha()]\n    return ''.join(c if not c.isalpha() else letters.pop() for c in S)", "passed": true, "score": {"loc": 3, "tokens": 46, "cc": 0, "nest": 1, "execution_time": 0.016744, "novelty": 0.3986189185579211}}, {"code": "def reverseOnlyLetters(S):\n    letters = [c for c in S if c.isalpha()]\n    return ''.join([letters.pop() if c.isalpha() else c for c in S])", "passed": true, "score": {"loc": 3, "tokens": 47, "cc": 0, "nest": 1, "execution_time": 0.016664, "novelty": 0.350805470878912}}, {"code": "def reverseOnlyLetters(S: str) -> str:\n    letters = [c for c in S if c.isalpha()][::-1]\n    return ''.join(next(letters) if c.isalpha() else c for c in S)", "passed": false, "score": {"loc": 3, "tokens": 55, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5025964573237762}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 5215, "entry_point": "lastSubstring", "best_list": [{"code": "def lastSubstring(s):\n    return max(s[i:] for i in range(len(s)))", "passed": true, "score": {"loc": 2, "tokens": 25, "cc": 0, "nest": 1, "execution_time": 0.016371, "novelty": 0.2997701101944523}}, {"code": "def lastSubstring(s: str) -> str:\n    return max(s[i:] for i in range(len(s)))", "passed": true, "score": {"loc": 2, "tokens": 30, "cc": 0, "nest": 1, "execution_time": 0.016656, "novelty": 0.2993117081450286}}, {"code": "def lastSubstring(s):\n    max_char = max(s)\n    max_suffixes = [i for i, char in enumerate(s) if char == max_char]\n    return max(s[i:] for i in max_suffixes)", "passed": true, "score": {"loc": 4, "tokens": 44, "cc": 0, "nest": 1, "execution_time": 0.016752, "novelty": 0.7294250539974583}}, {"code": "def lastSubstring(s):\n    max_char = max(s)\n    return max(s.split(max_char))", "passed": false, "score": {"loc": 3, "tokens": 22, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.640968820345476}}], "num_pass": 9, "num_uniq": 5, "num_fail": 1, "fail_uniq": 1}
{"id": 5225, "entry_point": "numSubarraysWithSum", "best_list": [{"code": "def numSubarraysWithSum(A, S):\n    count, current_sum, seen_sums = 0, 0, {0: 1}\n    for num in A:\n        current_sum += num\n        if current_sum - S in seen_sums:\n            count += seen_sums[current_sum - S]\n        seen_sums[current_sum] = seen_sums.get(current_sum, 0) + 1\n    return count", "passed": true, "score": {"loc": 8, "tokens": 65, "cc": 2, "nest": 3, "execution_time": 0.016778, "novelty": 0.34850836059980383}}, {"code": "def numSubarraysWithSum(A, S):\n    count, curr_sum, result = 0, 0, 0\n    prefix_sum = {0: 1}\n    \n    for num in A:\n        curr_sum += num\n        if curr_sum - S in prefix_sum:\n            result += prefix_sum[curr_sum - S]\n        prefix_sum[curr_sum] = prefix_sum.get(curr_sum, 0) + 1\n    \n    return result", "passed": true, "score": {"loc": 9, "tokens": 68, "cc": 2, "nest": 3, "execution_time": 0.016547, "novelty": 0.4719463139458545}}, {"code": "def numSubarraysWithSum(A, S):\n    count = 0\n    current_sum = 0\n    prefix_sum_count = {0: 1}\n    \n    for num in A:\n        current_sum += num\n        if current_sum - S in prefix_sum_count:\n            count += prefix_sum_count[current_sum - S]\n        prefix_sum_count[current_sum] = prefix_sum_count.get(current_sum, 0) + 1\n    \n    return count", "passed": true, "score": {"loc": 10, "tokens": 63, "cc": 2, "nest": 3, "execution_time": 0.016697, "novelty": 0.3789387864541385}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 5255, "entry_point": "racecar", "best_list": [{"code": "def racecar(target):\n    q = [(0, 1, 0)]\n    visited = set((0, 1))\n    while q:\n        pos, speed, moves = q.pop(0)\n        if pos == target:\n            return moves\n        # Accelerate\n        new_pos, new_speed = pos + speed, speed * 2\n        if (new_pos, new_speed) not in visited and new_pos >= 0:\n            visited.add((new_pos, new_speed))\n            q.append((new_pos, new_speed, moves + 1))\n        # Reverse\n        new_speed = -1 if speed > 0 else 1\n        if (pos, new_speed) not in visited and pos >= 0:\n            visited.add((pos, new_speed))\n            q.append((pos, new_speed, moves + 1))", "passed": true, "score": {"loc": 17, "tokens": 153, "cc": 6, "nest": 3, "execution_time": 0.016574, "novelty": 0.506620786363918}}, {"code": "from heapq import heappush, heappop\n\ndef racecar(target):\n    pq = [(0, 0, 1)]\n    visited = set()\n    \n    while pq:\n        moves, pos, speed = heappop(pq)\n        \n        if pos == target:\n            return moves\n        \n        if (pos, speed) in visited:\n            continue\n        visited.add((pos, speed))\n        \n        # Accelerate\n        heappush(pq, (moves + 1, pos + speed, speed * 2))\n        \n        # Reverse\n        if speed > 0:\n            heappush(pq, (moves + 1, pos, -1))\n        else:\n            heappush(pq, (moves + 1, pos, 1))", "passed": true, "score": {"loc": 18, "tokens": 127, "cc": 4, "nest": 3, "execution_time": 0.016658, "novelty": 0.6323760494378331}}, {"code": "def racecar(target):\n    queue = [(0, 1, 0)]\n    visited = set((0, 1))\n    \n    while queue:\n        pos, speed, moves = queue.pop(0)\n        \n        if pos == target:\n            return moves\n        \n        # Accelerate\n        new_pos = pos + speed\n        new_speed = speed * 2\n        if (new_pos, new_speed) not in visited and new_pos > 0 and new_pos <= target * 2:\n            queue.append((new_pos, new_speed, moves + 1))\n            visited.add((new_pos, new_speed))\n        \n        # Reverse\n        new_speed = -1 if speed > 0 else 1\n        if (pos, new_speed) not in visited and new_speed != 0:\n            queue.append((pos, new_speed, moves + 1))\n            visited.add((pos, new_speed))", "passed": true, "score": {"loc": 18, "tokens": 158, "cc": 6, "nest": 3, "execution_time": 0.016741, "novelty": 0.5597334942033616}}, {"code": "def racecar(target):\n    def min_steps(pos, speed, memo):\n        if pos == target:\n            return 0\n        if (pos, speed) in memo:\n            return memo[(pos, speed)]\n        # Accelerate\n        memo[pos, speed] = min_steps(pos + speed, speed * 2, memo) + 1\n        # Reverse\n        if pos + speed > 0:\n            reverse_steps = min_steps(pos, -1, memo) + 1\n            memo[pos, speed] = min(memo[pos, speed], reverse_steps)\n        return memo[pos, speed]\n    \n    memo = {}\n    return min_steps(0, 1, memo)", "passed": false, "score": {"loc": 15, "tokens": 125, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.8307675082065484}}, {"code": "def racecar(target):\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for i in range(1, target + 1):\n        k = 1\n        while (1 << k) - 1 < i:\n            dp[i] = min(dp[i], dp[(1 << k) - 1 - i] + k + 1)\n            if (1 << k) - 1 - i < i:\n                dp[i] = min(dp[i], dp[i - ((1 << k) - 1 - i)] + k + 2)\n            k += 1\n\n        if (1 << k) - 1 == i:\n            dp[i] = k\n\n    return dp[target]", "passed": false, "score": {"loc": 13, "tokens": 161, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.8354919451314343}}, {"code": "def racecar(target):\n    dp = [0] * (target + 1)\n    for t in range(1, target + 1):\n        k = t.bit_length() - 1\n        if 2**k - 1 == t:\n            dp[t] = k\n        else:\n            dp[t] = dp[2**k - 1 - t] + k + 1 + (k > 1 and dp[t - 2**(k - 1)])\n    return dp[target]", "passed": false, "score": {"loc": 9, "tokens": 102, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.8046941014845557}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 5308, "entry_point": "removeDuplicates", "best_list": [{"code": "def removeDuplicates(s: str, k: int) -> str:\n    stack = []\n    for char in s:\n        if stack and stack[-1][0] == char:\n            stack[-1][1] += 1\n            if stack[-1][1] == k:\n                stack.pop()\n        else:\n            stack.append([char, 1])\n    return ''.join(char * count for char, count in stack)", "passed": true, "score": {"loc": 10, "tokens": 96, "cc": 4, "nest": 4, "execution_time": 0.016621, "novelty": 0.02151528866330188}}, {"code": "def removeDuplicates(s: str, k: int) -> str:\n    stack = []\n    for char in s:\n        if stack and stack[-1][0] == char:\n            stack[-1][1] += 1\n            if stack[-1][1] == k:\n                stack.pop()\n        else:\n            stack.append([char, 1])\n    return ''.join(char * count for char, count in stack)\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "passed": true, "score": {"loc": 12, "tokens": 109, "cc": 4, "nest": 4, "execution_time": 0.016606, "novelty": 0.08367334294450779}}, {"code": "def removeDuplicates(s, k):\n    while True:\n        stack = []\n        for char in s:\n            if stack and stack[-1][0] == char:\n                stack[-1][1] += 1\n                if stack[-1][1] == k:\n                    stack.pop()\n            else:\n                stack.append([char, 1])\n        s = ''.join(char * count for char, count in stack)\n        if len(s) == len(s):\n            break\n    return s", "passed": true, "score": {"loc": 14, "tokens": 108, "cc": 6, "nest": 5, "execution_time": 0.01666, "novelty": 0.1355771327761015}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 5316, "entry_point": "isPrefixOfWord", "best_list": [{"code": "def isPrefixOfWord(sentence, searchWord):\n    return next((i + 1 for i, word in enumerate(sentence.split()) if word.startswith(searchWord)), -1)", "passed": true, "score": {"loc": 2, "tokens": 40, "cc": 0, "nest": 1, "execution_time": 0.016599, "novelty": 0.5801472295201484}}, {"code": "def isPrefixOfWord(sentence: str, searchWord: str) -> int:\n    return next((i + 1 for i, word in enumerate(sentence.split()) if word.startswith(searchWord)), -1)", "passed": true, "score": {"loc": 2, "tokens": 47, "cc": 0, "nest": 1, "execution_time": 0.016603, "novelty": 0.5519077193487789}}, {"code": "def isPrefixOfWord(sentence, searchWord):\n    for i, word in enumerate(sentence.split()):\n        if word.startswith(searchWord):\n            return i + 1\n    return -1", "passed": true, "score": {"loc": 5, "tokens": 37, "cc": 2, "nest": 3, "execution_time": 0.016488, "novelty": 0.25154644482062305}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 5431, "entry_point": "countDigitOne", "best_list": [{"code": "def countDigitOne(n):\n    count = 0\n    for i in range(1, n + 1):\n        count += str(i).count('1')\n    return count", "passed": true, "score": {"loc": 5, "tokens": 37, "cc": 1, "nest": 2, "execution_time": 0.016701, "novelty": 0.674611515281179}}, {"code": "def countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        low = n % i\n        digit = (n // i) % 10\n        high = n // (i * 10)\n        if digit == 0:\n            count += high * i\n        elif digit == 1:\n            count += high * i + low + 1\n        else:\n            count += (high + 1) * i\n        i *= 10\n    return count", "passed": true, "score": {"loc": 15, "tokens": 89, "cc": 3, "nest": 4, "execution_time": 0.016632, "novelty": 0.4937887971721371}}, {"code": "def countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        lowerNumbers = n - (n // i) * i\n        currentDigit = (n // i) % 10\n        higherNumbers = n // (i * 10)\n        if currentDigit < 1:\n            count += higherNumbers * i\n        elif currentDigit == 1:\n            count += higherNumbers * i + lowerNumbers + 1\n        else:\n            count += (higherNumbers + 1) * i\n        i *= 10\n    return count", "passed": true, "score": {"loc": 15, "tokens": 95, "cc": 3, "nest": 4, "execution_time": 0.016605, "novelty": 0.5349779627207989}}, {"code": "def countDigitOne(n: int) -> int:\n    if n <= 0:\n        return 0\n    \n    def helper(num: int) -> int:\n        if num == 0:\n            return 0\n        digit = num % 10\n        lower = num % 1000\n        higher = num // 1000\n        if digit == 0:\n            return helper(lower)\n        elif digit == 1:\n            return helper(lower) + higher + 1\n        else:\n            return helper(lower) + (higher + 1) * 1000 + digit * 100\n    \n    return helper(n)", "passed": false, "score": {"loc": 16, "tokens": 104, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.7980183284736115}}, {"code": "def countDigitOne(n):\n    def countInSubNumber(num, pos, mod, base):\n        higher = num // (base * 10)\n        current = (num // base) % 10\n        lower = num % base\n        total = 0\n        if current == 0:\n            total = higher * mod\n        elif current == 1:\n            total = higher * mod + lower + 1\n        else:\n            total = (higher + 1) * mod\n        return total\n\n    mod, result = 1, 0\n    while n >= mod:\n        result += countInSubNumber(n, mod, mod * 10, 10 * mod)\n        mod *= 10\n    return result", "passed": false, "score": {"loc": 18, "tokens": 121, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.6368314465013736}}], "num_pass": 8, "num_uniq": 6, "num_fail": 2, "fail_uniq": 2}
{"id": 552, "entry_point": "countOdds", "best_list": [{"code": "def countOdds(low, high):\n    return (high - low) // 2 + (low % 2 or high % 2)", "passed": true, "score": {"loc": 2, "tokens": 27, "cc": 1, "nest": 1, "execution_time": 0.016547, "novelty": 0.2730031431979827}}, {"code": "def countOdds(low, high):\n    return (high - low + 1 + (low % 2 + high % 2)) // 2", "passed": true, "score": {"loc": 2, "tokens": 29, "cc": 0, "nest": 1, "execution_time": 0.016444, "novelty": 0.35897620146273457}}, {"code": "def countOdds(low, high):\n    return (high - low + 1) // 2 + (high % 2 or low % 2)", "passed": true, "score": {"loc": 2, "tokens": 29, "cc": 1, "nest": 1, "execution_time": 0.016634, "novelty": 0.34089612059180796}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 559, "entry_point": "tilingRectangle", "best_list": [{"code": "def tilingRectangle(n, m):\n    from functools import lru_cache\n\n    @lru_cache(None)\n    def dp(a, b):\n        if a == b:\n            return 1\n        if a > b:\n            a, b = b, a\n        if a == 1:\n            return b\n        if a == 2:\n            return 3 if b == 3 else 2 * a\n        return min(dp(a, b - a) + dp(a, a), dp(a, b - 1) + dp(a - 1, b - 1) + dp(a - 1, b))\n    \n    return dp(n, m)", "passed": true, "score": {"loc": 14, "tokens": 125, "cc": 4, "nest": 3, "execution_time": 0.016608, "novelty": 0.7722751610214859}}, {"code": "def tilingRectangle(n, m):\n    def dfs(h, tries):\n        if all(h[i] == m for i in range(n)):\n            return tries\n        min_tiles = float('inf')\n        for i in range(n):\n            if h[i] < m:\n                for j in range(min(m - h[i], i + 1), 0, -1):\n                    new_h = h[:]\n                    for k in range(j):\n                        new_h[i - k] += j\n                    min_tiles = min(min_tiles, dfs(new_h, tries + 1))\n                    for k in range(j):\n                        new_h[i - k] -= j\n        return min_tiles\n\n    return dfs([0] * n, 0)", "passed": true, "score": {"loc": 16, "tokens": 154, "cc": 6, "nest": 6, "execution_time": 0.016947, "novelty": 0.7614429046879388}}, {"code": "def tilingRectangle(n, m):\n    def dfs(used, target):\n        if sum(used) == target:\n            return 0\n        if min(used) == target:\n            return target\n        return min(dfs(used[:i] + (used[i] - x,) + used[i+1:], target) + 1 for i in range(len(used)) for x in range(1, min(used[i], target - sum(used[:i]) + 1)))\n\n    return dfs((n,) * m, n * m)", "passed": false, "score": {"loc": 8, "tokens": 124, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.8030023282234785}}, {"code": "def tilingRectangle(n, m):\n    if n > m:\n        n, m = m, n\n\n    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            for size in range(1, min(i, j) + 1):\n                for x in range(i - size + 1):\n                    for y in range(j - size + 1):\n                        dp[i][j] = min(dp[i][j], 1 + dp[x][y] + dp[i - x][j - y])\n\n    return dp[n][m]", "passed": false, "score": {"loc": 12, "tokens": 169, "cc": 6, "nest": 6, "execution_time": 10.0, "novelty": 0.7818697751501177}}, {"code": "def tilingRectangle(n, m):\n    def solve(x, y, w, h, state, memo):\n        if state == 0:\n            return 0\n        if (x, y, w, h, state) in memo:\n            return memo[(x, y, w, h, state)]\n        min_cuts = float('inf')\n        for i in range(1, min(w, h) + 1):\n            if (state & (1 << (x + i - 1 + (y + i - 1) * w))) == 0:\n                new_state = state\n                for j in range(i):\n                    for k in range(i):\n                        new_state |= (1 << (x + j + (y + k) * w))\n                min_cuts = min(min_cuts, 1 + solve(x + i, y, w - i, h, new_state, memo) + solve(x, y + i, w, h - i, new_state, memo))\n        memo[(x, y, w, h, state)] = min_cuts\n        return min_cuts\n\n    return solve(0, 0, n, m, (1 << (n * m)) - 1, {})", "passed": false, "score": {"loc": 17, "tokens": 249, "cc": 6, "nest": 6, "execution_time": 10.0, "novelty": 0.7859463936548008}}, {"code": "def tilingRectangle(n: int, m: int) -> int:\n    def dfs(heights, count):\n        if all(h == n for h in heights):\n            return count\n        min_count = float('inf')\n        for i in range(len(heights)):\n            for j in range(i, len(heights)):\n                height = max(heights[i:j + 1])\n                if height == n:\n                    continue\n                new_heights = heights[:]\n                for k in range(i, j + 1):\n                    new_heights[k] += height\n                min_count = min(min_count, dfs(new_heights, count + 1))\n        return min_count\n\n    return dfs([0] * m, 0)", "passed": false, "score": {"loc": 16, "tokens": 143, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.7093579270550913}}, {"code": "def tilingRectangle(n, m):\n    def helper(x, y, width, height, memo):\n        if (x, y, width, height) in memo:\n            return memo[(x, y, width, height)]\n        if width == height:\n            memo[(x, y, width, height)] = 1\n        elif width > height:\n            memo[(x, y, width, height)] = helper(x, y, height, width, memo)\n        else:\n            res = float('inf')\n            for i in range(1, width + 1):\n                res = min(res, helper(x, y, width - i, height, memo) + helper(x + i, y, i, height, memo))\n                if res == 1:\n                    break\n            memo[(x, y, width, height)] = res\n        return memo[(x, y, width, height)]\n\n    return helper(0, 0, n, m, {})", "passed": false, "score": {"loc": 17, "tokens": 204, "cc": 5, "nest": 6, "execution_time": 10.0, "novelty": 0.8014568497987418}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 8}
{"id": 584, "entry_point": "numberOfSubarrays", "best_list": [{"code": "def numberOfSubarrays(nums, k):\n    odd_indices = [-1] + [i for i, x in enumerate(nums) if x % 2 == 1] + [len(nums)]\n    count = 0\n    for i in range(1, len(odd_indices) - k):\n        count += (odd_indices[i] - odd_indices[i-1]) * (odd_indices[i+k] - odd_indices[i+k-1])\n    return count", "passed": true, "score": {"loc": 6, "tokens": 95, "cc": 1, "nest": 2, "execution_time": 0.016671, "novelty": 0.6314286256726982}}, {"code": "def numberOfSubarrays(nums, k):\n    odd_indices = [-1] + [i for i, x in enumerate(nums) if x % 2 != 0] + [len(nums)]\n    count = 0\n    for i in range(1, len(odd_indices) - k):\n        count += (odd_indices[i] - odd_indices[i-1]) * (odd_indices[i+k] - odd_indices[i+k-1])\n    return count", "passed": true, "score": {"loc": 6, "tokens": 95, "cc": 1, "nest": 2, "execution_time": 0.016729, "novelty": 0.6317445437319948}}, {"code": "def numberOfSubarrays(nums, k):\n    def atMostK(k):\n        count = i = 0\n        for j, num in enumerate(nums):\n            k -= num % 2\n            while k < 0:\n                k += nums[i] % 2\n                i += 1\n            count += j - i + 1\n        return count\n    \n    return atMostK(k) - atMostK(k - 1)", "passed": true, "score": {"loc": 11, "tokens": 75, "cc": 2, "nest": 4, "execution_time": 0.016578, "novelty": 0.30465472693167284}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 5540, "entry_point": "numUniqueEmails", "best_list": [{"code": "def numUniqueEmails(emails):\n    return len({local.replace('.', '').split('+')[0] + domain for local, domain in (email.split('@') for email in emails)})", "passed": true, "score": {"loc": 2, "tokens": 54, "cc": 0, "nest": 1, "execution_time": 0.016601, "novelty": 0.7107366926183334}}, {"code": "def numUniqueEmails(emails):\n    return len(set(map(normalize, emails)))\n\ndef normalize(email):\n    local, domain = email.split('@')\n    local = local.replace('.', '').split('+')[0]\n    return local + '@' + domain", "passed": true, "score": {"loc": 6, "tokens": 68, "cc": 0, "nest": 1, "execution_time": 0.016547, "novelty": 0.6477548722659051}}, {"code": "def numUniqueEmails(emails):\n    unique_emails = set()\n    for email in emails:\n        local, domain = email.split('@')\n        local = local.split('+')[0].replace('.', '')\n        unique_emails.add(local + '@' + domain)\n    return len(unique_emails)", "passed": true, "score": {"loc": 7, "tokens": 68, "cc": 1, "nest": 2, "execution_time": 0.016477, "novelty": 0.3430238345346375}}, {"code": "def numUniqueEmails(email):\n    local, domain = email.split('@')\n    local = local.replace('.', '').split('+')[0]\n    return f\"{local}@{domain}\"\n\ndef numUniqueEmails(emails):\n    return len({numUniqueEmails(email) for email in emails})", "passed": false, "score": {"loc": 6, "tokens": 72, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6632512389188978}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 5544, "entry_point": "baseNeg2", "best_list": [{"code": "def baseNeg2(N):\n    if N == 0:\n        return \"0\"\n    result = []\n    while N != 0:\n        N, remainder = divmod(N, -2)\n        if remainder < 0:\n            N, remainder = N + 1, remainder + 2\n        result.append(str(remainder))\n    return \"\".join(reversed(result))", "passed": true, "score": {"loc": 10, "tokens": 73, "cc": 3, "nest": 3, "execution_time": 0.016717, "novelty": 0.5928575025715606}}, {"code": "def baseNeg2(n):\n    if n == 0:\n        return \"0\"\n    digits = []\n    while n != 0:\n        n, remainder = divmod(n, -2)\n        if remainder < 0:\n            remainder += 2\n            n += 1\n        digits.append(str(remainder))\n    return ''.join(digits[::-1])", "passed": true, "score": {"loc": 11, "tokens": 73, "cc": 3, "nest": 3, "execution_time": 0.016623, "novelty": 0.5692749849691825}}, {"code": "def baseNeg2(N):\n    if N == 0:\n        return \"0\"\n    result = []\n    while N != 0:\n        remainder = N % -2\n        N //= -2\n        if remainder < 0:\n            remainder += 2\n            N += 1\n        result.append(str(remainder))\n    return ''.join(result[::-1])", "passed": true, "score": {"loc": 12, "tokens": 74, "cc": 3, "nest": 3, "execution_time": 0.01651, "novelty": 0.21209219277437086}}, {"code": "def baseNeg2(N):\n    return bin((N + (N & 1)) >> 1).replace(\"0b\", \"\").replace(\"-\", \"\")", "passed": false, "score": {"loc": 2, "tokens": 42, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6959607279718796}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 5628, "entry_point": "superPow", "best_list": [{"code": "def superPow(a, b):\n    return pow(a, int(''.join(map(str, b))), 1337)", "passed": true, "score": {"loc": 2, "tokens": 31, "cc": 0, "nest": 1, "execution_time": 0.016472, "novelty": 0.45899640280097376}}, {"code": "def superPow(a: int, b: list[int]) -> int:\n    return pow(a, int(''.join(map(str, b))), 1337)", "passed": true, "score": {"loc": 2, "tokens": 41, "cc": 0, "nest": 1, "execution_time": 0.016547, "novelty": 0.5119156797297135}}, {"code": "def superPow(a, b):\n    result = 1\n    for digit in b:\n        result = (result ** 10 * pow(a, digit, 1337)) % 1337\n    return result", "passed": true, "score": {"loc": 5, "tokens": 37, "cc": 1, "nest": 2, "execution_time": 0.016421, "novelty": 0.6066841988369888}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 5712, "entry_point": "maxDotProduct", "best_list": [{"code": "def maxDotProduct(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[float('-inf')] * (n + 1) for _ in range(m + 1)]\n    for i in range(m):\n        for j in range(n):\n            dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j], dp[i][j] + nums1[i] * nums2[j], nums1[i] * nums2[j])\n    return dp[m][n]", "passed": true, "score": {"loc": 7, "tokens": 135, "cc": 2, "nest": 3, "execution_time": 0.016711, "novelty": 0.4753617886318461}}, {"code": "def maxDotProduct(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[float('-inf')] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + nums1[i-1] * nums2[j-1], nums1[i-1] * nums2[j-1])\n    \n    return dp[m][n]", "passed": true, "score": {"loc": 7, "tokens": 151, "cc": 2, "nest": 3, "execution_time": 0.016626, "novelty": 0.2012298164760279}}, {"code": "def maxDotProduct(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[-float('inf')] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + nums1[i-1] * nums2[j-1], nums1[i-1] * nums2[j-1])\n    return dp[m][n]", "passed": true, "score": {"loc": 7, "tokens": 151, "cc": 2, "nest": 3, "execution_time": 0.01663, "novelty": 0.19866200011259905}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 5873, "entry_point": "isPowerOfTwo", "best_list": [{"code": "def isPowerOfTwo(n):\n    return n > 0 and (n & (n - 1)) == 0", "passed": true, "score": {"loc": 2, "tokens": 23, "cc": 1, "nest": 1, "execution_time": 0.016543, "novelty": 0.10134728261362058}}, {"code": "def isPowerOfTwo(n):\n    while n > 1:\n        n /= 2\n    return n == 1", "passed": true, "score": {"loc": 4, "tokens": 20, "cc": 1, "nest": 2, "execution_time": 0.016437, "novelty": 0.4765995190479465}}, {"code": "def isPowerOfTwo(n):\n    if n <= 0:\n        return False\n    while n % 2 == 0:\n        n //= 2\n    return n == 1", "passed": true, "score": {"loc": 6, "tokens": 32, "cc": 2, "nest": 2, "execution_time": 0.016724, "novelty": 0.5530200434024002}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 5889, "entry_point": "longestConsecutive", "best_list": [{"code": "def longestConsecutive(nums):\n    num_set = set(nums)\n    longest_streak = 0\n\n    for num in num_set:\n        if num - 1 not in num_set:\n            current_num = num\n            current_streak = 1\n\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_streak += 1\n\n            longest_streak = max(longest_streak, current_streak)\n\n    return longest_streak", "passed": true, "score": {"loc": 12, "tokens": 59, "cc": 3, "nest": 4, "execution_time": 0.016551, "novelty": 0.1230787673078122}}, {"code": "def longestConsecutive(nums):\n    if not nums:\n        return 0\n    \n    nums = set(nums)\n    longest_streak = 0\n    \n    for num in nums:\n        if num - 1 not in nums:\n            current_num = num\n            current_streak = 1\n            \n            while current_num + 1 in nums:\n                current_num += 1\n                current_streak += 1\n            \n            longest_streak = max(longest_streak, current_streak)\n    \n    return longest_streak", "passed": true, "score": {"loc": 14, "tokens": 65, "cc": 4, "nest": 4, "execution_time": 0.016497, "novelty": 0.6564562821404512}}, {"code": "def longestConsecutive(nums):\n    if not nums:\n        return 0\n\n    nums = sorted(set(nums))\n    longest_streak = 1\n    current_streak = 1\n\n    for i in range(1, len(nums)):\n        if nums[i] != nums[i - 1]:\n            if nums[i] == nums[i - 1] + 1:\n                current_streak += 1\n            else:\n                longest_streak = max(longest_streak, current_streak)\n                current_streak = 1\n\n    return max(longest_streak, current_streak)", "passed": true, "score": {"loc": 14, "tokens": 94, "cc": 4, "nest": 4, "execution_time": 0.016419, "novelty": 0.6921526668370696}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 5899, "entry_point": "reverseVowels", "best_list": [{"code": "def reverseVowels(s):\n    vowels = \"aeiouAEIOU\"\n    s_list = list(s)\n    i, j = 0, len(s) - 1\n    \n    while i < j:\n        if s_list[i] not in vowels:\n            i += 1\n        elif s_list[j] not in vowels:\n            j -= 1\n        else:\n            s_list[i], s_list[j] = s_list[j], s_list[i]\n            i += 1\n            j -= 1\n    \n    return ''.join(s_list)", "passed": true, "score": {"loc": 14, "tokens": 97, "cc": 3, "nest": 4, "execution_time": 0.016387, "novelty": 0.2970843732021785}}, {"code": "def reverseVowels(s):\n    s_list = list(s)\n    vowels = 'aeiouAEIOU'\n    i, j = 0, len(s) - 1\n    \n    while i < j:\n        if s_list[i] not in vowels:\n            i += 1\n        elif s_list[j] not in vowels:\n            j -= 1\n        else:\n            s_list[i], s_list[j] = s_list[j], s_list[i]\n            i += 1\n            j -= 1\n    \n    return ''.join(s_list)", "passed": true, "score": {"loc": 14, "tokens": 97, "cc": 3, "nest": 4, "execution_time": 0.016636, "novelty": 0.1205710532937807}}, {"code": "def reverseVowels(s: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    s_list = list(s)\n    i, j = 0, len(s) - 1\n    \n    while i < j:\n        if s_list[i] not in vowels:\n            i += 1\n        elif s_list[j] not in vowels:\n            j -= 1\n        else:\n            s_list[i], s_list[j] = s_list[j], s_list[i]\n            i += 1\n            j -= 1\n    \n    return ''.join(s_list)", "passed": true, "score": {"loc": 14, "tokens": 102, "cc": 3, "nest": 4, "execution_time": 0.016444, "novelty": 0.29398553664734894}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 5901, "entry_point": "brokenCalc", "best_list": [{"code": "def brokenCalc(X, Y):\n    return X - Y if X >= Y else 1 + (brokenCalc(X, Y // 2) if Y % 2 == 0 else brokenCalc(X, Y + 1))", "passed": true, "score": {"loc": 2, "tokens": 47, "cc": 0, "nest": 1, "execution_time": 0.016642, "novelty": 0.5113096706505215}}, {"code": "def brokenCalc(X, Y):\n    if X >= Y:\n        return X - Y\n    elif Y % 2 == 0:\n        return 1 + brokenCalc(X, Y // 2)\n    else:\n        return 2 + brokenCalc(X, (Y + 1) // 2)", "passed": true, "score": {"loc": 7, "tokens": 56, "cc": 2, "nest": 3, "execution_time": 0.016314, "novelty": 0.37680453462881836}}, {"code": "def brokenCalc(X, Y):\n    if X >= Y:\n        return X - Y\n    if Y % 2 == 0:\n        return 1 + brokenCalc(X, Y // 2)\n    else:\n        return 1 + min(brokenCalc(X, Y + 1), brokenCalc(X, Y // 2))", "passed": true, "score": {"loc": 7, "tokens": 64, "cc": 2, "nest": 2, "execution_time": 0.016661, "novelty": 0.386430828794571}}, {"code": "def brokenCalc(X, Y):\n    if X >= Y:\n        return X - Y\n    return 1 + (Y + 1) // 2 * (Y & 1) + brokenCalc(X, (Y + 1) // 2)", "passed": false, "score": {"loc": 4, "tokens": 49, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.5618059598444587}}, {"code": "def brokenCalc(X, Y):\n    if X >= Y:\n        return X - Y\n    dp = [float('inf')] * (Y + 1)\n    dp[0] = 0\n    dp[1] = 1\n    for y in range(2, Y + 1):\n        dp[y] = dp[y - 1] + 1\n        if y % 2 == 0:\n            dp[y] = min(dp[y], dp[y // 2] + 1)\n    return dp[Y] + X - 1", "passed": false, "score": {"loc": 11, "tokens": 110, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6962179394858019}}, {"code": "def brokenCalc(X, Y):\n    if X >= Y:\n        return X - Y\n    return 1 + min(brokenCalc(X, Y + 1), brokenCalc(X, Y // 2)) if Y % 2 else brokenCalc(X, Y // 2)", "passed": false, "score": {"loc": 4, "tokens": 56, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.5477146725114512}}, {"code": "def brokenCalc(X, Y):\n    if X >= Y:\n        return X - Y\n    if Y % 2 == 0:\n        return 1 + brokenCalc(X, Y // 2)\n    else:\n        return 1 + min(brokenCalc(X, Y + 1), brokenCalc(X, Y - 1))", "passed": false, "score": {"loc": 7, "tokens": 63, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.38404790027782043}}], "num_pass": 6, "num_uniq": 5, "num_fail": 4, "fail_uniq": 4}
{"id": 5922, "entry_point": "minRefuelStops", "best_list": [{"code": "def minRefuelStops(target, startFuel, stations):\n    refuels = 0\n    max_reach = startFuel\n    i = 0\n    pq = []\n    \n    while max_reach < target:\n        while i < len(stations) and stations[i][0] <= max_reach:\n            heapq.heappush(pq, -stations[i][1])\n            i += 1\n        if not pq:\n            return -1\n        max_reach -= heapq.heappop(pq)\n        refuels += 1\n    \n    return refuels", "passed": true, "score": {"loc": 14, "tokens": 88, "cc": 4, "nest": 3, "execution_time": 0.016411, "novelty": 0.573056421935411}}, {"code": "def minRefuelStops(target, startFuel, stations):\n    stops = 0\n    fuel = startFuel\n    i = 0\n    max_heap = []\n    \n    while fuel < target:\n        while i < len(stations) and stations[i][0] <= fuel:\n            heapq.heappush(max_heap, -stations[i][1])\n            i += 1\n        if not max_heap:\n            return -1\n        fuel -= heapq.heappop(max_heap)\n        stops += 1\n    \n    return stops", "passed": true, "score": {"loc": 14, "tokens": 88, "cc": 4, "nest": 3, "execution_time": 0.016641, "novelty": 0.5255176990586488}}, {"code": "def minRefuelStops(target, startFuel, stations):\n    from heapq import heappop, heappush\n    max_heap = []\n    fuel = startFuel\n    stops = 0\n    i = 0\n    while fuel < target:\n        while i < len(stations) and stations[i][0] <= fuel:\n            heappush(max_heap, -stations[i][1])\n            i += 1\n        if not max_heap:\n            return -1\n        fuel += -heappop(max_heap)\n        stops += 1\n    return stops", "passed": true, "score": {"loc": 15, "tokens": 91, "cc": 4, "nest": 3, "execution_time": 0.016559, "novelty": 0.533800036071648}}, {"code": "def minRefuelStops(target, startFuel, stations):\n    stations.append([target, 0])\n    pq = []\n    fuel = startFuel\n    stops = 0\n    \n    for pos, gas in stations:\n        fuel -= pos\n        while pq and fuel < 0:\n            fuel -= heapq.heappop(pq)\n            stops += 1\n        if fuel < 0:\n            return -1\n        heapq.heappush(pq, -gas)\n    \n    return stops", "passed": false, "score": {"loc": 14, "tokens": 80, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.6394192115633359}}, {"code": "def minRefuelStops(target, startFuel, stations):\n    import heapq\n    \n    stops = 0\n    max_reach = startFuel\n    refuel_heap = []\n    \n    stations.append([target, 0])\n    \n    for position, fuel in stations:\n        while max_reach < position:\n            if not refuel_heap:\n                return -1\n            max_reach -= heapq.heappop(refuel_heap)\n            stops += 1\n        heapq.heappush(refuel_heap, -fuel)\n    \n    return stops", "passed": false, "score": {"loc": 14, "tokens": 75, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.6357551900018474}}, {"code": "from heapq import heappop, heappush\n\ndef minRefuelStops(target, startFuel, stations):\n    max_heap = []\n    stops = 0\n    current_fuel = startFuel\n    \n    stations.append([target, 0])\n    \n    for position, fuel in stations:\n        while max_heap and current_fuel < position:\n            current_fuel -= heappop(max_heap)\n            stops += 1\n        if current_fuel < position:\n            return -1\n        heappush(max_heap, -fuel)\n    \n    return stops", "passed": false, "score": {"loc": 14, "tokens": 78, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.5931021820029121}}, {"code": "def minRefuelStops(target, startFuel, stations):\n    import heapq\n    stops = 0\n    fuel_heap = []\n    current_fuel = startFuel\n    \n    for station in stations:\n        while fuel_heap and current_fuel < station[0]:\n            current_fuel -= heapq.heappop(fuel_heap)\n            stops += 1\n        if current_fuel < station[0]:\n            return -1\n        heapq.heappush(fuel_heap, -station[1])\n    \n    while fuel_heap and current_fuel < target:\n        current_fuel -= heapq.heappop(fuel_heap)\n        stops += 1\n    if current_fuel < target:\n        return -1\n    \n    return stops", "passed": false, "score": {"loc": 18, "tokens": 103, "cc": 7, "nest": 3, "execution_time": 10.0, "novelty": 0.6510855561660729}}, {"code": "def minRefuelStops(target, startFuel, stations):\n    max_reach = startFuel\n    fuel_stops = 0\n    stations.append([target, 0])\n    \n    for i in range(len(stations) - 1):\n        if max_reach < stations[i][0]:\n            return -1\n        while stations and max_reach >= stations[-1][0]:\n            max_reach += stations.pop()[1]\n        if max_reach < stations[i][0]:\n            return -1\n        max_reach -= stations[i][0]\n        fuel_stops += 1\n    \n    return fuel_stops", "passed": false, "score": {"loc": 14, "tokens": 109, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.7881993309173578}}], "num_pass": 4, "num_uniq": 4, "num_fail": 6, "fail_uniq": 6}
{"id": 620, "entry_point": "smallestRangeII", "best_list": [{"code": "def smallestRangeII(A, K):\n    A.sort()\n    res = A[-1] - A[0]\n    for i in range(len(A) - 1):\n        res = min(res, max(A[-1] - K, A[i] + K) - min(A[0] + K, A[i + 1] - K))\n    return res", "passed": true, "score": {"loc": 6, "tokens": 83, "cc": 1, "nest": 2, "execution_time": 0.016462, "novelty": 0.19638493212846497}}, {"code": "def smallestRangeII(A, K):\n    A.sort()\n    ans = A[-1] - A[0]\n    for i in range(len(A) - 1):\n        ans = min(ans, max(A[-1] - K, A[i] + K) - min(A[0] + K, A[i + 1] - K))\n    return ans", "passed": true, "score": {"loc": 6, "tokens": 83, "cc": 1, "nest": 2, "execution_time": 0.016645, "novelty": 0.19948689446690804}}, {"code": "def smallestRangeII(A, K):\n    A.sort()\n    result = A[-1] - A[0]\n    for i in range(len(A) - 1):\n        result = min(result, max(A[-1] - K, A[i] + K) - min(A[0] + K, A[i + 1] - K))\n    return result", "passed": true, "score": {"loc": 6, "tokens": 83, "cc": 1, "nest": 2, "execution_time": 0.016864, "novelty": 0.19645823233402337}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 6068, "entry_point": "maxArea", "best_list": [{"code": "def maxArea(height):\n    l, r = 0, len(height) - 1\n    max_area = 0\n    while l < r:\n        max_area = max(max_area, (r - l) * min(height[l], height[r]))\n        if height[l] < height[r]:\n            l += 1\n        else:\n            r -= 1\n    return max_area", "passed": true, "score": {"loc": 10, "tokens": 74, "cc": 2, "nest": 3, "execution_time": 0.016544, "novelty": 0.17104651376210134}}, {"code": "def maxArea(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n    while left < right:\n        max_area = max(max_area, (right - left) * min(height[left], height[right]))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area", "passed": true, "score": {"loc": 10, "tokens": 74, "cc": 2, "nest": 3, "execution_time": 0.016615, "novelty": 0.11580692536157622}}, {"code": "def maxArea(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n    while left < right:\n        max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area", "passed": true, "score": {"loc": 10, "tokens": 74, "cc": 2, "nest": 3, "execution_time": 0.016706, "novelty": 0.12242131105637521}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 6077, "entry_point": "findContentChildren", "best_list": [{"code": "def findContentChildren(g, s):\n    g.sort()\n    s.sort()\n    i = j = 0\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1\n        j += 1\n    return i", "passed": true, "score": {"loc": 9, "tokens": 60, "cc": 3, "nest": 3, "execution_time": 0.016487, "novelty": 0.07792403155603822}}, {"code": "def findContentChildren(g, s):\n    g.sort()\n    s.sort()\n    child_i = cookie_j = 0\n    while child_i < len(g) and cookie_j < len(s):\n        if g[child_i] <= s[cookie_j]:\n            child_i += 1\n        cookie_j += 1\n    return child_i", "passed": true, "score": {"loc": 9, "tokens": 60, "cc": 3, "nest": 3, "execution_time": 0.016701, "novelty": 0.29969951631539893}}, {"code": "def findContentChildren(g, s):\n    g.sort()\n    s.sort()\n    i, j = 0, 0\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1\n        j += 1\n    return i", "passed": true, "score": {"loc": 9, "tokens": 62, "cc": 3, "nest": 3, "execution_time": 0.016542, "novelty": 0.0747836634255088}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 6164, "entry_point": "lengthOfLIS", "best_list": [{"code": "def lengthOfLIS(nums):\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "passed": true, "score": {"loc": 9, "tokens": 78, "cc": 4, "nest": 4, "execution_time": 0.016316, "novelty": 0.07593661262251539}}, {"code": "def lengthOfLIS(nums):\n    if not nums:\n        return 0\n    \n    tails = [0] * len(nums)\n    size = 0\n    \n    for num in nums:\n        left, right = 0, size\n        while left < right:\n            mid = (left + right) // 2\n            if tails[mid] < num:\n                left = mid + 1\n            else:\n                right = mid\n        tails[left] = num\n        size = max(size, left + 1)\n    \n    return size", "passed": true, "score": {"loc": 16, "tokens": 88, "cc": 4, "nest": 4, "execution_time": 0.016778, "novelty": 0.571310799670239}}], "num_pass": 10, "num_uniq": 2, "num_fail": 0, "fail_uniq": 0}
{"id": 6165, "entry_point": "distanceBetweenBusStops", "best_list": [{"code": "def distanceBetweenBusStops(distance, start, destination):\n    total_distance = sum(distance)\n    clockwise_distance = sum(distance[min(start, destination):max(start, destination)])\n    return min(clockwise_distance, total_distance - clockwise_distance)", "passed": true, "score": {"loc": 4, "tokens": 46, "cc": 0, "nest": 1, "execution_time": 0.016659, "novelty": 0.4124426180256159}}, {"code": "def distanceBetweenBusStops(distance, start, destination):\n    n = len(distance)\n    clockwise = sum(distance[start:destination])\n    counterclockwise = sum(distance) - clockwise\n    return min(clockwise, counterclockwise)", "passed": true, "score": {"loc": 5, "tokens": 42, "cc": 0, "nest": 1, "execution_time": 0.01655, "novelty": 0.26443767152184805}}, {"code": "def distanceBetweenBusStops(distance, start, destination):\n    n = len(distance)\n    clockwise = sum(distance[min(start, destination):max(start, destination)])\n    counterclockwise = sum(distance) - clockwise\n    return min(clockwise, counterclockwise)", "passed": true, "score": {"loc": 5, "tokens": 52, "cc": 0, "nest": 1, "execution_time": 0.01672, "novelty": 0.3860469030866107}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 6201, "entry_point": "maxSubarraySumCircular", "best_list": [{"code": "def maxSubarraySumCircular(A):\n    total_sum = sum(A)\n    max_current = max_global = A[0]\n    min_current = min_global = A[0]\n    \n    for num in A[1:]:\n        max_current = max(num, max_current + num)\n        max_global = max(max_global, max_current)\n        \n        min_current = min(num, min_current + num)\n        min_global = min(min_global, min_current)\n    \n    if max_global > 0:\n        return max(max_global, total_sum - min_global)\n    return max_global", "passed": true, "score": {"loc": 12, "tokens": 89, "cc": 2, "nest": 2, "execution_time": 0.016561, "novelty": 0.48685078636913504}}, {"code": "def maxSubarraySumCircular(A):\n    n = len(A)\n    total_sum = max_sum = current_max = min_sum = current_min = A[0]\n    \n    for num in A[1:]:\n        current_max = max(num, current_max + num)\n        max_sum = max(max_sum, current_max)\n        \n        current_min = min(num, current_min + num)\n        min_sum = min(min_sum, current_min)\n        \n        total_sum += num\n    \n    if max_sum < 0:\n        return max_sum\n    \n    return max(max_sum, total_sum - min_sum)", "passed": true, "score": {"loc": 12, "tokens": 91, "cc": 2, "nest": 2, "execution_time": 0.016598, "novelty": 0.3707985650518809}}, {"code": "def maxSubarraySumCircular(A):\n    total, max_subarray, min_subarray, cur_max, cur_min = 0, float('-inf'), float('inf'), 0, 0\n    for num in A:\n        total += num\n        cur_max = max(cur_max + num, num)\n        max_subarray = max(max_subarray, cur_max)\n        cur_min = min(cur_min + num, num)\n        min_subarray = min(min_subarray, cur_min)\n    if max_subarray > 0:\n        return max(max_subarray, total - min_subarray)\n    else:\n        return max_subarray", "passed": true, "score": {"loc": 12, "tokens": 99, "cc": 2, "nest": 2, "execution_time": 0.016612, "novelty": 0.5659984807203504}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 6263, "entry_point": "shortestCommonSupersequence", "best_list": [{"code": "def shortestCommonSupersequence(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n        for j in range(n):\n            if str1[i] == str2[j]:\n                dp[i + 1][j + 1] = dp[i][j] + 1\n            else:\n                dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n\n    i, j = m, n\n    result = []\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1]:\n            result.append(str1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            result.append(str1[i - 1])\n            i -= 1\n        else:\n            result.append(str2[j - 1])\n            j -= 1\n\n    while i > 0:\n        result.append(str1[i - 1])\n        i -= 1\n\n    while j > 0:\n        result.append(str2[j - 1])\n        j -= 1\n\n    return ''.join(reversed(result))", "passed": true, "score": {"loc": 29, "tokens": 287, "cc": 9, "nest": 4, "execution_time": 0.016722, "novelty": 0.4376109163743279}}, {"code": "def shortestCommonSupersequence(str1: str, str2: str) -> str:\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    i, j = m, n\n    result = []\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1]:\n            result.append(str1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            result.append(str1[i - 1])\n            i -= 1\n        else:\n            result.append(str2[j - 1])\n            j -= 1\n\n    while i > 0:\n        result.append(str1[i - 1])\n        i -= 1\n\n    while j > 0:\n        result.append(str2[j - 1])\n        j -= 1\n\n    return ''.join(result[::-1])", "passed": true, "score": {"loc": 29, "tokens": 305, "cc": 9, "nest": 4, "execution_time": 0.016724, "novelty": 0.4038818135393103}}, {"code": "def shortestCommonSupersequence(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    lcs_len = dp[m][n]\n    i, j = m, n\n    result = []\n    \n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1]:\n            result.append(str1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            result.append(str1[i - 1])\n            i -= 1\n        else:\n            result.append(str2[j - 1])\n            j -= 1\n    \n    while i > 0:\n        result.append(str1[i - 1])\n        i -= 1\n    \n    while j > 0:\n        result.append(str2[j - 1])\n        j -= 1\n    \n    return ''.join(reversed(result))", "passed": true, "score": {"loc": 30, "tokens": 304, "cc": 9, "nest": 4, "execution_time": 0.016825, "novelty": 0.40791112403335084}}, {"code": "def shortestCommonSupersequence(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [['' for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if str1[i] == str2[j]:\n                dp[i][j] = str1[i] + dp[i + 1][j + 1]\n            else:\n                dp[i][j] = min(dp[i + 1][j], dp[i][j + 1], key=len)\n    \n    return dp[0][0]", "passed": false, "score": {"loc": 10, "tokens": 159, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5378035536948951}}, {"code": "def shortestCommonSupersequence(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[\"\" for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + str1[i - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len)\n    \n    def build_result(dp, str1, str2):\n        i, j = len(str1), len(str2)\n        result = []\n        while i > 0 or j > 0:\n            if i > 0 and dp[i][j] == dp[i - 1][j]:\n                result.append(str1[i - 1])\n                i -= 1\n            elif j > 0 and dp[i][j] == dp[i][j - 1]:\n                result.append(str2[j - 1])\n                j -= 1\n            else:\n                result.append(dp[i][j][-1])\n                if dp[i][j][0] in str1:\n                    i -= 1\n                if dp[i][j][0] in str2:\n                    j -= 1\n        return ''.join(reversed(result))\n    \n    return build_result(dp, str1, str2)", "passed": false, "score": {"loc": 27, "tokens": 337, "cc": 11, "nest": 6, "execution_time": 10.0, "novelty": 0.7063847678524069}}, {"code": "def shortestCommonSupersequence(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m - 1, -1, -1):\n        dp[i][n] = dp[i + 1][n] + str1[i]\n\n    for j in range(n - 1, -1, -1):\n        dp[m][j] = dp[m][j + 1] + str2[j]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if str1[i] == str2[j]:\n                dp[i][j] = dp[i + 1][j + 1] + str1[i]\n            else:\n                dp[i][j] = min(dp[i + 1][j], dp[i][j + 1])\n\n    return dp[0][0]", "passed": false, "score": {"loc": 14, "tokens": 227, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.6876363124019622}}, {"code": "def shortestCommonSupersequence(str1: str, str2: str) -> str:\n    m, n = len(str1), len(str2)\n    dp = [['' for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if str1[i] == str2[j]:\n                dp[i][j] = str1[i] + dp[i + 1][j + 1]\n            else:\n                dp[i][j] = min(dp[i + 1][j], dp[i][j + 1], key=len)\n    \n    return dp[0][0]\n\ndef _equivalent(lhs: str, rhs: str) -> bool:\n    return lhs == rhs", "passed": false, "score": {"loc": 12, "tokens": 186, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5322705949239601}}, {"code": "def shortestCommonSupersequence(str1: str, str2: str) -> str:\n    m, n = len(str1), len(str2)\n    dp = [['' for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if str1[i] == str2[j]:\n                dp[i][j] = str1[i] + dp[i + 1][j + 1]\n            else:\n                dp[i][j] = min(dp[i + 1][j] + str2[j], dp[i][j + 1] + str1[i], key=len)\n\n    return dp[0][0]", "passed": false, "score": {"loc": 10, "tokens": 176, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5723458391088256}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 6353, "entry_point": "minNumberOfFrogs", "best_list": [{"code": "def minNumberOfFrogs(croakOfFrogs: str) -> int:\n    if len(croakOfFrogs) % 5 != 0:\n        return -1\n    \n    counts = {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0}\n    frogs = 0\n    \n    for char in croakOfFrogs:\n        counts[char] += 1\n        \n        if counts['c'] < counts['r'] or counts['r'] < counts['o'] or counts['o'] < counts['a'] or counts['a'] < counts['k']:\n            return -1\n        \n        if char == 'k':\n            frogs = max(frogs, counts['c'])\n            for c in 'croak':\n                counts[c] -= 1\n    \n    return frogs if counts == {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0} else -1", "passed": true, "score": {"loc": 14, "tokens": 208, "cc": 6, "nest": 4, "execution_time": 0.016606, "novelty": 0.7974218657597949}}, {"code": "def minNumberOfFrogs(croakOfFrogs: str) -> int:\n    if len(croakOfFrogs) % 5 != 0:\n        return -1\n    \n    counts = {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0}\n    frogs = 0\n    \n    for char in croakOfFrogs:\n        counts[char] += 1\n        if char == 'c':\n            frogs = max(frogs, counts['c'])\n        elif char == 'k':\n            for c in counts:\n                counts[c] -= 1\n    \n    if any(counts.values()):\n        return -1\n    \n    return frogs", "passed": true, "score": {"loc": 15, "tokens": 129, "cc": 6, "nest": 5, "execution_time": 0.016522, "novelty": 0.7458514186241646}}, {"code": "def minNumberOfFrogs(croakOfFrogs: str) -> int:\n    count = [0] * 5\n    frogs = 0\n    for c in croakOfFrogs:\n        if c == 'c':\n            count[0] += 1\n            frogs = max(frogs, count[0])\n        elif c == 'r':\n            if count[0] == 0:\n                return -1\n            count[0] -= 1\n            count[1] += 1\n        elif c == 'o':\n            if count[1] == 0:\n                return -1\n            count[1] -= 1\n            count[2] += 1\n        elif c == 'a':\n            if count[2] == 0:\n                return -1\n            count[2] -= 1\n            count[3] += 1\n        elif c == 'k':\n            if count[3] == 0:\n                return -1\n            count[3] -= 1\n            count[4] += 1\n            count[0] -= 1\n    if any(count[i] != 0 for i in range(4)):\n        return -1\n    return frogs", "passed": true, "score": {"loc": 31, "tokens": 219, "cc": 11, "nest": 8, "execution_time": 0.016689, "novelty": 0.7631977059043877}}, {"code": "def minNumberOfFrogs(croakOfFrogs: str) -> int:\n    counts = {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0}\n    frogs = 0\n    max_frogs = 0\n\n    for char in croakOfFrogs:\n        counts[char] += 1\n        if char == 'c':\n            frogs += 1\n            max_frogs = max(max_frogs, frogs)\n        elif char == 'k':\n            frogs -= 1\n        else:\n            if counts[char] > counts[chr(ord(char) - 1)]:\n                return -1\n\n    if frogs != 0:\n        return -1\n\n    return max_frogs", "passed": false, "score": {"loc": 17, "tokens": 129, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.4743118293404093}}, {"code": "def minNumberOfFrogs(croakOfFrogs):\n    counts = {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0}\n    frogs = 0\n    max_frogs = 0\n    \n    for c in croakOfFrogs:\n        counts[c] += 1\n        if c == 'c':\n            frogs += 1\n            max_frogs = max(max_frogs, frogs)\n        elif c == 'k':\n            frogs -= 1\n    \n        if counts['c'] < counts['r'] or counts['r'] < counts['o'] or counts['o'] < counts['a'] or counts['a'] < counts['k']:\n            return -1\n    \n    if frogs != 0:\n        return -1\n    \n    return max_frogs", "passed": false, "score": {"loc": 16, "tokens": 160, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.5016390897758014}}, {"code": "def minNumberOfFrogs(croakOfFrogs):\n    counts = {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0}\n    frogs = 0\n    max_frogs = 0\n    \n    for char in croakOfFrogs:\n        counts[char] += 1\n        if char == 'c':\n            frogs += 1\n            max_frogs = max(max_frogs, frogs)\n        elif char == 'k':\n            frogs -= 1\n        elif counts['c'] < counts['r'] or counts['r'] < counts['o'] or counts['o'] < counts['a'] or counts['a'] < counts['k']:\n            return -1\n    \n    if frogs != 0:\n        return -1\n    \n    return max_frogs", "passed": false, "score": {"loc": 16, "tokens": 160, "cc": 6, "nest": 5, "execution_time": 10.0, "novelty": 0.5007426549703553}}, {"code": "def minNumberOfFrogs(croakOfFrogs):\n    counts = {'c': 0, 'r': 0, 'o': 0, 'a': 0, 'k': 0}\n    frogs = 0\n    max_frogs = 0\n    \n    for char in croakOfFrogs:\n        counts[char] += 1\n        if char == 'c':\n            frogs += 1\n            max_frogs = max(max_frogs, frogs)\n        elif char == 'k':\n            frogs -= 1\n    \n    if not all(counts[char] == counts['c'] for char in 'croak'):\n        return -1\n    \n    return max_frogs", "passed": false, "score": {"loc": 14, "tokens": 118, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.49756523720358337}}, {"code": "def minNumberOfFrogs(croakOfFrogs):\n    croak_map = {'c': 0, 'r': 1, 'o': 2, 'a': 3, 'k': 4}\n    count = [0] * 5\n    frogs = 0\n    for char in croakOfFrogs:\n        i = croak_map[char]\n        count[i] += 1\n        if i == 0:\n            frogs = max(frogs, count[0])\n        elif count[i] > count[i - 1]:\n            return -1\n    if any(count[i] != count[0] for i in range(1, 5)):\n        return -1\n    return frogs", "passed": false, "score": {"loc": 14, "tokens": 129, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.6383958554498878}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 6374, "entry_point": "findMedianSortedArrays", "best_list": [{"code": "def findMedianSortedArrays(nums1, nums2):\n    def get_kth(a, b, k):\n        if len(a) > len(b):\n            a, b = b, a\n        if len(a) == 0:\n            return b[k]\n        if k == 0:\n            return min(a[0], b[0])\n        i = min(len(a) - 1, k // 2)\n        j = min(len(b) - 1, k // 2)\n        if a[i] > b[j]:\n            return get_kth(a, b[j+1:], k-j-1)\n        else:\n            return get_kth(a[i+1:], b, k-i-1)\n    \n    total_length = len(nums1) + len(nums2)\n    if total_length % 2 == 1:\n        return get_kth(nums1, nums2, total_length // 2)\n    else:\n        return (get_kth(nums1, nums2, total_length // 2 - 1) + get_kth(nums1, nums2, total_length // 2)) / 2", "passed": true, "score": {"loc": 19, "tokens": 215, "cc": 5, "nest": 3, "execution_time": 0.016763, "novelty": 0.7240603888935444}}, {"code": "def findMedianSortedArrays(nums1, nums2):\n    def find_kth(nums1, nums2, k):\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        if len(nums1) == 0:\n            return nums2[k]\n        if k == 0:\n            return min(nums1[0], nums2[0])\n        \n        i = min(len(nums1) - 1, k // 2)\n        j = min(len(nums2) - 1, k // 2)\n        \n        if nums1[i] > nums2[j]:\n            return find_kth(nums1, nums2[j+1:], k-j-1)\n        else:\n            return find_kth(nums1[i+1:], nums2, k-i-1)\n    \n    total = len(nums1) + len(nums2)\n    if total % 2 == 1:\n        return find_kth(nums1, nums2, total // 2)\n    else:\n        return (find_kth(nums1, nums2, total // 2 - 1) + find_kth(nums1, nums2, total // 2)) / 2", "passed": true, "score": {"loc": 19, "tokens": 215, "cc": 5, "nest": 3, "execution_time": 0.0169, "novelty": 0.7028788662696712}}, {"code": "def findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    x, y = len(nums1), len(nums2)\n    low, high = 0, x\n    \n    while low <= high:\n        partitionX = (low + high) // 2\n        partitionY = (x + y + 1) // 2 - partitionX\n        \n        maxX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n        minX = float('inf') if partitionX == x else nums1[partitionX]\n        \n        maxY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n        minY = float('inf') if partitionY == y else nums2[partitionY]\n        \n        if maxX <= minY and maxY <= minX:\n            if (x + y) % 2 == 0:\n                return (max(maxX, maxY) + min(minX, minY)) / 2\n            else:\n                return max(maxX, maxY)\n        elif maxX > minY:\n            high = partitionX - 1\n        else:\n            low = partitionX + 1", "passed": true, "score": {"loc": 21, "tokens": 221, "cc": 6, "nest": 4, "execution_time": 0.016689, "novelty": 0.6195498989892897}}, {"code": "def findMedianSortedArrays(nums1, nums2):\n    def find_kth(nums1, nums2, k):\n        if not nums1: return nums2[k]\n        if not nums2: return nums1[k]\n        if k == 0: return min(nums1[0], nums2[0])\n\n        mid1, mid2 = len(nums1) // 2, len(nums2) // 2\n        if nums1[mid1] < nums2[mid2]:\n            if k <= mid1 + mid2:\n                return find_kth(nums1[:mid1 + 1], nums2, k)\n            else:\n                return find_kth(nums1[mid1 + 1:], nums2, k - mid1 - 1)\n        else:\n            if k <= mid1 + mid2:\n                return find_kth(nums1, nums2[:mid2 + 1], k)\n            else:\n                return find_kth(nums1, nums2[mid2 + 1:], k - mid2 - 1)\n\n    total = len(nums1) + len(nums2)\n    if total % 2 == 1:\n        return find_kth(nums1, nums2, total // 2)\n    else:\n        return (find_kth(nums1, nums2, total // 2 - 1) + find_kth(nums1, nums2, total // 2)) / 2", "passed": false, "score": {"loc": 21, "tokens": 238, "cc": 7, "nest": 4, "execution_time": 10.0, "novelty": 0.8219280891844898}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 6479, "entry_point": "maxProduct", "best_list": [{"code": "def maxProduct(nums):\n    max_product = min_product = result = nums[0]\n    for num in nums[1:]:\n        if num < 0:\n            max_product, min_product = min_product, max_product\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n        result = max(result, max_product)\n    return result", "passed": true, "score": {"loc": 9, "tokens": 67, "cc": 2, "nest": 3, "execution_time": 0.016664, "novelty": 0.3011830834520942}}, {"code": "def maxProduct(nums):\n    if not nums:\n        return 0\n    \n    max_prod = min_prod = result = nums[0]\n    \n    for num in nums[1:]:\n        if num < 0:\n            max_prod, min_prod = min_prod, max_prod\n        \n        max_prod = max(num, max_prod * num)\n        min_prod = min(num, min_prod * num)\n        \n        result = max(result, max_prod)\n    \n    return result", "passed": true, "score": {"loc": 11, "tokens": 73, "cc": 3, "nest": 3, "execution_time": 0.016516, "novelty": 0.3511474082468995}}, {"code": "def maxProduct(nums):\n    if not nums:\n        return 0\n    \n    max_product = min_product = result = nums[0]\n    \n    for num in nums[1:]:\n        if num < 0:\n            max_product, min_product = min_product, max_product\n        \n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n        \n        result = max(result, max_product)\n    \n    return result", "passed": true, "score": {"loc": 11, "tokens": 73, "cc": 3, "nest": 3, "execution_time": 0.01665, "novelty": 0.3162082213626263}}, {"code": "def maxProduct(nums):\n    if not nums:\n        return 0\n    \n    max_product = current_max = current_min = nums[0]\n    \n    for num in nums[1:]:\n        if num == 0:\n            current_max, current_min = 1, 1\n            max_product = max(max_product, 0)\n        else:\n            temp_max = current_max * num\n            current_max = max(num, temp_max, current_min * num)\n            current_min = min(num, temp_min, current_min * num)\n            max_product = max(max_product, current_max)\n    \n    return max_product", "passed": false, "score": {"loc": 14, "tokens": 93, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5383087749702993}}], "num_pass": 9, "num_uniq": 6, "num_fail": 1, "fail_uniq": 1}
{"id": 6499, "entry_point": "numIdenticalPairs", "best_list": [{"code": "def numIdenticalPairs(nums):\n    from collections import Counter\n    count = Counter(nums)\n    return sum(v * (v - 1) // 2 for v in count.values())", "passed": true, "score": {"loc": 4, "tokens": 38, "cc": 0, "nest": 1, "execution_time": 0.016678, "novelty": 0.6451668264386647}}, {"code": "def numIdenticalPairs(nums):\n    count = 0\n    num_dict = {}\n    for num in nums:\n        count += num_dict.get(num, 0)\n        num_dict[num] = num_dict.get(num, 0) + 1\n    return count", "passed": true, "score": {"loc": 7, "tokens": 46, "cc": 1, "nest": 2, "execution_time": 0.016428, "novelty": 0.4721165736556997}}, {"code": "def numIdenticalPairs(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                count += 1\n    return count", "passed": true, "score": {"loc": 7, "tokens": 53, "cc": 3, "nest": 4, "execution_time": 0.016699, "novelty": 0.6322033964512299}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 658, "entry_point": "maxSumAfterPartitioning", "best_list": [{"code": "def maxSumAfterPartitioning(arr, k):\n    n = len(arr)\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(1, min(k, i) + 1):\n            dp[i] = max(dp[i], dp[i - j] + max(arr[i - j:i]) * j)\n    return dp[n]", "passed": true, "score": {"loc": 7, "tokens": 92, "cc": 2, "nest": 3, "execution_time": 0.016603, "novelty": 0.29997325281001685}}, {"code": "def maxSumAfterPartitioning(arr, k):\n    n = len(arr)\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            dp[i] = max(dp[i], dp[i - j] + max(arr[i - j:i]) * j)\n    return dp[n]", "passed": true, "score": {"loc": 7, "tokens": 92, "cc": 2, "nest": 3, "execution_time": 0.016663, "novelty": 0.3072313963353206}}, {"code": "def maxSumAfterPartitioning(arr, k):\n    n = len(arr)\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        m = 0\n        for j in range(1, min(k, i) + 1):\n            m = max(m, arr[i - j])\n            dp[i] = max(dp[i], dp[i - j] + m * j)\n    return dp[n]", "passed": true, "score": {"loc": 9, "tokens": 98, "cc": 2, "nest": 3, "execution_time": 0.01658, "novelty": 0.19358692167762248}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 6500, "entry_point": "containsNearbyDuplicate", "best_list": [{"code": "def containsNearbyDuplicate(nums, k):\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        if num in num_to_index and i - num_to_index[num] <= k:\n            return True\n        num_to_index[num] = i\n    return False", "passed": true, "score": {"loc": 7, "tokens": 47, "cc": 3, "nest": 3, "execution_time": 0.016567, "novelty": 0.39805376419120553}}, {"code": "def containsNearbyDuplicate(nums, k):\n    seen = {}\n    for i, num in enumerate(nums):\n        if num in seen and i - seen[num] <= k:\n            return True\n        seen[num] = i\n    return False", "passed": true, "score": {"loc": 7, "tokens": 47, "cc": 3, "nest": 3, "execution_time": 0.016637, "novelty": 0.06583280437873718}}, {"code": "def containsNearbyDuplicate(nums, k):\n    num_indices = {}\n    for i, num in enumerate(nums):\n        if num in num_indices and i - num_indices[num] <= k:\n            return True\n        num_indices[num] = i\n    return False", "passed": true, "score": {"loc": 7, "tokens": 47, "cc": 3, "nest": 3, "execution_time": 0.01672, "novelty": 0.2514727136525182}}, {"code": "def containsNearbyDuplicate(nums, k):\n    seen = set()\n    for i, num in enumerate(nums):\n        if num in seen and i - seen[num] <= k:\n            return True\n        seen.add(num)\n        if len(seen) > k:\n            seen.remove(nums[i - k])\n    return False", "passed": false, "score": {"loc": 9, "tokens": 67, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.48946809897154164}}], "num_pass": 9, "num_uniq": 3, "num_fail": 1, "fail_uniq": 1}
{"id": 6560, "entry_point": "calculate", "best_list": [{"code": "def calculate(s: str) -> int:\n    stack, current_number, sign = [], 0, 1\n    for char in s:\n        if char.isdigit():\n            current_number = current_number * 10 + int(char)\n        elif char in '+-':\n            stack.append(current_number * sign)\n            current_number, sign = 0, 1 if char == '+' else -1\n        elif char == '(':\n            stack.append(sign)\n            current_number, sign = 0, 1\n        elif char == ')':\n            stack.append(current_number * sign)\n            sign = 1\n            current_number = sum(stack[-3::-2]) * stack[-2] + (stack[-1] if len(stack) % 2 else 0)\n            stack = stack[:-3]\n    stack.append(current_number * sign)\n    return sum(stack)", "passed": true, "score": {"loc": 18, "tokens": 176, "cc": 5, "nest": 6, "execution_time": 0.016832, "novelty": 0.6941003370510235}}, {"code": "def calculate(s: str) -> int:\n    stack = []\n    num = 0\n    sign = 1\n    result = 0\n\n    for i, char in enumerate(s):\n        if char.isdigit():\n            num = num * 10 + int(char)\n        if char == '+' or char == '-' or char == ')' or i == len(s) - 1:\n            result += sign * num\n            if char == ')':\n                prev_result = stack.pop()\n                result = prev_result + result if stack else result\n            sign = 1 if char == '+' else -1\n            num = 0\n        elif char == '(':\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n\n    return result", "passed": true, "score": {"loc": 21, "tokens": 157, "cc": 6, "nest": 4, "execution_time": 0.01676, "novelty": 0.6587660508995754}}, {"code": "def calculate(expression: str) -> int:\n    stack = []\n    current_number = 0\n    current_operation = '+'\n    \n    def apply_operation():\n        if current_operation == '+':\n            stack.append(current_number)\n        elif current_operation == '-':\n            stack.append(-current_number)\n    \n    for i, char in enumerate(expression):\n        if char.isdigit():\n            current_number = current_number * 10 + int(char)\n        if char in '+-(' or i == len(expression) - 1:\n            apply_operation()\n            current_operation = char\n            current_number = 0\n        if char == ')':\n            sum_of_stack = sum(stack)\n            stack = []\n            apply_operation()\n            stack.append(sum_of_stack)\n    \n    return sum(stack)", "passed": true, "score": {"loc": 22, "tokens": 144, "cc": 7, "nest": 4, "execution_time": 0.016665, "novelty": 0.733541209140885}}, {"code": "def calculate(s: str) -> int:\n    def apply_operator(op, stack):\n        right = stack.pop()\n        left = stack.pop()\n        if op == '+':\n            stack.append(left + right)\n        elif op == '-':\n            stack.append(left - right)\n\n    def evaluate(expression):\n        stack = []\n        num = 0\n        op = '+'\n        i = 0\n        while i < len(expression):\n            if expression[i].isdigit():\n                num = num * 10 + int(expression[i])\n            if expression[i] in '+-(' or i == len(expression) - 1:\n                if op == '+':\n                    stack.append(num)\n                elif op == '-':\n                    stack.append(-num)\n                num = 0\n                op = expression[i]\n                if op == '(':\n                    num, j = evaluate(expression[i + 1:])\n                    i = j\n            i += 1\n        while stack:\n            apply_operator(op, stack)\n        return stack.pop()\n\n    return evaluate(s.replace(' ', ''))", "passed": false, "score": {"loc": 31, "tokens": 235, "cc": 10, "nest": 6, "execution_time": 10.0, "novelty": 0.8239226629278308}}, {"code": "def calculate(s):\n    def helper(s):\n        def consume_space():\n            nonlocal i\n            while i < len(s) and s[i] == ' ':\n                i += 1\n        \n        def parse_number():\n            nonlocal i\n            start = i\n            while i < len(s) and s[i].isdigit():\n                i += 1\n            return int(s[start:i])\n        \n        def parse_term():\n            consume_space()\n            if i < len(s) and s[i] in \"+-\":\n                sign = s[i]\n                i += 1\n                consume_space()\n                num = parse_number()\n                return num if sign == '+' else -num\n            else:\n                return parse_number()\n        \n        def parse_expression():\n            consume_space()\n            result = parse_term()\n            consume_space()\n            while i < len(s) and s[i] in \"+-\":\n                operator = s[i]\n                i += 1\n                consume_space()\n                result += parse_term() if operator == '+' else -parse_term()\n                consume_space()\n            return result\n        \n        consume_space()\n        i = 0\n        return parse_expression()\n    \n    return helper(s)", "passed": false, "score": {"loc": 37, "tokens": 228, "cc": 8, "nest": 4, "execution_time": 10.0, "novelty": 0.8560779677183412}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 6602, "entry_point": "minSteps", "best_list": [{"code": "def minSteps(n):\n    if n == 1:\n        return 0\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return i + minSteps(n // i)\n    return n", "passed": true, "score": {"loc": 7, "tokens": 54, "cc": 3, "nest": 3, "execution_time": 0.016702, "novelty": 0.6062647694953409}}, {"code": "def minSteps(n):\n    steps = 0\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            steps += divisor\n            n //= divisor\n        divisor += 1\n    return steps", "passed": true, "score": {"loc": 9, "tokens": 40, "cc": 2, "nest": 3, "execution_time": 0.016619, "novelty": 0.5537147053509939}}, {"code": "def minSteps(n):\n    steps = 0\n    factor = 2\n    while n > 1:\n        while n % factor == 0:\n            steps += factor\n            n //= factor\n        factor += 1\n    return steps", "passed": true, "score": {"loc": 9, "tokens": 40, "cc": 2, "nest": 3, "execution_time": 0.016744, "novelty": 0.5514987972437544}}, {"code": "def minSteps(n):\n    dp = list(range(n + 1))\n    for i in range(2, n + 1):\n        for j in range(i - 1, 0, -1):\n            if i % j == 0:\n                dp[i] = dp[j] + (i // j)\n                break\n    return dp[n]", "passed": false, "score": {"loc": 8, "tokens": 74, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.6992684206447437}}, {"code": "def minSteps(n):\n    return n if n <= 1 else min(x + minSteps(n // x) for x in range(2, n + 1) if n % x == 0)", "passed": false, "score": {"loc": 2, "tokens": 44, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6071219214447277}}], "num_pass": 7, "num_uniq": 5, "num_fail": 3, "fail_uniq": 2}
{"id": 6631, "entry_point": "jump", "best_list": [{"code": "def jump(nums):\n    def min_jumps(start, end):\n        if start >= end:\n            return 0\n        if nums[start] == 0:\n            return float('inf')\n        return min(1 + min_jumps(start + i, end) for i in range(1, nums[start] + 1))\n    \n    return min_jumps(0, len(nums) - 1)", "passed": true, "score": {"loc": 8, "tokens": 78, "cc": 2, "nest": 3, "execution_time": 0.01661, "novelty": 0.816396036893065}}, {"code": "def jump(nums):\n    jumps = 0\n    current_end = 0\n    farthest = 0\n    \n    for i in range(len(nums) - 1):\n        farthest = max(farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = farthest\n    \n    return jumps", "passed": true, "score": {"loc": 10, "tokens": 56, "cc": 2, "nest": 3, "execution_time": 0.016635, "novelty": 0.2062291059615129}}, {"code": "def jump(nums):\n    n = len(nums)\n    jumps = 0\n    current_end = 0\n    farthest = 0\n    for i in range(n - 1):\n        farthest = max(farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = farthest\n            if current_end >= n - 1:\n                break\n    return jumps", "passed": true, "score": {"loc": 13, "tokens": 68, "cc": 3, "nest": 4, "execution_time": 0.016652, "novelty": 0.45697666645702073}}, {"code": "def jump(nums):\n    jumps = [0] * len(nums)\n    for i in range(len(nums) - 2, -1, -1):\n        if nums[i] == 0:\n            jumps[i] = float('inf')\n        else:\n            jumps[i] = min(jumps[min(i + nums[i], len(nums) - 1)] + 1, jumps[i + 1] if i + 1 < len(nums) else float('inf'))\n    return jumps[0]", "passed": false, "score": {"loc": 8, "tokens": 114, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7514930032906972}}], "num_pass": 9, "num_uniq": 3, "num_fail": 1, "fail_uniq": 1}
{"id": 6643, "entry_point": "maxUniqueSplit", "best_list": [{"code": "def maxUniqueSplit(s):\n    def backtrack(start, path):\n        if start == len(s):\n            return len(path)\n        max_split = 0\n        for end in range(start + 1, len(s) + 1):\n            substring = s[start:end]\n            if substring not in path:\n                max_split = max(max_split, backtrack(end, path | {substring}))\n        return max_split\n\n    return backtrack(0, set())", "passed": true, "score": {"loc": 11, "tokens": 90, "cc": 3, "nest": 4, "execution_time": 0.016667, "novelty": 0.43073121948651183}}, {"code": "def maxUniqueSplit(s):\n    def dfs(start, path):\n        if start == len(s):\n            result[0] = max(result[0], len(path))\n            return\n        for end in range(start + 1, len(s) + 1):\n            substring = s[start:end]\n            if substring not in path:\n                dfs(end, path | {substring})\n    \n    result = [0]\n    dfs(0, set())\n    return result[0]", "passed": true, "score": {"loc": 12, "tokens": 100, "cc": 3, "nest": 4, "execution_time": 0.01686, "novelty": 0.6388264090359399}}, {"code": "def maxUniqueSplit(s):\n    def dfs(start, seen):\n        if start == len(s):\n            return 0\n        max_split = 0\n        for end in range(start + 1, len(s) + 1):\n            substring = s[start:end]\n            if substring not in seen:\n                seen.add(substring)\n                max_split = max(max_split, 1 + dfs(end, seen))\n                seen.remove(substring)\n        return max_split\n    \n    return dfs(0, set())", "passed": true, "score": {"loc": 13, "tokens": 97, "cc": 3, "nest": 4, "execution_time": 0.016692, "novelty": 0.396218857575386}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 6708, "entry_point": "findMaxConsecutiveOnes", "best_list": [{"code": "from itertools import groupby\n\ndef findMaxConsecutiveOnes(nums):\n    return max(len(list(g)) for k, g in groupby(nums) if k == 1)", "passed": true, "score": {"loc": 3, "tokens": 35, "cc": 0, "nest": 1, "execution_time": 0.016672, "novelty": 0.5009471705244499}}, {"code": "from itertools import groupby\n\ndef findMaxConsecutiveOnes(nums):\n    return max(sum(1 for _ in g) for k, g in groupby(nums) if k == 1)", "passed": true, "score": {"loc": 3, "tokens": 36, "cc": 0, "nest": 1, "execution_time": 0.016501, "novelty": 0.5107289660576428}}, {"code": "from itertools import groupby\n\ndef findMaxConsecutiveOnes(nums):\n    return max((sum(1 for _ in g) for k, g in groupby(nums) if k == 1), default=0)", "passed": true, "score": {"loc": 3, "tokens": 42, "cc": 0, "nest": 1, "execution_time": 0.016747, "novelty": 0.5203788768956705}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 6771, "entry_point": "findLHS", "best_list": [{"code": "from collections import Counter\n\ndef findLHS(nums):\n    count = Counter(nums)\n    return max(count[n] + count[n+1] for n in count if count[n+1] > 0)", "passed": true, "score": {"loc": 4, "tokens": 44, "cc": 0, "nest": 1, "execution_time": 0.016576, "novelty": 0.2618719777233167}}, {"code": "from collections import Counter\n\ndef findLHS(nums):\n    count = Counter(nums)\n    return max([count[n] + count[n + 1] for n in count if count[n + 1]], default=0)", "passed": true, "score": {"loc": 4, "tokens": 48, "cc": 0, "nest": 1, "execution_time": 0.016556, "novelty": 0.44280567987709596}}, {"code": "def findLHS(nums):\n    from collections import Counter\n    count = Counter(nums)\n    return max((count[n] + count[n + 1] for n in count if count[n + 1]), default=0)", "passed": true, "score": {"loc": 4, "tokens": 48, "cc": 0, "nest": 1, "execution_time": 0.01656, "novelty": 0.14676878587601272}}, {"code": "from collections import Counter\n\ndef findLHS(nums):\n    count = Counter(nums)\n    return max(count[num] + count[num+1] for num in count if num+1 in count, default=0)", "passed": false, "score": {"loc": 4, "tokens": 45, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.9591687397022092}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 6775, "entry_point": "maxSum", "best_list": [{"code": "def maxSum(nums1, nums2):\n    MOD = 10**9 + 7\n    i, j = 0, 0\n    sum1, sum2 = 0, 0\n    while i < len(nums1) or j < len(nums2):\n        if i < len(nums1) and (j == len(nums2) or nums1[i] < nums2[j]):\n            sum1 += nums1[i]\n            i += 1\n        elif j < len(nums2) and (i == len(nums1) or nums1[i] > nums2[j]):\n            sum2 += nums2[j]\n            j += 1\n        else:\n            sum1 = sum2 = max(sum1, sum2) + nums1[i]\n            i += 1\n            j += 1\n    return max(sum1, sum2) % MOD", "passed": true, "score": {"loc": 16, "tokens": 157, "cc": 8, "nest": 4, "execution_time": 0.016635, "novelty": 0.6052216932047776}}, {"code": "def maxSum(nums1, nums2):\n    MOD = 10**9 + 7\n    i, j = 0, 0\n    sum1, sum2 = 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            sum1 += nums1[i]\n            i += 1\n        elif nums1[i] > nums2[j]:\n            sum2 += nums2[j]\n            j += 1\n        else:\n            sum1 = sum2 = max(sum1, sum2) + nums1[i]\n            i += 1\n            j += 1\n    sum1 += sum(nums1[i:])\n    sum2 += sum(nums2[j:])\n    return max(sum1, sum2) % MOD", "passed": true, "score": {"loc": 18, "tokens": 145, "cc": 4, "nest": 4, "execution_time": 0.016721, "novelty": 0.1517911483573705}}, {"code": "def maxSum(nums1, nums2):\n    i, j = 0, 0\n    mod = 10**9 + 7\n    sum1, sum2 = 0, 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            sum1 += nums1[i]\n            i += 1\n        elif nums1[i] > nums2[j]:\n            sum2 += nums2[j]\n            j += 1\n        else:\n            sum1 = sum2 = max(sum1, sum2) + nums1[i]\n            i += 1\n            j += 1\n    sum1 += sum(nums1[i:])\n    sum2 += sum(nums2[j:])\n    return max(sum1, sum2) % mod", "passed": true, "score": {"loc": 18, "tokens": 145, "cc": 4, "nest": 4, "execution_time": 0.016782, "novelty": 0.18929664575414185}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 6804, "entry_point": "spiralOrder", "best_list": [{"code": "def spiralOrder(matrix):\n    result = []\n    while matrix:\n        result += matrix.pop(0)\n        if matrix and matrix[0]:\n            for row in matrix:\n                result.append(row.pop())\n        if matrix:\n            result += matrix.pop()[::-1]\n        if matrix and matrix[0]:\n            for row in matrix[::-1]:\n                result.append(row.pop(0))\n    return result", "passed": true, "score": {"loc": 13, "tokens": 94, "cc": 8, "nest": 4, "execution_time": 0.016837, "novelty": 0.2975381733431729}}, {"code": "def spiralOrder(matrix):\n    if not matrix:\n        return []\n    \n    result = []\n    while matrix:\n        result += matrix.pop(0)\n        if matrix and matrix[0]:\n            for row in matrix:\n                result.append(row.pop())\n        if matrix:\n            result += matrix.pop()[::-1]\n        if matrix and matrix[0]:\n            for row in matrix[::-1]:\n                result.append(row.pop(0))\n    return result", "passed": true, "score": {"loc": 15, "tokens": 101, "cc": 9, "nest": 4, "execution_time": 0.016727, "novelty": 0.8285020964917827}}, {"code": "def spiralOrder(matrix):\n    result = []\n    while matrix:\n        result += matrix.pop(0)\n        if matrix and matrix[0]:\n            for row in matrix:\n                result.append(row.pop())\n        if matrix:\n            result += matrix.pop()[::-1]\n        if matrix and matrix[0]:\n            for row in matrix[::-1]:\n                result.append(row.pop(0))\n    return result\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "passed": true, "score": {"loc": 15, "tokens": 107, "cc": 8, "nest": 4, "execution_time": 0.016803, "novelty": 0.3413185941148025}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 6906, "entry_point": "shipWithinDays", "best_list": [{"code": "def shipWithinDays(weights, D):\n    left, right = max(weights), sum(weights)\n    while left < right:\n        mid = (left + right) // 2\n        days, current = 1, 0\n        for weight in weights:\n            if current + weight > mid:\n                days += 1\n                current = 0\n            current += weight\n        if days > D:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": true, "score": {"loc": 15, "tokens": 83, "cc": 4, "nest": 4, "execution_time": 0.016589, "novelty": 0.4697467751303426}}, {"code": "def shipWithinDays(weights, D):\n    left, right = max(weights), sum(weights)\n    \n    while left < right:\n        mid = (left + right) // 2\n        current = 0\n        days = 1\n        \n        for weight in weights:\n            if current + weight > mid:\n                days += 1\n                current = 0\n            current += weight\n        \n        if days > D:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left", "passed": true, "score": {"loc": 16, "tokens": 82, "cc": 4, "nest": 4, "execution_time": 0.016532, "novelty": 0.4696731963789633}}, {"code": "def shipWithinDays(weights, D):\n    left, right = max(weights), sum(weights)\n    while left < right:\n        mid = (left + right) // 2\n        days = 1\n        current = 0\n        for w in weights:\n            if current + w > mid:\n                days += 1\n                current = w\n            else:\n                current += w\n        if days > D:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": true, "score": {"loc": 17, "tokens": 84, "cc": 4, "nest": 4, "execution_time": 0.016681, "novelty": 0.47420048988956953}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 6909, "entry_point": "isSolvable", "best_list": [{"code": "from itertools import permutations\n\ndef isSolvable(words, result):\n    chars = set(''.join(words + [result]))\n    if len(chars) > 10 or len(result) > len(words[0]):\n        return False\n    for perm in permutations('0123456789', len(chars)):\n        char_to_digit = dict(zip(chars, perm))\n        if any(char_to_digit[word[0]] == '0' for word in words + [result]):\n            continue\n        if sum(int(''.join(char_to_digit[char] for char in word)) for word in words) == int(''.join(char_to_digit[char] for char in result)):\n            return True\n    return False", "passed": true, "score": {"loc": 12, "tokens": 152, "cc": 5, "nest": 3, "execution_time": 0.016691, "novelty": 0.6492952737019577}}, {"code": "def isSolvable(words, result):\n    from itertools import permutations\n\n    letters = set(''.join(words) + result)\n    if len(letters) > 10 or len(result) > len(words[0]):\n        return False\n\n    for perm in permutations(range(10), len(letters)):\n        letter_to_digit = dict(zip(letters, perm))\n        if any(letter_to_digit[word[0]] == 0 for word in words + [result]):\n            continue\n        if sum(int(''.join(str(letter_to_digit[ch]) for ch in word)) for word in words) == int(''.join(str(letter_to_digit[ch]) for ch in result)):\n            return True\n    return False", "passed": true, "score": {"loc": 12, "tokens": 155, "cc": 5, "nest": 3, "execution_time": 0.016658, "novelty": 0.6771953077738581}}, {"code": "from itertools import permutations\n\ndef isSolvable(words, result):\n    chars = set(''.join(words) + result)\n    if len(chars) > 10:\n        return False\n    if len(result) > max(len(word) for word in words):\n        return False\n    digits = range(10)\n    for perm in permutations(digits, len(chars)):\n        char_to_digit = dict(zip(chars, perm))\n        if any(char_to_digit[word[0]] == 0 for word in words + [result]):\n            continue\n        if sum(int(''.join(map(char_to_digit.__getitem__, word))) for word in words) == int(''.join(map(char_to_digit.__getitem__, result))):\n            return True\n    return False", "passed": true, "score": {"loc": 15, "tokens": 159, "cc": 5, "nest": 3, "execution_time": 0.016623, "novelty": 0.7293839609811703}}, {"code": "def isSolvable(words, result):\n    from itertools import permutations\n\n    def _to_num(word):\n        return int(''.join(str(d) for d in word))\n\n    def _equivalent(lhs, rhs):\n        return _to_num(lhs) == _to_num(rhs)\n\n    chars = set(''.join(words + [result]))\n    if len(chars) > 10:\n        return False\n\n    if len(result) > len(words[0]):\n        words, result = result, words\n\n    leading_chars = set(word[0] for word in words + [result])\n    digits = list(range(10))\n    for perm in permutations(digits, len(chars)):\n        if any(perm[chars.index(c)] == 0 for c in leading_chars):\n            continue\n        if _equivalent(words, result, perm):\n            return True\n    return False", "passed": false, "score": {"loc": 19, "tokens": 177, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.8442639947095261}}, {"code": "from itertools import permutations\n\ndef isSolvable(words, result):\n    from collections import defaultdict\n    from functools import reduce\n    \n    # Collect all unique characters\n    all_chars = set(words + [result])\n    leading_chars = set(w[0] for w in words + [result] if len(w) > 1)\n    \n    # Generate all possible permutations of digit assignments to characters\n    digits = '0123456789'\n    for perm in permutations(digits, len(all_chars)):\n        char_to_digit = dict(zip(all_chars, perm))\n        \n        # Convert words and result to numbers using the current permutation\n        num_words = [int(''.join(char_to_digit[c] for c in word)) for word in words]\n        num_result = int(''.join(char_to_digit[c] for c in result))\n        \n        # Check if the equation holds and no leading character is assigned 0\n        if sum(num_words) == num_result and all(char_to_digit[c] != '0' for c in leading_chars):\n            return True\n    \n    return False", "passed": false, "score": {"loc": 18, "tokens": 196, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7670542661477575}}, {"code": "def isSolvable(words, result):\n    from itertools import permutations\n\n    chars = set(''.join(words) + result)\n    if len(chars) > 10:\n        return False\n\n    def valid(perm):\n        total = 0\n        for word in words:\n            num = int(''.join(str(perm[ord(c) - ord('A')]) for c in word))\n            total += num\n        num = int(''.join(str(perm[ord(c) - ord('A')]) for c in result))\n        return total == num\n\n    for perm in permutations(range(10), len(chars)):\n        if valid(perm) and (len(words[0]) > 1 or perm[ord(words[0][0]) - ord('A')] != 0) and (len(result) > 1 or perm[ord(result[0]) - ord('A')] != 0):\n            return True\n    return False", "passed": false, "score": {"loc": 16, "tokens": 215, "cc": 7, "nest": 3, "execution_time": 10.0, "novelty": 0.7724569888665913}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 6912, "entry_point": "canPartition", "best_list": [{"code": "def canPartition(nums):\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target = total_sum // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        for j in range(target, num - 1, -1):\n            dp[j] = dp[j] or dp[j - num]\n    return dp[target]", "passed": true, "score": {"loc": 11, "tokens": 86, "cc": 4, "nest": 3, "execution_time": 0.016648, "novelty": 0.012672563127453462}}, {"code": "def canPartition(nums):\n    total = sum(nums)\n    if total % 2 != 0:\n        return False\n    target = total // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        for j in range(target, num - 1, -1):\n            dp[j] = dp[j] or dp[j - num]\n    return dp[target]", "passed": true, "score": {"loc": 11, "tokens": 86, "cc": 4, "nest": 3, "execution_time": 0.016739, "novelty": 0.014845128055878343}}, {"code": "def canPartition(nums):\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target = total_sum // 2\n    n = len(nums)\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        for j in range(target, num - 1, -1):\n            dp[j] = dp[j] or dp[j - num]\n    return dp[target]", "passed": true, "score": {"loc": 12, "tokens": 92, "cc": 4, "nest": 3, "execution_time": 0.016493, "novelty": 0.44988116044438686}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 6919, "entry_point": "getMaxRepetitions", "best_list": [{"code": "def getMaxRepetitions(s1, n1, s2, n2):\n    if n1 == 0:\n        return 0\n    \n    idx = 0\n    count = 0\n    s1_length = len(s1)\n    s2_length = len(s2)\n    \n    for _ in range(n1):\n        for char in s1:\n            if char == s2[idx]:\n                idx += 1\n                if idx == s2_length:\n                    idx = 0\n                    count += 1\n    \n    return count // n2", "passed": true, "score": {"loc": 15, "tokens": 82, "cc": 5, "nest": 5, "execution_time": 0.016668, "novelty": 0.5986684825349091}}, {"code": "def getMaxRepetitions(s1, n1, s2, n2):\n    if n1 == 0:\n        return 0\n    \n    s1_len, s2_len = len(s1), len(s2)\n    s1_count, s2_count = 0, 0\n    s2_index = 0\n    \n    while s1_count < n1:\n        s1_count += 1\n        for char in s1:\n            if char == s2[s2_index]:\n                s2_index += 1\n                if s2_index == s2_len:\n                    s2_count += 1\n                    s2_index = 0\n    \n    return s2_count // n2", "passed": true, "score": {"loc": 15, "tokens": 88, "cc": 5, "nest": 5, "execution_time": 0.016576, "novelty": 0.6555167518087104}}, {"code": "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    if n1 == 0:\n        return 0\n    \n    count_s2 = 0\n    index_s1 = 0\n    len_s1 = len(s1)\n    len_s2 = len(s2)\n    \n    for _ in range(n1):\n        for char in s1:\n            if char == s2[index_s1]:\n                index_s1 += 1\n                if index_s1 == len_s2:\n                    count_s2 += 1\n                    index_s1 = 0\n    \n    return count_s2 // n2", "passed": true, "score": {"loc": 15, "tokens": 93, "cc": 5, "nest": 5, "execution_time": 0.0166, "novelty": 0.5979392532559215}}, {"code": "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    if n1 == 0:\n        return 0\n    s1_len, s2_len = len(s1), len(s2)\n    s1_reps, s2_reps = [0], [0]\n    i, j = 0, 0\n\n    while True:\n        i += 1\n        for char in s1:\n            if char == s2[j]:\n                j += 1\n                if j == s2_len:\n                    j = 0\n                    s2_reps.append(s2_reps[-1] + 1)\n        s1_reps.append(i)\n\n        if i - s1_reps[-2] == s1_reps[-1] - s1_reps[-3]:\n            cycle_length = i - s1_reps[-2]\n            cycle_s2_reps = s2_reps[-1] - s2_reps[-2]\n            remaining_length = n1 - s1_reps[-1]\n            full_cycles = remaining_length // cycle_length\n            return (s2_reps[-1] + full_cycles * cycle_s2_reps) // n2", "passed": false, "score": {"loc": 21, "tokens": 188, "cc": 6, "nest": 5, "execution_time": 10.0, "novelty": 0.7241496808611996}}, {"code": "def getMaxRepetitions(s1, n1, s2, n2):\n    if n1 == 0:\n        return 0\n    \n    pos, cnt1, cnt2 = 0, 0, 0\n    seen = {}\n    \n    while cnt1 < n1:\n        pos = s1.find(s2[pos], pos + 1)\n        if pos == -1:\n            pos = s1.find(s2[0])\n            cnt1 += 1\n            cnt2 += 1\n        else:\n            pos += 1\n            cnt1 += 1\n            cnt2 += 1\n        \n        if (pos, cnt2) in seen:\n            break\n    \n    if (pos, cnt2) not in seen:\n        return cnt2 // n2\n    \n    prev_cnt1, prev_cnt2 = seen[(pos, cnt2)]\n    cycle_cnt1 = cnt1 - prev_cnt1\n    cycle_cnt2 = cnt2 - prev_cnt2\n    \n    remaining = n1 - prev_cnt1\n    full_cycles = remaining // cycle_cnt1\n    \n    return (prev_cnt2 + full_cycles * cycle_cnt2) // n2", "passed": false, "score": {"loc": 25, "tokens": 164, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.7569213586604466}}, {"code": "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    if n1 == 0:\n        return 0\n\n    dp = {}\n    p, q = 0, 0\n    count = 0\n\n    for i in range(n1):\n        for char in s1:\n            if char == s2[q]:\n                q += 1\n                if q == len(s2):\n                    q = 0\n                    count += 1\n            if (p, q) in dp:\n                break\n            dp[(p, q)] = i, count\n        p = i + 1\n\n    if (p, q) not in dp:\n        return count // n2\n\n    cycle_start_i, cycle_count = dp[(p, q)]\n    cycle_length = p - cycle_start_i\n    cycle_repetitions = (n1 - cycle_start_i) // cycle_length\n    remaining_count = count - cycle_count\n\n    return (remaining_count + cycle_repetitions * cycle_count) // n2", "passed": false, "score": {"loc": 24, "tokens": 172, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.6824962636204166}}, {"code": "def getMaxRepetitions(s1, n1, s2, n2):\n    if n1 == 0:\n        return 0\n\n    pos, count1, count2 = 0, 0, 0\n    len1, len2 = len(s1), len(s2)\n    repeat = {}\n\n    while count1 < n1:\n        pos = s1.find(s2[pos], pos)\n        if pos == -1:\n            count1 += 1\n            pos = 0\n        else:\n            pos += 1\n            count2 += 1\n\n            if pos == len2:\n                count2, count1 = count2 // n2, count1 + 1\n                pos = 0\n\n            if (pos, count1) in repeat:\n                prev_count1, prev_count2 = repeat[(pos, count1)]\n                cycle_len1 = count1 - prev_count1\n                cycle_len2 = count2 - prev_count2\n                remaining = (n1 - count1) // cycle_len1\n                count1 += remaining * cycle_len1\n                count2 += remaining * cycle_len2\n\n    return count2 // n2", "passed": false, "score": {"loc": 25, "tokens": 169, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.7195371242380934}}, {"code": "def getMaxRepetitions(s1, n1, s2, n2):\n    def count_repetitions(s1, s2):\n        count = i = j = 0\n        while i < len(s1):\n            if s1[i] == s2[j]:\n                j += 1\n                if j == len(s2):\n                    count += 1\n                    j = 0\n            i += 1\n        return count\n\n    if n1 == 0:\n        return 0\n\n    count = 0\n    repetitions = [0] * len(s2)\n    states = {}\n    index = 0\n\n    for _ in range(n1):\n        count += count_repetitions(s1, s2)\n        index = (index + count_repetitions(s1, s2)) % len(s2)\n        if index in states:\n            break\n        states[index] = (count, _)\n\n    if index not in states:\n        return count // n2\n\n    cycle_count = count - states[index][0]\n    cycle_length = _ - states[index][1]\n    full_cycles = (n1 - states[index][1] - 1) // cycle_length\n    remaining_repetitions = count_repetitions(s1[:states[index][1] + full_cycles * cycle_length + len(s1)], s2)\n\n    return (states[index][0] + full_cycles * cycle_count + remaining_repetitions) // n2", "passed": false, "score": {"loc": 30, "tokens": 248, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.8257496294262597}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 6921, "entry_point": "findMaxForm", "best_list": [{"code": "def findMaxForm(arr, m, n):\n    from collections import defaultdict\n    dp = defaultdict(int)\n    for s in arr:\n        count = s.count('0'), s.count('1')\n        for i in range(m, count[0] - 1, -1):\n            for j in range(n, count[1] - 1, -1):\n                dp[i, j] = max(dp[i, j], dp[i - count[0], j - count[1]] + 1)\n    return dp[m, n]", "passed": true, "score": {"loc": 9, "tokens": 122, "cc": 3, "nest": 4, "execution_time": 0.016799, "novelty": 0.3754194116311136}}, {"code": "def findMaxForm(strs, m, n):\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for s in strs:\n        zeros = s.count('0')\n        ones = s.count('1')\n        for i in range(m, zeros - 1, -1):\n            for j in range(n, ones - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n    return dp[m][n]", "passed": true, "score": {"loc": 9, "tokens": 127, "cc": 3, "nest": 4, "execution_time": 0.016617, "novelty": 0.05794882172562177}}, {"code": "from typing import List\n\ndef findMaxForm(strs: List[str], m: int, n: int) -> int:\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for s in strs:\n        zeros = s.count('0')\n        ones = s.count('1')\n        for i in range(m, zeros - 1, -1):\n            for j in range(n, ones - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n    return dp[m][n]", "passed": true, "score": {"loc": 10, "tokens": 143, "cc": 3, "nest": 4, "execution_time": 0.018121, "novelty": 0.14306972235220505}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 7048, "entry_point": "minOperations", "best_list": [{"code": "def minOperations(logs):\n    depth = 0\n    for log in logs:\n        if log == \"../\":\n            depth = max(0, depth - 1)\n        elif log != \"./\":\n            depth += 1\n    return depth", "passed": true, "score": {"loc": 8, "tokens": 49, "cc": 3, "nest": 4, "execution_time": 0.01652, "novelty": 0.04882068769536785}}, {"code": "def minOperations(logs):\n    stack = []\n    for log in logs:\n        if log == \"../\":\n            if stack:\n                stack.pop()\n        elif log != \"./\":\n            stack.append(log)\n    return len(stack)", "passed": true, "score": {"loc": 9, "tokens": 53, "cc": 4, "nest": 4, "execution_time": 0.016765, "novelty": 0.45984654731457797}}], "num_pass": 10, "num_uniq": 2, "num_fail": 0, "fail_uniq": 0}
{"id": 7091, "entry_point": "findPairs", "best_list": [{"code": "def findPairs(nums, k):\n    if k < 0:\n        return 0\n    count = 0\n    num_set = set(nums)\n    for num in num_set:\n        if num + k in num_set:\n            count += 1\n    return count", "passed": true, "score": {"loc": 9, "tokens": 42, "cc": 3, "nest": 3, "execution_time": 0.016479, "novelty": 0.5494172938345403}}, {"code": "def findPairs(nums, k):\n    if k < 0:\n        return 0\n    num_set = set(nums)\n    pairs = set()\n    for num in num_set:\n        if num + k in num_set:\n            pairs.add((num, num + k))\n    return len(pairs)", "passed": true, "score": {"loc": 9, "tokens": 55, "cc": 3, "nest": 3, "execution_time": 0.016541, "novelty": 0.5383895121411499}}, {"code": "def findPairs(nums, k):\n    if k < 0:\n        return 0\n    count = 0\n    num_set = set(nums)\n    if k == 0:\n        return sum(1 for num in num_set if nums.count(num) > 1)\n    for num in num_set:\n        if num + k in num_set:\n            count += 1\n    return count", "passed": true, "score": {"loc": 11, "tokens": 66, "cc": 4, "nest": 3, "execution_time": 0.016704, "novelty": 0.6299847680921695}}, {"code": "def findPairs(nums, k):\n    from collections import Counter\n    count = Counter(nums)\n    return sum(v > 1 for v in count.values()) if k == 0 else sum(k in count for k in count)", "passed": false, "score": {"loc": 4, "tokens": 49, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7137452627395833}}, {"code": "def findPairs(nums, k):\n    if k < 0:\n        return 0\n    count = 0\n    seen = set()\n    duplicates = set()\n    \n    for num in nums:\n        if (num - k) in seen and (num - k) not in duplicates:\n            count += 1\n            duplicates.add(num - k)\n        if (num + k) in seen and (num + k) not in duplicates:\n            count += 1\n            duplicates.add(num + k)\n        seen.add(num)\n    \n    return count", "passed": false, "score": {"loc": 15, "tokens": 101, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.6821508438530264}}, {"code": "def findPairs(nums, k):\n    if k < 0:\n        return 0\n    count = 0\n    seen = set()\n    for num in nums:\n        if num + k in seen:\n            count += 1\n        if num - k in seen:\n            count += 1\n        seen.add(num)\n    return count", "passed": false, "score": {"loc": 12, "tokens": 58, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.5866203559433179}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 7154, "entry_point": "threeSumMulti", "best_list": [{"code": "def threeSumMulti(A, target):\n    count = {}\n    result = 0\n    mod = 10**9 + 7\n    \n    for k, x in enumerate(A):\n        result = (result + count.get(target - x, 0)) % mod\n        for j in range(k):\n            y = A[j]\n            count[x + y] = count.get(x + y, 0) + 1\n    \n    return result", "passed": true, "score": {"loc": 10, "tokens": 86, "cc": 2, "nest": 3, "execution_time": 0.016542, "novelty": 0.8274707731297664}}, {"code": "from collections import Counter\n\ndef threeSumMulti(A, target):\n    count = Counter(A)\n    result = 0\n    for i in range(101):\n        for j in range(i, 101):\n            k = target - i - j\n            if k < 0 or k > 100:\n                continue\n            if i == j == k:\n                result += count[i] * (count[i] - 1) * (count[i] - 2) // 6\n            elif i == j and i != k:\n                result += count[i] * (count[i] - 1) // 2 * count[k]\n            elif i < j and j < k:\n                result += count[i] * count[j] * count[k]\n    return result % (10**9 + 7)\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "passed": true, "score": {"loc": 18, "tokens": 178, "cc": 9, "nest": 6, "execution_time": 0.017095, "novelty": 0.5787632888497471}}, {"code": "from collections import Counter\n\ndef threeSumMulti(A, target):\n    count = Counter(A)\n    result = 0\n    mod = 10**9 + 7\n    \n    for i in range(101):\n        for j in range(i, 101):\n            k = target - i - j\n            if k >= j and k <= 100:\n                if i == j == k:\n                    result += count[i] * (count[i] - 1) * (count[i] - 2) // 6\n                elif i == j != k:\n                    result += count[i] * (count[i] - 1) // 2 * count[k]\n                elif i < j == k:\n                    result += count[i] * count[j] * (count[j] - 1) // 2\n                else:\n                    result += count[i] * count[j] * count[k]\n    \n    return result % mod", "passed": true, "score": {"loc": 18, "tokens": 190, "cc": 7, "nest": 7, "execution_time": 0.016868, "novelty": 0.6000212879440845}}, {"code": "from collections import Counter\nfrom typing import List\n\ndef threeSumMulti(A: List[int], target: int) -> int:\n    count = Counter(A)\n    result = 0\n    MOD = 10**9 + 7\n    \n    for i in sorted(count):\n        for j in sorted(count):\n            k = target - i - j\n            if k in count:\n                if i == j == k:\n                    result += count[i] * (count[i] - 1) * (count[i] - 2) // 6\n                elif i == j != k:\n                    result += count[i] * (count[i] - 1) // 2 * count[k]\n                elif i != j == k:\n                    result += count[j] * (count[j] - 1) // 2 * count[i]\n                else:\n                    result += count[i] * count[j] * count[k]\n                result %= MOD\n    \n    return result", "passed": false, "score": {"loc": 20, "tokens": 199, "cc": 6, "nest": 7, "execution_time": 10.0, "novelty": 0.6614244983517408}}, {"code": "from collections import Counter\n\ndef threeSumMulti(A, target):\n    count = Counter(A)\n    mod = 10**9 + 7\n    result = 0\n\n    # Case 1: All three numbers are the same\n    for num in count:\n        if 3 * num == target:\n            result += count[num] * (count[num] - 1) * (count[num] - 2) // 6\n            result %= mod\n\n    # Case 2: Two numbers are the same, one is different\n    for num1 in count:\n        for num2 in count:\n            if num1 != num2 and num1 + 2 * num2 == target:\n                result += count[num1] * count[num2] * (count[num2] - 1) // 2\n                result %= mod\n\n    # Case 3: All three numbers are different\n    for num1 in count:\n        for num2 in count:\n            for num3 in count:\n                if num1 != num2 and num2 != num3 and num1 != num3 and num1 + num2 + num3 == target:\n                    result += count[num1] * count[num2] * count[num3]\n                    result %= mod\n\n    return result", "passed": false, "score": {"loc": 24, "tokens": 222, "cc": 11, "nest": 5, "execution_time": 10.0, "novelty": 0.6922658126688244}}, {"code": "def threeSumMulti(A, target):\n    A.sort()\n    n = len(A)\n    count = 0\n    for i in range(n - 2):\n        if i > 0 and A[i] == A[i - 1]:\n            continue\n        j, k = i + 1, n - 1\n        while j < k:\n            total = A[i] + A[j] + A[k]\n            if total < target:\n                j += 1\n            elif total > target:\n                k -= 1\n            else:\n                if A[j] == A[k]:\n                    count += k - j\n                else:\n                    count += (k - j) * (k - j + 1) // 2\n                j += 1\n                k -= 1\n                while j < k and A[j] == A[j - 1]:\n                    j += 1\n                while j < k and A[k] == A[k + 1]:\n                    k -= 1\n    return count % (10**9 + 7)", "passed": false, "score": {"loc": 26, "tokens": 205, "cc": 11, "nest": 6, "execution_time": 10.0, "novelty": 0.7753210532850836}}], "num_pass": 7, "num_uniq": 6, "num_fail": 3, "fail_uniq": 3}
{"id": 7166, "entry_point": "shortestPathAllKeys", "best_list": [{"code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    rows, cols = len(grid), len(grid[0])\n    start, keys = None, 0\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '@':\n                start = (r, c)\n            elif grid[r][c].islower():\n                keys |= 1 << (ord(grid[r][c]) - ord('a'))\n    \n    queue = deque([(start[0], start[1], 0)])\n    visited = set((start[0], start[1], 0))\n    moves = 0\n    \n    while queue:\n        for _ in range(len(queue)):\n            r, c, mask = queue.popleft()\n            if mask == keys:\n                return moves\n            \n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != '#':\n                    new_mask = mask\n                    if grid[nr][nc].islower():\n                        new_mask |= 1 << (ord(grid[nr][nc]) - ord('a'))\n                    elif grid[nr][nc].isupper() and (new_mask & (1 << (ord(grid[nr][nc].lower()) - ord('a')))) == 0:\n                        continue\n                    if (nr, nc, new_mask) not in visited:\n                        visited.add((nr, nc, new_mask))\n                        queue.append((nr, nc, new_mask))\n        moves += 1\n    \n    return -1", "passed": true, "score": {"loc": 31, "tokens": 388, "cc": 14, "nest": 7, "execution_time": 0.016916, "novelty": 0.7642358707703292}}, {"code": "from collections import deque\n\ndef shortestPathAllKeys(grid):\n    R, C = len(grid), len(grid[0])\n    keys = set()\n    start = (0, 0)\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == '@':\n                start = (r, c)\n            elif grid[r][c].islower():\n                keys.add(grid[r][c])\n    \n    all_keys = (1 << len(keys)) - 1\n    queue = deque([(start, 0, 0)])\n    visited = set([(start, 0)])\n    \n    while queue:\n        (r, c), keys_collected, moves = queue.popleft()\n        if keys_collected == all_keys:\n            return moves\n        \n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] != '#':\n                new_keys_collected = keys_collected\n                if grid[nr][nc].islower():\n                    new_keys_collected |= 1 << (ord(grid[nr][nc]) - ord('a'))\n                if grid[nr][nc].isupper():\n                    if new_keys_collected & (1 << (ord(grid[nr][nc]) - ord('A'))):\n                        new_keys_collected &= ~(1 << (ord(grid[nr][nc]) - ord('A')))\n                    else:\n                        continue\n                \n                if (nr, nc, new_keys_collected) not in visited:\n                    visited.add((nr, nc, new_keys_collected))\n                    queue.append(((nr, nc), new_keys_collected, moves + 1))\n    \n    return -1", "passed": true, "score": {"loc": 33, "tokens": 395, "cc": 13, "nest": 6, "execution_time": 0.017269, "novelty": 0.6703722114804254}}, {"code": "def shortestPathAllKeys(grid):\n    from collections import deque\n    \n    M, N = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    def get_start_and_keys():\n        start = None\n        keys = set()\n        for i in range(M):\n            for j in range(N):\n                if grid[i][j] == '@':\n                    start = (i, j)\n                elif grid[i][j].islower():\n                    keys.add(grid[i][j])\n        return start, keys\n    \n    start, keys = get_start_and_keys()\n    all_keys = (1 << len(keys)) - 1\n    \n    queue = deque([(start, 0, 0)])\n    visited = set([(start, 0)])\n    \n    while queue:\n        (x, y), key_mask, steps = queue.popleft()\n        \n        if key_mask == all_keys:\n            return steps\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] != '#':\n                new_key_mask = key_mask\n                if grid[nx][ny].islower():\n                    new_key_mask |= 1 << (ord(grid[nx][ny]) - ord('a'))\n                if grid[nx][ny].isupper() and (new_key_mask & (1 << (ord(grid[nx][ny]) - ord('A')))) == 0:\n                    continue\n                if (nx, ny, new_key_mask) not in visited:\n                    visited.add((nx, ny, new_key_mask))\n                    queue.append(((nx, ny), new_key_mask, steps + 1))\n    \n    return -1", "passed": true, "score": {"loc": 34, "tokens": 384, "cc": 13, "nest": 6, "execution_time": 0.016887, "novelty": 0.7754015672792509}}, {"code": "from collections import deque\n\ndef shortestPathAllKeys(self, grid: list[str]) -> int:\n    m, n = len(grid), len(grid[0])\n    keys = sum(1 for c in grid for c in \"abcdef\" if c in c)\n    directions = [0, 1, 0, -1, 0]\n    start = None\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"@\":\n                start = (i, j)\n            elif grid[i][j] in \"abcdef\":\n                keys |= 1 << (ord(grid[i][j]) - ord(\"a\"))\n    queue = deque([(start, 0)])\n    visited = set(queue)\n    while queue:\n        (x, y), state = queue.popleft()\n        if state == keys:\n            return len(visited) - 1\n        for k in range(4):\n            nx, ny = x + directions[k], y + directions[k + 1]\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != \"#\":\n                new_state = state\n                if grid[nx][ny] in \"abcdef\":\n                    new_state |= 1 << (ord(grid[nx][ny]) - ord(\"a\"))\n                if grid[nx][ny].isupper() and not (new_state & (1 << (ord(grid[nx][ny].lower()) - ord(\"a\")))):\n                    continue\n                if (nx, ny, new_state) not in visited:\n                    visited.add((nx, ny, new_state))\n                    queue.append(((nx, ny), new_state))\n    return -1", "passed": false, "score": {"loc": 30, "tokens": 380, "cc": 13, "nest": 5, "execution_time": 10.0, "novelty": 0.8547556821860876}}, {"code": "def shortestPathAllKeys(grid):\n    rows, cols = len(grid), len(grid[0])\n    directions = [0, 1, 0, -1, 0]\n    all_keys = 0\n    start = (0, 0)\n\n    # Find starting point and count all keys\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '@':\n                start = (r, c)\n            elif grid[r][c].islower():\n                all_keys |= 1 << (ord(grid[r][c]) - ord('a'))\n\n    # BFS initialization\n    queue = [(start[0], start[1], 0, 0)]  # (row, col, keys collected, moves)\n    visited = set(queue)\n\n    while queue:\n        r, c, keys, moves = queue.pop(0)\n\n        # Check all four directions\n        for i in range(4):\n            nr, nc = r + directions[i], c + directions[i + 1]\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != '#':\n                if grid[nr][nc].islower():\n                    new_keys = keys | (1 << (ord(grid[nr][nc]) - ord('a')))\n                    if new_keys == all_keys:\n                        return moves + 1\n                    if (nr, nc, new_keys) not in visited:\n                        visited.add((nr, nc, new_keys))\n                        queue.append((nr, nc, new_keys, moves + 1))\n                elif grid[nr][nc].isupper() and (keys & (1 << (ord(grid[nr][nc].lower()) - ord('a')))):\n                    if (nr, nc, keys) not in visited:\n                        visited.add((nr, nc, keys))\n                        queue.append((nr, nc, keys, moves + 1))\n\n    return -1", "passed": false, "score": {"loc": 33, "tokens": 425, "cc": 14, "nest": 7, "execution_time": 10.0, "novelty": 0.7653320500090794}}, {"code": "def shortestPathAllKeys(self, grid):\n    R, C = len(grid), len(grid[0])\n    start = None\n    keys = set()\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == '@':\n                start = (r, c)\n            elif grid[r][c] in 'abcdef':\n                keys.add(grid[r][c])\n    all_keys = ''.join(sorted(keys))\n    target = (1 << len(keys)) - 1\n    q = [(0, start[0], start[1], 0)]\n    visited = set()\n    while q:\n        dist, r, c, state = q.pop(0)\n        if (r, c, state) in visited:\n            continue\n        visited.add((r, c, state))\n        if state == target:\n            return dist\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] != '#':\n                if grid[nr][nc] in 'abcdef':\n                    q.append((dist + 1, nr, nc, state | (1 << (ord(grid[nr][nc]) - ord('a')))))\n                elif grid[nr][nc] in 'ABCDEF' and (state & (1 << (ord(grid[nr][nc]) - ord('A')))):\n                    q.append((dist + 1, nr, nc, state))\n    return -1", "passed": false, "score": {"loc": 29, "tokens": 379, "cc": 13, "nest": 6, "execution_time": 10.0, "novelty": 0.7485680184192331}}, {"code": "def shortestPathAllKeys(grid):\n    rows, cols = len(grid), len(grid[0])\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    start = None\n    keys = set()\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '@':\n                start = (r, c)\n            elif grid[r][c].islower():\n                keys.add(grid[r][c])\n    \n    target = (1 << len(keys)) - 1\n    queue = [(start[0], start[1], 0, 0)]\n    visited = set()\n    \n    while queue:\n        r, c, key_state, moves = queue.pop(0)\n        if (r, c, key_state) in visited:\n            continue\n        visited.add((r, c, key_state))\n        \n        if key_state == target:\n            return moves\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != '#':\n                if grid[nr][nc].islower():\n                    new_key_state = key_state | (1 << (ord(grid[nr][nc]) - ord('a')))\n                    queue.append((nr, nc, new_key_state, moves + 1))\n                elif grid[nr][nc].isupper() and (key_state & (1 << (ord(grid[nr][nc]) - ord('A')))):\n                    queue.append((nr, nc, key_state, moves + 1))\n    \n    return -1", "passed": false, "score": {"loc": 30, "tokens": 371, "cc": 13, "nest": 6, "execution_time": 10.0, "novelty": 0.7431684585742004}}, {"code": "from collections import namedtuple\n\ndef shortestPathAllKeys(grid):\n    n, m = len(grid), len(grid[0])\n    Key = namedtuple('Key', 'x y keys')\n    \n    def get_start():\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '@':\n                    return Key(i, j, 0)\n        return None\n    \n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and grid[x][y] != '#'\n    \n    def get_neighbors(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny):\n                yield nx, ny\n    \n    start = get_start()\n    if not start:\n        return -1\n    \n    target_keys = (1 << k) for k in range(6) if grid[k][0].islower()\n    target_mask = sum(target_keys)\n    \n    queue = [(start.x, start.y, start.keys, 0)]\n    visited = set((start.x, start.y, start.keys))\n    \n    while queue:\n        x, y, keys, steps = queue.pop(0)\n        if keys == target_mask:\n            return steps\n        \n        for nx, ny in get_neighbors(x, y):\n            key = ord(grid[nx][ny]) - ord('a')\n            new_keys = keys\n            if key >= 0:\n                new_keys |= 1 << key\n            if (nx, ny, new_keys) not in visited and is_valid(nx, ny):\n                visited.add((nx, ny, new_keys))\n                queue.append((nx, ny, new_keys, steps + 1))\n    \n    return -1", "passed": false, "score": {"loc": 37, "tokens": 389, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.9770326833673397}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 7177, "entry_point": "wordBreak", "best_list": [{"code": "def wordBreak(s, wordDict):\n    def dp(i):\n        if i == len(s):\n            return True\n        return any(dp(j) for j in range(i + 1, len(s) + 1) if s[i:j] in wordDict)\n    \n    return dp(0)", "passed": true, "score": {"loc": 6, "tokens": 63, "cc": 1, "nest": 3, "execution_time": 0.01669, "novelty": 0.8256228499000102}}, {"code": "def wordBreak(s, wordDict):\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n    return dp[-1]", "passed": true, "score": {"loc": 6, "tokens": 77, "cc": 2, "nest": 2, "execution_time": 0.016693, "novelty": 0.6187650912797918}}, {"code": "def wordBreak(s, wordDict):\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordDict:\n                dp[i] = True\n                break\n    return dp[len(s)]", "passed": true, "score": {"loc": 9, "tokens": 81, "cc": 4, "nest": 4, "execution_time": 0.016726, "novelty": 0.4297247868124495}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 7253, "entry_point": "smallestRangeI", "best_list": [{"code": "def smallestRangeI(A, K):\n    return max(0, max(A) - min(A) - 2 * K)", "passed": true, "score": {"loc": 2, "tokens": 27, "cc": 0, "nest": 1, "execution_time": 0.016637, "novelty": 0.12044677420955197}}, {"code": "def smallestRangeI(A, K):\n    if not A or K < 0:\n        return 0\n    return max(0, max(A) - min(A) - 2 * K)", "passed": true, "score": {"loc": 4, "tokens": 37, "cc": 2, "nest": 2, "execution_time": 0.016658, "novelty": 0.6263285055297954}}, {"code": "def smallestRangeI(A, K):\n    if not A:\n        return 0\n    min_val, max_val = min(A), max(A)\n    return max(0, max_val - min_val - 2 * K)", "passed": true, "score": {"loc": 5, "tokens": 40, "cc": 1, "nest": 2, "execution_time": 0.016629, "novelty": 0.6942859358131018}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 7362, "entry_point": "findLucky", "best_list": [{"code": "from collections import Counter\n\ndef findLucky(arr):\n    return max((num for num, freq in Counter(arr).items() if num == freq), default=-1)", "passed": true, "score": {"loc": 3, "tokens": 40, "cc": 0, "nest": 1, "execution_time": 0.016541, "novelty": 0.4482650990820263}}, {"code": "def findLucky(arr):\n    from collections import Counter\n    count = Counter(arr)\n    return max((x for x in count if count[x] == x), default=-1)", "passed": true, "score": {"loc": 4, "tokens": 40, "cc": 0, "nest": 1, "execution_time": 0.016492, "novelty": 0.48921970055410524}}, {"code": "def findLucky(arr):\n    from collections import Counter\n    count = Counter(arr)\n    return max((num for num, freq in count.items() if num == freq), default=-1)", "passed": true, "score": {"loc": 4, "tokens": 43, "cc": 0, "nest": 1, "execution_time": 0.016452, "novelty": 0.4258575953032572}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 773, "entry_point": "hammingDistance", "best_list": [{"code": "def hammingDistance(x, y):\n    return bin(x ^ y).count('1')", "passed": true, "score": {"loc": 2, "tokens": 22, "cc": 0, "nest": 1, "execution_time": 0.01669, "novelty": 0.4126970674447866}}, {"code": "def hammingDistance(x, y):\n    xor_result = x ^ y\n    distance = 0\n    while xor_result:\n        distance += xor_result & 1\n        xor_result >>= 1\n    return distance", "passed": true, "score": {"loc": 7, "tokens": 32, "cc": 1, "nest": 2, "execution_time": 0.016454, "novelty": 0.32543756356240605}}, {"code": "def hammingDistance(x, y):\n    xor = x ^ y\n    distance = 0\n    while xor:\n        distance += xor & 1\n        xor >>= 1\n    return distance", "passed": true, "score": {"loc": 7, "tokens": 32, "cc": 1, "nest": 2, "execution_time": 0.01662, "novelty": 0.31978910226179125}}, {"code": "def hammingDistance(x, y):\n    return (x ^ y).bit_count()", "passed": false, "score": {"loc": 2, "tokens": 18, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.38990668939883755}}], "num_pass": 7, "num_uniq": 5, "num_fail": 3, "fail_uniq": 1}
{"id": 784, "entry_point": "repeatedStringMatch", "best_list": [{"code": "def repeatedStringMatch(A, B):\n    q, r = divmod(len(B), len(A))\n    for i in range(2):\n        if B in A * (q + i):\n            return q + i\n    return -1", "passed": true, "score": {"loc": 6, "tokens": 50, "cc": 2, "nest": 3, "execution_time": 0.0167, "novelty": 0.51784000336111}}, {"code": "def repeatedStringMatch(A, B):\n    count = 1\n    while B not in A * count:\n        count += 1\n        if count > 10000 // len(A) + 1:\n            return -1\n    return count", "passed": true, "score": {"loc": 7, "tokens": 41, "cc": 2, "nest": 3, "execution_time": 0.019598, "novelty": 0.4815596885085789}}, {"code": "def repeatedStringMatch(A: str, B: str) -> int:\n    if B in A:\n        return 1\n    for i in range(1, 10001):\n        if B in A * i:\n            return i\n    return -1", "passed": true, "score": {"loc": 7, "tokens": 44, "cc": 3, "nest": 3, "execution_time": 0.115399, "novelty": 0.5497699945839682}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 7526, "entry_point": "findMin", "best_list": [{"code": "def findMin(nums):\n    return min(nums)", "passed": true, "score": {"loc": 2, "tokens": 11, "cc": 0, "nest": 1, "execution_time": 0.01648, "novelty": 0.5334004699563611}}, {"code": "def findMin(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]", "passed": true, "score": {"loc": 9, "tokens": 59, "cc": 2, "nest": 3, "execution_time": 0.016589, "novelty": 0.29491813061802985}}, {"code": "def findMin(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < nums[right]:\n            right = mid\n        else:\n            left = mid + 1\n    return nums[left]", "passed": true, "score": {"loc": 9, "tokens": 59, "cc": 2, "nest": 3, "execution_time": 0.016768, "novelty": 0.34478817610211054}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 7575, "entry_point": "sumSubarrayMins", "best_list": [{"code": "def sumSubarrayMins(A):\n    MOD = 10**9 + 7\n    total = 0\n    for i in range(len(A)):\n        min_val = A[i]\n        for j in range(i, len(A)):\n            min_val = min(min_val, A[j])\n            total = (total + min_val) % MOD\n    return total", "passed": true, "score": {"loc": 9, "tokens": 69, "cc": 2, "nest": 3, "execution_time": 0.0166, "novelty": 0.6274290486194529}}, {"code": "def sumSubarrayMins(A):\n    MOD = 10**9 + 7\n    stack = []\n    A = [0] + A + [0]\n    result = 0\n    for i, a in enumerate(A):\n        while stack and A[stack[-1]] > a:\n            j = stack.pop()\n            k = stack[-1]\n            result += A[j] * (i - j) * (j - k)\n        stack.append(i)\n    return result % MOD", "passed": true, "score": {"loc": 12, "tokens": 99, "cc": 3, "nest": 3, "execution_time": 0.01656, "novelty": 0.435465090647725}}, {"code": "def sumSubarrayMins(A):\n    MOD = 10**9 + 7\n    total_sum = 0\n    stack = []\n    A = [0] + A + [0]\n    for i, num in enumerate(A):\n        while stack and A[stack[-1]] > num:\n            j = stack.pop()\n            k = stack[-1]\n            total_sum = (total_sum + A[j] * (i - j) * (j - k)) % MOD\n        stack.append(i)\n    return total_sum", "passed": true, "score": {"loc": 12, "tokens": 102, "cc": 3, "nest": 3, "execution_time": 0.01659, "novelty": 0.4272859616159407}}, {"code": "def sumSubarrayMins(A):\n    MOD = 10**9 + 7\n    n = len(A)\n    stack = []\n    left = [0] * n\n    right = [n] * n\n\n    for i in range(n):\n        while stack and A[stack[-1]] > A[i]:\n            stack.pop()\n        if stack:\n            left[i] = i - stack[-1]\n        stack.append(i)\n\n    stack = []\n    for i in range(n-1, -1, -1):\n        while stack and A[stack[-1]] >= A[i]:\n            stack.pop()\n        if stack:\n            right[i] = stack[-1] - i\n        stack.append(i)\n\n    return sum(A[i] * left[i] * right[i] for i in range(n)) % MOD", "passed": false, "score": {"loc": 20, "tokens": 180, "cc": 8, "nest": 3, "execution_time": 10.0, "novelty": 0.6446154345658575}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 7608, "entry_point": "minPatches", "best_list": [{"code": "def minPatches(nums, n):\n    i, max_reach, patches = 0, 1, 0\n    while max_reach <= n:\n        if i < len(nums) and nums[i] <= max_reach:\n            max_reach += nums[i]\n            i += 1\n        else:\n            max_reach += max_reach\n            patches += 1\n    return patches", "passed": true, "score": {"loc": 10, "tokens": 64, "cc": 3, "nest": 3, "execution_time": 0.016545, "novelty": 0.4191641552467922}}, {"code": "def minPatches(nums, n):\n    i, patch_count, max_reach = 0, 0, 0\n    while max_reach < n:\n        if i < len(nums) and nums[i] <= max_reach + 1:\n            max_reach += nums[i]\n            i += 1\n        else:\n            max_reach += max_reach + 1\n            patch_count += 1\n    return patch_count", "passed": true, "score": {"loc": 10, "tokens": 67, "cc": 3, "nest": 3, "execution_time": 0.016544, "novelty": 0.374156586384374}}, {"code": "def minPatches(nums, n):\n    patch_count = 0\n    i, reach = 0, 1\n    while reach <= n:\n        if i < len(nums) and nums[i] <= reach:\n            reach += nums[i]\n            i += 1\n        else:\n            reach += reach\n            patch_count += 1\n    return patch_count", "passed": true, "score": {"loc": 11, "tokens": 63, "cc": 3, "nest": 3, "execution_time": 0.016551, "novelty": 0.25139639101720435}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 7686, "entry_point": "numRollsToTarget", "best_list": [{"code": "def numRollsToTarget(d, f, target):\n    MOD = 10**9 + 7\n    dp = [[0] * (target + 1) for _ in range(d + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, d + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = sum(dp[i - 1][j - k] for k in range(1, f + 1) if j >= k) % MOD\n\n    return dp[d][target]", "passed": true, "score": {"loc": 8, "tokens": 121, "cc": 2, "nest": 3, "execution_time": 0.016642, "novelty": 0.47152324963056513}}, {"code": "def numRollsToTarget(d: int, f: int, target: int) -> int:\n    MOD = 10**9 + 7\n    dp = [[0] * (target + 1) for _ in range(d + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, d + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = sum(dp[i - 1][j - k] for k in range(1, f + 1) if j - k >= 0) % MOD\n\n    return dp[d][target]", "passed": true, "score": {"loc": 8, "tokens": 132, "cc": 2, "nest": 3, "execution_time": 0.016742, "novelty": 0.44907523203320854}}, {"code": "def numRollsToTarget(d, f, target):\n    MOD = 10**9 + 7\n    dp = [[0] * (target + 1) for _ in range(d + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, d + 1):\n        for j in range(1, target + 1):\n            for k in range(1, f + 1):\n                if j >= k:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % MOD\n\n    return dp[d][target]", "passed": true, "score": {"loc": 10, "tokens": 130, "cc": 4, "nest": 5, "execution_time": 0.01685, "novelty": 0.5274214576850318}}, {"code": "def numRollsToTarget(d, f, target):\n    MOD = 10**9 + 7\n    dp = [[0] * (target + 1) for _ in range(d + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, d + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = sum(dp[i-1][max(0, j-k)] for k in range(1, f + 1)) % MOD\n\n    return dp[d][target]", "passed": false, "score": {"loc": 8, "tokens": 121, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.491196147098262}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 7774, "entry_point": "maxProfit", "best_list": [{"code": "def maxProfit(prices):\n    first_buy, first_sell = float('inf'), 0\n    second_buy, second_sell = float('inf'), 0\n    \n    for price in prices:\n        first_buy = min(first_buy, price)\n        first_sell = max(first_sell, price - first_buy)\n        second_buy = min(second_buy, price - first_sell)\n        second_sell = max(second_sell, price - second_buy)\n    \n    return second_sell", "passed": true, "score": {"loc": 9, "tokens": 75, "cc": 1, "nest": 2, "execution_time": 0.016615, "novelty": 0.6468792382030824}}, {"code": "def maxProfit(prices):\n    if not prices:\n        return 0\n\n    first_buy, first_sell = float('-inf'), 0\n    second_buy, second_sell = float('-inf'), 0\n\n    for price in prices:\n        first_buy = max(first_buy, -price)\n        first_sell = max(first_sell, first_buy + price)\n        second_buy = max(second_buy, first_sell - price)\n        second_sell = max(second_sell, second_buy + price)\n\n    return second_sell", "passed": true, "score": {"loc": 11, "tokens": 84, "cc": 2, "nest": 2, "execution_time": 0.016623, "novelty": 0.6676379732631632}}, {"code": "def maxProfit(prices):\n    n = len(prices)\n    if n == 0:\n        return 0\n    \n    first_buy, first_sell, second_buy, second_sell = float('-inf'), 0, float('-inf'), 0\n    \n    for price in prices:\n        first_buy = max(first_buy, -price)\n        first_sell = max(first_sell, first_buy + price)\n        second_buy = max(second_buy, first_sell - price)\n        second_sell = max(second_sell, second_buy + price)\n    \n    return second_sell", "passed": true, "score": {"loc": 11, "tokens": 93, "cc": 2, "nest": 2, "execution_time": 0.016531, "novelty": 0.7007317004285775}}, {"code": "def maxProfit(prices):\n    if not prices:\n        return 0\n    \n    n = len(prices)\n    left_profits = [0] * n\n    right_profits = [0] * n\n    \n    min_price = float('inf')\n    for i in range(n):\n        min_price = min(min_price, prices[i])\n        left_profits[i] = max(left_profits[i - 1], prices[i] - min_price)\n    \n    max_price = float('-inf')\n    for i in range(n - 1, -1, -1):\n        max_price = max(max_price, prices[i])\n        right_profits[i] = max(right_profits[i + 1], max_price - prices[i])\n    \n    max_profit = 0\n    for i in range(n):\n        max_profit = max(max_profit, left_profits[i] + right_profits[i])\n    \n    return max_profit", "passed": false, "score": {"loc": 18, "tokens": 166, "cc": 4, "nest": 2, "execution_time": 10.0, "novelty": 0.7206633125079638}}, {"code": "def maxProfit(prices):\n    if not prices:\n        return 0\n\n    n = len(prices)\n    profit = 0\n    min_price = prices[0]\n\n    for i in range(1, n):\n        if prices[i] < min_price:\n            min_price = prices[i]\n        else:\n            profit = max(profit, prices[i] - min_price)\n\n    return profit", "passed": false, "score": {"loc": 12, "tokens": 68, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7632471826724992}}, {"code": "def maxProfit(prices):\n    if not prices:\n        return 0\n    \n    n = len(prices)\n    dp = [[0] * 3 for _ in range(n)]\n    \n    for i in range(1, n):\n        max_diff = -prices[0]\n        for j in range(1, 3):\n            dp[i][j] = max(dp[i - 1][j], prices[i] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j - 1] - prices[i])\n    \n    return dp[-1][2]", "passed": false, "score": {"loc": 11, "tokens": 120, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7389369140433419}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 7793, "entry_point": "findBestValue", "best_list": [{"code": "def findBestValue(arr, target):\n    arr.sort()\n    n = len(arr)\n    prefix_sum = 0\n    for i, num in enumerate(arr):\n        prefix_sum += num\n        if prefix_sum + (n - i - 1) * num >= target:\n            return (target - prefix_sum) // (n - i - 1) if n - i - 1 != 0 else arr[-1]\n    return arr[-1]", "passed": true, "score": {"loc": 9, "tokens": 88, "cc": 2, "nest": 3, "execution_time": 0.016734, "novelty": 0.7470041083589166}}, {"code": "def findBestValue(arr, target):\n    arr.sort()\n    prefix_sum = [0]\n    for num in arr:\n        prefix_sum.append(prefix_sum[-1] + num)\n    \n    n = len(arr)\n    left, right = 0, max(arr)\n    \n    while left < right:\n        mid = (left + right) // 2\n        idx = bisect.bisect(arr, mid)\n        current_sum = prefix_sum[idx] + mid * (n - idx)\n        \n        if current_sum == target:\n            return mid\n        elif current_sum < target:\n            left = mid + 1\n        else:\n            right = mid\n    \n    idx = bisect.bisect(arr, left)\n    if idx == 0 or abs(target - prefix_sum[idx] - left * (n - idx)) < abs(target - prefix_sum[idx - 1] - left * (n - idx - 1)):\n        return left\n    else:\n        return left - 1", "passed": false, "score": {"loc": 22, "tokens": 177, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.6733936573204415}}, {"code": "def findBestValue(arr, target):\n    arr.sort()\n    acc = [0]\n    for num in arr:\n        acc.append(acc[-1] + num)\n    \n    left, right = 0, arr[-1]\n    while left < right:\n        mid = (left + right) // 2\n        idx = bisect.bisect_right(arr, mid)\n        if acc[idx] + mid * (len(arr) - idx) < target:\n            left = mid + 1\n        else:\n            right = mid\n    \n    idx = bisect.bisect_right(arr, left)\n    if idx == 0:\n        return left\n    sum_before = acc[idx - 1]\n    diff_before = abs(sum_before + left * idx - target)\n    sum_after = acc[-1] - sum_before\n    diff_after = abs(sum_after + left * (len(arr) - idx) - target)\n    \n    if diff_before <= diff_after:\n        return arr[idx - 1]\n    else:\n        return left", "passed": false, "score": {"loc": 24, "tokens": 183, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.6739150097445021}}, {"code": "def findBestValue(arr, target):\n    arr.sort()\n    prefix_sum = [0]\n    for num in arr:\n        prefix_sum.append(prefix_sum[-1] + num)\n    n = len(arr)\n    left, right = 0, arr[-1]\n    best_value = 0\n    best_diff = float('inf')\n    while left <= right:\n        mid = (left + right) // 2\n        idx = bisect_right(arr, mid)\n        current_sum = prefix_sum[idx] + (n - idx) * mid\n        diff = abs(target - current_sum)\n        if diff < best_diff:\n            best_diff = diff\n            best_value = mid\n        if current_sum < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return best_value", "passed": false, "score": {"loc": 22, "tokens": 139, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.634225187227241}}, {"code": "def findBestValue(arr, target):\n    arr.sort()\n    cumsum = [0]\n    for num in arr:\n        cumsum.append(cumsum[-1] + num)\n    \n    left, right = 0, max(arr)\n    while left < right:\n        mid = (left + right) // 2\n        idx = bisect.bisect_right(arr, mid)\n        if cumsum[idx] + mid * (len(arr) - idx) < target:\n            left = mid + 1\n        else:\n            right = mid\n    \n    idx = bisect.bisect_right(arr, left)\n    value1 = cumsum[idx] + left * (len(arr) - idx)\n    value2 = cumsum[idx - 1] + left * (len(arr) - idx + 1)\n    return left if abs(value1 - target) <= abs(value2 - target) else left - 1", "passed": false, "score": {"loc": 17, "tokens": 168, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7026664960570129}}, {"code": "def findBestValue(arr, target):\n    left, right = 0, max(arr) + 1\n    while left < right:\n        mid = (left + right) // 2\n        current_sum = sum(min(mid, x) for x in arr)\n        if current_sum == target:\n            return mid\n        elif current_sum < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left if abs(target - sum(min(left, x) for x in arr)) < abs(target - sum(min(right, x) for x in arr)) else right", "passed": false, "score": {"loc": 12, "tokens": 115, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7700495122340647}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 7895, "entry_point": "minNumberOperations", "best_list": [{"code": "def minNumberOperations(target):\n    return sum(max(target[i] - target[i-1], 0) for i in range(1, len(target))) + target[0]", "passed": true, "score": {"loc": 2, "tokens": 43, "cc": 0, "nest": 1, "execution_time": 0.01664, "novelty": 0.3527809677162588}}, {"code": "def minNumberOperations(target):\n    return sum(max(0, target[i] - target[i - 1]) for i in range(1, len(target))) + target[0]", "passed": true, "score": {"loc": 2, "tokens": 43, "cc": 0, "nest": 1, "execution_time": 0.016714, "novelty": 0.3984075398168304}}, {"code": "def minNumberOperations(target):\n    increments = 0\n    for i in range(1, len(target)):\n        increments += max(0, target[i] - target[i-1])\n    return increments + target[0]", "passed": true, "score": {"loc": 5, "tokens": 48, "cc": 1, "nest": 2, "execution_time": 0.016714, "novelty": 0.6718297676193244}}, {"code": "def minNumberOperations(target):\n    return sum(map(lambda x: max(0, target[x] - target[x-1]), range(1, len(target))))", "passed": false, "score": {"loc": 2, "tokens": 42, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5752187534078794}}], "num_pass": 9, "num_uniq": 5, "num_fail": 1, "fail_uniq": 1}
{"id": 804, "entry_point": "largestPerimeter", "best_list": [{"code": "def largestPerimeter(A):\n    A.sort(reverse=True)\n    for i in range(len(A) - 2):\n        if A[i] < A[i + 1] + A[i + 2]:\n            return A[i] + A[i + 1] + A[i + 2]\n    return 0", "passed": true, "score": {"loc": 6, "tokens": 68, "cc": 2, "nest": 3, "execution_time": 0.016526, "novelty": 0.0}}], "num_pass": 10, "num_uniq": 1, "num_fail": 0, "fail_uniq": 0}
{"id": 811, "entry_point": "maxProfit", "best_list": [{"code": "def maxProfit(prices):\n    if not prices:\n        return 0\n\n    buy, sell, cool = float('-inf'), 0, 0\n    for price in prices:\n        buy, sell, cool = max(buy, cool - price), buy + price, max(cool, sell)\n    return max(sell, cool)", "passed": true, "score": {"loc": 7, "tokens": 66, "cc": 2, "nest": 2, "execution_time": 0.016503, "novelty": 0.6049777729527505}}, {"code": "def maxProfit(prices):\n    if not prices:\n        return 0\n    \n    n = len(prices)\n    hold, sold, reset = float('-inf'), float('-inf'), 0\n    \n    for price in prices:\n        hold, sold, reset = max(hold, reset - price), hold + price, max(reset, sold)\n    \n    return max(sold, reset)", "passed": true, "score": {"loc": 8, "tokens": 78, "cc": 2, "nest": 2, "execution_time": 0.016643, "novelty": 0.667223295839376}}, {"code": "def maxProfit(prices):\n    if not prices:\n        return 0\n\n    n = len(prices)\n    dp = [0] * n\n    for i in range(1, n):\n        dp[i] = max(dp[i-1], prices[i] - prices[i-1] + (dp[i-2] if i >= 2 else 0))\n    return dp[-1]", "passed": true, "score": {"loc": 8, "tokens": 83, "cc": 2, "nest": 2, "execution_time": 0.01658, "novelty": 0.6232372431952344}}, {"code": "def maxProfit(prices):\n    def dp(i, holding):\n        if i >= len(prices):\n            return 0\n        if (i, holding) in memo:\n            return memo[(i, holding)]\n        if holding:\n            profit = max(dp(i + 1, False) + prices[i], dp(i + 1, True))\n        else:\n            profit = max(dp(i + 1, True) - prices[i] - cooldown, dp(i + 1, False))\n        memo[(i, holding)] = profit\n        return profit\n\n    memo = {}\n    cooldown = 1\n    return dp(0, False)", "passed": false, "score": {"loc": 15, "tokens": 130, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.8458389256851151}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 817, "entry_point": "rob", "best_list": [{"code": "def rob(houses):\n    def rob_linear(houses):\n        prev1, prev2 = 0, 0\n        for house in houses:\n            prev1, prev2 = prev2, max(prev1 + house, prev2)\n        return prev2\n\n    if not houses:\n        return 0\n    if len(houses) == 1:\n        return houses[0]\n\n    return max(rob_linear(houses[:-1]), rob_linear(houses[1:]))", "passed": true, "score": {"loc": 11, "tokens": 82, "cc": 3, "nest": 3, "execution_time": 0.016738, "novelty": 0.43891803304460575}}, {"code": "def rob(nums):\n    def rob_linear(houses):\n        dp = [0, 0]\n        for house in houses:\n            dp.append(max(dp[-1], dp[-2] + house))\n        return dp[-1]\n\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    return max(rob_linear(nums[1:]), rob_linear(nums[:-1]))", "passed": true, "score": {"loc": 11, "tokens": 93, "cc": 3, "nest": 3, "execution_time": 0.016609, "novelty": 0.7598098656131835}}, {"code": "def rob(houses):\n    def rob_linear(houses):\n        dp = [0] * (len(houses) + 1)\n        dp[1] = houses[0]\n        for i in range(2, len(houses) + 1):\n            dp[i] = max(dp[i-1], dp[i-2] + houses[i-1])\n        return dp[-1]\n\n    if not houses:\n        return 0\n    if len(houses) == 1:\n        return houses[0]\n    return max(rob_linear(houses[:-1]), rob_linear(houses[1:]))", "passed": true, "score": {"loc": 12, "tokens": 126, "cc": 3, "nest": 3, "execution_time": 0.016602, "novelty": 0.5999564746058115}}, {"code": "def rob(houses):\n    def rob_linear(houses):\n        if not houses:\n            return 0\n        if len(houses) == 1:\n            return houses[0]\n        prev1, prev2 = 0, 0\n        for house in houses:\n            prev1, prev2 = prev2, max(prev1, prev2 + house)\n        return prev2\n\n    if not houses:\n        return 0\n    if len(houses) == 1:\n        return houses[0]\n    return max(rob_linear(houses[:-1]), rob_linear(houses[1:]))", "passed": false, "score": {"loc": 15, "tokens": 102, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.4677991430813626}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 1}
{"id": 8014, "entry_point": "shortestPalindrome", "best_list": [{"code": "def shortestPalindrome(s):\n    n = len(s)\n    rev = s[::-1]\n    for i in range(n + 1):\n        if s.startswith(rev[i:]):\n            return rev[:i] + s", "passed": true, "score": {"loc": 6, "tokens": 51, "cc": 2, "nest": 3, "execution_time": 0.016474, "novelty": 0.6330344777966552}}, {"code": "def shortestPalindrome(s):\n    if not s:\n        return \"\"\n    \n    for i in range(len(s), -1, -1):\n        if s[:i] == s[:i][::-1]:\n            return s[i:][::-1] + s", "passed": true, "score": {"loc": 6, "tokens": 64, "cc": 3, "nest": 3, "execution_time": 0.016581, "novelty": 0.4573367138637322}}, {"code": "def shortestPalindrome(s):\n    if s == s[::-1]:\n        return s\n    for i in range(len(s), 0, -1):\n        if s[:i] == s[:i][::-1]:\n            return s[i:][::-1] + s", "passed": true, "score": {"loc": 6, "tokens": 70, "cc": 3, "nest": 3, "execution_time": 0.016671, "novelty": 0.4140758598112677}}, {"code": "def shortestPalindrome(s: str) -> str:\n    if s == s[::-1]:\n        return s\n    for i in range(len(s)):\n        if s[i:] == s[i:][::-1]:\n            return s[:i][::-1] + s", "passed": false, "score": {"loc": 6, "tokens": 70, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.3139238304008827}}, {"code": "def shortestPalindrome(s):\n    if s == s[::-1]:\n        return s\n    for i in range(len(s)):\n        if s[:i] == s[:i][::-1]:\n            return s[i:][::-1] + s", "passed": false, "score": {"loc": 6, "tokens": 65, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.287201196073088}}, {"code": "def shortestPalindrome(s):\n    if s == s[::-1]:\n        return s\n    \n    for i in range(len(s)):\n        if s[i:] == s[i:][::-1]:\n            return s[:i][::-1] + s\n    \n    return s", "passed": false, "score": {"loc": 7, "tokens": 67, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.3121789645954327}}, {"code": "def shortestPalindrome(s):\n    if s == s[::-1]:\n        return s\n    for i in range(len(s)):\n        if s[i:] == s[i:][::-1]:\n            return s[:i][::-1] + s", "passed": false, "score": {"loc": 6, "tokens": 65, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.3032154722278324}}, {"code": "def shortestPalindrome(s):\n    if not s:\n        return \"\"\n    for i in range(len(s)):\n        if s[i:] == s[i:][::-1]:\n            return s[:i][::-1] + s", "passed": false, "score": {"loc": 6, "tokens": 58, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.2661876188532555}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 8045, "entry_point": "backspaceCompare", "best_list": [{"code": "def backspaceCompare(S, T):\n    def build(s):\n        result = []\n        for char in s:\n            if char != '#':\n                result.append(char)\n            elif result:\n                result.pop()\n        return ''.join(result)\n    return build(S) == build(T)", "passed": true, "score": {"loc": 10, "tokens": 64, "cc": 3, "nest": 5, "execution_time": 0.016429, "novelty": 0.4364516271683817}}, {"code": "def backspaceCompare(S, T):\n    def build(s):\n        stack = []\n        for char in s:\n            if char == '#' and stack:\n                stack.pop()\n            elif char != '#':\n                stack.append(char)\n        return ''.join(stack)\n    \n    return build(S) == build(T)", "passed": true, "score": {"loc": 10, "tokens": 71, "cc": 4, "nest": 5, "execution_time": 0.01655, "novelty": 0.5730921401889332}}, {"code": "def backspaceCompare(S: str, T: str) -> bool:\n    def process_string(s: str) -> str:\n        result = []\n        for char in s:\n            if char != '#':\n                result.append(char)\n            elif result:\n                result.pop()\n        return ''.join(result)\n    \n    return process_string(S) == process_string(T)", "passed": true, "score": {"loc": 10, "tokens": 76, "cc": 3, "nest": 5, "execution_time": 0.016648, "novelty": 0.4881238399510539}}, {"code": "def backspaceCompare(S: str, T: str) -> bool:\n    def process(s: str) -> str:\n        return ''.join(c for c in reversed(s) if c != '#' or not (yield from range(next((i for i, ch in enumerate(s) if ch == '#'), len(s), -1) - 1)))\n\n    return process(S) == process(T)", "passed": false, "score": {"loc": 4, "tokens": 100, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.6478165332784367}}, {"code": "def backspaceCompare(S, T):\n    def build(s):\n        return ''.join(c for c in reversed(s) if c != '#' or (c == '#' and (yield)))\n\n    return build(S) == build(T)", "passed": false, "score": {"loc": 4, "tokens": 60, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.6048621343874779}}, {"code": "def backspaceCompare(S: str, T: str) -> bool:\n    def process(s):\n        skip = 0\n        for i in reversed(range(len(s))):\n            if s[i] == '#':\n                skip += 1\n            elif skip:\n                skip -= 1\n            else:\n                yield s[i]\n    \n    return all(x == y for x, y in zip_longest(process(S), process(T)))", "passed": false, "score": {"loc": 11, "tokens": 92, "cc": 3, "nest": 5, "execution_time": 10.0, "novelty": 0.5883431646070632}}, {"code": "def backspaceCompare(S: str, T: str) -> bool:\n    def process(s: str) -> str:\n        return ''.join(filter(None, (c[:-1] if c == '#' else c for c in ''.join(reversed(list(s))))))\n\n    return process(S) == process(T)", "passed": false, "score": {"loc": 4, "tokens": 82, "cc": 0, "nest": 2, "execution_time": 10.0, "novelty": 0.5977021101471527}}, {"code": "def backspaceCompare(S: str, T: str) -> bool:\n    def process(s):\n        skip = 0\n        for char in reversed(s):\n            if char == '#':\n                skip += 1\n            elif skip:\n                skip -= 1\n            else:\n                yield char\n\n    return all(x == y for x, y in itertools.zip_longest(process(S), process(T)))", "passed": false, "score": {"loc": 11, "tokens": 82, "cc": 3, "nest": 5, "execution_time": 10.0, "novelty": 0.5870848166815628}}], "num_pass": 5, "num_uniq": 4, "num_fail": 5, "fail_uniq": 5}
{"id": 8104, "entry_point": "integerBreak", "best_list": [{"code": "def integerBreak(n):\n    dp = [0] * (n + 1)\n    for i in range(2, n + 1):\n        dp[i] = max(max(j * (i - j), j * dp[i - j]) for j in range(1, i))\n    return dp[n]", "passed": true, "score": {"loc": 5, "tokens": 70, "cc": 1, "nest": 2, "execution_time": 0.016613, "novelty": 0.5927363224585386}}, {"code": "def integerBreak(n):\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            dp[i] = max(dp[i], j * dp[i - j], j * (i - j))\n    return dp[n]", "passed": true, "score": {"loc": 7, "tokens": 79, "cc": 2, "nest": 3, "execution_time": 0.01653, "novelty": 0.2625366068199856}}, {"code": "def integerBreak(n):\n    memo = [0] * (n + 1)\n    memo[1] = 1\n    \n    for i in range(2, n + 1):\n        for j in range(1, i):\n            memo[i] = max(memo[i], j * memo[i - j], j * (i - j))\n    \n    return memo[n]", "passed": true, "score": {"loc": 7, "tokens": 79, "cc": 2, "nest": 3, "execution_time": 0.016601, "novelty": 0.27268315883828664}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 8215, "entry_point": "reformat", "best_list": [{"code": "def reformat(s: str) -> str:\n    digits, letters = [], []\n    for char in s:\n        if char.isdigit():\n            digits.append(char)\n        else:\n            letters.append(char)\n    if abs(len(digits) - len(letters)) > 1:\n        return \"\"\n    if len(digits) > len(letters):\n        digits, letters = letters, digits\n    result = []\n    for digit, letter in zip(digits, letters):\n        result.extend([digit, letter])\n    if len(digits) < len(letters):\n        result.append(letters[-1])\n    return \"\".join(result)", "passed": true, "score": {"loc": 17, "tokens": 138, "cc": 6, "nest": 3, "execution_time": 0.016598, "novelty": 0.7012057892621316}}, {"code": "def reformat(s):\n    digits = [char for char in s if char.isdigit()]\n    letters = [char for char in s if char.isalpha()]\n    \n    if abs(len(digits) - len(letters)) > 1:\n        return \"\"\n    \n    if len(digits) > len(letters):\n        digits, letters = letters, digits\n    \n    return \"\".join(d + l for d, l in zip(digits, letters)) + (digits[-1] if len(digits) > len(letters) else \"\")", "passed": false, "score": {"loc": 8, "tokens": 115, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.277254306693276}}, {"code": "def reformat(s):\n    digits = [c for c in s if c.isdigit()]\n    letters = [c for c in s if c.isalpha()]\n    \n    if abs(len(digits) - len(letters)) > 1:\n        return \"\"\n    \n    if len(digits) > len(letters):\n        digits, letters = letters, digits\n    \n    result = []\n    for d, l in zip(digits, letters):\n        result.extend([d, l])\n    \n    if digits:\n        result.append(digits[-1])\n    \n    return \"\".join(result)", "passed": false, "score": {"loc": 13, "tokens": 120, "cc": 4, "nest": 2, "execution_time": 10.0, "novelty": 0.1754977234339149}}, {"code": "def reformat(s: str) -> str:\n    letters = [c for c in s if c.isalpha()]\n    digits = [c for c in s if c.isdigit()]\n    \n    if abs(len(letters) - len(digits)) > 1:\n        return \"\"\n    \n    if len(letters) < len(digits):\n        letters, digits = digits, letters\n    \n    result = []\n    for i in range(len(digits)):\n        result.append(letters[i])\n        result.append(digits[i])\n    \n    if len(letters) > len(digits):\n        result.append(letters[-1])\n    \n    return \"\".join(result)", "passed": false, "score": {"loc": 14, "tokens": 140, "cc": 4, "nest": 2, "execution_time": 10.0, "novelty": 0.4003323280859199}}, {"code": "def reformat(s):\n    digits = [c for c in s if c.isdigit()]\n    letters = [c for c in s if c.isalpha()]\n    \n    if abs(len(digits) - len(letters)) > 1:\n        return \"\"\n    \n    if len(digits) > len(letters):\n        digits, letters = letters, digits\n    \n    result = []\n    for d, l in zip(digits, letters):\n        result.extend([d, l])\n    \n    if len(digits) < len(letters):\n        result.append(letters[-1])\n    \n    return \"\".join(result)", "passed": false, "score": {"loc": 13, "tokens": 128, "cc": 4, "nest": 2, "execution_time": 10.0, "novelty": 0.16120630160853155}}, {"code": "def reformat(s: str) -> str:\n    digits = [c for c in s if c.isdigit()]\n    letters = [c for c in s if c.isalpha()]\n    if abs(len(digits) - len(letters)) > 1:\n        return \"\"\n    if len(digits) > len(letters):\n        digits, letters = letters, digits\n    return \"\".join(a + b for a, b in zip(letters, digits)) + letters[-1] if len(letters) > len(digits) else \"\".join(a + b for a, b in zip(digits, letters))", "passed": false, "score": {"loc": 8, "tokens": 136, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.37553699484418523}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 7}
{"id": 8249, "entry_point": "singleNonDuplicate", "best_list": [{"code": "def singleNonDuplicate(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            left = mid + 2\n        else:\n            right = mid\n    return nums[left]", "passed": true, "score": {"loc": 11, "tokens": 74, "cc": 3, "nest": 3, "execution_time": 0.016669, "novelty": 0.058103279190259816}}, {"code": "def singleNonDuplicate(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            left = mid + 2\n        else:\n            right = mid\n    return nums[left]", "passed": true, "score": {"loc": 11, "tokens": 76, "cc": 3, "nest": 3, "execution_time": 0.016617, "novelty": 0.024205109425921245}}, {"code": "def singleNonDuplicate(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] != nums[mid + 1]:\n            right = mid\n        else:\n            left = mid + 2\n    return nums[left]", "passed": true, "score": {"loc": 11, "tokens": 76, "cc": 3, "nest": 3, "execution_time": 0.01664, "novelty": 0.09713275376460984}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 8284, "entry_point": "findUnsortedSubarray", "best_list": [{"code": "def findUnsortedSubarray(nums):\n    sorted_nums = sorted(nums)\n    left = right = -1\n    for i in range(len(nums)):\n        if nums[i] != sorted_nums[i]:\n            if left == -1:\n                left = i\n            right = i\n    return right - left + 1 if left != -1 else 0", "passed": true, "score": {"loc": 9, "tokens": 68, "cc": 3, "nest": 4, "execution_time": 0.016679, "novelty": 0.4700783790814709}}, {"code": "def findUnsortedSubarray(nums):\n    sorted_nums = sorted(nums)\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right and nums[left] == sorted_nums[left]:\n        left += 1\n    \n    while left <= right and nums[right] == sorted_nums[right]:\n        right -= 1\n    \n    return right - left + 1", "passed": true, "score": {"loc": 9, "tokens": 71, "cc": 4, "nest": 2, "execution_time": 0.016549, "novelty": 0.5903468135636052}}, {"code": "def findUnsortedSubarray(nums):\n    sorted_nums = sorted(nums)\n    start = len(nums)\n    end = 0\n    \n    for i in range(len(nums)):\n        if nums[i] != sorted_nums[i]:\n            start = min(start, i)\n            end = max(end, i)\n    \n    return end - start + 1 if end - start > 0 else 0", "passed": true, "score": {"loc": 9, "tokens": 74, "cc": 2, "nest": 3, "execution_time": 0.01674, "novelty": 0.2790696594896773}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 8323, "entry_point": "maxSumTwoNoOverlap", "best_list": [{"code": "def maxSumTwoNoOverlap(A, L, M):\n    n = len(A)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    max_L = [0] * n\n    max_M = [0] * n\n    \n    # Calculate max sum of L-length subarray ending at each position\n    for i in range(L - 1, n):\n        max_L[i] = max(max_L[i - 1], prefix_sum[i + 1] - prefix_sum[i + 1 - L])\n    \n    # Calculate max sum of M-length subarray ending at each position\n    for i in range(M - 1, n):\n        max_M[i] = max(max_M[i - 1], prefix_sum[i + 1] - prefix_sum[i + 1 - M])\n    \n    # Calculate max sum of two non-overlapping subarrays\n    result = 0\n    for i in range(L - 1, n - M):\n        result = max(result, max_L[i] + prefix_sum[i + M + 1] - prefix_sum[i + 1])\n    for i in range(M - 1, n - L):\n        result = max(result, max_M[i] + prefix_sum[i + L + 1] - prefix_sum[i + 1])\n    \n    return result", "passed": true, "score": {"loc": 20, "tokens": 272, "cc": 5, "nest": 2, "execution_time": 0.016614, "novelty": 0.664420256042547}}, {"code": "def maxSumTwoNoOverlap(A, L, M):\n    n = len(A)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    def maxSum(subarray_length):\n        max_sum = float('-inf')\n        current_max = 0\n        for i in range(subarray_length, n + 1):\n            current_max = max(current_max, prefix_sum[i] - prefix_sum[i - subarray_length])\n            max_sum = max(max_sum, prefix_sum[i] - prefix_sum[i - subarray_length] + current_max)\n        return max_sum\n    \n    return max(maxSum(L) + maxSum(M), maxSum(M) + maxSum(L))", "passed": false, "score": {"loc": 13, "tokens": 144, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5600308693731338}}, {"code": "def maxSumTwoNoOverlap(A, L, M):\n    n = len(A)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    max_l_sum = [0] * n\n    for i in range(L - 1, n):\n        max_l_sum[i] = prefix_sum[i + 1] - prefix_sum[i - L + 1]\n    \n    max_m_sum = [0] * n\n    for i in range(M - 1, n):\n        max_m_sum[i] = prefix_sum[i + 1] - prefix_sum[i - M + 1]\n    \n    max_l_sum[i] = max(max_l_sum[i], max_l_sum[i - 1])\n    max_m_sum[i] = max(max_m_sum[i], max_m_sum[i - 1])\n    \n    result = 0\n    for i in range(L - 1, n - M):\n        result = max(result, max_l_sum[i] + max_m_sum[i + M])\n    \n    for i in range(M - 1, n - L):\n        result = max(result, max_m_sum[i] + max_l_sum[i + L])\n    \n    return result", "passed": false, "score": {"loc": 19, "tokens": 236, "cc": 5, "nest": 2, "execution_time": 10.0, "novelty": 0.640614339871943}}, {"code": "def maxSumTwoNoOverlap(A, L, M):\n    n = len(A)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    def maxSumOne(length):\n        max_sum = float('-inf')\n        current_sum = 0\n        for i in range(length, n + 1):\n            current_sum = prefix_sum[i] - prefix_sum[i - length]\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n    \n    max_L = maxSumOne(L)\n    max_M = maxSumOne(M)\n    \n    max_sum = 0\n    for i in range(L, n - M + 1):\n        max_sum = max(max_sum, max_L + prefix_sum[i + M] - prefix_sum[i])\n    for i in range(M, n - L + 1):\n        max_sum = max(max_sum, max_M + prefix_sum[i + L] - prefix_sum[i])\n    \n    return max_sum", "passed": false, "score": {"loc": 20, "tokens": 189, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.5518107242434549}}, {"code": "def maxSumTwoNoOverlap(A, L, M):\n    n = len(A)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + A[i]\n\n    def maxSumOfSubarray(length):\n        dp = [0] * n\n        max_sum = 0\n        for i in range(length - 1, n):\n            dp[i] = prefix[i + 1] - prefix[i - length + 1]\n            max_sum = max(max_sum, dp[i])\n            if i >= length:\n                dp[i] += max_sum\n        return max(dp)\n\n    sum_L = maxSumOfSubarray(L)\n    sum_M = maxSumOfSubarray(M)\n    return max(sum_L + sum_M - max(sum_L, sum_M), sum_L + maxSumOfSubarray(M), sum_M + maxSumOfSubarray(L))", "passed": false, "score": {"loc": 17, "tokens": 168, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5808716070998468}}, {"code": "def maxSumTwoNoOverlap(A, L, M):\n    def maxSumOneSubarray(A, length):\n        max_sum = float('-inf')\n        current_sum = 0\n        for i in range(len(A)):\n            current_sum += A[i]\n            if i >= length:\n                current_sum -= A[i - length]\n            if i >= length - 1:\n                max_sum = max(max_sum, current_sum)\n        return max_sum\n\n    maxL = maxSumOneSubarray(A, L)\n    maxM = maxSumOneSubarray(A, M)\n    max_sum = float('-inf')\n\n    for i in range(len(A) - L - M + 1):\n        sum1 = sum(A[i:i+L])\n        sum2 = sum(A[i+L:i+L+M])\n        max_sum = max(max_sum, sum1 + sum2)\n\n    for i in range(len(A) - L - M + 1):\n        sum1 = sum(A[i:i+M])\n        sum2 = sum(A[i+M:i+M+L])\n        max_sum = max(max_sum, sum1 + sum2)\n\n    return max(max_sum, maxL + maxM)", "passed": false, "score": {"loc": 23, "tokens": 229, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.788138520258705}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 8342, "entry_point": "isGoodArray", "best_list": [{"code": "from math import gcd\nfrom functools import reduce\n\ndef isGoodArray(nums):\n    return reduce(gcd, nums) == 1", "passed": true, "score": {"loc": 4, "tokens": 24, "cc": 0, "nest": 1, "execution_time": 0.016418, "novelty": 0.4124560649016473}}, {"code": "def isGoodArray(nums):\n    from functools import reduce\n    from math import gcd\n    return reduce(gcd, nums) == 1", "passed": true, "score": {"loc": 4, "tokens": 24, "cc": 0, "nest": 1, "execution_time": 0.016527, "novelty": 0.41016436304172454}}, {"code": "def isGoodArray(nums):\n    gcd = nums[0]\n    for num in nums:\n        gcd = math.gcd(gcd, num)\n    return gcd == 1", "passed": true, "score": {"loc": 5, "tokens": 32, "cc": 1, "nest": 2, "execution_time": 0.016562, "novelty": 0.47085344129441664}}, {"code": "def isGoodArray(nums):\n    return all(gcd(x, y) == 1 for x, y in pairwise(nums))\n\nfrom itertools import pairwise\nfrom math import gcd", "passed": false, "score": {"loc": 4, "tokens": 36, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6145227447480199}}, {"code": "def isGoodArray(nums):\n    acc = 0\n    for num in nums:\n        acc = gcd(acc, num)\n    return acc == 1", "passed": false, "score": {"loc": 5, "tokens": 27, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.3538018594821133}}], "num_pass": 8, "num_uniq": 6, "num_fail": 2, "fail_uniq": 2}
{"id": 8381, "entry_point": "countBattleships", "best_list": [{"code": "def countBattleships(board):\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[i])):\n            if board[i][j] == 'X':\n                if (i == 0 or board[i-1][j] != 'X') and (j == 0 or board[i][j-1] != 'X'):\n                    count += 1\n    return count", "passed": true, "score": {"loc": 8, "tokens": 99, "cc": 7, "nest": 5, "execution_time": 0.016562, "novelty": 0.026277081163006755}}, {"code": "def countBattleships(board):\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'X':\n                if (i == 0 or board[i-1][j] == '.') and (j == 0 or board[i][j-1] == '.'):\n                    count += 1\n    return count", "passed": false, "score": {"loc": 8, "tokens": 99, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.018830915159639194}}, {"code": "def countBattleships(board):\n    count = 0\n    rows, cols = len(board), len(board[0])\n    for i in range(rows):\n        for j in range(cols):\n            if board[i][j] == 'X':\n                if (i == 0 or board[i-1][j] == '.') and (j == 0 or board[i][j-1] == '.'):\n                    count += 1\n    return count", "passed": false, "score": {"loc": 9, "tokens": 106, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.1453186883693539}}, {"code": "def countBattleships(board):\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'X':\n                if (i == 0 or board[i-1][j] != 'X') and (j == 0 or board[i][j-1] != 'X'):\n                    count += 1\n    return count", "passed": false, "score": {"loc": 8, "tokens": 99, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.01821128979002773}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 3}
{"id": 8405, "entry_point": "minCostToMoveChips", "best_list": [{"code": "def minCostToMoveChips(position):\n    odd = sum(1 for p in position if p % 2)\n    return min(odd, len(position) - odd)", "passed": true, "score": {"loc": 3, "tokens": 32, "cc": 0, "nest": 1, "execution_time": 0.016619, "novelty": 0.1793700813918515}}, {"code": "def minCostToMoveChips(position):\n    even_count = sum(pos % 2 == 0 for pos in position)\n    return min(even_count, len(position) - even_count)", "passed": true, "score": {"loc": 3, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016629, "novelty": 0.3888085340489369}}, {"code": "def minCostToMoveChips(position):\n    odd = sum(1 for p in position if p % 2 != 0)\n    return min(odd, len(position) - odd)", "passed": true, "score": {"loc": 3, "tokens": 35, "cc": 0, "nest": 1, "execution_time": 0.016497, "novelty": 0.22116985078021467}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 862, "entry_point": "increasingTriplet", "best_list": [{"code": "def increasingTriplet(nums):\n    first = second = float('inf')\n    for n in nums:\n        if n <= first:\n            first = n\n        elif n <= second:\n            second = n\n        else:\n            return True\n    return False", "passed": true, "score": {"loc": 10, "tokens": 45, "cc": 3, "nest": 4, "execution_time": 0.016547, "novelty": 0.0020045644931663276}}, {"code": "def increasingTriplet(arr):\n    first = second = float('inf')\n    for num in arr:\n        if num <= first:\n            first = num\n        elif num <= second:\n            second = num\n        else:\n            return True\n    return False", "passed": true, "score": {"loc": 10, "tokens": 45, "cc": 3, "nest": 4, "execution_time": 0.016565, "novelty": 0.012144732387671997}}, {"code": "def increasingTriplet(nums):\n    first = second = float('inf')\n    for num in nums:\n        if num <= first:\n            first = num\n        elif num <= second:\n            second = num\n        else:\n            return True\n    return False", "passed": true, "score": {"loc": 10, "tokens": 45, "cc": 3, "nest": 4, "execution_time": 0.01678, "novelty": 0.005534397660674539}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 877, "entry_point": "longestSubarray", "best_list": [{"code": "def longestSubarray(nums):\n    max_length = zero_count = start = 0\n    for end, num in enumerate(nums):\n        zero_count += num == 0\n        while zero_count > 1:\n            zero_count -= nums[start] == 0\n            start += 1\n        max_length = max(max_length, end - start)\n    return max_length", "passed": true, "score": {"loc": 9, "tokens": 61, "cc": 2, "nest": 3, "execution_time": 0.016722, "novelty": 0.43704692853676785}}, {"code": "def longestSubarray(nums):\n    max_length = 0\n    left = 0\n    zero_count = 0\n    \n    for right in range(len(nums)):\n        zero_count += nums[right] == 0\n        \n        while zero_count > 1:\n            zero_count -= nums[left] == 0\n            left += 1\n        \n        max_length = max(max_length, right - left)\n    \n    return max_length", "passed": true, "score": {"loc": 11, "tokens": 67, "cc": 2, "nest": 3, "execution_time": 0.016842, "novelty": 0.4490486041317622}}, {"code": "def longestSubarray(nums):\n    max_length = 0\n    left = 0\n    zero_count = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zero_count += 1\n\n        while zero_count > 1:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n\n        max_length = max(max_length, right - left)\n\n    return max_length", "passed": true, "score": {"loc": 13, "tokens": 73, "cc": 4, "nest": 4, "execution_time": 0.016636, "novelty": 0.40059195967351735}}, {"code": "def longestSubarray(nums):\n    max_length = 0\n    prev_length = 0\n    zero_count = 0\n    \n    for i, num in enumerate(nums):\n        if num == 0:\n            zero_count += 1\n            if zero_count > 1:\n                max_length = max(max_length, prev_length + zero_count - 1)\n                prev_length = zero_count - 1\n                zero_count = 1\n            else:\n                prev_length = zero_count\n        else:\n            prev_length += 1\n    \n    return max(max_length, prev_length - (1 if zero_count > 0 else 0))", "passed": false, "score": {"loc": 16, "tokens": 88, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.624200156662672}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 8511, "entry_point": "numBusesToDestination", "best_list": [{"code": "def numBusesToDestination(routes, S, T):\n    if S == T:\n        return 0\n    \n    from collections import deque, defaultdict\n    \n    stop_to_routes = defaultdict(list)\n    for i, route in enumerate(routes):\n        for stop in route:\n            stop_to_routes[stop].append(i)\n    \n    visited_routes = set()\n    queue = deque([(S, 0)])\n    \n    while queue:\n        current_stop, current_buses = queue.popleft()\n        \n        for route_id in stop_to_routes[current_stop]:\n            if route_id in visited_routes:\n                continue\n            visited_routes.add(route_id)\n            \n            for next_stop in routes[route_id]:\n                if next_stop == T:\n                    return current_buses + 1\n                queue.append((next_stop, current_buses + 1))\n    \n    return -1", "passed": true, "score": {"loc": 21, "tokens": 136, "cc": 8, "nest": 5, "execution_time": 0.016603, "novelty": 0.5078461047752771}}, {"code": "from collections import deque\n\ndef numBusesToDestination(routes, S, T):\n    if S == T:\n        return 0\n    \n    stop_to_routes = {}\n    for i, route in enumerate(routes):\n        for stop in route:\n            if stop not in stop_to_routes:\n                stop_to_routes[stop] = []\n            stop_to_routes[stop].append(i)\n    \n    queue = deque([(S, 1)])\n    visited_routes = set()\n    \n    while queue:\n        current_stop, buses_taken = queue.popleft()\n        for bus in stop_to_routes[current_stop]:\n            if bus not in visited_routes:\n                visited_routes.add(bus)\n                for next_stop in routes[bus]:\n                    if next_stop == T:\n                        return buses_taken\n                    if next_stop not in visited_routes:\n                        queue.append((next_stop, buses_taken + 1))\n    \n    return -1", "passed": true, "score": {"loc": 23, "tokens": 149, "cc": 10, "nest": 6, "execution_time": 0.016601, "novelty": 0.6541458666102409}}, {"code": "def numBusesToDestination(routes, S, T):\n    if S == T:\n        return 0\n    \n    from collections import defaultdict, deque\n    \n    stop_to_routes = defaultdict(list)\n    for i, route in enumerate(routes):\n        for stop in route:\n            stop_to_routes[stop].append(i)\n    \n    queue = deque([(S, 1)])\n    visited_stops = set([S])\n    visited_routes = set()\n    \n    while queue:\n        current_stop, buses_taken = queue.popleft()\n        for route_index in stop_to_routes[current_stop]:\n            if route_index not in visited_routes:\n                visited_routes.add(route_index)\n                for next_stop in routes[route_index]:\n                    if next_stop == T:\n                        return buses_taken\n                    if next_stop not in visited_stops:\n                        visited_stops.add(next_stop)\n                        queue.append((next_stop, buses_taken + 1))\n    \n    return -1", "passed": true, "score": {"loc": 23, "tokens": 154, "cc": 9, "nest": 6, "execution_time": 0.016756, "novelty": 0.48182273696555133}}, {"code": "from collections import defaultdict, deque\n\ndef numBusesToDestination(routes, S, T):\n    if S == T:\n        return 0\n    \n    graph = defaultdict(set)\n    for bus, stops in enumerate(routes):\n        for stop in stops:\n            graph[stop].add(bus)\n    \n    visited_stops = set()\n    visited_buses = set()\n    queue = deque([(S, 1)])\n    \n    while queue:\n        current_stop, buses_taken = queue.popleft()\n        if current_stop == T:\n            return buses_taken\n        \n        visited_stops.add(current_stop)\n        for bus in graph[current_stop]:\n            if bus not in visited_buses:\n                visited_buses.add(bus)\n                for next_stop in routes[bus]:\n                    if next_stop not in visited_stops:\n                        queue.append((next_stop, buses_taken + 1))\n    \n    return -1", "passed": false, "score": {"loc": 23, "tokens": 151, "cc": 9, "nest": 6, "execution_time": 10.0, "novelty": 0.44593318697840745}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 8542, "entry_point": "countGoodTriplets", "best_list": [{"code": "def countGoodTriplets(arr, a, b, c):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            for k in range(j + 1, len(arr)):\n                if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                    count += 1\n    return count", "passed": true, "score": {"loc": 8, "tokens": 111, "cc": 5, "nest": 5, "execution_time": 0.016486, "novelty": 0.5121541806118055}}, {"code": "def countGoodTriplets(arr, a, b, c):\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(arr[i] - arr[j]) <= a:\n                for k in range(j + 1, n):\n                    if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                        count += 1\n    return count", "passed": true, "score": {"loc": 10, "tokens": 109, "cc": 6, "nest": 6, "execution_time": 0.016623, "novelty": 0.0785045059524967}}, {"code": "def countGoodTriplets(arr, a, b, c):\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(arr[i] - arr[j]) <= a:\n                for k in range(j + 1, n):\n                    if abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                        count += 1\n    return count", "passed": true, "score": {"loc": 10, "tokens": 109, "cc": 6, "nest": 6, "execution_time": 0.016736, "novelty": 0.10250530862580254}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 8625, "entry_point": "smallestDistancePair", "best_list": [{"code": "def smallestDistancePair(nums, k):\n    nums.sort()\n    n = len(nums)\n    distances = []\n    \n    for i in range(n-1):\n        for j in range(i+1, n):\n            distances.append(nums[j] - nums[i])\n    \n    distances.sort()\n    return distances[k-1]", "passed": true, "score": {"loc": 9, "tokens": 71, "cc": 2, "nest": 3, "execution_time": 0.016546, "novelty": 0.6560627535297436}}, {"code": "from typing import List\nimport bisect\n\ndef smallestDistancePair(nums: List[int], k: int) -> int:\n    nums.sort()\n    distances = []\n    \n    for i in range(1, len(nums)):\n        distances.extend(nums[j] - nums[i-1] for j in range(i))\n    \n    distances.sort()\n    return distances[k-1]", "passed": true, "score": {"loc": 9, "tokens": 81, "cc": 1, "nest": 2, "execution_time": 0.018221, "novelty": 0.750625800895838}}, {"code": "def smallestDistancePair(nums, k):\n    nums.sort()\n    n = len(nums)\n    left, right = 0, nums[-1] - nums[0]\n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        j = 0\n        for i in range(n):\n            while j < n and nums[j] - nums[i] <= mid:\n                j += 1\n            count += j - i - 1\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": true, "score": {"loc": 17, "tokens": 111, "cc": 5, "nest": 4, "execution_time": 0.016583, "novelty": 0.4579097357328963}}, {"code": "def smallestDistancePair(nums, k):\n    nums.sort()\n    n = len(nums)\n    left, right = 0, nums[-1] - nums[0]\n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        for i in range(n):\n            j = bisect.bisect_right(nums, nums[i] + mid)\n            count += j - i - 1\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": false, "score": {"loc": 15, "tokens": 101, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.43190048719055496}}, {"code": "def smallestDistancePair(nums, k):\n    nums.sort()\n    n = len(nums)\n    left, right = 0, nums[-1] - nums[0]\n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        for i in range(n):\n            j = bisect_right(nums, nums[i] + mid, i + 1)\n            count += j - i - 1\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": false, "score": {"loc": 15, "tokens": 103, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.42137634456501516}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 8708, "entry_point": "isUgly", "best_list": [{"code": "def isUgly(num):\n    if num <= 0:\n        return False\n    for prime in 2, 3, 5:\n        while num % prime == 0:\n            num //= prime\n    return num == 1", "passed": true, "score": {"loc": 7, "tokens": 41, "cc": 3, "nest": 3, "execution_time": 0.016412, "novelty": 0.048763325456857354}}, {"code": "def isUgly(num):\n    if num <= 0:\n        return False\n    for p in 2, 3, 5:\n        while num % p == 0:\n            num //= p\n    return num == 1", "passed": true, "score": {"loc": 7, "tokens": 41, "cc": 3, "nest": 3, "execution_time": 0.016507, "novelty": 0.04297572323387855}}, {"code": "def isUgly(num):\n    if num <= 0:\n        return False\n    for f in 2, 3, 5:\n        while num % f == 0:\n            num //= f\n    return num == 1", "passed": true, "score": {"loc": 7, "tokens": 41, "cc": 3, "nest": 3, "execution_time": 0.01653, "novelty": 0.0407169337802924}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 8742, "entry_point": "reverseWords", "best_list": [{"code": "def reverseWords(s):\n    return ' '.join(s.split()[::-1])", "passed": true, "score": {"loc": 2, "tokens": 24, "cc": 0, "nest": 1, "execution_time": 0.016749, "novelty": 0.14749331520281506}}, {"code": "def reverseWords(s):\n    return ' '.join(word for word in reversed(s.split()) if word)", "passed": true, "score": {"loc": 2, "tokens": 27, "cc": 0, "nest": 1, "execution_time": 0.016688, "novelty": 0.5228084924395191}}, {"code": "def reverseWords(s):\n    return ' '.join(word for word in s.split()[::-1])", "passed": true, "score": {"loc": 2, "tokens": 28, "cc": 0, "nest": 1, "execution_time": 0.016701, "novelty": 0.29171348245326834}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 8743, "entry_point": "strStr", "best_list": [{"code": "def strStr(haystack, needle):\n    return haystack.find(needle)", "passed": true, "score": {"loc": 2, "tokens": 15, "cc": 0, "nest": 1, "execution_time": 0.01651, "novelty": 0.12182334385818117}}, {"code": "def strStr(haystack: str, needle: str) -> int:\n    return haystack.find(needle)", "passed": true, "score": {"loc": 2, "tokens": 22, "cc": 0, "nest": 1, "execution_time": 0.016535, "novelty": 0.21086549724139658}}, {"code": "def strStr(haystack: str, needle: str) -> int:\n    if needle == \"\":\n        return 0\n    return haystack.find(needle)", "passed": true, "score": {"loc": 4, "tokens": 31, "cc": 1, "nest": 2, "execution_time": 0.016457, "novelty": 0.657704200915629}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 8754, "entry_point": "clumsy", "best_list": [{"code": "def clumsy(N: int) -> int:\n    if N == 1: return 1\n    if N == 2: return 2 * 1\n    if N == 3: return 3 * 2 // 1\n    if N == 4: return 4 * 3 // 2 + 1\n    return N * (N-1) // (N-2) + clumsy(N-3)", "passed": true, "score": {"loc": 6, "tokens": 79, "cc": 4, "nest": 2, "execution_time": 0.016358, "novelty": 0.6944167811086224}}, {"code": "def clumsy(N):\n    ops = ['*', '//', '+', '-']\n    stack = [N]\n    op_index = 0\n    \n    for i in range(1, N):\n        if ops[op_index] == '*':\n            stack.append(stack.pop() * (N - i))\n        elif ops[op_index] == '//':\n            stack.append(int(stack.pop() / (N - i)))\n        elif ops[op_index] == '+':\n            stack.append(N - i)\n        elif ops[op_index] == '-':\n            stack.append(-(N - i))\n        \n        op_index = (op_index + 1) % 4\n    \n    return sum(stack)", "passed": true, "score": {"loc": 15, "tokens": 157, "cc": 5, "nest": 6, "execution_time": 0.016498, "novelty": 0.6774656161746904}}, {"code": "def clumsy(N):\n    stack = [N]\n    op = 0\n    for i in range(N - 1, 0, -1):\n        if op == 0:\n            stack[-1] *= i\n        elif op == 1:\n            stack[-1] //= i\n        elif op == 2:\n            stack.append(i)\n        elif op == 3:\n            stack.append(-i)\n        op = (op + 1) % 4\n    return sum(stack)\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "passed": true, "score": {"loc": 16, "tokens": 110, "cc": 5, "nest": 6, "execution_time": 0.016666, "novelty": 0.7146972872971971}}, {"code": "def clumsy(N):\n    from operator import mul, truediv, add, sub\n    ops = [mul, truediv, add, sub]\n    stack = [N]\n    for i in range(1, N):\n        op = ops[i % 4]\n        if op == mul:\n            stack[-1] *= N - i\n        elif op == truediv:\n            stack[-1] = int(stack[-1] / (N - i))\n        else:\n            stack.append(N - i)\n            stack.append(op)\n    return int(eval(' '.join(map(str, stack))))", "passed": false, "score": {"loc": 14, "tokens": 127, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7834839798043424}}, {"code": "def clumsy(N):\n    ops = [\"*\", \"//\", \"+\", \"-\"]\n    stack = [N]\n    i = 1\n    while i < N:\n        op = ops[i % 4]\n        if op == \"*\":\n            stack.append(stack.pop() * (N - i))\n        elif op == \"//\":\n            stack.append(int(stack.pop() / (N - i)))\n        elif op == \"+\":\n            stack.append(N - i)\n        elif op == \"-\":\n            stack.append(-(N - i))\n        i += 1\n    return sum(stack)", "passed": false, "score": {"loc": 16, "tokens": 143, "cc": 5, "nest": 6, "execution_time": 10.0, "novelty": 0.5945603173815839}}, {"code": "def clumsy(N: int) -> int:\n    stack = []\n    ops = ['*', '/', '+', '-']\n    op_index = 0\n    \n    for i in range(N, 0, -1):\n        if not stack:\n            stack.append(i)\n        else:\n            if ops[op_index] == '*':\n                stack[-1] *= i\n            elif ops[op_index] == '/':\n                stack[-1] = int(stack[-1] / i)\n            elif ops[op_index] == '+':\n                stack.append(i)\n            elif ops[op_index] == '-':\n                stack.append(-i)\n        \n        op_index = (op_index + 1) % 4\n    \n    return sum(stack)", "passed": false, "score": {"loc": 18, "tokens": 157, "cc": 6, "nest": 7, "execution_time": 10.0, "novelty": 0.816087835996296}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 8825, "entry_point": "nthUglyNumber", "best_list": [{"code": "def nthUglyNumber(n, a, b, c):\n    def count(x):\n        return x // a + x // b + x // c - x // ab - x // ac - x // bc + x // abc\n\n    ab = a * b // math.gcd(a, b)\n    ac = a * c // math.gcd(a, c)\n    bc = b * c // math.gcd(b, c)\n    abc = a * b * c // math.gcd(a, math.gcd(b, c))\n\n    low, high = 1, 2 * 10**9\n    while low < high:\n        mid = (low + high) // 2\n        if count(mid) < n:\n            low = mid + 1\n        else:\n            high = mid\n    return low", "passed": true, "score": {"loc": 15, "tokens": 169, "cc": 2, "nest": 3, "execution_time": 0.016612, "novelty": 0.5868424795641294}}, {"code": "def nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\n    from math import gcd\n    ab = a * b // gcd(a, b)\n    ac = a * c // gcd(a, c)\n    bc = b * c // gcd(b, c)\n    abc = a * bc // gcd(a, bc)\n    \n    def count(x):\n        return x // a + x // b + x // c - x // ab - x // ac - x // bc + x // abc\n    \n    low, high = 1, 2 * 10**9\n    while low < high:\n        mid = (low + high) // 2\n        if count(mid) < n:\n            low = mid + 1\n        else:\n            high = mid\n    return low", "passed": true, "score": {"loc": 16, "tokens": 167, "cc": 2, "nest": 3, "execution_time": 0.016671, "novelty": 0.49450228805561247}}, {"code": "def nthUglyNumber(n, a, b, c):\n    from math import gcd\n\n    def lcm(x, y):\n        return x * y // gcd(x, y)\n\n    ab = lcm(a, b)\n    ac = lcm(a, c)\n    bc = lcm(b, c)\n    abc = lcm(ab, c)\n\n    def count(x):\n        return x // a + x // b + x // c - x // ab - x // ac - x // bc + x // abc\n\n    left, right = 1, 2 * 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count(mid) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": true, "score": {"loc": 18, "tokens": 156, "cc": 2, "nest": 3, "execution_time": 0.01647, "novelty": 0.5057050229097114}}, {"code": "from math import gcd\n\ndef nthUglyNumber(x, y):\n    return x * y // gcd(x, y)\n\ndef nthUglyNumber(n, a, b, c):\n    ab = nthUglyNumber(a, b)\n    ac = nthUglyNumber(a, c)\n    bc = nthUglyNumber(b, c)\n    abc = nthUglyNumber(a, bc)\n    \n    def count(x):\n        return x // a + x // b + x // c - x // ab - x // ac - x // bc + x // abc\n    \n    left, right = 1, 2 * 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count(mid) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": false, "score": {"loc": 18, "tokens": 156, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.48403067646455755}}, {"code": "def nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\n    def count(x):\n        return x // a + x // b + x // c - x // ab - x // ac - x // bc + x // abc\n\n    ab = a * b // gcd(a, b)\n    ac = a * c // gcd(a, c)\n    bc = b * c // gcd(b, c)\n    abc = a * b * c // gcd(a, b, c)\n    left, right = 1, 2 * 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count(mid) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": false, "score": {"loc": 15, "tokens": 167, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.46777360025949877}}, {"code": "from math import gcd\n\ndef nthUglyNumber(x, y):\n    return x * y // gcd(x, y)\n\ndef count_ugly_numbers(n, a, b, c):\n    lcm_ab = nthUglyNumber(a, b)\n    lcm_ac = nthUglyNumber(a, c)\n    lcm_bc = nthUglyNumber(b, c)\n    lcm_abc = nthUglyNumber(a, nthUglyNumber(b, c))\n    \n    return n // a + n // b + n // c - n // lcm_ab - n // lcm_ac - n // lcm_bc + n // lcm_abc\n\ndef nthUglyNumber(n, a, b, c):\n    left, right = 1, 2 * 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count_ugly_numbers(mid, a, b, c) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": false, "score": {"loc": 18, "tokens": 173, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6382668153765618}}, {"code": "def nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    def lcm(x: int, y: int) -> int:\n        return x * y // gcd(x, y)\n\n    def count(x: int) -> int:\n        return x // a + x // b + x // c - x // ab - x // ac - x // bc + x // abc\n\n    ab = lcm(a, b)\n    ac = lcm(a, c)\n    bc = lcm(b, c)\n    abc = lcm(a, b, c)\n\n    left, right = 1, 2 * 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count(mid) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": false, "score": {"loc": 21, "tokens": 206, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6629490831399664}}, {"code": "def nthUglyNumber(n, a, b, c):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def lcm(x, y):\n        return x * y // gcd(x, y)\n\n    def count(x):\n        return x // a + x // b + x // c - x // lcm(a, b) - x // lcm(a, c) - x // lcm(b, c) + x // lcm(a, b, c)\n\n    left, right = 1, 2 * 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count(mid) < n:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": false, "score": {"loc": 17, "tokens": 164, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.667162580618359}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 8844, "entry_point": "getKth", "best_list": [{"code": "def getKth(lo, hi, k):\n    def power(x):\n        steps = 0\n        while x != 1:\n            x = x // 2 if x % 2 == 0 else 3 * x + 1\n            steps += 1\n        return steps\n\n    return sorted(range(lo, hi + 1), key=power)[k - 1]", "passed": true, "score": {"loc": 8, "tokens": 71, "cc": 1, "nest": 3, "execution_time": 0.016723, "novelty": 0.33021462456129}}, {"code": "def getKth(lo, hi, k):\n    def power(x):\n        steps = 0\n        while x != 1:\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x = 3 * x + 1\n            steps += 1\n        return steps\n\n    return sorted(range(lo, hi + 1), key=power)[k - 1]", "passed": true, "score": {"loc": 11, "tokens": 74, "cc": 2, "nest": 4, "execution_time": 0.016616, "novelty": 0.3125068556116797}}, {"code": "def getKth(lo, hi, k):\n    def power(x):\n        steps = 0\n        while x != 1:\n            if x % 2 == 0:\n                x = x // 2\n            else:\n                x = 3 * x + 1\n            steps += 1\n        return steps\n\n    return sorted(range(lo, hi + 1), key=power)[k - 1]", "passed": true, "score": {"loc": 11, "tokens": 75, "cc": 2, "nest": 4, "execution_time": 0.016523, "novelty": 0.30140595433155914}}, {"code": "def getKth(lo, hi, k):\n    @lru_cache(None)\n    def power(x):\n        steps = 0\n        while x != 1:\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x = 3 * x + 1\n            steps += 1\n        return steps\n\n    numbers = list(range(lo, hi + 1))\n    numbers.sort(key=lambda x: (power(x), x))\n    return numbers[k - 1]", "passed": false, "score": {"loc": 14, "tokens": 96, "cc": 2, "nest": 4, "execution_time": 10.0, "novelty": 0.5494051148866}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 8861, "entry_point": "shortestSubarray", "best_list": [{"code": "def shortestSubarray(A, K):\n    n = len(A)\n    min_length = float('inf')\n    start = 0\n    current_sum = 0\n    \n    for end in range(n):\n        current_sum += A[end]\n        \n        while current_sum >= K:\n            min_length = min(min_length, end - start + 1)\n            current_sum -= A[start]\n            start += 1\n    \n    return min_length if min_length != float('inf') else -1", "passed": true, "score": {"loc": 12, "tokens": 87, "cc": 2, "nest": 3, "execution_time": 0.0167, "novelty": 0.5588258824187556}}, {"code": "from collections import deque\n\ndef shortestSubarray(A, K):\n    deque_idx = deque()\n    prefix_sum = [0]\n    for num in A:\n        prefix_sum.append(prefix_sum[-1] + num)\n    \n    min_length = float('inf')\n    for i, curr_sum in enumerate(prefix_sum):\n        while deque_idx and curr_sum - prefix_sum[deque_idx[0]] >= K:\n            min_length = min(min_length, i - deque_idx.popleft())\n        while deque_idx and curr_sum <= prefix_sum[deque_idx[-1]]:\n            deque_idx.pop()\n        deque_idx.append(i)\n    \n    return min_length if min_length != float('inf') else -1", "passed": true, "score": {"loc": 14, "tokens": 128, "cc": 6, "nest": 3, "execution_time": 0.016561, "novelty": 0.6954069620060985}}, {"code": "def shortestSubarray(A, K):\n    n = len(A)\n    ans = float('inf')\n    prefix_sum = [0]\n    for x in A:\n        prefix_sum.append(prefix_sum[-1] + x)\n    \n    queue = []\n    for i, acc in enumerate(prefix_sum):\n        while queue and acc - prefix_sum[queue[0]] >= K:\n            ans = min(ans, i - queue.pop(0))\n        while queue and acc <= prefix_sum[queue[-1]]:\n            queue.pop()\n        queue.append(i)\n    \n    return ans if ans < float('inf') else -1", "passed": true, "score": {"loc": 14, "tokens": 129, "cc": 6, "nest": 3, "execution_time": 0.016591, "novelty": 0.7025316101020354}}, {"code": "def shortestSubarray(A, K):\n    prefix_sum = [0]\n    min_length = float('inf')\n    min_index = {0: -1}\n    \n    for i, num in enumerate(A):\n        prefix_sum.append(prefix_sum[-1] + num)\n    \n    for i, total in enumerate(prefix_sum):\n        if total - K in min_index:\n            min_length = min(min_length, i - min_index[total - K])\n        \n        while min_index and total <= prefix_sum[min_index[-1]]:\n            min_index.pop()\n        \n        min_index[total] = i\n    \n    return min_length if min_length != float('inf') else -1", "passed": false, "score": {"loc": 13, "tokens": 124, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.7944853742799659}}, {"code": "def shortestSubarray(A, K):\n    n = len(A)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    deque = []\n    min_length = float('inf')\n    \n    for i in range(n + 1):\n        while deque and prefix_sum[i] - prefix_sum[deque[0]] >= K:\n            min_length = min(min_length, i - deque.popleft())\n        while deque and prefix_sum[i] <= prefix_sum[deque[-1]]:\n            deque.pop()\n        deque.append(i)\n    \n    return min_length if min_length != float('inf') else -1", "passed": false, "score": {"loc": 14, "tokens": 148, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.5385968639351302}}, {"code": "def shortestSubarray(A, K):\n    from collections import deque\n    \n    queue = deque()\n    prefix_sum = 0\n    min_length = float('inf')\n    \n    for i, num in enumerate(A):\n        prefix_sum += num\n        \n        while queue and prefix_sum - A[queue[0]] >= K:\n            min_length = min(min_length, i - queue.popleft())\n        \n        while queue and prefix_sum <= A[queue[-1]]:\n            queue.pop()\n        \n        queue.append(i)\n    \n    return min_length if min_length != float('inf') else -1", "passed": false, "score": {"loc": 13, "tokens": 113, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.5377499171955786}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 8898, "entry_point": "minDays", "best_list": [{"code": "def minDays(n):\n    memo = {0: 0, 1: 1}\n    \n    def dp(x):\n        if x not in memo:\n            memo[x] = 1 + min(x % 2 + dp(x // 2), x % 3 + dp(x // 3))\n        return memo[x]\n    \n    return dp(n)", "passed": true, "score": {"loc": 7, "tokens": 72, "cc": 1, "nest": 3, "execution_time": 0.016847, "novelty": 0.5205853052603445}}, {"code": "def minDays(n):\n    from functools import lru_cache\n\n    @lru_cache(None)\n    def dp(x):\n        if x <= 1:\n            return x\n        return 1 + min(dp(x // 2) + x % 2, dp(x // 3) + x % 3)\n\n    return dp(n)", "passed": true, "score": {"loc": 8, "tokens": 63, "cc": 1, "nest": 3, "execution_time": 0.016601, "novelty": 0.5304949994106101}}, {"code": "def minDays(n: int) -> int:\n    from functools import lru_cache\n    \n    @lru_cache(None)\n    def dp(x):\n        if x <= 1:\n            return x\n        return 1 + min(x % 2 + dp(x // 2), x % 3 + dp(x // 3))\n    \n    return dp(n)", "passed": true, "score": {"loc": 8, "tokens": 68, "cc": 1, "nest": 3, "execution_time": 0.01666, "novelty": 0.5218891457064555}}, {"code": "def minDays(n):\n    @lru_cache(None)\n    def dfs(x):\n        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        return 1 + min(x % 2 + dfs(x // 2), x % 3 + dfs(x // 3))\n    return dfs(n)", "passed": false, "score": {"loc": 9, "tokens": 67, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.4864765664976426}}, {"code": "def minDays(n):\n    from functools import lru_cache\n    \n    @lru_cache(None)\n    def dp(x):\n        if x == 1:\n            return 1\n        return 1 + min(x % 2 + dp(x // 2), x % 3 + dp(x // 3))\n    \n    return dp(n)", "passed": false, "score": {"loc": 8, "tokens": 63, "cc": 1, "nest": 3, "execution_time": 10.0, "novelty": 0.37983378367810294}}, {"code": "from functools import lru_cache\n\n@lru_cache(None)\ndef minDays(n):\n    if n == 1:\n        return 1\n    return 1 + min(n % 2 + minDays(n // 2), n % 3 + minDays(n // 3))", "passed": false, "score": {"loc": 6, "tokens": 52, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.49985458491967216}}, {"code": "def minDays(n):\n    memo = {}\n    def dp(n):\n        if n in memo:\n            return memo[n]\n        if n <= 1:\n            return n\n        div2 = dp(n // 2) if n % 2 == 0 else float('inf')\n        div3 = dp(n // 3) if n % 3 == 0 else float('inf')\n        memo[n] = 1 + min(div2, div3)\n        return memo[n]\n    return dp(n)", "passed": false, "score": {"loc": 12, "tokens": 103, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6208970627541557}}, {"code": "def minDays(n):\n    from functools import lru_cache\n    @lru_cache(None)\n    def dp(n):\n        if n == 1:\n            return 1\n        if n % 2 == 0 and n % 3 == 0:\n            return 1 + min(dp(n // 2), dp(n // 3))\n        elif n % 2 == 0:\n            return 1 + dp(n // 2)\n        elif n % 3 == 0:\n            return 1 + dp(n // 3)\n        else:\n            return 1 + dp(n - 1)\n    return dp(n)", "passed": false, "score": {"loc": 15, "tokens": 117, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.6509200699999377}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 8906, "entry_point": "judgeCircle", "best_list": [{"code": "def judgeCircle(moves):\n    return moves.count('U') == moves.count('D') and moves.count('L') == moves.count('R')", "passed": true, "score": {"loc": 2, "tokens": 44, "cc": 1, "nest": 1, "execution_time": 0.016515, "novelty": 0.3484101782187836}}, {"code": "def judgeCircle(moves: str) -> bool:\n    return moves.count('R') == moves.count('L') and moves.count('U') == moves.count('D')", "passed": true, "score": {"loc": 2, "tokens": 49, "cc": 1, "nest": 1, "execution_time": 0.016505, "novelty": 0.328076640868622}}, {"code": "def judgeCircle(moves: str) -> bool:\n    return moves.count('U') == moves.count('D') and moves.count('L') == moves.count('R')", "passed": true, "score": {"loc": 2, "tokens": 49, "cc": 1, "nest": 1, "execution_time": 0.016551, "novelty": 0.3288058110856039}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 8916, "entry_point": "combinationSum3", "best_list": [{"code": "def combinationSum3(k, n):\n    def dfs(path, start, remaining):\n        if remaining == 0 and len(path) == k:\n            result.append(path)\n            return\n        if remaining < 0 or len(path) > k:\n            return\n        for i in range(start, 10):\n            dfs(path + [i], i + 1, remaining - i)\n    \n    result = []\n    dfs([], 1, n)\n    return result", "passed": true, "score": {"loc": 12, "tokens": 93, "cc": 5, "nest": 3, "execution_time": 0.016834, "novelty": 0.6735263405015242}}, {"code": "def combinationSum3(k, n):\n    def backtrack(start, path, remaining):\n        if len(path) == k and remaining == 0:\n            result.append(path)\n            return\n        if len(path) == k or remaining < 0:\n            return\n        for i in range(start, 10):\n            backtrack(i + 1, path + [i], remaining - i)\n\n    result = []\n    backtrack(1, [], n)\n    return result", "passed": true, "score": {"loc": 12, "tokens": 94, "cc": 5, "nest": 3, "execution_time": 0.016943, "novelty": 0.3585438375350518}}, {"code": "def combinationSum3(k, n):\n    results = []\n    \n    def backtrack(start, path, remaining):\n        if len(path) == k and remaining == 0:\n            results.append(path)\n            return\n        if len(path) == k or remaining <= 0:\n            return\n        for i in range(start, 10):\n            backtrack(i + 1, path + [i], remaining - i)\n    \n    backtrack(1, [], n)\n    return results", "passed": true, "score": {"loc": 12, "tokens": 95, "cc": 5, "nest": 3, "execution_time": 0.016848, "novelty": 0.37803599218421724}}, {"code": "def combinationSum3(k: int, n: int) -> List[List[int]]:\n    def backtrack(start, k, n, path):\n        if k == 0 and n == 0:\n            results.append(path[:])\n            return\n        if k == 0 or n < 0:\n            return\n        for i in range(start, 10):\n            path.append(i)\n            backtrack(i + 1, k - 1, n - i, path)\n            path.pop()\n\n    results = []\n    backtrack(1, k, n, [])\n    return results", "passed": false, "score": {"loc": 14, "tokens": 119, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.5030261310132602}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 9022, "entry_point": "getWinner", "best_list": [{"code": "def getWinner(arr, k):\n    winner, win_count = arr[0], 0\n    for num in arr[1:]:\n        if num > winner:\n            winner, win_count = num, 1\n        else:\n            win_count += 1\n        if win_count == k:\n            break\n    return winner", "passed": true, "score": {"loc": 10, "tokens": 54, "cc": 3, "nest": 3, "execution_time": 0.016596, "novelty": 0.30431559590349755}}, {"code": "def getWinner(arr, k):\n    winner, win_count = arr[0], 0\n    for num in arr[1:]:\n        if num > winner:\n            winner, win_count = num, 1\n        else:\n            win_count += 1\n        if win_count == k:\n            return winner\n    return winner", "passed": true, "score": {"loc": 10, "tokens": 55, "cc": 3, "nest": 3, "execution_time": 0.016538, "novelty": 0.2906511968888632}}, {"code": "def getWinner(arr, k):\n    winner = arr[0]\n    win_count = 0\n    \n    for num in arr[1:]:\n        if num > winner:\n            winner = num\n            win_count = 1\n        else:\n            win_count += 1\n        \n        if win_count == k:\n            break\n    \n    return winner", "passed": true, "score": {"loc": 12, "tokens": 52, "cc": 3, "nest": 3, "execution_time": 0.016639, "novelty": 0.24618888526174054}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 9027, "entry_point": "findTheDistanceValue", "best_list": [{"code": "def findTheDistanceValue(arr1, arr2, d):\n    return sum(all(abs(a - b) > d for b in arr2) for a in arr1)", "passed": true, "score": {"loc": 2, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016492, "novelty": 0.09285206106074662}}, {"code": "def findTheDistanceValue(arr1, arr2, d):\n    return sum(all(abs(a1 - a2) > d for a2 in arr2) for a1 in arr1)", "passed": true, "score": {"loc": 2, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016698, "novelty": 0.4134992428115125}}, {"code": "def findTheDistanceValue(arr1, arr2, d):\n    return sum(all(abs(x - y) > d for y in arr2) for x in arr1)", "passed": true, "score": {"loc": 2, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016721, "novelty": 0.06856417016349226}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 9052, "entry_point": "canFinish", "best_list": [{"code": "def canFinish(n, prerequisites):\n    graph = [[] for _ in range(n)]\n    in_degree = [0] * n\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    queue = [i for i in range(n) if in_degree[i] == 0]\n    count = 0\n    \n    while queue:\n        prereq = queue.pop(0)\n        count += 1\n        \n        for course in graph[prereq]:\n            in_degree[course] -= 1\n            if in_degree[course] == 0:\n                queue.append(course)\n    \n    return count == n", "passed": true, "score": {"loc": 16, "tokens": 124, "cc": 4, "nest": 4, "execution_time": 0.016628, "novelty": 0.19497239351905393}}, {"code": "def canFinish(n, prerequisites):\n    graph = [[] for _ in range(n)]\n    in_degree = [0] * n\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    queue = [course for course in range(n) if in_degree[course] == 0]\n    count = 0\n    \n    while queue:\n        course = queue.pop(0)\n        count += 1\n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n    \n    return count == n", "passed": true, "score": {"loc": 16, "tokens": 124, "cc": 4, "nest": 4, "execution_time": 0.016633, "novelty": 0.2153964646483031}}, {"code": "def canFinish(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    indegree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        indegree[course] += 1\n    \n    queue = [course for course in range(numCourses) if indegree[course] == 0]\n    count = 0\n    \n    while queue:\n        course = queue.pop(0)\n        count += 1\n        \n        for next_course in graph[course]:\n            indegree[next_course] -= 1\n            if indegree[next_course] == 0:\n                queue.append(next_course)\n    \n    return count == numCourses", "passed": true, "score": {"loc": 16, "tokens": 124, "cc": 4, "nest": 4, "execution_time": 0.016795, "novelty": 0.2249998599761629}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 9097, "entry_point": "removePalindromeSub", "best_list": [{"code": "def removePalindromeSub(s):\n    return 1 if s == s[::-1] else 2", "passed": true, "score": {"loc": 2, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 0.016687, "novelty": 0.0643339493985976}}, {"code": "def removePalindromeSub(s: str) -> int:\n    return 1 if s == s[::-1] else 2", "passed": true, "score": {"loc": 2, "tokens": 26, "cc": 0, "nest": 1, "execution_time": 0.016447, "novelty": 0.1251882513109146}}, {"code": "def removePalindromeSub(s):\n    return 0 if not s else 1 if s == s[::-1] else 2", "passed": true, "score": {"loc": 2, "tokens": 26, "cc": 0, "nest": 1, "execution_time": 0.016626, "novelty": 0.1273519079011678}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 9113, "entry_point": "find132pattern", "best_list": [{"code": "def find132pattern(nums):\n    stack = []\n    third = float('-inf')\n    for num in reversed(nums):\n        if num < third: return True\n        while stack and stack[-1] < num: third = stack.pop()\n        stack.append(num)\n    return False", "passed": true, "score": {"loc": 8, "tokens": 60, "cc": 4, "nest": 3, "execution_time": 0.01656, "novelty": 0.18576593846076905}}, {"code": "def find132pattern(nums):\n    min_stack = []\n    second_max = float('-inf')\n    \n    for num in reversed(nums):\n        if num < second_max:\n            return True\n        while min_stack and min_stack[-1] < num:\n            second_max = min_stack.pop()\n        min_stack.append(num)\n    \n    return False", "passed": true, "score": {"loc": 10, "tokens": 60, "cc": 4, "nest": 3, "execution_time": 0.016531, "novelty": 0.2097682364839396}}, {"code": "def find132pattern(nums):\n    stack = []\n    third = float('-inf')\n    \n    for j in range(len(nums)-1, -1, -1):\n        if nums[j] < third:\n            return True\n        while stack and nums[j] > stack[-1]:\n            third = stack.pop()\n        stack.append(nums[j])\n    \n    return False", "passed": true, "score": {"loc": 10, "tokens": 80, "cc": 4, "nest": 3, "execution_time": 0.016652, "novelty": 0.32252809942956984}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 9147, "entry_point": "minimumOneBitOperations", "best_list": [{"code": "def minimumOneBitOperations(n):\n    return n ^ (n >> 1)", "passed": true, "score": {"loc": 2, "tokens": 15, "cc": 0, "nest": 1, "execution_time": 0.016627, "novelty": 0.5531757198354736}}, {"code": "def minimumOneBitOperations(n: int) -> int:\n    return n if n == 0 else 2 * minimumOneBitOperations(n ^ (n >> 1)) - 1", "passed": true, "score": {"loc": 2, "tokens": 34, "cc": 0, "nest": 1, "execution_time": 0.01655, "novelty": 0.5216299016734125}}, {"code": "def minimumOneBitOperations(n):\n    n = n.bit_length()\n    return (1 << n) - 1 - minimumOneBitOperations(n - 1) if n else 0", "passed": true, "score": {"loc": 3, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016713, "novelty": 0.5258179088288581}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 9211, "entry_point": "generateTheString", "best_list": [{"code": "def generateTheString(n):\n    return 'a' * (n - 1) + ('b' if n % 2 == 0 else 'a')", "passed": true, "score": {"loc": 2, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016614, "novelty": 0.12977449418127385}}, {"code": "def generateTheString(n):\n    if n % 2 == 1:\n        return 'a' * n\n    else:\n        return 'a' * (n - 1) + 'b'", "passed": true, "score": {"loc": 5, "tokens": 36, "cc": 1, "nest": 2, "execution_time": 0.016603, "novelty": 0.46735099933175384}}, {"code": "def generateTheString(n):\n    if n % 2 == 0:\n        return 'a' * (n - 1) + 'b'\n    else:\n        return 'a' * n", "passed": true, "score": {"loc": 5, "tokens": 36, "cc": 1, "nest": 2, "execution_time": 0.016633, "novelty": 0.42585495413401386}}, {"code": "def generateTheString(n: int) -> str:\n    return 'a' * (n - (n & 1)) + 'b' * (n & 1)", "passed": false, "score": {"loc": 2, "tokens": 35, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.372942131544282}}], "num_pass": 9, "num_uniq": 3, "num_fail": 1, "fail_uniq": 1}
{"id": 9273, "entry_point": "findKthNumber", "best_list": [{"code": "def findKthNumber(n, k):\n    count = 0\n    current = 1\n    while count < k:\n        if current <= n:\n            count += 1\n        if count == k:\n            return current\n        if current * 10 > n:\n            current += 1\n        else:\n            current *= 10", "passed": true, "score": {"loc": 12, "tokens": 54, "cc": 4, "nest": 3, "execution_time": 0.016505, "novelty": 0.6737771053285686}}, {"code": "def findKthNumber(n: int, k: int) -> int:\n    count = 0\n    current = 1\n    while count < k:\n        count += 1\n        if count == k:\n            return current\n        if current * 10 <= n:\n            current *= 10\n        else:\n            current += 1\n            while current > n or current % 10 == 0:\n                current //= 10\n                current += 1", "passed": true, "score": {"loc": 14, "tokens": 77, "cc": 5, "nest": 4, "execution_time": 0.016811, "novelty": 0.6331140267726686}}, {"code": "def findKthNumber(n, k):\n    def count_numbers(prefix):\n        count = 0\n        current = prefix\n        while current <= n:\n            count += min(n + 1, current + 10) - current\n            current *= 10\n        return count\n\n    prefix = 1\n    k -= 1\n    while k > 0:\n        count = count_numbers(prefix)\n        if k < count:\n            prefix *= 10\n            k -= 1\n        else:\n            prefix += 1\n            k -= count\n    return prefix", "passed": true, "score": {"loc": 19, "tokens": 90, "cc": 3, "nest": 3, "execution_time": 0.016615, "novelty": 0.5287691764501126}}, {"code": "def findKthNumber(n, k):\n    return sorted(range(1, n + 1))[k - 1]", "passed": false, "score": {"loc": 2, "tokens": 25, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7412033835322567}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 9327, "entry_point": "heightChecker", "best_list": [{"code": "def heightChecker(heights):\n    return sum(h1 != h2 for h1, h2 in zip(heights, sorted(heights)))", "passed": true, "score": {"loc": 2, "tokens": 28, "cc": 0, "nest": 1, "execution_time": 0.016565, "novelty": 0.15845593262270008}}, {"code": "def heightChecker(heights):\n    return sum(h != s for h, s in zip(heights, sorted(heights)))", "passed": true, "score": {"loc": 2, "tokens": 28, "cc": 0, "nest": 1, "execution_time": 0.016636, "novelty": 0.16039536545304367}}, {"code": "def heightChecker(heights):\n    sorted_heights = sorted(heights)\n    return sum(h1 != h2 for h1, h2 in zip(heights, sorted_heights))", "passed": true, "score": {"loc": 3, "tokens": 31, "cc": 0, "nest": 1, "execution_time": 0.016485, "novelty": 0.1795745598316122}}, {"code": "def heightChecker(heights):\n    sorted_heights = sorted(heights)\n    index_map = {height: idx for idx, height in enumerate(sorted_heights)}\n    return sum(index_map[height] != idx for idx, height in enumerate(heights))", "passed": false, "score": {"loc": 4, "tokens": 48, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.4782129763077724}}], "num_pass": 9, "num_uniq": 3, "num_fail": 1, "fail_uniq": 1}
{"id": 9382, "entry_point": "uniquePaths", "best_list": [{"code": "def uniquePaths(m, n):\n    from math import comb\n    return comb(m + n - 2, n - 1)", "passed": true, "score": {"loc": 3, "tokens": 25, "cc": 0, "nest": 1, "execution_time": 0.016479, "novelty": 0.6154815559776688}}, {"code": "from math import comb\n\ndef uniquePaths(m, n):\n    return comb(m + n - 2, n - 1)", "passed": true, "score": {"loc": 3, "tokens": 25, "cc": 0, "nest": 1, "execution_time": 0.016715, "novelty": 0.598019652828812}}, {"code": "def uniquePaths(m, n):\n    dp = [1] * n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[j] += dp[j - 1]\n    return dp[-1]", "passed": true, "score": {"loc": 6, "tokens": 53, "cc": 2, "nest": 3, "execution_time": 0.016687, "novelty": 0.6446222941218451}}, {"code": "def uniquePaths(m, n):\n    def helper(x, y):\n        if x == 0 or y == 0:\n            return 0\n        if x == 1 and y == 1:\n            return 1\n        return helper(x-1, y) + helper(x, y-1)\n    \n    return helper(m-1, n-1)", "passed": false, "score": {"loc": 8, "tokens": 71, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.698634467330842}}, {"code": "def uniquePaths(m, n):\n    def dp(i, j):\n        if i == 0 or j == 0:\n            return 0\n        if i == 1 and j == 1:\n            return 1\n        return dp(i-1, j) + dp(j-1, i)\n    return dp(m-1, n-1)", "passed": false, "score": {"loc": 8, "tokens": 71, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.6905870555165092}}], "num_pass": 8, "num_uniq": 7, "num_fail": 2, "fail_uniq": 2}
{"id": 9421, "entry_point": "climbStairs", "best_list": [{"code": "def climbStairs(n):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return b", "passed": true, "score": {"loc": 5, "tokens": 32, "cc": 1, "nest": 2, "execution_time": 0.01642, "novelty": 0.2408101726241878}}, {"code": "def climbStairs(n: int) -> int:\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return b", "passed": true, "score": {"loc": 5, "tokens": 37, "cc": 1, "nest": 2, "execution_time": 0.016565, "novelty": 0.25748260404079604}}, {"code": "def climbStairs(n):\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n + 1):\n        a, b = b, a + b\n    return b", "passed": true, "score": {"loc": 7, "tokens": 44, "cc": 2, "nest": 2, "execution_time": 0.016534, "novelty": 0.3292349033714016}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 9459, "entry_point": "maxSumDivThree", "best_list": [{"code": "def maxSumDivThree(nums):\n    mod = [0] * 3\n    for num in nums:\n        for j in mod[:]:\n            mod[(j + num) % 3] = max(mod[(j + num) % 3], j + num)\n    return mod[0]", "passed": true, "score": {"loc": 6, "tokens": 59, "cc": 2, "nest": 3, "execution_time": 0.016518, "novelty": 0.6458456994560751}}, {"code": "def maxSumDivThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        for d in dp[:]:\n            dp[(d + num) % 3] = max(dp[(d + num) % 3], d + num)\n    return dp[0]", "passed": true, "score": {"loc": 6, "tokens": 61, "cc": 2, "nest": 3, "execution_time": 0.016586, "novelty": 0.5075192564049215}}, {"code": "def maxSumDivThree(nums):\n    mod_sum = [0, 0, 0]\n    for num in nums:\n        for i in range(2, -1, -1):\n            mod_sum[(i + num) % 3] = max(mod_sum[(i + num) % 3], mod_sum[i] + num)\n    return mod_sum[0]", "passed": false, "score": {"loc": 6, "tokens": 70, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.44110470429438076}}, {"code": "def maxSumDivThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        for mod in [num % 3, (num + dp[0]) % 3, (num + dp[1]) % 3]:\n            dp[mod] = max(dp[mod], dp[(mod - num) % 3] + num)\n    return dp[0]", "passed": false, "score": {"loc": 6, "tokens": 81, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5529823975198851}}, {"code": "def maxSumDivThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        for i in range(2, -1, -1):\n            dp[(i + num) % 3] = max(dp[(i + num) % 3], dp[i] + num)\n    return dp[0]", "passed": false, "score": {"loc": 6, "tokens": 70, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.39693716484994546}}, {"code": "def maxSumDivThree(nums):\n    dp = [0, float('-inf'), float('-inf')]\n    for num in nums:\n        for mod in range(3):\n            dp[(mod + num) % 3] = max(dp[(mod + num) % 3], dp[mod] + num)\n    return dp[0]", "passed": false, "score": {"loc": 6, "tokens": 76, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7655779742334574}}, {"code": "def maxSumDivThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        for mod, val in enumerate(dp[:]):\n            dp[(mod + num) % 3] = max(dp[(mod + num) % 3], val + num)\n    return dp[0]", "passed": false, "score": {"loc": 6, "tokens": 66, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.4361958385504472}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 6}
{"id": 9461, "entry_point": "maximumSwap", "best_list": [{"code": "def maximumSwap(n):\n    digits = list(str(n))\n    last = {int(d): i for i, d in enumerate(digits)}\n    for i, d in enumerate(digits):\n        for d2 in range(9, int(d), -1):\n            if last.get(d2, -1) > i:\n                digits[i], digits[last[d2]] = digits[last[d2]], digits[i]\n                return int(''.join(digits))\n    return n", "passed": true, "score": {"loc": 9, "tokens": 111, "cc": 3, "nest": 4, "execution_time": 0.016362, "novelty": 0.4594541589684463}}, {"code": "def maximumSwap(num):\n    digits = list(str(num))\n    last = {int(d): i for i, d in enumerate(digits)}\n    for i, d in enumerate(digits):\n        for k in range(9, int(d), -1):\n            if last.get(k, -1) > i:\n                digits[i], digits[last[k]] = digits[last[k]], digits[i]\n                return int(''.join(digits))\n    return num", "passed": true, "score": {"loc": 9, "tokens": 111, "cc": 3, "nest": 4, "execution_time": 0.016799, "novelty": 0.4525388257109424}}, {"code": "def maximumSwap(n):\n    digits = [int(d) for d in str(n)]\n    pos = {d: i for i, d in enumerate(digits)}\n    for i, d in enumerate(digits):\n        for k in range(9, d, -1):\n            if pos.get(k, -1) > i:\n                digits[i], digits[pos[k]] = digits[pos[k]], digits[i]\n                return int(''.join(map(str, digits)))\n    return n", "passed": true, "score": {"loc": 9, "tokens": 116, "cc": 3, "nest": 4, "execution_time": 0.016512, "novelty": 0.5061217899422921}}, {"code": "def maximumSwap(num):\n    digits = list(str(num))\n    last = {int(d): i for i, d in enumerate(digits)}\n    for i, d in enumerate(digits):\n        d = int(d)\n        for k in range(9, d, -1):\n            if last.get(k) > i:\n                digits[i], digits[last[k]] = digits[last[k]], digits[i]\n                return int(''.join(digits))\n    return num", "passed": false, "score": {"loc": 10, "tokens": 111, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5049907264175684}}, {"code": "def maximumSwap(num):\n    digits = list(str(num))\n    last = {int(d): i for i, d in enumerate(digits)}\n    for i, d in enumerate(digits):\n        for d2 in range(9, int(d), -1):\n            if last[d2] > i:\n                digits[i], digits[last[d2]] = digits[last[d2]], digits[i]\n                return int(''.join(digits))\n    return num", "passed": false, "score": {"loc": 9, "tokens": 106, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5279414418482793}}, {"code": "def maximumSwap(num):\n    digits = list(str(num))\n    idx = {int(d): i for i, d in enumerate(digits)}\n    for i in range(len(digits)):\n        for d in range(9, int(digits[i]), -1):\n            d = str(d)\n            if idx[int(d)] > i:\n                digits[i], digits[idx[int(d)]] = digits[idx[int(d)]], digits[i]\n                return int(''.join(digits))\n    return num", "passed": false, "score": {"loc": 10, "tokens": 125, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.6147804301912039}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 9539, "entry_point": "numEquivDominoPairs", "best_list": [{"code": "def numEquivDominoPairs(dominoes):\n    from collections import Counter\n    count = Counter(tuple(sorted(d)) for d in dominoes)\n    return sum(v * (v - 1) // 2 for v in count.values())", "passed": true, "score": {"loc": 4, "tokens": 48, "cc": 0, "nest": 1, "execution_time": 0.01668, "novelty": 0.49781895546552113}}, {"code": "def numEquivDominoPairs(dominoes):\n    domino_counts = {}\n    for domino in dominoes:\n        sorted_domino = tuple(sorted(domino))\n        domino_counts[sorted_domino] = domino_counts.get(sorted_domino, 0) + 1\n    return sum(count * (count - 1) // 2 for count in domino_counts.values())", "passed": true, "score": {"loc": 6, "tokens": 61, "cc": 1, "nest": 2, "execution_time": 0.016651, "novelty": 0.632777419370717}}, {"code": "from collections import Counter\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs or lhs == rhs[::-1]\n\ndef numEquivDominoPairs(dominoes):\n    count = Counter(tuple(sorted(d)) for d in dominoes)\n    return sum(v * (v - 1) // 2 for v in count.values())", "passed": true, "score": {"loc": 6, "tokens": 72, "cc": 1, "nest": 1, "execution_time": 0.016768, "novelty": 0.6632929749734208}}, {"code": "def numEquivDominoPairs(dominoes):\n    from collections import Counter\n    count = Counter(tuple(sorted(d)) for d in dominoes)\n    return sum(v * (v - 1) // 2 for v in count.values())\n\ndef _equivalent(lhs, rhs):\n    return sorted(lhs) == sorted(rhs)", "passed": false, "score": {"loc": 6, "tokens": 67, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6196097506295049}}, {"code": "def _equivalent(lhs, rhs):\n    return sorted(lhs) == sorted(rhs)\n\ndef numEquivDominoPairs(dominoes):\n    counts = {}\n    for domino in dominoes:\n        key = tuple(sorted(domino))\n        counts[key] = counts.get(key, 0) + 1\n    return sum(v * (v - 1) // 2 for v in counts.values())", "passed": false, "score": {"loc": 8, "tokens": 80, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.7361569502510068}}, {"code": "def numEquivDominoPairs(dominoes):\n    count = 0\n    for i in range(len(dominoes)):\n        for j in range(i + 1, len(dominoes)):\n            if (dominoes[i][0] == dominoes[j][0] and dominoes[i][1] == dominoes[j][1]) or \\\n               (dominoes[i][0] == dominoes[j][1] and dominoes[i][1] == dominoes[j][0]):\n                count += 1\n    return count\n\ndef _equivalent(lhs, rhs):\n    return (lhs[0] == rhs[0] and lhs[1] == rhs[1]) or (lhs[0] == rhs[1] and lhs[1] == rhs[0])", "passed": false, "score": {"loc": 10, "tokens": 171, "cc": 9, "nest": 4, "execution_time": 10.0, "novelty": 0.8153397149308849}}], "num_pass": 7, "num_uniq": 6, "num_fail": 3, "fail_uniq": 3}
{"id": 9573, "entry_point": "isOneBitCharacter", "best_list": [{"code": "def isOneBitCharacter(bits):\n    i = 0\n    while i < len(bits) - 1:\n        i += bits[i] + 1\n    return len(bits) - i == 1", "passed": true, "score": {"loc": 5, "tokens": 38, "cc": 1, "nest": 2, "execution_time": 0.016592, "novelty": 0.1577300586420184}}, {"code": "def isOneBitCharacter(bits):\n    i = 0\n    while i < len(bits) - 1:\n        i += bits[i] + 1\n    return i == len(bits) - 1", "passed": true, "score": {"loc": 5, "tokens": 38, "cc": 1, "nest": 2, "execution_time": 0.016616, "novelty": 0.3044667654369705}}, {"code": "def isOneBitCharacter(bits):\n    i, n = 0, len(bits)\n    while i < n - 1:\n        i += bits[i] + 1\n    return n - i == 1", "passed": true, "score": {"loc": 5, "tokens": 39, "cc": 1, "nest": 2, "execution_time": 0.016565, "novelty": 0.40208246979170026}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 9591, "entry_point": "leastInterval", "best_list": [{"code": "from collections import Counter\n\ndef leastInterval(tasks, n):\n    return max(len(tasks), (n + 1) * (max(Counter(tasks).values()) - 1) + list(Counter(tasks).values()).count(max(Counter(tasks).values())))", "passed": true, "score": {"loc": 3, "tokens": 69, "cc": 0, "nest": 1, "execution_time": 0.016613, "novelty": 0.6680054707597582}}, {"code": "def leastInterval(tasks, n):\n    freq = sorted([tasks.count(task) for task in set(tasks)], reverse=True)\n    max_freq = freq[0]\n    max_count = freq.count(max_freq)\n    return max((max_freq - 1) * (n + 1) + max_count, len(tasks))", "passed": true, "score": {"loc": 5, "tokens": 68, "cc": 0, "nest": 1, "execution_time": 0.016634, "novelty": 0.5454102712104739}}, {"code": "def leastInterval(tasks, n):\n    from collections import Counter\n    freq = list(Counter(tasks).values())\n    max_freq = max(freq)\n    max_count = freq.count(max_freq)\n    return max((max_freq - 1) * (n + 1) + max_count, len(tasks))", "passed": true, "score": {"loc": 6, "tokens": 61, "cc": 0, "nest": 1, "execution_time": 0.016576, "novelty": 0.4943659866574035}}, {"code": "def leastInterval(tasks, n):\n    freq = [0] * 26\n    for task in tasks:\n        freq[ord(task) - ord('A')] += 1\n    max_freq = max(freq)\n    max_count = freq.count(max_freq)\n    return max((max_freq - 1) * (n + 1) + max_count, len(tasks))", "passed": false, "score": {"loc": 7, "tokens": 73, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.66558916793147}}, {"code": "def leastInterval(tasks, n):\n    if n == 0:\n        return len(tasks)\n    \n    task_counts = [0] * 26\n    for task in tasks:\n        task_counts[ord(task) - ord('A')] += 1\n    \n    max_count = max(task_counts)\n    max_tasks = task_counts.count(max_count)\n    \n    return max((max_count - 1) * (n + 1) + max_tasks, len(tasks))", "passed": false, "score": {"loc": 9, "tokens": 84, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.772636559892401}}, {"code": "def leastInterval(tasks, n):\n    task_counts = [0] * 26\n    max_count = 0\n    max_count_tasks = 0\n    \n    for task in tasks:\n        task_counts[ord(task) - ord('A')] += 1\n        if task_counts[ord(task) - ord('A')] > max_count:\n            max_count = task_counts[ord(task) - ord('A')]\n            max_count_tasks = 1\n        elif task_counts[ord(task) - ord('A')] == max_count:\n            max_count_tasks += 1\n    \n    part_count = max_count - 1\n    part_length = n - (max_count_tasks - 1)\n    empty_slots = part_count * part_length\n    available_tasks = len(tasks) - max_count * max_count_tasks\n    \n    idles = max(0, empty_slots - available_tasks)\n    \n    return len(tasks) + idles", "passed": false, "score": {"loc": 17, "tokens": 149, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7983795564350049}}, {"code": "def leastInterval(tasks, n):\n    freq = list(collections.Counter(tasks).values())\n    max_freq = max(freq)\n    n_max = freq.count(max_freq)\n    return max(len(tasks), (max_freq - 1) * (n + 1) + n_max)", "passed": false, "score": {"loc": 5, "tokens": 59, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5524093591899534}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 9652, "entry_point": "longestDecomposition", "best_list": [{"code": "def longestDecomposition(text: str) -> int:\n    def dfs(left, right):\n        if left >= right:\n            return 0\n        for i in range(1, right - left + 1):\n            if text[left:left + i] == text[right - i + 1:right + 1]:\n                return 2 + dfs(left + i, right - i)\n        return 1\n    \n    return dfs(0, len(text) - 1)", "passed": true, "score": {"loc": 9, "tokens": 92, "cc": 3, "nest": 4, "execution_time": 0.016583, "novelty": 0.8263707282493402}}, {"code": "def longestDecomposition(text: str) -> int:\n    n = len(text)\n    dp = [0] * (n + 1)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if text[:i + 1] == text[j:]: \n                dp[j] = max(dp[j], dp[i] + 2)\n    return dp[n]", "passed": false, "score": {"loc": 8, "tokens": 90, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7015253843672431}}, {"code": "def longestDecomposition(text):\n    n = len(text)\n    result = 0\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and text[i:j] != text[n-j:i:-1]:\n            j += 1\n        result += 2 if j == n else 1\n        i = j\n    return result", "passed": false, "score": {"loc": 11, "tokens": 73, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5721733698255935}}, {"code": "def longestDecomposition(text):\n    n = len(text)\n    result = 0\n    i, j = 0, n - 1\n    while i < j:\n        k = 1\n        while text[i:i+k] != text[j-k+1:j+1]:\n            k += 1\n        result += 2\n        i += k\n        j -= k\n    if i == j:\n        result += 1\n    return result", "passed": false, "score": {"loc": 14, "tokens": 84, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.49844760331133575}}, {"code": "def longestDecomposition(text):\n    n = len(text)\n    i = 0\n    j = n - 1\n    result = 0\n    prefix = []\n    suffix = []\n    \n    while i < j:\n        prefix.append(text[i])\n        suffix.insert(0, text[j])\n        if prefix == suffix:\n            result += 2\n            prefix.clear()\n            suffix.clear()\n        i += 1\n        j -= 1\n    \n    if i == j:\n        result += 1\n    \n    return result", "passed": false, "score": {"loc": 19, "tokens": 96, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.682510632684445}}, {"code": "def longestDecomposition(text: str) -> int:\n    k, n = 0, len(text)\n    i, j = 0, n\n    while i < j:\n        while text[i:j] != text[n-j:n-i]:\n            j -= 1\n        k += 2\n        i = j\n        j = n\n    return k + (n - i) % 2", "passed": false, "score": {"loc": 10, "tokens": 77, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5773132190397499}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 9693, "entry_point": "new21Game", "best_list": [{"code": "def new21Game(N, K, W):\n    if K == 0 or N >= K + W:\n        return 1.0\n    dp = [0] * (N + 1)\n    dp[0] = 1.0\n    window_sum = 1.0\n    \n    for i in range(1, N + 1):\n        dp[i] = window_sum / W\n        if i < K:\n            window_sum += dp[i]\n        if i >= W:\n            window_sum -= dp[i - W]\n    \n    return sum(dp[K:])", "passed": true, "score": {"loc": 13, "tokens": 107, "cc": 5, "nest": 3, "execution_time": 0.016581, "novelty": 0.3951478805674242}}, {"code": "def new21Game(N, K, W):\n    if K == 0 or N >= K + W:\n        return 1.0\n    dp = [0.0] * (N + 1)\n    dp[0] = 1.0\n    window_sum = 1.0\n    for i in range(1, N + 1):\n        dp[i] = window_sum / W\n        if i < K:\n            window_sum += dp[i]\n        if i - W >= 0:\n            window_sum -= dp[i - W]\n    return sum(dp[K:])", "passed": true, "score": {"loc": 13, "tokens": 111, "cc": 5, "nest": 3, "execution_time": 0.016699, "novelty": 0.3853025204175873}}, {"code": "def new21Game(N: int, K: int, W: int) -> float:\n    if K == 0 or N >= K + W:\n        return 1.0\n    dp = [0.0] * (N + 1)\n    dp[0] = 1.0\n    window_sum = 1.0\n    for i in range(1, N + 1):\n        dp[i] = window_sum / W\n        if i < K:\n            window_sum += dp[i]\n        if i >= W:\n            window_sum -= dp[i - W]\n    return sum(dp[K:])", "passed": true, "score": {"loc": 13, "tokens": 118, "cc": 5, "nest": 3, "execution_time": 0.016575, "novelty": 0.3924587737841151}}, {"code": "def new21Game(N, K, W):\n    if K == 0:\n        return 1.0\n    dp = [0.0] * (N + W + 1)\n    dp[N] = 1.0\n    for i in range(N - 1, -1, -1):\n        for j in range(1, W + 1):\n            if i + j <= N:\n                dp[i] += dp[i + j]\n    return sum(dp[:K])", "passed": false, "score": {"loc": 10, "tokens": 100, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.4851819048751408}}, {"code": "from functools import lru_cache\n\n@lru_cache(None)\ndef new21Game(N, K, W):\n    if K == 0 or N >= K + W:\n        return 1.0\n    return sum(new21Game(N - i, K, W) for i in range(1, W + 1)) / W", "passed": false, "score": {"loc": 6, "tokens": 63, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.6360493385910712}}, {"code": "def new21Game(N, K, W):\n    if K == 0:\n        return 1.0\n    dp = [0.0] * (N + W + 1)\n    dp[N] = 1.0\n    for i in range(N - 1, -1, -1):\n        dp[i] = sum(dp[i + 1:i + W + 1]) / W\n    return sum(dp[:K])", "passed": false, "score": {"loc": 8, "tokens": 90, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.4302134933069516}}, {"code": "def new21Game(N: int, K: int, W: int) -> float:\n    if K == 0 or N >= K + W:\n        return 1.0\n    dp = [0.0] * (K + W + 1)\n    dp[K] = 1.0\n    for i in range(K - 1, -1, -1):\n        dp[i] = sum(dp[i + 1:i + W + 1]) / W\n    return dp[0]", "passed": false, "score": {"loc": 8, "tokens": 102, "cc": 3, "nest": 2, "execution_time": 10.0, "novelty": 0.38720379427100304}}, {"code": "def new21Game(N, K, W):\n    if K == 0:\n        return 1.0\n    dp = [0.0] * (N + W + 1)\n    for i in range(N, -1, -1):\n        for j in range(W, 0, -1):\n            if i + j <= N:\n                dp[i] += dp[i + j] / W\n    return dp[0]", "passed": false, "score": {"loc": 9, "tokens": 89, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.5770210092715973}}], "num_pass": 4, "num_uniq": 3, "num_fail": 6, "fail_uniq": 6}
{"id": 9695, "entry_point": "canConstruct", "best_list": [{"code": "def canConstruct(ransomNote: str, magazine: str) -> bool:\n    return all(magazine.count(char) >= ransomNote.count(char) for char in set(ransomNote))", "passed": true, "score": {"loc": 2, "tokens": 40, "cc": 0, "nest": 1, "execution_time": 0.016459, "novelty": 0.5349901034504092}}, {"code": "def canConstruct(ransomNote, magazine):\n    from collections import Counter\n    return not Counter(ransomNote) - Counter(magazine)", "passed": true, "score": {"loc": 3, "tokens": 23, "cc": 0, "nest": 1, "execution_time": 0.016703, "novelty": 0.5092745409062747}}, {"code": "def canConstruct(ransomNote: str, magazine: str) -> bool:\n    from collections import Counter\n    return not Counter(ransomNote) - Counter(magazine)", "passed": true, "score": {"loc": 3, "tokens": 30, "cc": 0, "nest": 1, "execution_time": 0.016595, "novelty": 0.4241414862939402}}, {"code": "def canConstruct(ransomNote, magazine):\n    count = [0] * 26\n    for char in magazine:\n        count[ord(char) - ord('a')] += 1\n    for char in ransomNote:\n        if count[ord(char) - ord('a')] == 0:\n            return False\n        count[ord(char) - ord('a')] -= 1\n    return True", "passed": false, "score": {"loc": 9, "tokens": 82, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.648433848034751}}, {"code": "def canConstruct(ransomNote: str, magazine: str) -> bool:\n    count = [0] * 26\n    for char in magazine:\n        count[ord(char) - ord('a')] += 1\n    for char in ransomNote:\n        if count[ord(char) - ord('a')] == 0:\n            return False\n        count[ord(char) - ord('a')] -= 1\n    return True", "passed": false, "score": {"loc": 9, "tokens": 89, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5718556761571465}}], "num_pass": 8, "num_uniq": 6, "num_fail": 2, "fail_uniq": 2}
{"id": 9763, "entry_point": "titleToNumber", "best_list": [{"code": "def titleToNumber(s): return sum((ord(c) - ord('A') + 1) * (26 ** i) for i, c in enumerate(reversed(s)))", "passed": true, "score": {"loc": 1, "tokens": 44, "cc": 0, "nest": 1, "execution_time": 0.016678, "novelty": 0.2530186201942445}}, {"code": "def titleToNumber(s):\n    return 0 if not s else titleToNumber(s[:-1]) * 26 + (ord(s[-1]) - ord('A') + 1)", "passed": true, "score": {"loc": 2, "tokens": 43, "cc": 0, "nest": 1, "execution_time": 0.016663, "novelty": 0.6276885244144057}}, {"code": "def titleToNumber(s):\n    result = 0\n    for char in s:\n        result = result * 26 + (ord(char) - ord('A') + 1)\n    return result", "passed": true, "score": {"loc": 5, "tokens": 37, "cc": 1, "nest": 2, "execution_time": 0.016617, "novelty": 0.5056099653925439}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 9788, "entry_point": "numDupDigitsAtMostN", "best_list": [{"code": "def numDupDigitsAtMostN(N):\n    def has_repeated_digits(num):\n        digits = str(num)\n        return len(digits) != len(set(digits))\n    \n    count = 0\n    for i in range(1, N + 1):\n        if has_repeated_digits(i):\n            count += 1\n    return count", "passed": true, "score": {"loc": 9, "tokens": 59, "cc": 2, "nest": 3, "execution_time": 0.016703, "novelty": 0.6230529654524906}}, {"code": "def numDupDigitsAtMostN(N):\n    def has_repeated_digits(n):\n        digits = []\n        while n:\n            d = n % 10\n            if d in digits:\n                return True\n            digits.append(d)\n            n //= 10\n        return False\n\n    return sum(has_repeated_digits(i) for i in range(1, N + 1))", "passed": true, "score": {"loc": 11, "tokens": 63, "cc": 2, "nest": 4, "execution_time": 0.01664, "novelty": 0.3708797428935635}}, {"code": "def numDupDigitsAtMostN(N):\n    def has_repeated_digits(number):\n        digits = []\n        while number > 0:\n            digit = number % 10\n            if digit in digits:\n                return True\n            digits.append(digit)\n            number //= 10\n        return False\n\n    return sum(has_repeated_digits(i) for i in range(1, N + 1))", "passed": true, "score": {"loc": 11, "tokens": 65, "cc": 2, "nest": 4, "execution_time": 0.016547, "novelty": 0.3915580740885869}}, {"code": "def numDupDigitsAtMostN(N):\n    def count_non_repeated(n):\n        if n == 0:\n            return 1\n        digits = [i for i in range(1, 10)]\n        count = 0\n        while n > 0:\n            d = n % 10\n            count += len(digits) * factorial(len(digits) - 1)\n            digits.remove(d)\n            n //= 10\n        return count\n\n    def factorial(n):\n        if n == 0:\n            return 1\n        result = 1\n        for i in range(1, n + 1):\n            result *= i\n        return result\n\n    def has_repeated_digits(n):\n        seen = set()\n        while n > 0:\n            d = n % 10\n            if d in seen:\n                return True\n            seen.add(d)\n            n //= 10\n        return False\n\n    count = 0\n    for i in range(1, len(str(N)) + 1):\n        count += 9 * count_non_repeated(i - 1)\n    count -= sum(1 for i in range(1, len(str(N)) + 1) if has_repeated_digits(i))\n    return count", "passed": false, "score": {"loc": 33, "tokens": 216, "cc": 7, "nest": 4, "execution_time": 10.0, "novelty": 0.8467111165759831}}, {"code": "def numDupDigitsAtMostN(N):\n    def has_repeated_digits(n):\n        digits = []\n        while n > 0:\n            d = n % 10\n            if d in digits or d == 0:\n                return True\n            digits.append(d)\n            n //= 10\n        return False\n\n    return sum(1 for i in range(1, N + 1) if has_repeated_digits(i))", "passed": false, "score": {"loc": 11, "tokens": 72, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.4356138936657099}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 9877, "entry_point": "containsNearbyAlmostDuplicate", "best_list": [{"code": "def containsNearbyAlmostDuplicate(nums, k, t):\n    bucket = {}\n    for i, num in enumerate(nums):\n        bucket_id = num // (t + 1)\n        if bucket_id in bucket:\n            return True\n        if bucket_id - 1 in bucket and abs(bucket[bucket_id - 1] - num) <= t:\n            return True\n        if bucket_id + 1 in bucket and abs(bucket[bucket_id + 1] - num) <= t:\n            return True\n        bucket[bucket_id] = num\n        if i >= k:\n            del bucket[nums[i - k] // (t + 1)]\n    return False", "passed": true, "score": {"loc": 14, "tokens": 120, "cc": 7, "nest": 3, "execution_time": 0.016611, "novelty": 0.22489896539079046}}, {"code": "def containsNearbyAlmostDuplicate(nums, k, t):\n    window = {}\n    for i, num in enumerate(nums):\n        bucket = num // (t + 1)\n        if bucket in window:\n            return True\n        if bucket - 1 in window and abs(window[bucket - 1] - num) <= t:\n            return True\n        if bucket + 1 in window and abs(window[bucket + 1] - num) <= t:\n            return True\n        window[bucket] = num\n        if i >= k:\n            del window[nums[i - k] // (t + 1)]\n    return False", "passed": true, "score": {"loc": 14, "tokens": 120, "cc": 7, "nest": 3, "execution_time": 0.016791, "novelty": 0.25010249323473976}}, {"code": "def containsNearbyAlmostDuplicate(nums, k, t):\n    bucket = {}\n    w = t + 1\n    for i, num in enumerate(nums):\n        id = num // w\n        if id in bucket:\n            return True\n        if id - 1 in bucket and abs(bucket[id - 1] - num) < w:\n            return True\n        if id + 1 in bucket and abs(bucket[id + 1] - num) < w:\n            return True\n        bucket[id] = num\n        if i >= k:\n            del bucket[nums[i - k] // w]\n    return False", "passed": true, "score": {"loc": 15, "tokens": 115, "cc": 7, "nest": 3, "execution_time": 0.016541, "novelty": 0.12981063022454664}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 9930, "entry_point": "findKthPositive", "best_list": [{"code": "def findKthPositive(arr, k):\n    count = 0\n    num = 1\n    while True:\n        if num not in arr:\n            count += 1\n        if count == k:\n            return num\n        num += 1", "passed": true, "score": {"loc": 9, "tokens": 39, "cc": 3, "nest": 3, "execution_time": 0.016517, "novelty": 0.6121162717582259}}, {"code": "def findKthPositive(arr, k):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] - mid - 1 < k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left + k", "passed": true, "score": {"loc": 9, "tokens": 64, "cc": 2, "nest": 3, "execution_time": 0.016639, "novelty": 0.6957934592622053}}, {"code": "def findKthPositive(arr, k):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        missing = arr[mid] - mid - 1\n        if missing < k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left + k", "passed": true, "score": {"loc": 10, "tokens": 67, "cc": 2, "nest": 3, "execution_time": 0.016688, "novelty": 0.6709926456025526}}, {"code": "def findKthPositive(arr, k):\n    return next(x for x in range(1, arr[-1] + k + 1) if x not in arr)", "passed": false, "score": {"loc": 2, "tokens": 35, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6460347945550357}}, {"code": "def findKthPositive(arr, k):\n    return k + len([x for x in range(1, arr[-1] + k + 1) if x not in arr])", "passed": false, "score": {"loc": 2, "tokens": 39, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6430160422240816}}, {"code": "def findKthPositive(arr, k):\n    return arr[-1] + k - sum(arr)", "passed": false, "score": {"loc": 2, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6385240778889744}}, {"code": "def findKthPositive(arr, k):\n    missing_count = 0\n    i = 0\n    n = len(arr)\n    \n    while missing_count < k:\n        if i >= n or arr[i] != i + 1:\n            missing_count += 1\n        else:\n            i += 1\n    \n    return missing_count + i", "passed": false, "score": {"loc": 10, "tokens": 55, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7019590945645844}}], "num_pass": 6, "num_uniq": 5, "num_fail": 4, "fail_uniq": 4}
{"id": 9934, "entry_point": "jobScheduling", "best_list": [{"code": "def jobScheduling(startTime, endTime, profit):\n    n = len(startTime)\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n    dp = [0] * (n + 1)\n    last_end_time = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        last = i - 1\n        while last >= 0 and jobs[last][1] > jobs[i - 1][0]:\n            last -= 1\n        dp[i] = max(dp[i - 1], jobs[i - 1][2] + dp[last + 1])\n        last_end_time[i] = last + 1\n    \n    return dp[n]", "passed": true, "score": {"loc": 12, "tokens": 150, "cc": 3, "nest": 3, "execution_time": 0.016604, "novelty": 0.5819611235638285}}, {"code": "def jobScheduling(startTime, endTime, profit):\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n    dp = [0] * len(jobs)\n    dp[0] = jobs[0][2]\n    for i in range(1, len(jobs)):\n        dp[i] = max(jobs[i][2], dp[i-1])\n        j = i - 1\n        while j >= 0 and jobs[j][1] <= jobs[i][0]:\n            j -= 1\n        if j >= 0:\n            dp[i] = max(dp[i], dp[j] + jobs[i][2])\n    return dp[-1]", "passed": false, "score": {"loc": 12, "tokens": 159, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.6161996160937457}}, {"code": "def jobScheduling(startTime, endTime, profit):\n    n = len(startTime)\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n    dp = [0] * (n + 1)\n    last_end_time = 0\n\n    for i in range(1, n + 1):\n        s, e, p = jobs[i - 1]\n        dp[i] = dp[i - 1]\n        j = bisect_right(jobs, (s, float('inf')), key=lambda x: x[1], hi=last_end_time)\n        if j > 0:\n            dp[i] = max(dp[i], dp[j] + p)\n        last_end_time = max(last_end_time, e)\n\n    return dp[n]", "passed": false, "score": {"loc": 13, "tokens": 156, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5755355712561725}}, {"code": "def jobScheduling(startTime, endTime, profit):\n    n = len(startTime)\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n    dp = [0] * (n + 1)\n    stack = []\n\n    for i in range(n):\n        start, end, profit = jobs[i]\n        while stack and stack[-1][1] > start:\n            stack.pop()\n        if not stack:\n            dp[i + 1] = dp[i] + profit\n        else:\n            dp[i + 1] = max(dp[i], dp[stack[-1][0]] + profit)\n        stack.append((i, end))\n\n    return dp[n]\n\ndef _equivalent(_lhs, _rhs):\n    return _lhs == _rhs", "passed": false, "score": {"loc": 17, "tokens": 166, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.6045329740531036}}, {"code": "def jobScheduling(startTime, endTime, profit):\n    n = len(startTime)\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n    dp = [(0, 0)]\n    for s, e, p in jobs:\n        i = bisect.bisect(dp, (s, float('inf'))) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append((e, dp[i][1] + p))\n    return dp[-1][1]", "passed": false, "score": {"loc": 9, "tokens": 125, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5363542978438784}}, {"code": "def jobScheduling(startTime, endTime, profit):\n    n = len(startTime)\n    jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n    dp = [0] * (n + 1)\n    end_indices = [0] * (n + 1)\n    \n    for i in range(n - 1, -1, -1):\n        end_indices[i] = bisect_right(jobs, jobs[i][1], key=lambda x: x[0])\n        dp[i] = max(jobs[i][2] + dp[end_indices[i]], dp[i + 1])\n    \n    return dp[0]", "passed": false, "score": {"loc": 9, "tokens": 139, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.5431697747985665}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 9935, "entry_point": "lengthLongestPath", "best_list": [{"code": "def lengthLongestPath(path: str) -> int:\n    max_length = 0\n    path_length = {0: 0}\n    \n    for line in path.split('\\n'):\n        depth = line.count('\\t')\n        name = line.lstrip('\\t')\n        \n        if '.' in name:\n            max_length = max(max_length, path_length[depth] + len(name))\n        else:\n            path_length[depth + 1] = path_length[depth] + len(name) + 1\n    \n    return max_length", "passed": true, "score": {"loc": 11, "tokens": 101, "cc": 2, "nest": 3, "execution_time": 0.016715, "novelty": 0.48535185709703965}}, {"code": "def lengthLongestPath(input):\n    stack, max_len = [], 0\n    for line in input.split('\\n'):\n        depth = line.count('\\t')\n        name = line.replace('\\t', '')\n        while stack and stack[-1][1] >= depth:\n            stack.pop()\n        if '.' in name:\n            max_len = max(max_len, sum(len(x[0]) for x in stack) + len(name))\n        else:\n            stack.append((name, depth))\n    return max_len", "passed": true, "score": {"loc": 12, "tokens": 119, "cc": 4, "nest": 3, "execution_time": 0.01682, "novelty": 0.4809143088920832}}, {"code": "def lengthLongestPath(_path: str) -> int:\n    path_length = 0\n    max_length = 0\n    level_length = [0]\n    \n    for line in _path.split('\\n'):\n        depth = line.count('\\t')\n        line = line.replace('\\t', '')\n        \n        if '.' in line:\n            max_length = max(max_length, path_length + len(line) - depth + 1)\n        else:\n            level_length[depth] = path_length + len(line) + 1\n            path_length = level_length[depth]\n    \n    return max_length - 1 if max_length > 0 else 0", "passed": true, "score": {"loc": 13, "tokens": 115, "cc": 2, "nest": 3, "execution_time": 0.01664, "novelty": 0.5711647015394921}}, {"code": "def lengthLongestPath(input):\n    max_len = 0\n    path_len = [0]\n    \n    for line in input.splitlines():\n        name = line.lstrip('\\t')\n        depth = len(line) - len(name)\n        \n        while depth + 1 > len(path_len):\n            path_len.append(0)\n        \n        path_len[depth + 1] = path_len[depth] + len(name)\n        \n        if '.' in name:\n            max_len = max(max_len, path_len[depth + 1] + depth)\n    \n    return max_len", "passed": false, "score": {"loc": 12, "tokens": 101, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6192512721556287}}, {"code": "def lengthLongestPath(fs):\n    max_len = depth = 0\n    stack = [(-1, 0)]  # (depth, length)\n    for line in fs.split('\\n'):\n        name = line.lstrip('\\t')\n        depth = len(line) - len(name)\n        while stack and stack[-1][0] >= depth:\n            stack.pop()\n        stack.append((depth, stack[-1][1] + len(name) + (1 if '.' in name else 0)))\n        if '.' in name:\n            max_len = max(max_len, stack[-1][1])\n    return max_len", "passed": false, "score": {"loc": 12, "tokens": 140, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.6780079815572475}}, {"code": "def lengthLongestPath(_input: str) -> int:\n    max_len, path_len = 0, {}\n    for line in _input.split('\\n'):\n        depth = line.count('\\t')\n        name = line.lstrip('\\t')\n        path_len[depth] = path_len[depth - 1] + len(name) + (1 if depth > 0 else 0)\n        if '.' in name:\n            max_len = max(max_len, path_len[depth])\n    return max_len", "passed": false, "score": {"loc": 9, "tokens": 100, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5533830111484209}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 9963, "entry_point": "maxSatisfied", "best_list": [{"code": "def maxSatisfied(customers, grumpy, X):\n    total_satisfied = sum(customers[i] for i in range(len(customers)) if not grumpy[i])\n    window_satisfied = sum(customers[i] for i in range(X) if grumpy[i])\n    max_satisfied = total_satisfied + window_satisfied\n    \n    for i in range(X, len(customers)):\n        window_satisfied += customers[i] * grumpy[i] - customers[i - X] * grumpy[i - X]\n        max_satisfied = max(max_satisfied, total_satisfied + window_satisfied)\n    \n    return max_satisfied", "passed": true, "score": {"loc": 8, "tokens": 112, "cc": 1, "nest": 2, "execution_time": 0.016717, "novelty": 0.6321819983378515}}, {"code": "def maxSatisfied(customers, grumpy, X):\n    total_satisfied = sum(customers[i] for i in range(len(customers)) if not grumpy[i])\n    max_satisfied = window_sum = 0\n    for i in range(len(customers)):\n        if grumpy[i]:\n            window_sum += customers[i]\n        if i >= X and grumpy[i - X]:\n            window_sum -= customers[i - X]\n        max_satisfied = max(max_satisfied, window_sum)\n    return total_satisfied + max_satisfied", "passed": true, "score": {"loc": 10, "tokens": 98, "cc": 4, "nest": 3, "execution_time": 0.016655, "novelty": 0.421407062020708}}, {"code": "def maxSatisfied(customers, grumpy, X):\n    base_satisfied = sum(customers[i] for i in range(len(customers)) if not grumpy[i])\n    max_extra_satisfied = 0\n    current_extra_satisfied = 0\n    for i in range(len(customers)):\n        if grumpy[i]:\n            current_extra_satisfied += customers[i]\n        if i >= X and grumpy[i - X]:\n            current_extra_satisfied -= customers[i - X]\n        max_extra_satisfied = max(max_extra_satisfied, current_extra_satisfied)\n    return base_satisfied + max_extra_satisfied", "passed": true, "score": {"loc": 11, "tokens": 99, "cc": 4, "nest": 3, "execution_time": 0.016646, "novelty": 0.4509063530084676}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 9971, "entry_point": "findLengthOfLCIS", "best_list": [{"code": "def findLengthOfLCIS(nums):\n    longest = current = 0\n    for i in range(len(nums)):\n        if i == 0 or nums[i] > nums[i - 1]:\n            current += 1\n        else:\n            longest = max(longest, current)\n            current = 1\n    return max(longest, current)", "passed": true, "score": {"loc": 9, "tokens": 64, "cc": 3, "nest": 3, "execution_time": 0.016622, "novelty": 0.5559476943249184}}, {"code": "def findLengthOfLCIS(nums):\n    max_len = 0\n    current_len = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    return max(max_len, current_len)", "passed": true, "score": {"loc": 10, "tokens": 62, "cc": 2, "nest": 3, "execution_time": 0.016506, "novelty": 0.23202519321092785}}, {"code": "def findLengthOfLCIS(nums):\n    longest, current = 0, 0\n    prev = float('-inf')\n    for num in nums:\n        if num > prev:\n            current += 1\n        else:\n            longest = max(longest, current)\n            current = 1\n        prev = num\n    return max(longest, current)", "passed": true, "score": {"loc": 11, "tokens": 59, "cc": 2, "nest": 3, "execution_time": 0.016634, "novelty": 0.47622079816160745}}, {"code": "def findLengthOfLCIS(nums):\n    return max((len(list(group)) for num, group in itertools.groupby(nums, key=lambda x, y=iter(nums): next(y, x) > x)), default=0)", "passed": false, "score": {"loc": 2, "tokens": 55, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.714878075682267}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 1038, "entry_point": "numberToWords", "best_list": [{"code": "def numberToWords(num):\n    if num == 0:\n        return \"Zero\"\n    \n    belowTwenty = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n    tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n    thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n    \n    def words(n):\n        if n < 20:\n            return belowTwenty[n]\n        elif n < 100:\n            return tens[n // 10] + (\" \" + words(n % 10) if n % 10 else \"\")\n        else:\n            return belowTwenty[n // 100] + \" Hundred\" + (\" \" + words(n % 100) if n % 100 else \"\")\n    \n    res = \"\"\n    i = 0\n    while num > 0:\n        if num % 1000 != 0:\n            res = words(num % 1000) + \" \" + thousands[i] + \" \" + res\n        num //= 1000\n        i += 1\n    \n    return res.strip()", "passed": true, "score": {"loc": 21, "tokens": 294, "cc": 5, "nest": 4, "execution_time": 0.016498, "novelty": 0.603777316234271}}, {"code": "def numberToWords(num):\n    if num == 0:\n        return \"Zero\"\n    belowTwenty = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n    tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n    thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n    def helper(n):\n        if n == 0:\n            return \"\"\n        elif n < 20:\n            return belowTwenty[n] + \" \"\n        elif n < 100:\n            return tens[n // 10] + \" \" + helper(n % 10)\n        else:\n            return belowTwenty[n // 100] + \" Hundred \" + helper(n % 100)\n\n    result = \"\"\n    i = 0\n    while num > 0:\n        if num % 1000 != 0:\n            result = helper(num % 1000) + thousands[i] + \" \" + result\n        num //= 1000\n        i += 1\n    return result.strip()", "passed": true, "score": {"loc": 23, "tokens": 283, "cc": 6, "nest": 5, "execution_time": 0.016578, "novelty": 0.5511322706748201}}, {"code": "def numberToWords(num):\n    if num == 0:\n        return \"Zero\"\n    \n    LESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n    TENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n    THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n    \n    def helper(n):\n        if n == 0:\n            return \"\"\n        elif n < 20:\n            return LESS_THAN_20[n] + \" \"\n        elif n < 100:\n            return TENS[n // 10] + \" \" + helper(n % 10)\n        else:\n            return LESS_THAN_20[n // 100] + \" Hundred \" + helper(n % 100)\n    \n    result = \"\"\n    i = 0\n    while num > 0:\n        if num % 1000 != 0:\n            result = helper(num % 1000) + THOUSANDS[i] + \" \" + result\n        num //= 1000\n        i += 1\n    \n    return result.strip()", "passed": true, "score": {"loc": 23, "tokens": 283, "cc": 6, "nest": 5, "execution_time": 0.016845, "novelty": 0.508828641719118}}, {"code": "def numberToWords(num):\n    if num == 0:\n        return \"Zero\"\n    \n    def ones(n):\n        switcher = {\n            1: \"One\",\n            2: \"Two\",\n            3: \"Three\",\n            4: \"Four\",\n            5: \"Five\",\n            6: \"Six\",\n            7: \"Seven\",\n            8: \"Eight\",\n            9: \"Nine\"\n        }\n        return switcher.get(n, \"\")\n    \n    def teens(n):\n        switcher = {\n            10: \"Ten\",\n            11: \"Eleven\",\n            12: \"Twelve\",\n            13: \"Thirteen\",\n            14: \"Fourteen\",\n            15: \"Fifteen\",\n            16: \"Sixteen\",\n            17: \"Seventeen\",\n            18: \"Eighteen\",\n            19: \"Nineteen\"\n        }\n        return switcher.get(n, \"\")\n    \n    def tens(n):\n        switcher = {\n            2: \"Twenty\",\n            3: \"Thirty\",\n            4: \"Forty\",\n            5: \"Fifty\",\n            6: \"Sixty\",\n            7: \"Seventy\",\n            8: \"Eighty\",\n            9: \"Ninety\"\n        }\n        return switcher.get(n, \"\")\n    \n    def hundreds(n):\n        return ones(n) + \" Hundred\"\n    \n    def three_digit(n):\n        if n == 0:\n            return \"\"\n        elif n < 10:\n            return ones(n)\n        elif n < 20:\n            return teens(n)\n        elif n < 100:\n            return tens(n // 10) + (\" \" + ones(n % 10) if n % 10 != 0 else \"\")\n        else:\n            return hundreds(n // 100) + (\" \" + three_digit(n % 100) if n % 100 != 0 else \"\")\n    \n    units = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n    result = []\n    i = 0\n    \n    while num > 0:\n        if num % 1000 != 0:\n            result.append(three_digit(num % 1000) + (\" \" + units[i] if i >", "passed": false, "score": {"loc": 61, "tokens": 412, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.8438249517843742}}, {"code": "def numberToWords(num):\n    def one(num):\n        switcher = {\n            1: 'One',\n            2: 'Two',\n            3: 'Three',\n            4: 'Four',\n            5: 'Five',\n            6: 'Six',\n            7: 'Seven',\n            8: 'Eight',\n            9: 'Nine'\n        }\n        return switcher.get(num)\n\n    def two_less_20(num):\n        switcher = {\n            10: 'Ten',\n            11: 'Eleven',\n            12: 'Twelve',\n            13: 'Thirteen',\n            14: 'Fourteen',\n            15: 'Fifteen',\n            16: 'Sixteen',\n            17: 'Seventeen',\n            18: 'Eighteen',\n            19: 'Nineteen'\n        }\n        return switcher.get(num)\n\n    def ten(num):\n        switcher = {\n            2: 'Twenty',\n            3: 'Thirty',\n            4: 'Forty',\n            5: 'Fifty',\n            6: 'Sixty',\n            7: 'Seventy',\n            8: 'Eighty',\n            9: 'Ninety'\n        }\n        return switcher.get(num)\n\n    def two(num):\n        if not num:\n            return ''\n        elif num < 10:\n            return one(num)\n        elif num < 20:\n            return two_less_20(num)\n        else:\n            tenner = num // 10\n            rest = num - tenner * 10\n            return ten(tenner) + (' ' + one(rest) if rest else '')\n\n    def three(num):\n        hundred = num // 100\n        rest = num - hundred * 100\n        if hundred and rest:\n            return one(hundred) + ' Hundred ' + two(rest)\n        elif not hundred and rest:\n            return two(rest)\n        elif hundred and not rest:\n            return one(hundred) + ' Hundred'\n\n    billion = num // 1000000000\n    million = (num - billion * 1000000000) // 1000000\n    thousand = (num - billion * 1000", "passed": false, "score": {"loc": 63, "tokens": 374, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.8103054959147595}}, {"code": "def numberToWords(num):\n    if num == 0:\n        return \"Zero\"\n    \n    def one(num):\n        switcher = {\n            1: 'One',\n            2: 'Two',\n            3: 'Three',\n            4: 'Four',\n            5: 'Five',\n            6: 'Six',\n            7: 'Seven',\n            8: 'Eight',\n            9: 'Nine'\n        }\n        return switcher.get(num, \"\")\n    \n    def two_less_20(num):\n        switcher = {\n            10: 'Ten',\n            11: 'Eleven',\n            12: 'Twelve',\n            13: 'Thirteen',\n            14: 'Fourteen',\n            15: 'Fifteen',\n            16: 'Sixteen',\n            17: 'Seventeen',\n            18: 'Eighteen',\n            19: 'Nineteen'\n        }\n        return switcher.get(num, \"\")\n    \n    def ten(num):\n        switcher = {\n            2: 'Twenty',\n            3: 'Thirty',\n            4: 'Forty',\n            5: 'Fifty',\n            6: 'Sixty',\n            7: 'Seventy',\n            8: 'Eighty',\n            9: 'Ninety'\n        }\n        return switcher.get(num, \"\")\n    \n    def two(num):\n        if num < 10:\n            return one(num)\n        elif num < 20:\n            return two_less_20(num)\n        else:\n            tenner = num // 10\n            rest = num - tenner * 10\n            return ten(tenner) + (\" \" + one(rest) if rest else \"\")\n    \n    def three(num):\n        hundred = num // 100\n        rest = num - hundred * 100\n        if hundred and rest:\n            return one(hundred) + \" Hundred \" + two(rest)\n        elif hundred:\n            return one(hundred) + \" Hundred\"\n        elif rest:\n            return two(rest)\n    \n    billions = num // 1000000000\n    millions = (num % 1000000000) // 1000000\n    thousands = (num % 1", "passed": false, "score": {"loc": 63, "tokens": 376, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.804250863866142}}, {"code": "def numberToWords(num):\n    if num == 0:\n        return \"Zero\"\n\n    def one(num):\n        switcher = {\n            1: 'One',\n            2: 'Two',\n            3: 'Three',\n            4: 'Four',\n            5: 'Five',\n            6: 'Six',\n            7: 'Seven',\n            8: 'Eight',\n            9: 'Nine'\n        }\n        return switcher.get(num)\n\n    def two_less_20(num):\n        switcher = {\n            10: 'Ten',\n            11: 'Eleven',\n            12: 'Twelve',\n            13: 'Thirteen',\n            14: 'Fourteen',\n            15: 'Fifteen',\n            16: 'Sixteen',\n            17: 'Seventeen',\n            18: 'Eighteen',\n            19: 'Nineteen'\n        }\n        return switcher.get(num)\n\n    def ten(num):\n        switcher = {\n            2: 'Twenty',\n            3: 'Thirty',\n            4: 'Forty',\n            5: 'Fifty',\n            6: 'Sixty',\n            7: 'Seventy',\n            8: 'Eighty',\n            9: 'Ninety'\n        }\n        return switcher.get(num)\n\n    def two(num):\n        if not num:\n            return ''\n        elif num < 10:\n            return one(num)\n        elif num < 20:\n            return two_less_20(num)\n        else:\n            tenner = num // 10\n            rest = num - tenner * 10\n            return ten(tenner) + (' ' + one(rest) if rest else '')\n\n    def three(num):\n        hundred = num // 100\n        rest = num - hundred * 100\n        if hundred and rest:\n            return one(hundred) + ' Hundred ' + two(rest)\n        elif not hundred and rest:\n            return two(rest)\n        elif hundred and not rest:\n            return one(hundred) + ' Hundred'\n\n    billion = num // 1000000000\n    million = (num - billion * 1000000000) // 1000000", "passed": false, "score": {"loc": 64, "tokens": 376, "cc": 10, "nest": 5, "execution_time": 10.0, "novelty": 0.8616820595867436}}, {"code": "class Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n\n        def two(num):\n            if not num:\n                return \"\"\n            elif num < 10:\n                return ones[num]\n            elif num < 20:\n                return teens[num - 10]\n            else:\n                return tens[num // 10] + (\" \" + ones[num % 10] if num % 10 else \"\")\n\n        def three(num):\n            hundred = num // 100\n            rest = num % 100\n            if hundred:\n                return ones[hundred] + \" Hundred\" + (\" \" + two(rest) if rest else \"\")\n            else:\n                return two(rest)\n\n        result = \"\"\n        i = 0\n        while num > 0:\n            group = num % 1000\n            if group:\n                result = three(group) + (\" \" + thousands[i] if i else \"\") + (\" \" + result if result else \"\")\n            num //= 1000\n            i += 1\n\n        return result", "passed": false, "score": {"loc": 33, "tokens": 350, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.6870625132755033}}], "num_pass": 5, "num_uniq": 4, "num_fail": 5, "fail_uniq": 5}
{"id": 10000, "entry_point": "isInterleave", "best_list": [{"code": "def isInterleave(s1, s2, s3):\n    if len(s1) + len(s2) != len(s3):\n        return False\n    \n    dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    dp[0][0] = True\n    \n    for i in range(len(s1) + 1):\n        for j in range(len(s2) + 1):\n            if i > 0:\n                dp[i][j] |= dp[i-1][j] and s1[i-1] == s3[i+j-1]\n            if j > 0:\n                dp[i][j] |= dp[i][j-1] and s2[j-1] == s3[i+j-1]\n    \n    return dp[len(s1)][len(s2)]", "passed": true, "score": {"loc": 12, "tokens": 186, "cc": 7, "nest": 4, "execution_time": 0.01659, "novelty": 0.45916850713813695}}, {"code": "def isInterleave(s1: str, s2: str, s3: str) -> bool:\n    if len(s1) + len(s2) != len(s3):\n        return False\n\n    dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    dp[0][0] = True\n\n    for i in range(len(s1) + 1):\n        for j in range(len(s2) + 1):\n            if i > 0:\n                dp[i][j] |= dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]\n            if j > 0:\n                dp[i][j] |= dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\n\n    return dp[len(s1)][len(s2)]", "passed": true, "score": {"loc": 12, "tokens": 195, "cc": 7, "nest": 4, "execution_time": 0.016669, "novelty": 0.4596598370720847}}, {"code": "def isInterleave(s1, s2, s3):\n    if len(s1) + len(s2) != len(s3):\n        return False\n    \n    dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    dp[0][0] = True\n    \n    for i in range(len(s1) + 1):\n        for j in range(len(s2) + 1):\n            if i > 0:\n                dp[i][j] = dp[i][j] or (dp[i-1][j] and s1[i-1] == s3[i+j-1])\n            if j > 0:\n                dp[i][j] = dp[i][j] or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\n    \n    return dp[-1][-1]", "passed": true, "score": {"loc": 12, "tokens": 200, "cc": 9, "nest": 4, "execution_time": 0.016739, "novelty": 0.47354651577499574}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 10054, "entry_point": "kthFactor", "best_list": [{"code": "def kthFactor(n, k):\n    for i in range(1, n + 1):\n        if n % i == 0:\n            k -= 1\n            if k == 0:\n                return i\n    return -1", "passed": true, "score": {"loc": 7, "tokens": 43, "cc": 3, "nest": 4, "execution_time": 0.01661, "novelty": 0.16579119298405176}}, {"code": "def kthFactor(n: int, k: int) -> int:\n    for i in range(1, n + 1):\n        if n % i == 0:\n            k -= 1\n            if k == 0:\n                return i\n    return -1", "passed": true, "score": {"loc": 7, "tokens": 50, "cc": 3, "nest": 4, "execution_time": 0.016563, "novelty": 0.18202532059180554}}, {"code": "def kthFactor(n, k):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n            if count == k:\n                return i\n    return -1", "passed": true, "score": {"loc": 8, "tokens": 46, "cc": 3, "nest": 4, "execution_time": 0.016463, "novelty": 0.13931432109412945}}, {"code": "def kthFactor(n, k):\n    return next((i for i in range(1, n + 1) if n % i == 0), -1) if (len([i for i in range(1, n + 1) if n % i == 0])) >= k else -1", "passed": false, "score": {"loc": 2, "tokens": 69, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6521141429763786}}, {"code": "def kthFactor(n, k):\n    left, right = 1, n\n    while left <= right:\n        mid = (left + right) // 2\n        if n % mid == 0:\n            k -= 1\n            if k == 0:\n                return mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1", "passed": false, "score": {"loc": 12, "tokens": 66, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.47511175430089636}}], "num_pass": 8, "num_uniq": 4, "num_fail": 2, "fail_uniq": 2}
{"id": 10132, "entry_point": "canConvertString", "best_list": [{"code": "from collections import Counter\n\ndef canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    shifts = [ord(t[i]) - ord(s[i]) if ord(t[i]) >= ord(s[i]) else 26 + ord(t[i]) - ord(s[i]) for i in range(len(s))]\n    counts = Counter(shifts)\n    \n    for shift, count in counts.items():\n        if count > 1 and shift * (count - 1) + shift > k:\n            return False\n    \n    return True", "passed": true, "score": {"loc": 10, "tokens": 139, "cc": 4, "nest": 3, "execution_time": 0.016826, "novelty": 0.6715447335458131}}, {"code": "def canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    shifts = [0] * 26\n    for cs, ct in zip(s, t):\n        diff = (ord(ct) - ord(cs) + 26) % 26\n        if diff > 0:\n            if shifts[diff] >= k:\n                return False\n            shifts[diff] += 26\n    return True", "passed": true, "score": {"loc": 11, "tokens": 94, "cc": 4, "nest": 4, "execution_time": 0.016543, "novelty": 0.31563551772233955}}, {"code": "def canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    shifts = [0] * 26\n    for a, b in zip(s, t):\n        if a != b:\n            diff = (ord(b) - ord(a) + 26) % 26\n            if shifts[diff] * 26 + diff > k:\n                return False\n            shifts[diff] += 1\n    \n    return True", "passed": true, "score": {"loc": 11, "tokens": 98, "cc": 4, "nest": 4, "execution_time": 0.016588, "novelty": 0.4345270923832004}}, {"code": "def canConvertString(s, t, k):\n    if len(s) != len(t):\n        return False\n    shifts = [0] * 26\n    for cs, ct in zip(s, t):\n        shift = (ord(ct) - ord(cs) + 26) % 26\n        if shift == 0:\n            continue\n        shifts[shift] += 1\n        if shifts[shift] * 26 + shift > k:\n            return False\n    return True", "passed": false, "score": {"loc": 12, "tokens": 90, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.32735345239564295}}, {"code": "def canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    shifts = [0] * 26\n    for c1, c2 in zip(s, t):\n        shift = (ord(c2) - ord(c1) + 26) % 26\n        if shifts[shift] * 26 + shift > k:\n            return False\n        shifts[shift] += 1\n    \n    return True", "passed": false, "score": {"loc": 10, "tokens": 92, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.3296465325306468}}, {"code": "def canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    shifts = [0] * 26\n    for cs, ct in zip(s, t):\n        shift = (ord(ct) - ord(cs) + 26) % 26\n        if shift == 0:\n            continue\n        shifts[shift - 1] += 26\n        shifts[shift - 1] -= 1\n        if shifts[shift - 1] > k:\n            return False\n    return True", "passed": false, "score": {"loc": 13, "tokens": 108, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.38017500654200687}}, {"code": "def canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    shifts = [0] * 26\n    for i in range(len(s)):\n        diff = (ord(t[i]) - ord(s[i])) % 26\n        if diff == 0 and shifts[0] == 0 and k > 0:\n            shifts[0] = 1\n            k -= 1\n        elif shifts[diff] == 0 and k >= diff:\n            shifts[diff] = 1\n            k -= diff\n        elif k >= diff + 26 * shifts[diff]:\n            shifts[diff] += 1\n            k -= diff + 26 * shifts[diff]\n        else:\n            return False\n    return True", "passed": false, "score": {"loc": 18, "tokens": 161, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.6137344090451269}}, {"code": "def canConvertString(s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n        return False\n    shifts = [0] * 26\n    for sc, tc in zip(s, t):\n        shift = (ord(tc) - ord(sc) + 26) % 26\n        if shift == 0:\n            continue\n        shifts[shift - 1] += 1\n        if shifts[shift - 1] * 26 + shift > k:\n            return False\n    return True", "passed": false, "score": {"loc": 12, "tokens": 103, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.33314992599051174}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 10264, "entry_point": "deleteAndEarn", "best_list": [{"code": "from collections import Counter\n\ndef deleteAndEarn(nums):\n    max_val = max(nums)\n    dp = [0] * (max_val + 1)\n    count = Counter(nums)\n    \n    for i in range(1, max_val + 1):\n        dp[i] = max(dp[i - 1], dp[i - 2] + i * count[i])\n    \n    return dp[max_val]", "passed": true, "score": {"loc": 8, "tokens": 78, "cc": 1, "nest": 2, "execution_time": 0.016507, "novelty": 0.6152959750310083}}, {"code": "def deleteAndEarn(nums):\n    from collections import Counter\n    count = Counter(nums)\n    max_val = max(nums)\n    dp = [0] * (max_val + 1)\n    dp[1] = count[1]\n    for i in range(2, max_val + 1):\n        dp[i] = max(dp[i - 1], dp[i - 2] + i * count[i])\n    return dp[max_val]", "passed": true, "score": {"loc": 9, "tokens": 87, "cc": 1, "nest": 2, "execution_time": 0.016736, "novelty": 0.6817021436752038}}, {"code": "def deleteAndEarn(nums):\n    from collections import Counter\n    max_num = max(nums)\n    scores = [0] * (max_num + 1)\n    for num in nums:\n        scores[num] += num\n    \n    prev, curr = 0, 0\n    for score in scores:\n        prev, curr = curr, max(curr, prev + score)\n    \n    return curr", "passed": true, "score": {"loc": 10, "tokens": 67, "cc": 2, "nest": 2, "execution_time": 0.016397, "novelty": 0.47767289934038815}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 10303, "entry_point": "longestPalindrome", "best_list": [{"code": "def longestPalindrome(s):\n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    longest = \"\"\n    for i in range(len(s)):\n        odd = expand_around_center(i, i)\n        even = expand_around_center(i, i + 1)\n        longest = max(longest, odd, even, key=len)\n    return longest", "passed": true, "score": {"loc": 12, "tokens": 104, "cc": 3, "nest": 3, "execution_time": 0.016792, "novelty": 0.4324281214716872}}, {"code": "def longestPalindrome(s):\n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    if len(s) < 2:\n        return s\n\n    longest = \"\"\n    for i in range(len(s)):\n        odd = expand_around_center(i, i)\n        even = expand_around_center(i, i + 1)\n        longest = max(longest, odd, even, key=len)\n\n    return longest", "passed": true, "score": {"loc": 14, "tokens": 114, "cc": 4, "nest": 3, "execution_time": 0.016666, "novelty": 0.5330413326803114}}, {"code": "def longestPalindrome(s):\n    n = len(s)\n    if n == 0:\n        return \"\"\n    \n    def expand_around_center(left, right):\n        while left >= 0 and right < n and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n    \n    longest = \"\"\n    for i in range(n):\n        odd = expand_around_center(i, i)\n        even = expand_around_center(i, i + 1)\n        longest = max(longest, odd, even, key=len)\n    \n    return longest", "passed": true, "score": {"loc": 15, "tokens": 113, "cc": 4, "nest": 3, "execution_time": 0.016707, "novelty": 0.4673658941390235}}, {"code": "def longestPalindrome(s):\n    n = len(s)\n    if n == 0:\n        return \"\"\n    start, max_len = 0, 1\n    dp = [[False] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = True\n        if i < n - 1 and s[i] == s[i + 1]:\n            dp[i][i + 1] = True\n            start = i\n            max_len = 2\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if dp[i + 1][j - 1] and s[i] == s[j]:\n                dp[i][j] = True\n                start = i\n                max_len = length\n    return s[start:start + max_len]", "passed": false, "score": {"loc": 20, "tokens": 177, "cc": 8, "nest": 4, "execution_time": 10.0, "novelty": 0.8312195142215649}}, {"code": "def longestPalindrome(s):\n    n = len(s)\n    start, max_len = 0, 1\n    \n    for i in range(n):\n        len1 = expandAroundCenter(s, i, i)\n        len2 = expandAroundCenter(s, i, i + 1)\n        max_len = max(max_len, len1, len2)\n        \n        if max_len > 2 * (i - start + 1):\n            start = i - (max_len - 1) // 2\n    \n    return s[start:start + max_len]\n\ndef expandAroundCenter(s, left, right):\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n        right += 1\n    return right - left - 1", "passed": false, "score": {"loc": 15, "tokens": 141, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.6301470632770232}}, {"code": "def longestPalindrome(s):\n    if not s:\n        return \"\"\n    \n    start, end = 0, 0\n    \n    def expandAroundCenter(left, right):\n        nonlocal start, end\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        if right - left - 1 > end - start:\n            start, end = left + 1, right - 1\n    \n    for i in range(len(s)):\n        expandAroundCenter(i, i)\n        expandAroundCenter(i, i + 1)\n    \n    return s[start:end + 1]", "passed": false, "score": {"loc": 15, "tokens": 120, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.5401937204475226}}, {"code": "def longestPalindrome(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    start, end = 0, 0\n    \n    for i in range(len(s)):\n        len1 = expandAroundCenter(s, i, i)\n        len2 = expandAroundCenter(s, i, i + 1)\n        max_len = max(len1, len2)\n        \n        if max_len > end - start:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n    \n    return s[start:end + 1]\n\ndef expandAroundCenter(s: str, left: int, right: int) -> int:\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n        right += 1\n    return right - left - 1", "passed": false, "score": {"loc": 17, "tokens": 159, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.6480192913802381}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 10304, "entry_point": "maxNumberOfBalloons", "best_list": [{"code": "def maxNumberOfBalloons(text: str) -> int:\n    count = {char: text.count(char) for char in set(text)}\n    return min(count['b'], count['a'], count['l'] // 2, count['o'] // 2, count['n'])", "passed": true, "score": {"loc": 3, "tokens": 74, "cc": 0, "nest": 1, "execution_time": 0.016676, "novelty": 0.6885966599636753}}, {"code": "def maxNumberOfBalloons(text):\n    from collections import Counter\n    count = Counter(text)\n    return min(count['b'], count['a'], count['l'] // 2, count['o'] // 2, count['n'])", "passed": true, "score": {"loc": 4, "tokens": 60, "cc": 0, "nest": 1, "execution_time": 0.016562, "novelty": 0.1749160196013585}}, {"code": "from collections import Counter\n\ndef maxNumberOfBalloons(text):\n    count = Counter(text)\n    return min(count['b'], count['a'], count['l'] // 2, count['o'] // 2, count['n'])", "passed": true, "score": {"loc": 4, "tokens": 60, "cc": 0, "nest": 1, "execution_time": 0.016804, "novelty": 0.15769266992860753}}, {"code": "def maxNumberOfBalloons(text):\n    count = Counter(text)\n    return min(count['b'], count['a'], count['l'] // 2, count['o'] // 2, count['n'])", "passed": false, "score": {"loc": 3, "tokens": 56, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.15576438787216906}}, {"code": "def maxNumberOfBalloons(text):\n    count = [0] * 26\n    for char in text:\n        count[ord(char) - ord('a')] += 1\n    return min(count[ord('b') - ord('a')], count[ord('a') - ord('a')], count[ord('l') - ord('a')] // 2, count[ord('o') - ord('a')] // 2, count[ord('n') - ord('a')])", "passed": false, "score": {"loc": 5, "tokens": 129, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.7916929314839533}}], "num_pass": 8, "num_uniq": 5, "num_fail": 2, "fail_uniq": 2}
{"id": 10368, "entry_point": "findPeakElement", "best_list": [{"code": "def findPeakElement(nums):\n    n = len(nums)\n    for i in range(n):\n        if (i == 0 or nums[i] > nums[i - 1]) and (i == n - 1 or nums[i] > nums[i + 1]):\n            return i", "passed": true, "score": {"loc": 5, "tokens": 63, "cc": 5, "nest": 3, "execution_time": 0.016686, "novelty": 0.7851030101367025}}, {"code": "def findPeakElement(nums):\n    stack = []\n    for i, num in enumerate(nums):\n        while stack and num > nums[stack[-1]]:\n            stack.pop()\n        stack.append(i)\n    return stack[0]", "passed": true, "score": {"loc": 7, "tokens": 50, "cc": 3, "nest": 3, "execution_time": 0.01649, "novelty": 0.6916573986981205}}, {"code": "def findPeakElement(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[mid + 1]:\n            right = mid\n        else:\n            left = mid + 1\n    return left", "passed": true, "score": {"loc": 9, "tokens": 58, "cc": 2, "nest": 3, "execution_time": 0.016639, "novelty": 0.2332136468290662}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 10455, "entry_point": "minDays", "best_list": [{"code": "def minDays(bloomDay, m, k):\n    if len(bloomDay) < m * k:\n        return -1\n    \n    left, right = 1, max(bloomDay)\n    while left < right:\n        mid = (left + right) // 2\n        flowers, bouquets = 0, 0\n        for day in bloomDay:\n            if day <= mid:\n                flowers += 1\n                if flowers == k:\n                    bouquets += 1\n                    flowers = 0\n            else:\n                flowers = 0\n        if bouquets < m:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": true, "score": {"loc": 20, "tokens": 105, "cc": 6, "nest": 5, "execution_time": 0.016663, "novelty": 0.5818718717536255}}, {"code": "def minDays(bloomDay, m, k):\n    n = len(bloomDay)\n    if m * k > n:\n        return -1\n    \n    left, right = 1, max(bloomDay)\n    \n    while left < right:\n        mid = (left + right) // 2\n        bouquets = 0\n        flowers = 0\n        \n        for day in bloomDay:\n            if day <= mid:\n                flowers += 1\n                if flowers == k:\n                    bouquets += 1\n                    flowers = 0\n            else:\n                flowers = 0\n        \n        if bouquets < m:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left", "passed": true, "score": {"loc": 22, "tokens": 107, "cc": 6, "nest": 5, "execution_time": 0.016677, "novelty": 0.4936920153321144}}, {"code": "def minDays(bloomDay, m, k):\n    if m * k > len(bloomDay):\n        return -1\n    \n    def canMakeBouquets(days):\n        bouquets = 0\n        flowers = 0\n        for day in bloomDay:\n            if day <= days:\n                flowers += 1\n                if flowers == k:\n                    bouquets += 1\n                    flowers = 0\n            else:\n                flowers = 0\n        return bouquets >= m\n    \n    left, right = 1, max(bloomDay)\n    while left < right:\n        mid = (left + right) // 2\n        if canMakeBouquets(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left", "passed": true, "score": {"loc": 23, "tokens": 116, "cc": 6, "nest": 5, "execution_time": 0.016711, "novelty": 0.2886369452655786}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 10466, "entry_point": "checkValidString", "best_list": [{"code": "def checkValidString(s):\n    low = high = 0\n    for c in s:\n        low += 1 if c == '(' else -1\n        high += 1 if c != ')' else -1\n        if high < 0:\n            return False\n        low = max(0, low)\n    return low == 0", "passed": true, "score": {"loc": 9, "tokens": 64, "cc": 2, "nest": 3, "execution_time": 0.016683, "novelty": 0.44326213730497566}}, {"code": "def checkValidString(s: str) -> bool:\n    low = high = 0\n    for char in s:\n        low += 1 if char in '(*' else -1\n        high += 1 if char in ')*' else -1\n        if high < 0:\n            return False\n        low = max(0, low)\n    return low == 0", "passed": false, "score": {"loc": 9, "tokens": 69, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.15660734377874963}}, {"code": "def checkValidString(s):\n    low = high = 0\n    for char in s:\n        low += 1 if char in '(*' else -1\n        high += 1 if char in ')*' else -1\n        if high < 0:\n            return False\n        low = max(low, 0)\n    return low == 0", "passed": false, "score": {"loc": 9, "tokens": 64, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.14099582001263944}}, {"code": "def checkValidString(s):\n    low = high = 0\n    for char in s:\n        low += 1 if char in '(*' else -1\n        high += 1 if char in ')*' else -1\n        if high < 0:\n            return False\n        low = max(0, low)\n    return low == 0", "passed": false, "score": {"loc": 9, "tokens": 64, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.14787095267388584}}, {"code": "def checkValidString(s):\n    lo = hi = 0\n    for char in s:\n        lo += 1 if char != ')' else -1\n        hi += 1 if char != '(' else -1\n        if hi < 0:\n            return False\n        lo = max(lo, 0)\n    return lo == 0", "passed": false, "score": {"loc": 9, "tokens": 64, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.42391470570548095}}, {"code": "def checkValidString(s: str) -> bool:\n    lo = hi = 0\n    for char in s:\n        lo += 1 if char in '(*' else -1\n        hi += 1 if char in ')*' else -1\n        if hi < 0:\n            break\n        lo = max(lo, 0)\n    return lo == 0", "passed": false, "score": {"loc": 9, "tokens": 68, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.14961768337580228}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 8}
{"id": 1057, "entry_point": "makesquare", "best_list": [{"code": "def makesquare(nums):\n    total = sum(nums)\n    if total % 4 != 0:\n        return False\n    target = total // 4\n    nums.sort(reverse=True)\n    if nums[0] > target:\n        return False\n    \n    def dfs(index, sides):\n        if index == len(nums):\n            return all(side == target for side in sides)\n        for i in range(4):\n            if sides[i] + nums[index] <= target:\n                sides[i] += nums[index]\n                if dfs(index + 1, sides):\n                    return True\n                sides[i] -= nums[index]\n        return False\n    \n    return dfs(0, [0, 0, 0, 0])", "passed": true, "score": {"loc": 19, "tokens": 146, "cc": 6, "nest": 5, "execution_time": 0.016777, "novelty": 0.3725155863992672}}, {"code": "def makesquare(matchsticks):\n    total = sum(matchsticks)\n    if total % 4 != 0:\n        return False\n    side = total // 4\n    matchsticks.sort(reverse=True)\n    if matchsticks[0] > side:\n        return False\n    used = [False] * len(matchsticks)\n    \n    def dfs(sides_left, start):\n        if sides_left == 0:\n            return True\n        for i in range(start, len(matchsticks)):\n            if not used[i] and matchsticks[i] <= side:\n                used[i] = True\n                if dfs(sides_left - 1, i + 1):\n                    return True\n                used[i] = False\n        return False\n    \n    return dfs(3, 0)", "passed": true, "score": {"loc": 20, "tokens": 135, "cc": 7, "nest": 5, "execution_time": 0.016721, "novelty": 0.5406678903548732}}, {"code": "def makesquare(matchsticks):\n    total_sum = sum(matchsticks)\n    if total_sum % 4 != 0:\n        return False\n    side_length = total_sum // 4\n    if max(matchsticks) > side_length:\n        return False\n    matchsticks.sort(reverse=True)\n    sides = [0] * 4\n\n    def dfs(index):\n        if index == len(matchsticks):\n            return all(side == side_length for side in sides)\n        for i in range(4):\n            if sides[i] + matchsticks[index] <= side_length:\n                sides[i] += matchsticks[index]\n                if dfs(index + 1):\n                    return True\n                sides[i] -= matchsticks[index]\n        return False\n\n    return dfs(0)", "passed": true, "score": {"loc": 20, "tokens": 139, "cc": 6, "nest": 5, "execution_time": 0.016731, "novelty": 0.5125848522537887}}, {"code": "def makesquare(nums):\n    if not nums or len(nums) < 4:\n        return False\n    total_length = sum(nums)\n    if total_length % 4 != 0:\n        return False\n    side_length = total_length // 4\n    nums.sort(reverse=True)\n    if nums[0] > side_length:\n        return False\n\n    @lru_cache(None)\n    def can_make_square(sides, used, remaining):\n        if remaining == 0:\n            return True\n        if sides == 0:\n            return can_make_square(3, used, side_length)\n        for i in range(len(nums)):\n            if used & (1 << i):\n                continue\n            if nums[i] > remaining:\n                break\n            if can_make_square(sides - 1, used | (1 << i), remaining - nums[i]):\n                return True\n        return False\n\n    return can_make_square(3, 0, side_length)", "passed": false, "score": {"loc": 25, "tokens": 165, "cc": 10, "nest": 4, "execution_time": 10.0, "novelty": 0.6891441246366035}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 10543, "entry_point": "longestStrChain", "best_list": [{"code": "def longestStrChain(words):\n    words.sort(key=len)\n    dp = {}\n    for word in words:\n        dp[word] = max(dp.get(word[:i] + word[i+1:], 0) for i in range(len(word))) + 1\n    return max(dp.values())", "passed": true, "score": {"loc": 6, "tokens": 72, "cc": 1, "nest": 2, "execution_time": 0.016638, "novelty": 0.7802437403811132}}, {"code": "def longestStrChain(words):\n    words = set(words)\n    dp = {}\n    for word in sorted(words, key=len):\n        dp[word] = 1 + max(dp.get(word[:i] + word[i+1:], 0) for i in range(len(word)))\n    return max(dp.values())", "passed": true, "score": {"loc": 6, "tokens": 77, "cc": 1, "nest": 2, "execution_time": 0.016525, "novelty": 0.7763223378196671}}, {"code": "def longestStrChain(words):\n    dp = {}\n    for word in sorted(words, key=len):\n        dp[word] = 1\n        for i in range(len(word)):\n            predecessor = word[:i] + word[i+1:]\n            if predecessor in dp:\n                dp[word] = max(dp[word], dp[predecessor] + 1)\n    return max(dp.values())", "passed": true, "score": {"loc": 9, "tokens": 87, "cc": 3, "nest": 4, "execution_time": 0.016617, "novelty": 0.3764089076446122}}, {"code": "def longestStrChain(words):\n    from collections import defaultdict\n    words = sorted(words, key=len)\n    dp = defaultdict(lambda: 1)\n    for word in words:\n        for i in range(len(word)):\n            predecessor = word[:i] + word[i+1:]\n            if predecessor in dp:\n                dp[word] = max(dp[word], dp[predecessor] + 1)\n    return max(dp.values())", "passed": false, "score": {"loc": 10, "tokens": 92, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.6216882626387943}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 10580, "entry_point": "arrangeWords", "best_list": [{"code": "def arrangeWords(text):\n    words = text.lower().split()\n    words.sort(key=len)\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "passed": true, "score": {"loc": 5, "tokens": 46, "cc": 0, "nest": 1, "execution_time": 0.016482, "novelty": 0.4775818401303773}}, {"code": "def arrangeWords(text):\n    words = text.split()\n    words[0] = words[0].lower()\n    words.sort(key=len)\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "passed": true, "score": {"loc": 6, "tokens": 55, "cc": 0, "nest": 1, "execution_time": 0.016607, "novelty": 0.3097568079601145}}, {"code": "def arrangeWords(text: str) -> str:\n    words = text.split()\n    words[0] = words[0].lower()\n    words.sort(key=len)\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "passed": true, "score": {"loc": 6, "tokens": 60, "cc": 0, "nest": 1, "execution_time": 0.016637, "novelty": 0.7310318522213328}}, {"code": "def arrangeWords(text):\n    words = text.split()\n    words.sort(key=lambda word: (len(word), words.index(word)))\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "passed": false, "score": {"loc": 5, "tokens": 57, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.23853720654563104}}, {"code": "def arrangeWords(text: str) -> str:\n    words = text.split()\n    words.sort(key=lambda word: (len(word), words.index(word)))\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "passed": false, "score": {"loc": 5, "tokens": 62, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7010484924533475}}, {"code": "def arrangeWords(text: str) -> str:\n    words = text.split()\n    words[0] = words[0].lower()\n    words.sort(key=lambda x: (len(x), words.index(x)))\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "passed": false, "score": {"loc": 6, "tokens": 75, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.751640692614528}}, {"code": "def arrangeWords(text):\n    words = text.split()\n    words.sort(key=lambda x: (len(x), words.index(x)))\n    words[0] = words[0].capitalize()\n    return ' '.join(words)", "passed": false, "score": {"loc": 5, "tokens": 57, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.23807555407323633}}], "num_pass": 5, "num_uniq": 3, "num_fail": 5, "fail_uniq": 4}
{"id": 10585, "entry_point": "nthUglyNumber", "best_list": [{"code": "def nthUglyNumber(n):\n    ugly = [1]\n    i2 = i3 = i5 = 0\n    while len(ugly) < n:\n        while ugly[i2] * 2 <= ugly[-1]:\n            i2 += 1\n        while ugly[i3] * 3 <= ugly[-1]:\n            i3 += 1\n        while ugly[i5] * 5 <= ugly[-1]:\n            i5 += 1\n        ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))\n    return ugly[-1]", "passed": true, "score": {"loc": 12, "tokens": 117, "cc": 4, "nest": 3, "execution_time": 0.01659, "novelty": 0.6634684032206928}}, {"code": "def nthUglyNumber(n: int) -> int:\n    def is_ugly(num: int) -> bool:\n        for factor in 2, 3, 5:\n            while num % factor == 0:\n                num //= factor\n        return num == 1\n\n    count = 0\n    num = 0\n    while count < n:\n        num += 1\n        if is_ugly(num):\n            count += 1\n    return num", "passed": true, "score": {"loc": 13, "tokens": 76, "cc": 4, "nest": 4, "execution_time": 0.016528, "novelty": 0.757677175094443}}, {"code": "def nthUglyNumber(n):\n    ugly_numbers = [1]\n    i2, i3, i5 = 0, 0, 0\n    while len(ugly_numbers) < n:\n        next_ugly = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)\n        ugly_numbers.append(next_ugly)\n        if next_ugly == ugly_numbers[i2] * 2:\n            i2 += 1\n        if next_ugly == ugly_numbers[i3] * 3:\n            i3 += 1\n        if next_ugly == ugly_numbers[i5] * 5:\n            i5 += 1\n    return ugly_numbers[-1]", "passed": true, "score": {"loc": 13, "tokens": 112, "cc": 4, "nest": 3, "execution_time": 0.016549, "novelty": 0.5613312022702985}}, {"code": "def nthUglyNumber(n: int) -> int:\n    ugly = {1}\n    factors = [2, 3, 5]\n    while len(ugly) < n:\n        next_ugly = min(ugly * factors)\n        ugly.add(next_ugly)\n    return min(ugly)", "passed": false, "score": {"loc": 7, "tokens": 52, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.6873659827849672}}, {"code": "def nthUglyNumber(n: int) -> int:\n    ugly_numbers = {1}\n    factors = [2, 3, 5]\n    for _ in range(n - 1):\n        next_ugly = min(ugly_numbers) * factor for factor in factors)\n        ugly_numbers.add(next_ugly)\n        ugly_numbers.remove(min(ugly_numbers))\n    return min(ugly_numbers)", "passed": false, "score": {"loc": 8, "tokens": 68, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.9604208864097329}}], "num_pass": 8, "num_uniq": 6, "num_fail": 2, "fail_uniq": 2}
{"id": 10609, "entry_point": "isPerfectSquare", "best_list": [{"code": "def isPerfectSquare(num):\n    return int(num**0.5)**2 == num", "passed": true, "score": {"loc": 2, "tokens": 22, "cc": 0, "nest": 1, "execution_time": 0.016554, "novelty": 0.5957228247534687}}, {"code": "def isPerfectSquare(num: int) -> bool:\n    for i in range(int(num**0.5) + 1):\n        if i * i == num:\n            return True\n    return False", "passed": true, "score": {"loc": 5, "tokens": 41, "cc": 2, "nest": 3, "execution_time": 0.016662, "novelty": 0.5131154534114934}}, {"code": "def isPerfectSquare(num):\n    i = 1\n    while i * i <= num:\n        if i * i == num:\n            return True\n        i += 1\n    return False", "passed": true, "score": {"loc": 7, "tokens": 33, "cc": 2, "nest": 3, "execution_time": 0.016573, "novelty": 0.43408002922513655}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 10621, "entry_point": "minCut", "best_list": [{"code": "def minCut(s):\n    n = len(s)\n    dp = list(range(n))\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if s[i:j] == s[i:j][::-1]:\n                dp[j - 1] = min(dp[j - 1], dp[i - 1] + 1 if i > 0 else 0)\n    return dp[n - 1]", "passed": true, "score": {"loc": 8, "tokens": 103, "cc": 3, "nest": 4, "execution_time": 0.016588, "novelty": 0.5682479067743134}}, {"code": "def minCut(s: str) -> int:\n    n = len(s)\n    dp = [i - 1 for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i, n):\n            if s[i:j + 1] == s[i:j + 1][::-1]:\n                dp[j + 1] = min(dp[j + 1], dp[i] + 1)\n    return dp[n]", "passed": true, "score": {"loc": 8, "tokens": 105, "cc": 3, "nest": 4, "execution_time": 0.016646, "novelty": 0.4095549823498116}}, {"code": "def minCut(s):\n    n = len(s)\n    dp = list(range(n))\n    for i in range(n):\n        for j in range(i, -1, -1):\n            if s[j:i+1] == s[j:i+1][::-1]:\n                dp[i] = min(dp[i], (dp[j-1] if j > 0 else -1) + 1)\n    return dp[n-1]", "passed": true, "score": {"loc": 8, "tokens": 106, "cc": 3, "nest": 4, "execution_time": 0.01664, "novelty": 0.649456353587752}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 10634, "entry_point": "countTriplets", "best_list": [{"code": "def countTriplets(arr):\n    count = 0\n    for i in range(len(arr)):\n        xor = 0\n        for j in range(i, len(arr)):\n            xor ^= arr[j]\n            if xor == 0:\n                count += j - i\n    return count", "passed": true, "score": {"loc": 9, "tokens": 57, "cc": 3, "nest": 4, "execution_time": 0.016678, "novelty": 0.23055825993048173}}, {"code": "def countTriplets(arr):\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        xor_sum = 0\n        for j in range(i, n):\n            xor_sum ^= arr[j]\n            if xor_sum == 0:\n                count += j - i\n    return count", "passed": true, "score": {"loc": 10, "tokens": 57, "cc": 3, "nest": 4, "execution_time": 0.016537, "novelty": 0.16052975212785392}}, {"code": "def countTriplets(arr):\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        xor_sum = 0\n        for j in range(i, n):\n            xor_sum ^= arr[j]\n            if xor_sum == 0:\n                count += j - i\n    return count", "passed": true, "score": {"loc": 10, "tokens": 57, "cc": 3, "nest": 4, "execution_time": 0.016658, "novelty": 0.1322254783950415}}, {"code": "def countTriplets(arr):\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] ^ sum(arr[i + 1:j]) == 0:\n                count += j - i - 1\n    return count", "passed": false, "score": {"loc": 8, "tokens": 66, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.46398005702290934}}, {"code": "def countTriplets(arr):\n    n = len(arr)\n    return sum((i + 1) * (j - i - 1) for i in range(n) for j in range(i + 1, n + 1) if sum(arr[i:j]) == 0)", "passed": false, "score": {"loc": 3, "tokens": 62, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6809947458270151}}], "num_pass": 8, "num_uniq": 6, "num_fail": 2, "fail_uniq": 2}
{"id": 10745, "entry_point": "isRectangleOverlap", "best_list": [{"code": "def isRectangleOverlap(rec1, rec2):\n    return rec1[1] < rec2[3] and rec1[3] > rec2[1] and rec1[0] < rec2[2] and rec1[2] > rec2[0]", "passed": true, "score": {"loc": 2, "tokens": 48, "cc": 1, "nest": 1, "execution_time": 0.016583, "novelty": 0.5332742661329899}}, {"code": "def isRectangleOverlap(rec1, rec2):\n    return rec1[2] > rec2[0] and rec2[2] > rec1[0] and rec1[3] > rec2[1] and rec2[3] > rec1[1]", "passed": true, "score": {"loc": 2, "tokens": 48, "cc": 1, "nest": 1, "execution_time": 0.016594, "novelty": 0.45797149759148503}}, {"code": "def isRectangleOverlap(rec1, rec2):\n    return all([rec1[1] < rec2[3], rec1[3] > rec2[1], rec1[0] < rec2[2], rec1[2] > rec2[0]])", "passed": true, "score": {"loc": 2, "tokens": 53, "cc": 0, "nest": 1, "execution_time": 0.016305, "novelty": 0.8084922201442997}}, {"code": "def isRectangleOverlap(rec1, rec2):\n    return all(x < y[3] and y[3] > x[1] and x[0] < y[2] and y[2] > x[0] for x, y in [(rec1, rec2), (rec2, rec1)])", "passed": false, "score": {"loc": 2, "tokens": 66, "cc": 1, "nest": 1, "execution_time": 10.0, "novelty": 0.8098030144451854}}], "num_pass": 9, "num_uniq": 6, "num_fail": 1, "fail_uniq": 1}
{"id": 10775, "entry_point": "findNumbers", "best_list": [{"code": "def findNumbers(nums):\n    return sum(len(str(num)) % 2 == 0 for num in nums)", "passed": true, "score": {"loc": 2, "tokens": 26, "cc": 0, "nest": 1, "execution_time": 0.016413, "novelty": 0.2756998553848049}}, {"code": "def findNumbers(nums):\n    return sum(1 for num in nums if len(str(num)) % 2 == 0)", "passed": true, "score": {"loc": 2, "tokens": 28, "cc": 0, "nest": 1, "execution_time": 0.016488, "novelty": 0.318384456508912}}, {"code": "def findNumbers(nums):\n    count = 0\n    for num in nums:\n        if len(str(num)) % 2 == 0:\n            count += 1\n    return count", "passed": true, "score": {"loc": 6, "tokens": 34, "cc": 2, "nest": 3, "execution_time": 0.016326, "novelty": 0.23950007754014768}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 10793, "entry_point": "isNumber", "best_list": [{"code": "def isNumber(s):\n    try:\n        float(s)\n        return True\n    except ValueError:\n        return False", "passed": true, "score": {"loc": 6, "tokens": 19, "cc": 2, "nest": 2, "execution_time": 0.016676, "novelty": 0.8502102460902033}}, {"code": "def isNumber(s):\n    i, n = 0, len(s)\n    if i < n and (s[i] == '+' or s[i] == '-'): i += 1\n    digits, dot, e = False, False, False\n    while i < n and s[i].isdigit(): i, digits = i + 1, True\n    if i < n and s[i] == '.': i, dot = i + 1, True\n    while i < n and s[i].isdigit(): i, digits = i + 1, True\n    if i < n and s[i] == 'e':\n        i, e = i + 1, True\n        if i < n and (s[i] == '+' or s[i] == '-'): i += 1\n        if i < n and s[i].isdigit(): i += 1\n        else: return False\n    return 0 < i == n and digits and not (dot and not digits)", "passed": true, "score": {"loc": 13, "tokens": 222, "cc": 18, "nest": 3, "execution_time": 0.01661, "novelty": 0.8460930589167478}}, {"code": "def isNumber(s):\n    states = [\n        {' ': 0, 's': 1, 'd': 2, '.': 3},  # start state\n        {'d': 2, '.': 3},                # signed number after dot\n        {'d': 2, '.': 4, 'e': 5, ' ': 8}, # unsigned number or number after dot or exponent\n        {'d': 4},                        # unsigned number after dot\n        {'d': 4, 'e': 5, ' ': 8},        # unsigned number after dot or exponent\n        {'s': 6, 'd': 7},                # exponent sign\n        {'d': 7},                        # exponent\n        {'d': 7, ' ': 8},               # exponent or end of number\n        {' ': 8}                         # end of number\n    ]\n    state = 0\n    for c in s:\n        if c in '0123456789': c = 'd'\n        if c in '+-': c = 's'\n        if c in '.': c = '.'\n        if c in 'eE': c = 'e'\n        if c not in states[state]: return False\n        state = states[state][c]\n    return state in {2, 4, 7, 8}", "passed": true, "score": {"loc": 21, "tokens": 275, "cc": 6, "nest": 3, "execution_time": 0.016667, "novelty": 0.7171331690847343}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 10801, "entry_point": "isLongPressedName", "best_list": [{"code": "def isLongPressedName(name, typed):\n    i, j = 0, 0\n    while i < len(name) and j < len(typed):\n        if name[i] == typed[j]:\n            i += 1\n        j += 1\n    return i == len(name)", "passed": true, "score": {"loc": 7, "tokens": 58, "cc": 3, "nest": 3, "execution_time": 0.016499, "novelty": 0.3126548701116092}}, {"code": "def isLongPressedName(name: str, typed: str) -> bool:\n    i = j = 0\n    while i < len(name) and j < len(typed):\n        if name[i] == typed[j]:\n            i += 1\n        j += 1\n    return i == len(name)", "passed": true, "score": {"loc": 7, "tokens": 63, "cc": 3, "nest": 3, "execution_time": 0.016551, "novelty": 0.31346286145099134}}, {"code": "def isLongPressedName(name: str, typed: str) -> bool:\n    i, j = 0, 0\n    while i < len(name) and j < len(typed):\n        if name[i] == typed[j]:\n            i += 1\n        j += 1\n    return i == len(name)", "passed": true, "score": {"loc": 7, "tokens": 65, "cc": 3, "nest": 3, "execution_time": 0.016581, "novelty": 0.3022013493258049}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 10844, "entry_point": "findKthBit", "best_list": [{"code": "def findKthBit(n, k):\n    def invert_and_reverse(s):\n        return ''.join('1' if c == '0' else '0' for c in s[::-1])\n    \n    s = \"0\"\n    for _ in range(1, n):\n        s = s + \"1\" + invert_and_reverse(s)\n    \n    return s[k-1]", "passed": true, "score": {"loc": 7, "tokens": 79, "cc": 1, "nest": 2, "execution_time": 0.016498, "novelty": 0.6616940836878096}}, {"code": "def findKthBit(n, k):\n    if n == 1:\n        return \"0\"\n    mid = 2**(n-1)\n    if k == mid:\n        return \"1\"\n    if k < mid:\n        return findKthBit(n-1, k)\n    return \"0\" if findKthBit(n-1, 2*mid-k) == \"1\" else \"1\"", "passed": true, "score": {"loc": 9, "tokens": 78, "cc": 3, "nest": 2, "execution_time": 0.016651, "novelty": 0.41467317673559345}}, {"code": "def findKthBit(n: int, k: int) -> str:\n    if n == 1:\n        return \"0\"\n    mid = 2**(n-1)\n    if k == mid:\n        return \"1\"\n    if k < mid:\n        return findKthBit(n-1, k)\n    return \"0\" if findKthBit(n-1, 2*mid-k) == \"1\" else \"1\"", "passed": true, "score": {"loc": 9, "tokens": 85, "cc": 3, "nest": 2, "execution_time": 0.016654, "novelty": 0.4166779985022864}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 10867, "entry_point": "findLUSlength", "best_list": [{"code": "def findLUSlength(words):\n    words = sorted(words, key=lambda x: (-len(x), x))\n    for i, word in enumerate(words):\n        if all(word not in other for other in words if other != word):\n            return len(word)\n    return -1", "passed": true, "score": {"loc": 6, "tokens": 63, "cc": 2, "nest": 3, "execution_time": 0.016776, "novelty": 0.8364951450839165}}, {"code": "def findLUSlength(strs):\n    freq = {}\n    for s in strs:\n        freq[s] = freq.get(s, 0) + 1\n    for s, count in freq.items():\n        if count == 1:\n            return len(s)\n    return -1", "passed": true, "score": {"loc": 8, "tokens": 55, "cc": 3, "nest": 3, "execution_time": 0.016497, "novelty": 0.7661341087095715}}, {"code": "def findLUSlength(strs):\n    def is_subsequence(word, other):\n        it = iter(other)\n        return all(char in it for char in word)\n    \n    for i, word in enumerate(strs):\n        if not any(is_subsequence(word, strs[j]) for j in range(len(strs)) if i != j):\n            return len(word)\n    return -1", "passed": true, "score": {"loc": 8, "tokens": 79, "cc": 2, "nest": 3, "execution_time": 0.016722, "novelty": 0.8178527832854051}}, {"code": "def findLUSlength strs:\n    count = {}\n    for s in strs:\n        count[s] = count.get(s, 0) + 1\n    for s, cnt in count.items():\n        if cnt == 1:\n            return len(s)\n    return -1", "passed": false, "score": {"loc": 8, "tokens": 53, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.87343328567181}}, {"code": "def findLUSlength strs:\n    freq = {}\n    for s in strs:\n        freq[s] = freq.get(s, 0) + 1\n    max_len = -1\n    for s, count in freq.items():\n        if count == 1:\n            max_len = max(max_len, len(s))\n    return max_len", "passed": false, "score": {"loc": 9, "tokens": 62, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.8655311875524202}}, {"code": "def findLUSlength strs):\n    longest = -1\n    for i in range(len(strs)):\n        is_uncommon = True\n        for j in range(len(strs)):\n            if i != j and findLUSlength(strs[i], strs[j]):\n                is_uncommon = False\n                break\n        if is_uncommon:\n            longest = max(longest, len(strs[i]))\n    return longest\n\ndef findLUSlength(s, t):\n    t_iter = iter(t)\n    return all(c in t_iter for c in s)", "passed": false, "score": {"loc": 14, "tokens": 101, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.8756927266193194}}, {"code": "def findLUSlength strs:\n    longest = -1\n    for i, s1 in enumerate(strs):\n        is_uncommon = True\n        for j, s2 in enumerate(strs):\n            if i != j and s1 in s2:\n                is_uncommon = False\n                break\n        if is_uncommon:\n            longest = max(longest, len(s1))\n    return longest", "passed": false, "score": {"loc": 11, "tokens": 61, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.8719282854683461}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 10903, "entry_point": "isPossibleDivide", "best_list": [{"code": "def isPossibleDivide(nums, k):\n    if len(nums) % k != 0:\n        return False\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    for num in sorted(count):\n        if count[num] > 0:\n            for i in range(k):\n                count[num + i] -= 1\n                if count[num + i] < 0:\n                    return False\n    return True", "passed": true, "score": {"loc": 13, "tokens": 92, "cc": 6, "nest": 5, "execution_time": 0.016508, "novelty": 0.2536022056721543}}, {"code": "from collections import Counter\n\ndef isPossibleDivide(nums, k):\n    if len(nums) % k != 0:\n        return False\n    \n    count = Counter(nums)\n    nums.sort()\n    \n    for num in nums:\n        if count[num] == 0:\n            continue\n        for i in range(k):\n            count[num + i] -= 1\n            if count[num + i] < 0:\n                return False\n    return True", "passed": true, "score": {"loc": 14, "tokens": 82, "cc": 5, "nest": 4, "execution_time": 0.016797, "novelty": 0.2671608035728247}}, {"code": "def isPossibleDivide(nums, k):\n    if len(nums) % k != 0:\n        return False\n    \n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    \n    for num in sorted(nums):\n        if count[num] == 0:\n            continue\n        for i in range(num, num + k):\n            count[i] -= 1\n            if count[i] < 0:\n                return False\n    return True", "passed": true, "score": {"loc": 14, "tokens": 94, "cc": 6, "nest": 4, "execution_time": 0.016519, "novelty": 0.2784238215186643}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 10946, "entry_point": "findMin", "best_list": [{"code": "def findMin(nums):\n    return min(set(nums))", "passed": true, "score": {"loc": 2, "tokens": 14, "cc": 0, "nest": 1, "execution_time": 0.016614, "novelty": 0.7052230093771252}}, {"code": "def findMin(nums):\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            return nums[i]\n    return nums[0]", "passed": true, "score": {"loc": 5, "tokens": 42, "cc": 2, "nest": 3, "execution_time": 0.016662, "novelty": 0.6270861382564015}}, {"code": "def findMin(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < nums[right]:\n            right = mid\n        elif nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right -= 1\n    return nums[left]", "passed": true, "score": {"loc": 11, "tokens": 74, "cc": 3, "nest": 4, "execution_time": 0.016581, "novelty": 0.3218508318277431}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 10983, "entry_point": "maxRepOpt1", "best_list": [{"code": "def maxRepOpt1(text: str) -> int:\n    from collections import Counter\n    \n    count = Counter(text)\n    length = len(text)\n    result = 0\n    \n    for i in range(length):\n        if i + 1 < length and text[i] == text[i + 1]:\n            j = i + 2\n            while j < length and text[j] == text[i]:\n                j += 1\n            if j < length and text[j] == text[i] and count[text[i]] > j - i:\n                j += 1\n            result = max(result, j - i)\n            i = j - 1\n        else:\n            result = max(result, count[text[i]])\n    \n    return result", "passed": true, "score": {"loc": 17, "tokens": 148, "cc": 7, "nest": 4, "execution_time": 0.016563, "novelty": 0.7661741885038748}}, {"code": "def maxRepOpt1(text: str) -> int:\n    count = {}\n    for char in text:\n        count[char] = count.get(char, 0) + 1\n    \n    longest = 0\n    for i in range(len(text)):\n        if i > 0 and text[i] == text[i - 1]:\n            continue\n        \n        length = 1\n        for j in range(i + 1, len(text)):\n            if text[j] == text[i]:\n                length += 1\n            elif j - i > 1:\n                break\n        \n        if count[text[i]] > length:\n            length += 1\n        \n        longest = max(longest, length)\n    \n    return longest", "passed": true, "score": {"loc": 18, "tokens": 135, "cc": 8, "nest": 5, "execution_time": 0.016465, "novelty": 0.7782650153422879}}, {"code": "from collections import Counter\n\ndef maxRepOpt1(text):\n    count = Counter(text)\n    groups = [(k, sum(1 for _ in v)) for k, v in.groupby(text)]\n    result = 0\n    \n    for i, (char1, len1) in enumerate(groups):\n        if i > 0 and len1 < groups[i-1][1] + (i+1 < len(groups) and groups[i+1][1]):\n            result = max(result, min(count[char1], len1 + (i+1 < len(groups) and groups[i+1][1])))\n        elif i+1 < len(groups) and len1 < groups[i+1][1] + (i > 0 and groups[i-1][1]):\n            result = max(result, min(count[char1], len1 + (i > 0 and groups[i-1][1])))\n        else:\n            result = max(result, min(count[char1], len1))\n    \n    return result", "passed": false, "score": {"loc": 13, "tokens": 224, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.9922258799628014}}, {"code": "def maxRepOpt1(text):\n    from collections import defaultdict\n\n    def _equivalent(lhs, rhs):\n        return lhs == rhs\n\n    n = len(text)\n    left, right = 0, 0\n    max_length = 0\n    char_count = defaultdict(int)\n    window_count = defaultdict(int)\n\n    while right < n:\n        char_count[text[right]] += 1\n        window_count[text[right]] += 1\n\n        while (right - left + 1) - max(window_count.values()) > 1:\n            window_count[text[left]] -= 1\n            if window_count[text[left]] == 0:\n                del window_count[text[left]]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n        if right + 1 < n and text[right] == text[right + 1]:\n            right += 1\n            continue\n\n        if max(window_count.values()) == char_count[text[right]]:\n            window_count = defaultdict(int)\n            left = right + 1\n        else:\n            max_length = max(max_length, right - left + 2)\n            window_count = defaultdict(int)\n            left = right + 1\n\n        right += 1\n\n    return max_length", "passed": false, "score": {"loc": 30, "tokens": 228, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.9057971148654458}}, {"code": "def maxRepOpt1(text):\n    count = [0] * 26\n    for char in text:\n        count[ord(char) - ord('a')] += 1\n    \n    def max_len_with_one_swap(start):\n        max_len = 0\n        i = start\n        while i < len(text):\n            j = i\n            while j < len(text) and text[j] == text[i]:\n                j += 1\n            length = j - i\n            if length + 1 <= count[ord(text[i]) - ord('a')] and j < len(text) and text[j] == text[i]:\n                length += 1\n            if length + 2 <= count[ord(text[i]) - ord('a')] and j < len(text) and text[j] != text[i]:\n                length += 1\n            max_len = max(max_len, length)\n            if j == len(text) or text[j] != text[i]:\n                break\n            i = j + 1\n        return max_len\n    \n    max_len = 0\n    for i in range(len(text)):\n        max_len = max(max_len, max_len_with_one_swap(i))\n    return max_len", "passed": false, "score": {"loc": 25, "tokens": 241, "cc": 11, "nest": 4, "execution_time": 10.0, "novelty": 0.8563450162470451}}, {"code": "def maxRepOpt1(text: str) -> int:\n    from collections import Counter\n\n    count = Counter(text)\n    n = len(text)\n    i, j = 0, 0\n    result = 0\n\n    while j < n:\n        if text[j] != text[i]:\n            if j - i > result:\n                result = j - i\n            i = j\n        j += 1\n\n    if j - i > result:\n        result = j - i\n\n    for k in range(i, j):\n        if count[text[k]] > j - i:\n            result = j - i + 1\n            break\n\n    return result", "passed": false, "score": {"loc": 19, "tokens": 118, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.7728150583526997}}, {"code": "def maxRepOpt1(text):\n    from collections import Counter\n    \n    # Count the frequency of each character\n    char_count = Counter(text)\n    # Group consecutive identical characters\n    groups = [(char, len(list(group))) for char, group in itertools.groupby(text)]\n    \n    max_length = 0\n    \n    for i, (char, length) in enumerate(groups):\n        # Check the current group itself\n        if length + 1 < char_count[char]:\n            max_length = max(max_length, length + 1)\n        else:\n            max_length = max(max_length, length)\n        \n        # Check the previous and next groups\n        if i > 0 and i + 1 < len(groups) and groups[i - 1][0] == groups[i + 1][0]:\n            combined_length = groups[i - 1][1] + groups[i + 1][1] + (length + 1 < char_count[groups[i - 1][0]])\n            max_length = max(max_length, combined_length)\n    \n    return max_length", "passed": false, "score": {"loc": 18, "tokens": 199, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.8417608686130591}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 8}
{"id": 11081, "entry_point": "hasAllCodes", "best_list": [{"code": "def hasAllCodes(s: str, k: int) -> bool:\n    if len(s) < 2**k:\n        return False\n    seen = set()\n    for i in range(len(s) - k + 1):\n        seen.add(s[i:i+k])\n        if len(seen) == 2**k:\n            return True\n    return False", "passed": true, "score": {"loc": 9, "tokens": 77, "cc": 3, "nest": 3, "execution_time": 0.016686, "novelty": 0.6469780704502933}}, {"code": "def hasAllCodes(s: str, k: int) -> bool:\n    return len({s[i-k:i] for i in range(k, len(s)+1)}) == 2**k", "passed": false, "score": {"loc": 2, "tokens": 49, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.3640242938911762}}, {"code": "def hasAllCodes(s: str, k: int) -> bool:\n    seen = set()\n    for i in range(k, len(s) + 1):\n        seen.add(s[i - k:i])\n    return len(seen) == 2 ** k", "passed": false, "score": {"loc": 5, "tokens": 59, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.5147267676570519}}, {"code": "def hasAllCodes(s: str, k: int) -> bool:\n    return len({s[i:i+k] for i in range(len(s) - k + 1)}) == 1 << k", "passed": false, "score": {"loc": 2, "tokens": 49, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.3434077277479127}}, {"code": "def hasAllCodes(s: str, k: int) -> bool:\n    mask = (1 << k) - 1\n    seen = set()\n    value = 0\n    for i in range(len(s)):\n        value = (value << 1 | int(s[i])) & mask\n        if i >= k - 1:\n            seen.add(value)\n            value -= int(s[i - k + 1]) << (k - 1)\n    return len(seen) == 1 << k", "passed": false, "score": {"loc": 10, "tokens": 108, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7164793639301914}}, {"code": "def hasAllCodes(s: str, k: int) -> bool:\n    return len(set(s[i:i+k] for i in range(k, len(s) + 1))) == 1 << k", "passed": false, "score": {"loc": 2, "tokens": 50, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.33978238229324387}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 7}
{"id": 11105, "entry_point": "maxProductPath", "best_list": [{"code": "def maxProductPath(grid):\n    rows, cols = len(grid), len(grid[0])\n    MOD = 10**9 + 7\n\n    if grid[0][0] < 0 or grid[-1][-1] < 0:\n        return -1 if (rows * cols) % 2 else 0\n\n    dp_max = [[0] * cols for _ in range(rows)]\n    dp_min = [[0] * cols for _ in range(rows)]\n    dp_max[0][0] = dp_min[0][0] = grid[0][0]\n\n    for i in range(1, rows):\n        dp_max[i][0] = dp_min[i][0] = dp_max[i-1][0] * grid[i][0]\n\n    for j in range(1, cols):\n        dp_max[0][j] = dp_min[0][j] = dp_max[0][j-1] * grid[0][j]\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if grid[i][j] == 0:\n                dp_max[i][j] = dp_min[i][j] = 0\n            elif grid[i][j] > 0:\n                dp_max[i][j] = max(dp_max[i-1][j], dp_max[i][j-1]) * grid[i][j]\n                dp_min[i][j] = min(dp_min[i-1][j], dp_min[i][j-1]) * grid[i][j]\n            else:\n                dp_max[i][j] = min(dp_min[i-1][j], dp_min[i][j-1]) * grid[i][j]\n                dp_min[i][j] = max(dp_max[i-1][j], dp_max[i][j-1]) * grid[i][j]\n\n    return dp_max[-1][-1] % MOD if dp_max[-1][-1] >= 0 else -1", "passed": true, "score": {"loc": 23, "tokens": 449, "cc": 8, "nest": 5, "execution_time": 0.016892, "novelty": 0.8600806012624588}}, {"code": "def maxProductPath(grid):\n    rows, cols = len(grid), len(grid[0])\n    MOD = 10**9 + 7\n    \n    # Initialize the DP table with negative infinity\n    max_dp = [[-float('inf')] * cols for _ in range(rows)]\n    min_dp = [[float('inf')] * cols for _ in range(rows)]\n    \n    # Base case\n    max_dp[0][0] = grid[0][0]\n    min_dp[0][0] = grid[0][0]\n    \n    # Fill the DP table\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                continue\n            if i == 0:\n                max_dp[i][j] = max_dp[i][j-1] * grid[i][j]\n                min_dp[i][j] = min_dp[i][j-1] * grid[i][j]\n            elif j == 0:\n                max_dp[i][j] = max_dp[i-1][j] * grid[i][j]\n                min_dp[i][j] = min_dp[i-1][j] * grid[i][j]\n            else:\n                max_dp[i][j] = max(max_dp[i-1][j] * grid[i][j], max_dp[i][j-1] * grid[i][j])\n                min_dp[i][j] = min(min_dp[i-1][j] * grid[i][j], min_dp[i][j-1] * grid[i][j])\n    \n    # Return the result modulo 10^9 + 7\n    result = max_dp[-1][-1]\n    return result % MOD if result >= 0 else -1", "passed": false, "score": {"loc": 26, "tokens": 386, "cc": 6, "nest": 5, "execution_time": 10.0, "novelty": 0.7365780457609299}}, {"code": "def maxProductPath(grid):\n    rows, cols = len(grid), len(grid[0])\n    mod = 10**9 + 7\n    \n    @lru_cache(None)\n    def dp(r, c):\n        if r == rows or c == cols:\n            return float('-inf'), float('inf')\n        if r == rows - 1 and c == cols - 1:\n            return grid[r][c], grid[r][c]\n        min_p1, max_p1 = dp(r + 1, c)\n        min_p2, max_p2 = dp(r, c + 1)\n        min_p = min(grid[r][c] * min_p1, grid[r][c] * min_p2, grid[r][c] * max_p1, grid[r][c] * max_p2)\n        max_p = max(grid[r][c] * min_p1, grid[r][c] * min_p2, grid[r][c] * max_p1, grid[r][c] * max_p2)\n        return min_p, max_p\n    \n    min_p, max_p = dp(0, 0)\n    return max_p % mod if max_p >= 0 else -1", "passed": false, "score": {"loc": 16, "tokens": 238, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7015847224103686}}, {"code": "def maxProductPath(grid):\n    rows, cols = len(grid), len(grid[0])\n    MOD = 10**9 + 7\n    \n    @lru_cache(None)\n    def dp(r, c):\n        if r == rows or c == cols:\n            return float('-inf'), float('inf')\n        max_neg, max_pos = dp(r + 1, c) if r + 1 < rows else (float('-inf'), 0), dp(r, c + 1) if c + 1 < cols else (0, float('inf'))\n        max_neg *= grid[r][c]\n        max_pos *= grid[r][c]\n        if grid[r][c] == 0:\n            return 0, 0\n        elif grid[r][c] < 0:\n            return max_pos, max_neg\n        else:\n            return max_neg, max_pos\n    \n    result = dp(0, 0)\n    return result[0] % MOD if result[0] >= 0 else -1", "passed": false, "score": {"loc": 18, "tokens": 208, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.7326610321410476}}, {"code": "def maxProductPath(grid):\n    MOD = 10**9 + 7\n    rows, cols = len(grid), len(grid[0])\n    dp = [[(0, 0)] * cols for _ in range(rows)]\n    dp[0][0] = (grid[0][0], grid[0][0])\n    \n    for i in range(1, rows):\n        dp[i][0] = (dp[i-1][0][0] * grid[i][0], dp[i-1][0][1] * grid[i][0])\n    \n    for j in range(1, cols):\n        dp[0][j] = (dp[0][j-1][0] * grid[0][j], dp[0][j-1][1] * grid[0][j])\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            max_prod = max(dp[i-1][j][0], dp[i-1][j][1], dp[i][j-1][0], dp[i][j-1][1]) * grid[i][j]\n            min_prod = min(dp[i-1][j][0], dp[i-1][j][1], dp[i][j-1][0], dp[i][j-1][1]) * grid[i][j]\n            dp[i][j] = (max_prod, min_prod)\n    \n    max_product = dp[-1][-1][0]\n    return max_product % MOD if max_product >= 0 else -1", "passed": false, "score": {"loc": 16, "tokens": 384, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7924111152226775}}, {"code": "def maxProductPath(grid):\n    MOD = 10**9 + 7\n    rows, cols = len(grid), len(grid[0])\n    dp = [[(1, 1) for _ in range(cols)] for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 0:\n                dp[i][j] = (0, 0)\n            elif grid[i][j] < 0:\n                if i > 0:\n                    dp[i][j] = (dp[i-1][j][1] * grid[i][j], dp[i-1][j][0] * grid[i][j])\n                if j > 0:\n                    dp[i][j] = (dp[i][j-1][1] * grid[i][j], dp[i][j-1][0] * grid[i][j])\n            else:\n                if i > 0:\n                    dp[i][j] = (max(dp[i-1][j][0], dp[i-1][j][1]) * grid[i][j], min(dp[i-1][j][0], dp[i-1][j][1]) * grid[i][j])\n                if j > 0:\n                    dp[i][j] = (max(dp[i][j-1][0], dp[i][j-1][1]) * grid[i][j], min(dp[i][j-1][0], dp[i][j-1][1]) * grid[i][j])\n\n    result = dp[-1][-1]\n    return result[0] if result[0] >= 0 else -1", "passed": false, "score": {"loc": 20, "tokens": 424, "cc": 8, "nest": 6, "execution_time": 10.0, "novelty": 0.800517144165143}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 11120, "entry_point": "longestWord", "best_list": [{"code": "def longestWord(words):\n    word_set = set(words)\n    words.sort(key=lambda x: (-len(x), x))\n    for word in words:\n        if all(word[:i] in word_set for i in range(1, len(word))):\n            return word\n    return \"\"", "passed": true, "score": {"loc": 7, "tokens": 65, "cc": 2, "nest": 3, "execution_time": 0.016527, "novelty": 0.6314213378988834}}, {"code": "def longestWord(words):\n    words_set = set(words)\n    longest_word = \"\"\n\n    for word in words:\n        if all(word[:i] in words_set for i in range(1, len(word))):\n            if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word):\n                longest_word = word\n\n    return longest_word", "passed": true, "score": {"loc": 8, "tokens": 78, "cc": 5, "nest": 4, "execution_time": 0.016639, "novelty": 0.4536122717991602}}, {"code": "def longestWord(words):\n    word_set = set(words)\n    longest_word = \"\"\n\n    for word in words:\n        if all(word[:i] in word_set for i in range(1, len(word))):\n            if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word):\n                longest_word = word\n\n    return longest_word", "passed": true, "score": {"loc": 8, "tokens": 78, "cc": 5, "nest": 4, "execution_time": 0.016652, "novelty": 0.45360248388864877}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 11130, "entry_point": "findLatestStep", "best_list": [{"code": "from collections import Counter\n\ndef findLatestStep(arr, m):\n    n = len(arr)\n    if m == n:\n        return n\n    groups = Counter()\n    latest_step = -1\n    bits = [0] * (n + 2)\n    for i, x in enumerate(arr, 1):\n        left = bits[x-1]\n        right = bits[x+1]\n        groups[left] -= 1\n        groups[right] -= 1\n        groups[left + right + 1] += 1\n        bits[x - left] = bits[x + right] = left + right + 1\n        if groups[m] > 0:\n            latest_step = i\n    return latest_step", "passed": true, "score": {"loc": 18, "tokens": 131, "cc": 3, "nest": 3, "execution_time": 0.016767, "novelty": 0.8067436000019281}}, {"code": "def findLatestStep(arr, m):\n    if m == len(arr):\n        return m\n    bits = [0] * (len(arr) + 2)\n    counts = {0}\n    for i, x in enumerate(arr, 1):\n        l, r = bits[x-1], bits[x+1]\n        if l == m or r == m:\n            return i - 1\n        bits[x] = bits[x-l] = bits[x+r] = l + r + 1\n        counts.remove(l)\n        counts.remove(r)\n        counts.add(l + r + 1)\n    return -1", "passed": false, "score": {"loc": 14, "tokens": 131, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7281432447884908}}, {"code": "def findLatestStep(arr, m):\n    n = len(arr)\n    if m == n:\n        return n\n    groups = {}\n    counts = {}\n    latest_step = -1\n    for i, a in enumerate(arr, 1):\n        start, end = a, a\n        if a - 1 in groups:\n            start = groups[a - 1]\n            counts[start] -= 1\n            if counts[start] == 0:\n                del counts[start]\n        if a + 1 in groups:\n            end = groups[a + 1]\n            counts[end] -= 1\n            if counts[end] == 0:\n                del counts[end]\n        groups[start] = end\n        groups[end] = start\n        counts[start] = end - start + 1\n        if counts.get(m, 0) > 0:\n            latest_step = i\n    return latest_step", "passed": false, "score": {"loc": 25, "tokens": 164, "cc": 7, "nest": 4, "execution_time": 10.0, "novelty": 0.799794502926695}}, {"code": "def findLatestStep(arr, m):\n    if m == len(arr):\n        return len(arr)\n    groups = set()\n    for i, x in enumerate(arr, 1):\n        left, right = x - 1, x + 1\n        left_len, right_len = 0, 0\n        if left in groups:\n            left_len = groups.pop(left)\n        if right in groups:\n            right_len = groups.pop(right)\n        new_group = left_len + right_len + 1\n        if new_group == m:\n            return i\n        groups.add(x - left_len)\n        groups.add(x + right_len)\n    return -1", "passed": false, "score": {"loc": 17, "tokens": 117, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.755661709948424}}, {"code": "def findLatestStep(arr, m):\n    if m == len(arr):\n        return len(arr)\n    bitset = [0] * (len(arr) + 2)\n    groups = {}\n    latest_step = -1\n\n    for step, pos in enumerate(arr, 1):\n        left, right = bitset[pos - 1], bitset[pos + 1]\n        group_size = left + right + 1\n\n        if left in groups:\n            groups.pop(left)\n        if right in groups:\n            groups.pop(right)\n\n        groups[group_size] = True\n        bitset[pos - left] = group_size\n        bitset[pos + right] = group_size\n\n        if group_size == m:\n            latest_step = step\n\n    return latest_step", "passed": false, "score": {"loc": 19, "tokens": 135, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.8136928569334547}}, {"code": "from collections import defaultdict\n\ndef findLatestStep(arr, m):\n    n = len(arr)\n    bit_string = [0] * n\n    group_sizes = defaultdict(int)\n    latest_step = -1\n    \n    for step, pos in enumerate(arr, 1):\n        pos -= 1\n        bit_string[pos] = 1\n        \n        # Check left and right neighbors\n        left_size = group_sizes.get(pos - 1, 0)\n        right_size = group_sizes.get(pos + 1, 0)\n        \n        # Update group sizes\n        group_sizes[left_size] -= 1\n        group_sizes[right_size] -= 1\n        group_sizes[left_size + right_size + 1] += 1\n        \n        # Check if the new group size is m\n        if left_size + right_size + 1 == m:\n            latest_step = step\n    \n    return latest_step", "passed": false, "score": {"loc": 20, "tokens": 140, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7773245129355668}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 11170, "entry_point": "isEscapePossible", "best_list": [{"code": "def isEscapePossible(blocked, source, target):\n    blocked = set(map(tuple, blocked))\n    max_distance = len(blocked) ** 2\n    directions = [0, 1, 0, -1, 0]\n\n    def bfs(start, end):\n        visited = set([tuple(start)])\n        queue = [start]\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) == end:\n                return True\n            for i in range(4):\n                nx, ny = x + directions[i], y + directions[i + 1]\n                if 0 <= nx < 10**6 and 0 <= ny < 10**6 and (nx, ny) not in visited and (nx, ny) not in blocked:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    if len(visited) > max_distance:\n                        return True\n        return False\n\n    return bfs(source, target) and bfs(target, source)", "passed": true, "score": {"loc": 20, "tokens": 205, "cc": 7, "nest": 6, "execution_time": 0.016753, "novelty": 0.6655038467438733}}, {"code": "def isEscapePossible(blocked, source, target):\n    n = len(blocked)\n    blocked = set(map(tuple, blocked))\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def bfs(start, end):\n        visited = set([tuple(start)])\n        queue = [start]\n        for _ in range(n * n):\n            if not queue:\n                break\n            x, y = queue.pop(0)\n            if [x, y] == end:\n                return True\n            for dx, dy in directions:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < 10**6 and 0 <= new_y < 10**6 and (new_x, new_y) not in visited and (new_x, new_y) not in blocked:\n                    visited.add((new_x, new_y))\n                    queue.append((new_x, new_y))\n        return False\n\n    return bfs(source, target) and bfs(target, source)", "passed": true, "score": {"loc": 20, "tokens": 210, "cc": 7, "nest": 5, "execution_time": 0.016794, "novelty": 0.6150885639860919}}, {"code": "def isEscapePossible(blocked, source, target):\n    if not blocked:\n        return True\n    \n    def is_possible(blocked, start, end):\n        blocked = set(map(tuple, blocked))\n        seen = set()\n        queue = [start]\n        \n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) == end:\n                return True\n            if (x, y) in seen:\n                continue\n            seen.add((x, y))\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < 10**6 and 0 <= ny < 10**6 and (nx, ny) not in seen and (nx, ny) not in blocked:\n                    queue.append((nx, ny))\n            if len(seen) > len(blocked):\n                return True\n        return False\n    \n    return is_possible(blocked, source, target) and is_possible(blocked, target, source)", "passed": true, "score": {"loc": 22, "tokens": 218, "cc": 9, "nest": 5, "execution_time": 0.016878, "novelty": 0.7112295395063088}}, {"code": "def isEscapePossible(blocked, source, target):\n    def bfs(start, end):\n        if not blocked:\n            return True\n        if len(blocked) < 2:\n            return True\n        if start == end:\n            return True\n        \n        blocked_set = set(map(tuple, blocked))\n        max_dist = len(blocked) ** 2\n        queue = [start]\n        visited = {start}\n        \n        for _ in range(max_dist):\n            if end in visited:\n                return True\n            new_queue = []\n            for x, y in queue:\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < 10**6 and 0 <= ny < 10**6 and (nx, ny) not in blocked_set and (nx, ny) not in visited:\n                        new_queue.append((nx, ny))\n                        visited.add((nx, ny))\n            queue = new_queue\n        \n        return False\n    \n    return bfs(source, target) and bfs(target, source)", "passed": false, "score": {"loc": 25, "tokens": 220, "cc": 10, "nest": 6, "execution_time": 10.0, "novelty": 0.8600931174384931}}, {"code": "def isEscapePossible(blocked, source, target):\n    def bfs(start, end, blocked):\n        m, n = 10**6, 10**6\n        blocked = set(map(tuple, blocked))\n        queue = [start]\n        visited = set([start])\n        while queue:\n            x, y = queue.pop(0)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < m and 0 <= new_y < n and (new_x, new_y) not in visited and (new_x, new_y) not in blocked:\n                    if (new_x, new_y) == end:\n                        return True\n                    visited.add((new_x, new_y))\n                    queue.append((new_x, new_y))\n        return False\n\n    if not blocked:\n        return True\n\n    max_distance = len(blocked) * (len(blocked) - 1) // 2\n    return bfs(source, target, blocked) and bfs(target, source, blocked)", "passed": false, "score": {"loc": 20, "tokens": 223, "cc": 7, "nest": 6, "execution_time": 10.0, "novelty": 0.7672342870780229}}, {"code": "def isEscapePossible(blocked, source, target):\n    def bfs(blocked, start, end):\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        queue = [start]\n        visited = set(queue)\n        blocked = set(tuple(b) for b in blocked)\n        for _ in range(20000):  # Maximum 200^2 steps to escape\n            if end in visited:\n                return True\n            for _ in range(len(queue)):\n                x, y = queue.pop(0)\n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < 1000000 and 0 <= ny < 1000000 and (nx, ny) not in visited and (nx, ny) not in blocked:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n        return False\n    \n    return bfs(blocked, source, target) and bfs(blocked, target, source)", "passed": false, "score": {"loc": 18, "tokens": 208, "cc": 7, "nest": 6, "execution_time": 10.0, "novelty": 0.7707546118831856}}, {"code": "def isEscapePossible(blocked, source, target):\n    if not blocked:\n        return True\n    if len(blocked) <= 1:\n        return True\n    \n    blocked = set(map(tuple, blocked))\n    n = len(blocked)\n    boundary = n * (n - 1) // 2\n    \n    def bfs(start, end):\n        queue = [start]\n        visited = set([start])\n        while queue:\n            if len(visited) > boundary:\n                return True\n            x, y = queue.pop(0)\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < 10**6 and 0 <= new_y < 10**6 and (new_x, new_y) not in visited and (new_x, new_y) not in blocked:\n                    visited.add((new_x, new_y))\n                    queue.append((new_x, new_y))\n                    if (new_x, new_y) == end:\n                        return True\n        return len(visited) > boundary\n    \n    return bfs(source, target) and bfs(target, source)", "passed": false, "score": {"loc": 24, "tokens": 236, "cc": 9, "nest": 6, "execution_time": 10.0, "novelty": 0.7104377758084184}}, {"code": "def isEscapePossible(blocked, source, target):\n    if not blocked:\n        return True\n    \n    def bfs(start, end):\n        blocked = set(map(tuple, blocked))\n        queue = [start]\n        visited = {start}\n        bound = len(blocked) ** 2\n        \n        while queue and len(visited) < bound:\n            x, y = queue.pop(0)\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < 1000000 and 0 <= ny < 1000000 and (nx, ny) not in visited and (nx, ny) not in blocked:\n                    if (nx, ny) == end:\n                        return True\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n        \n        return False\n    \n    return bfs(source, target) and bfs(target, source)", "passed": false, "score": {"loc": 19, "tokens": 199, "cc": 8, "nest": 6, "execution_time": 10.0, "novelty": 0.61202283255984}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 11212, "entry_point": "flipLights", "best_list": [{"code": "def flipLights(n, m):\n    if m == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3 if m == 1 else 4\n    return 4 if m == 1 else 7", "passed": true, "score": {"loc": 8, "tokens": 48, "cc": 3, "nest": 2, "execution_time": 0.01648, "novelty": 0.15243900512884}}, {"code": "def flipLights(n, m):\n    if m == 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if m == 1:\n        return 3\n    return 4", "passed": true, "score": {"loc": 10, "tokens": 42, "cc": 4, "nest": 2, "execution_time": 0.016674, "novelty": 0.21420915624603465}}, {"code": "def flipLights(n, m):\n    if m == 0:\n        return 1\n    if n == 0:\n        return 0\n    if n == 1:\n        return 2\n    if n == 2:\n        return 3 if m == 1 else 4\n    return 4 if m == 1 else 7", "passed": true, "score": {"loc": 10, "tokens": 56, "cc": 4, "nest": 2, "execution_time": 0.016516, "novelty": 0.12771285845453173}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 11276, "entry_point": "detectCapitalUse", "best_list": [{"code": "def detectCapitalUse(word):\n    return word.isupper() or word.islower() or (word[0].isupper() and word[1:].islower())", "passed": true, "score": {"loc": 2, "tokens": 39, "cc": 2, "nest": 1, "execution_time": 0.016569, "novelty": 0.15630252728763583}}, {"code": "def detectCapitalUse(word):\n    return word.islower() or word.isupper() or (word[0].isupper() and word[1:].islower())", "passed": true, "score": {"loc": 2, "tokens": 39, "cc": 2, "nest": 1, "execution_time": 0.016599, "novelty": 0.15633940903311283}}, {"code": "def detectCapitalUse(word: str) -> bool:\n    return word.islower() or word.isupper() or (word[0].isupper() and word[1:].islower())", "passed": true, "score": {"loc": 2, "tokens": 44, "cc": 2, "nest": 1, "execution_time": 0.016565, "novelty": 0.8469257035869174}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 11369, "entry_point": "minWindow", "best_list": [{"code": "def minWindow(s: str, t: str) -> str:\n    from collections import Counter\n    target_count, window_count = Counter(t), Counter()\n    left, right = 0, 0\n    formed = 0\n    min_length = float('inf')\n    min_window = \"\"\n\n    while right < len(s):\n        character = s[right]\n        window_count[character] += 1\n\n        if character in target_count and window_count[character] == target_count[character]:\n            formed += 1\n\n        while left <= right and formed == len(target_count):\n            character = s[left]\n            if right - left + 1 < min_length:\n                min_length = right - left + 1\n                min_window = s[left:right + 1]\n\n            window_count[character] -= 1\n            if character in target_count and window_count[character] < target_count[character]:\n                formed -= 1\n\n            left += 1\n\n        right += 1\n\n    return min_window", "passed": true, "score": {"loc": 23, "tokens": 176, "cc": 8, "nest": 4, "execution_time": 0.016684, "novelty": 0.7013002095947808}}, {"code": "def minWindow(s: str, t: str) -> str:\n    if not t or not s:\n        return \"\"\n\n    from collections import Counter\n\n    dict_t = Counter(t)\n    required = len(dict_t)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = {}\n\n    ans = float(\"inf\"), None, None\n\n    while right < len(s):\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n\n        while left <= right and formed == required:\n            character = s[left]\n\n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n\n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n\n            left += 1    \n\n        right += 1    \n    return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]", "passed": true, "score": {"loc": 25, "tokens": 223, "cc": 10, "nest": 4, "execution_time": 0.016894, "novelty": 0.6410918602687876}}, {"code": "def minWindow(s: str, t: str) -> str:\n    from collections import Counter\n\n    t_count = Counter(t)\n    s_count = Counter()\n    required = len(t_count)\n    formed = 0\n    l = 0\n    r = 0\n    min_len = float('inf')\n    min_window = \"\"\n\n    while r < len(s):\n        character = s[r]\n        s_count[character] += 1\n\n        if character in t_count and s_count[character] == t_count[character]:\n            formed += 1\n\n        while l <= r and formed == required:\n            character = s[l]\n            if r - l + 1 < min_len:\n                min_len = r - l + 1\n                min_window = s[l:r+1]\n\n            s_count[character] -= 1\n            if character in t_count and s_count[character] < t_count[character]:\n                formed -= 1\n\n            l += 1\n\n        r += 1\n\n    return min_window", "passed": true, "score": {"loc": 26, "tokens": 177, "cc": 8, "nest": 4, "execution_time": 0.016658, "novelty": 0.6910720093860774}}, {"code": "def minWindow(s: str, t: str) -> str:\n    from collections import Counter\n    \n    if not t or not s:\n        return \"\"\n    \n    t_counter = Counter(t)\n    s_counter = Counter()\n    \n    required = len(t_counter)\n    formed = 0\n    \n    l = 0\n    min_length = float(\"inf\")\n    min_start = 0\n    \n    for r in range(len(s)):\n        s_counter[s[r]] += 1\n        \n        if s_counter[s[r]] == t_counter[s[r]]:\n            formed += 1\n        \n        while l <= r and formed == required:\n            if r - l + 1 < min_length:\n                min_length = r - l + 1\n                min_start = l\n            \n            s_counter[s[l]] -= 1\n            if s_counter[s[l]] < t_counter[s[l]]:\n                formed -= 1\n            l += 1\n    \n    return \"\" if min_length == float(\"inf\") else s[min_start:min_start + min_length]\n\n# Helper function to check if two strings are equivalent\ndef _equivalent(lhs: str, rhs: str) -> bool:\n    return lhs == rhs\n\n# Unit tests to satisfy\nassert _equivalent(minWindow(\"ADOBECODEBANC\", \"ABC\"), \"BANC\")\nassert _equivalent(minWindow(\"a\", \"a\"), \"a\")\nassert _equivalent(minWindow(\"a\", \"aa\"), \"\")\nassert _equivalent(minWindow(\"aa\", \"aa\"), \"aa\")\nassert _equivalent(minWindow(\"abcdebdde\", \"dab\"), \"abdbd\")", "passed": false, "score": {"loc": 33, "tokens": 317, "cc": 8, "nest": 4, "execution_time": 10.0, "novelty": 0.6992786666787951}}, {"code": "def minWindow(s: str, t: str) -> str:\n    from collections import Counter\n    \n    if not t or not s:\n        return \"\"\n    \n    t_count = Counter(t)\n    required = len(t_count)\n    \n    s_count = Counter()\n    formed = 0\n    \n    l = 0\n    min_length = float(\"inf\")\n    min_left = 0\n    min_right = 0\n    \n    for r in range(len(s)):\n        if s[r] in s_count:\n            s_count[s[r]] += 1\n            if s_count[s[r]] == t_count[s[r]]:\n                formed += 1\n        \n        while l <= r and formed == required:\n            window_length = r - l + 1\n            if window_length < min_length:\n                min_length = window_length\n                min_left, min_right = l, r\n            \n            if s[l] in s_count:\n                s_count[s[l]] -= 1\n                if s_count[s[l]] < t_count[s[l]]:\n                    formed -= 1\n            \n            l += 1\n    \n    return s[min_left:min_right + 1] if min_length != float(\"inf\") else \"\"", "passed": false, "score": {"loc": 28, "tokens": 215, "cc": 10, "nest": 5, "execution_time": 10.0, "novelty": 0.6888796909622532}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 11413, "entry_point": "checkInclusion", "best_list": [{"code": "def checkInclusion(s1, s2):\n    from collections import Counter\n    \n    s1_count = Counter(s1)\n    s2_count = Counter()\n    \n    for i in range(len(s2)):\n        s2_count[s2[i]] += 1\n        \n        if i >= len(s1):\n            if s2_count[s2[i - len(s1)]] == 1:\n                del s2_count[s2[i - len(s1)]]\n            else:\n                s2_count[s2[i - len(s1)]] -= 1\n        \n        if s1_count == s2_count:\n            return True\n    \n    return False", "passed": true, "score": {"loc": 14, "tokens": 110, "cc": 4, "nest": 4, "execution_time": 0.016693, "novelty": 0.6448181246342743}}, {"code": "from collections import Counter\n\ndef checkInclusion(s1, s2):\n    s1_count = Counter(s1)\n    s2_count = Counter(s2[:len(s1)])\n    \n    if s1_count == s2_count:\n        return True\n    \n    for i in range(len(s1), len(s2)):\n        s2_count[s2[i]] += 1\n        s2_count[s2[i - len(s1)]] -= 1\n        if s2_count[s2[i - len(s1)]] == 0:\n            del s2_count[s2[i - len(s1)]]\n        if s1_count == s2_count:\n            return True\n    \n    return False", "passed": true, "score": {"loc": 14, "tokens": 120, "cc": 4, "nest": 3, "execution_time": 0.016658, "novelty": 0.5710245692366509}}, {"code": "def checkInclusion(s1, s2):\n    from collections import Counter\n    \n    s1_count = Counter(s1)\n    window_count = Counter()\n    window_size = len(s1)\n    \n    for i in range(len(s2)):\n        window_count[s2[i]] += 1\n        if i >= window_size:\n            if window_count[s2[i - window_size]] == 1:\n                del window_count[s2[i - window_size]]\n            else:\n                window_count[s2[i - window_size]] -= 1\n        if window_count == s1_count:\n            return True\n    return False", "passed": true, "score": {"loc": 15, "tokens": 104, "cc": 4, "nest": 4, "execution_time": 0.016645, "novelty": 0.716989960798569}}, {"code": "def checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    s1_count = [0] * 26\n    s2_count = [0] * 26\n    \n    for i in range(len(s1)):\n        s1_count[ord(s1[i]) - ord('a')] += 1\n        s2_count[ord(s2[i]) - ord('a')] += 1\n    \n    if s1_count == s2_count:\n        return True\n    \n    for i in range(len(s1), len(s2)):\n        s2_count[ord(s2[i]) - ord('a')] += 1\n        s2_count[ord(s2[i - len(s1)]) - ord('a')] -= 1\n        \n        if s1_count == s2_count:\n            return True\n    \n    return False", "passed": false, "score": {"loc": 16, "tokens": 165, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.5368998459474201}}, {"code": "def checkInclusion(s1: str, s2: str) -> bool:\n    if len(s1) > len(s2):\n        return False\n    \n    s1_count = [0] * 26\n    s2_count = [0] * 26\n    \n    for i in range(len(s1)):\n        s1_count[ord(s1[i]) - ord('a')] += 1\n        s2_count[ord(s2[i]) - ord('a')] += 1\n    \n    if s1_count == s2_count:\n        return True\n    \n    for i in range(len(s1), len(s2)):\n        s2_count[ord(s2[i]) - ord('a')] += 1\n        s2_count[ord(s2[i - len(s1)]) - ord('a')] -= 1\n        if s1_count == s2_count:\n            return True\n    \n    return False", "passed": false, "score": {"loc": 16, "tokens": 172, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.5397304849337916}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 2}
{"id": 11461, "entry_point": "calculate", "best_list": [{"code": "def calculate(expression):\n    num, op = 0, '+'\n    stack = []\n    for char in expression + '+':\n        if char.isdigit():\n            num = num * 10 + int(char)\n        elif char in '+-*/':\n            if op == '+':\n                stack.append(num)\n            elif op == '-':\n                stack.append(-num)\n            elif op == '*':\n                stack.append(stack.pop() * num)\n            elif op == '/':\n                stack.append(int(stack.pop() / num))\n            num, op = 0, char\n    return sum(stack)", "passed": true, "score": {"loc": 17, "tokens": 139, "cc": 7, "nest": 8, "execution_time": 0.017362, "novelty": 0.495084438963154}}, {"code": "def calculate(expression):\n    stack = []\n    num = 0\n    sign = '+'\n    \n    for i, char in enumerate(expression):\n        if char.isdigit():\n            num = num * 10 + int(char)\n        \n        if char in '+-*/' or i == len(expression) - 1:\n            if sign == '+':\n                stack.append(num)\n            elif sign == '-':\n                stack.append(-num)\n            elif sign == '*':\n                stack.append(stack.pop() * num)\n            elif sign == '/':\n                stack.append(int(stack.pop() / num))\n            \n            sign = char\n            num = 0\n    \n    return sum(stack)", "passed": true, "score": {"loc": 19, "tokens": 148, "cc": 8, "nest": 7, "execution_time": 0.016631, "novelty": 0.4661651514528602}}, {"code": "def calculate(s):\n    stack = []\n    num = 0\n    op = '+'\n    for i, c in enumerate(s):\n        if c.isdigit():\n            num = num * 10 + int(c)\n        if i == len(s) - 1 or c in '+-*/':\n            if op == '+':\n                stack.append(num)\n            elif op == '-':\n                stack.append(-num)\n            elif op == '*':\n                stack.append(stack.pop() * num)\n            elif op == '/':\n                stack.append(int(stack.pop() / num))\n            op = c\n            num = 0\n    return sum(stack)", "passed": true, "score": {"loc": 19, "tokens": 148, "cc": 8, "nest": 7, "execution_time": 0.016738, "novelty": 0.4662141297026694}}, {"code": "def calculate(s):\n    def apply_operator(operators, values):\n        operator = operators.pop()\n        right = values.pop()\n        left = values.pop()\n        if operator == '+':\n            values.append(left + right)\n        elif operator == '-':\n            values.append(left - right)\n        elif operator == '*':\n            values.append(left * right)\n        elif operator == '/':\n            values.append(int(left / right))\n\n    operators = []\n    values = []\n    i = 0\n    while i < len(s):\n        if s[i].isspace():\n            i += 1\n            continue\n        if s[i].isdigit():\n            j = i\n            while j < len(s) and s[j].isdigit():\n                j += 1\n            values.append(int(s[i:j]))\n            i = j\n            continue\n        if s[i] in '+-*/':\n            while (operators and operators[-1] != '(' and\n                   (s[i] == '*' or s[i] == '/' or\n                    operators[-1] == '*' or operators[-1] == '/')):\n                apply_operator(operators, values)\n            operators.append(s[i])\n            i += 1\n            continue\n        if s[i] == '(':\n            operators.append(s[i])\n            i += 1\n            continue\n        if s[i] == ')':\n            while operators[-1] != '(':\n                apply_operator(operators, values)\n            operators.pop()\n            i += 1\n            continue\n    while operators:\n        apply_operator(operators, values)\n    return values[0]", "passed": false, "score": {"loc": 48, "tokens": 359, "cc": 17, "nest": 6, "execution_time": 10.0, "novelty": 0.7825919965808965}}, {"code": "def calculate(s: str) -> int:\n    def calc(op, num, res):\n        if op == '+':\n            return res + num\n        elif op == '-':\n            return res - num\n        elif op == '*':\n            return res * num\n        elif op == '/':\n            return res // num\n        else:\n            return num\n\n    op, num, res, i = '', 0, 0, 0\n    while i < len(s):\n        if s[i].isdigit():\n            num = num * 10 + int(s[i])\n        elif s[i] in '+-*/':\n            res = calc(op, num, res)\n            op, num = s[i], 0\n        i += 1\n    return calc(op, num, res)", "passed": false, "score": {"loc": 21, "tokens": 167, "cc": 7, "nest": 6, "execution_time": 10.0, "novelty": 0.7565091473815042}}, {"code": "def calculate(expression):\n    def apply_operator(operators, values):\n        operator = operators.pop()\n        right = values.pop()\n        left = values.pop()\n        if operator == '+':\n            values.append(left + right)\n        elif operator == '-':\n            values.append(left - right)\n        elif operator == '*':\n            values.append(left * right)\n        elif operator == '/':\n            values.append(int(left / right))\n\n    def greater_precedence(op1, op2):\n        precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n        return precedence[op1] > precedence[op2]\n\n    operators = []\n    values = []\n    i = 0\n    while i < len(expression):\n        if expression[i].isspace():\n            i += 1\n            continue\n        if expression[i].isdigit():\n            j = i\n            while j < len(expression) and expression[j].isdigit():\n                j += 1\n            values.append(int(expression[i:j]))\n            i = j\n        else:\n            while (operators and operators[-1] != '(' and\n                   greater_precedence(operators[-1], expression[i])):\n                apply_operator(operators, values)\n            operators.append(expression[i])\n            i += 1\n    while operators:\n        apply_operator(operators, values)\n    return values[0]", "passed": false, "score": {"loc": 38, "tokens": 297, "cc": 12, "nest": 6, "execution_time": 10.0, "novelty": 0.7180444929797065}}, {"code": "def calculate(expression: str) -> int:\n    ops = {\"+\": lambda a, b: a + b, \"-\": lambda a, b: a - b, \"*\": lambda a, b: a * b, \"/\": lambda a, b: int(a / b)}\n    \n    def evaluate(tokens):\n        stack = []\n        sign = '+'\n        num = 0\n        \n        for token in tokens:\n            if token.isdigit():\n                num = num * 10 + int(token)\n            \n            if token in ops or token == ')' or not token:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack.append(stack.pop() * num)\n                elif sign == '/':\n                    stack.append(int(stack.pop() / num))\n                \n                sign = token\n                num = 0\n            \n            if token == '(':\n                stack.append(evaluate(expression.split()[tokens.index(token) + 1:tokens.index(')')]))\n        \n        return sum(stack)\n    \n    return evaluate(expression.split())", "passed": false, "score": {"loc": 24, "tokens": 256, "cc": 9, "nest": 8, "execution_time": 10.0, "novelty": 0.747736042079111}}, {"code": "def calculate(expression: str) -> int:\n    tokens = expression.replace(' ', '').split()\n    stack = []\n    num = 0\n    sign = '+'\n    \n    for i, token in enumerate(tokens):\n        if token.isdigit():\n            num = num * 10 + int(token)\n        \n        if token in '+-*/' or i == len(tokens) - 1:\n            if sign == '+':\n                stack.append(num)\n            elif sign == '-':\n                stack.append(-num)\n            elif sign == '*':\n                stack.append(stack.pop() * num)\n            elif sign == '/':\n                stack.append(int(stack.pop() / num))\n            \n            sign = token\n            num = 0\n    \n    return sum(stack)", "passed": false, "score": {"loc": 20, "tokens": 169, "cc": 8, "nest": 7, "execution_time": 10.0, "novelty": 0.5857618211271938}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 1189, "entry_point": "constrainedSubsetSum", "best_list": [{"code": "def constrainedSubsetSum(nums, k):\n    n = len(nums)\n    dp = nums[:]\n    for i in range(1, n):\n        dp[i] += max(0, max(dp[max(0, i-k):i]))\n    return max(dp)", "passed": true, "score": {"loc": 6, "tokens": 62, "cc": 1, "nest": 2, "execution_time": 0.016719, "novelty": 0.6977862859363568}}, {"code": "def constrainedSubsetSum(nums, k):\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    max_queue = [0]\n\n    for i in range(1, len(nums)):\n        dp[i] = nums[i] + max(0, dp[max_queue[0]])\n        while max_queue and dp[i] >= dp[max_queue[-1]]:\n            max_queue.pop()\n        while max_queue and max_queue[0] <= i - k:\n            max_queue.pop(0)\n        max_queue.append(i)\n\n    return max(dp)", "passed": true, "score": {"loc": 12, "tokens": 120, "cc": 5, "nest": 3, "execution_time": 0.016645, "novelty": 0.639293157268112}}, {"code": "def constrainedSubsetSum(nums, k):\n    dp = [nums[0]]\n    deque = [0]\n    for i in range(1, len(nums)):\n        dp.append(nums[i] + dp[deque[0]])\n        while deque and dp[i] >= dp[deque[-1]]:\n            deque.pop()\n        deque.append(i)\n        if i - deque[0] >= k:\n            deque.popleft()\n        dp[i] = max(dp[i], nums[i], dp[i] - nums[i])\n    return max(dp)", "passed": true, "score": {"loc": 12, "tokens": 128, "cc": 4, "nest": 3, "execution_time": 0.016815, "novelty": 0.6757993719218358}}, {"code": "def constrainedSubsetSum(nums, k):\n    n = len(nums)\n    dp = nums.copy()\n    max_queue = []\n    \n    for i in range(1, n):\n        while max_queue and i - max_queue[0] > k:\n            heappop(max_queue)\n        dp[i] += nums[i] + (dp[max_queue[0]] if max_queue else 0)\n        heappush(max_queue, i)\n    \n    return max(dp)", "passed": false, "score": {"loc": 10, "tokens": 86, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6530662865347892}}, {"code": "from collections import deque\n\ndef constrainedSubsetSum(nums, k):\n    dp = nums[:]\n    max_queue = deque()\n    \n    for i in range(1, len(nums)):\n        dp[i] += max(0, dp[max_queue[0]] if max_queue[0] >= 0 else 0)\n        while max_queue and dp[i] >= dp[max_queue[-1]]:\n            max_queue.pop()\n        max_queue.append(i)\n        if i >= k and dp[max_queue[0]] == dp[i - k]:\n            max_queue.popleft()\n    \n    return max(dp)", "passed": false, "score": {"loc": 12, "tokens": 125, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.6812200625773335}}, {"code": "from collections import deque\n\ndef constrainedSubsetSum(nums, k):\n    n = len(nums)\n    max_sum = [0] * n\n    max_sum[0] = nums[0]\n    queue = deque([0])\n    \n    for i in range(1, n):\n        while queue and i - queue[0] > k:\n            queue.popleft()\n        max_sum[i] = max(queue[0] + nums[i], nums[i])\n        while queue and max_sum[i] > queue[-1]:\n            queue.pop()\n        queue.append(i)\n    \n    return max(max_sum)", "passed": false, "score": {"loc": 14, "tokens": 121, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.6871854061719946}}, {"code": "def constrainedSubsetSum(nums, k):\n    dp = []\n    from heapq import heappush, heappop\n    for i, num in enumerate(nums):\n        while dp and dp[0][1] < i - k:\n            heappop(dp)\n        current_max = num + (dp[0][0] if dp else 0)\n        heappush(dp, (current_max, i))\n    return max(dp)[0]", "passed": false, "score": {"loc": 9, "tokens": 82, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6837451908787189}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 1197, "entry_point": "findDuplicate", "best_list": [{"code": "def findDuplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)", "passed": true, "score": {"loc": 6, "tokens": 29, "cc": 2, "nest": 3, "execution_time": 0.016582, "novelty": 0.38633837077522604}}, {"code": "def findDuplicate(nums):\n    for i in range(len(nums)):\n        idx = abs(nums[i]) - 1\n        if nums[idx] < 0:\n            return abs(nums[i])\n        nums[idx] = -nums[idx]\n    return -1", "passed": true, "score": {"loc": 7, "tokens": 57, "cc": 2, "nest": 3, "execution_time": 0.016526, "novelty": 0.7500017926628724}}, {"code": "def findDuplicate(nums):\n    slow = nums[0]\n    fast = nums[nums[0]]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n    slow = 0\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    return slow", "passed": true, "score": {"loc": 11, "tokens": 65, "cc": 2, "nest": 2, "execution_time": 0.016658, "novelty": 0.6937673340374979}}, {"code": "def findDuplicate(nums):\n    mid = len(nums) // 2\n    while True:\n        lower, upper = 1, mid\n        countLower = countUpper = 0\n        for num in nums:\n            if lower <= num <= mid:\n                countLower += 1\n            else:\n                countUpper += 1\n        if countLower > mid - lower + 1:\n            upper = mid\n        else:\n            lower = mid + 1\n        if lower == upper:\n            return lower\n        mid = (lower + upper) // 2", "passed": false, "score": {"loc": 17, "tokens": 91, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.751057190841685}}], "num_pass": 9, "num_uniq": 4, "num_fail": 1, "fail_uniq": 1}
{"id": 11655, "entry_point": "totalNQueens", "best_list": [{"code": "def totalNQueens(n):\n    def solve(row, queens, diag1, diag2):\n        if row == n:\n            return 1\n        count = 0\n        for col in range(n):\n            if col not in queens and row - col not in diag1 and row + col not in diag2:\n                queens.add(col)\n                diag1.add(row - col)\n                diag2.add(row + col)\n                count += solve(row + 1, queens, diag1, diag2)\n                queens.remove(col)\n                diag1.remove(row - col)\n                diag2.remove(row + col)\n        return count\n\n    return solve(0, set(), set(), set())", "passed": true, "score": {"loc": 16, "tokens": 135, "cc": 4, "nest": 4, "execution_time": 0.016692, "novelty": 0.6764461510128983}}, {"code": "def totalNQueens(n):\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i] == col or abs(board[i] - col) == abs(i - row):\n                return False\n        return True\n\n    def backtrack(row, count):\n        if row == n:\n            count[0] += 1\n            return\n        for col in range(n):\n            if is_safe(board, row, col):\n                board[row] = col\n                backtrack(row + 1, count)\n                board[row] = -1\n\n    board = [-1] * n\n    count = [0]\n    backtrack(0, count)\n    return count[0]", "passed": true, "score": {"loc": 19, "tokens": 140, "cc": 6, "nest": 4, "execution_time": 0.016647, "novelty": 0.6097624020972776}}, {"code": "def totalNQueens(n):\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i][col] == 'Q' or (row - i == col - board[i].index('Q')) or (row - i == board[i].index('Q') - col):\n                return False\n        return True\n\n    def solve_n_queens(board, row):\n        if row == n:\n            solutions.append([''.join(row) for row in board])\n            return\n        for col in range(n):\n            if is_safe(board, row, col):\n                board[row][col] = 'Q'\n                solve_n_queens(board, row + 1)\n                board[row][col] = '.'\n\n    solutions = []\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    solve_n_queens(board, 0)\n    return len(solutions)", "passed": true, "score": {"loc": 19, "tokens": 203, "cc": 6, "nest": 4, "execution_time": 0.016907, "novelty": 0.7193567644454235}}, {"code": "def totalNQueens(n):\n    def is_not_under_attack(row, col):\n        return all(abs(r - row) != abs(c - col) and r != row for r, c in queens)\n\n    def place_queen(row, col):\n        queens.add((row, col))\n\n    def remove_queen(row, col):\n        queens.remove((row, col))\n\n    def backtrack(row = 0):\n        for col in range(n):\n            if is_not_under_attack(row, col):\n                place_queen(row, col)\n                if row + 1 == n:\n                    count[0] += 1\n                else:\n                    backtrack(row + 1)\n                remove_queen(row, col)\n\n    queens, count = set(), [0]\n    backtrack()\n    return count[0]", "passed": false, "score": {"loc": 19, "tokens": 157, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.7217047197760306}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 11675, "entry_point": "calculateMinimumHP", "best_list": [{"code": "def calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m][n - 1] = dp[m - 1][n] = 1\n    \n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            min_hp_needed = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]\n            dp[i][j] = max(1, min_hp_needed)\n    \n    return dp[0][0]", "passed": true, "score": {"loc": 9, "tokens": 156, "cc": 2, "nest": 3, "execution_time": 0.016697, "novelty": 0.14621684237858001}}, {"code": "def calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m][n - 1] = dp[m - 1][n] = 1\n    \n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            hp_needed = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]\n            dp[i][j] = max(1, hp_needed)\n    \n    return dp[0][0]", "passed": true, "score": {"loc": 9, "tokens": 156, "cc": 2, "nest": 3, "execution_time": 0.016717, "novelty": 0.14511936598078712}}, {"code": "def calculateMinimumHP(dungeon):\n    M, N = len(dungeon), len(dungeon[0])\n    dp = [[float('inf')] * (N + 1) for _ in range(M + 1)]\n    dp[M][N - 1] = dp[M - 1][N] = 1\n\n    for i in range(M - 1, -1, -1):\n        for j in range(N - 1, -1, -1):\n            min_hp = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]\n            dp[i][j] = max(1, min_hp)\n\n    return dp[0][0]", "passed": true, "score": {"loc": 9, "tokens": 156, "cc": 2, "nest": 3, "execution_time": 0.016732, "novelty": 0.15101678610483538}}, {"code": "def calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1])\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            hp = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]\n            dp[i][j] = max(1, hp)\n    return dp[0][0]", "passed": false, "score": {"loc": 9, "tokens": 165, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.3601228823520697}}, {"code": "def calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1])\n    \n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            need = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]\n            dp[i][j] = max(1, need)\n    \n    return dp[0][0]", "passed": false, "score": {"loc": 9, "tokens": 165, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.3587606512648809}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 2}
{"id": 11700, "entry_point": "findReplaceString", "best_list": [{"code": "def findReplaceString(S, indexes, sources, targets):\n    result = list(S)\n    for i, x, y in sorted(zip(indexes, sources, targets), reverse=True):\n        if S.startswith(x, i):\n            result[i:i+len(x)] = y\n    return ''.join(result)", "passed": true, "score": {"loc": 6, "tokens": 72, "cc": 2, "nest": 3, "execution_time": 0.016748, "novelty": 0.33076254632321256}}, {"code": "def findReplaceString(S, indexes, sources, targets):\n    result = list(S)\n    for i, x, y in sorted(zip(indexes, sources, targets), reverse=True):\n        if S[i:i+len(x)] == x:\n            result[i:i+len(x)] = y\n    return ''.join(result)", "passed": true, "score": {"loc": 6, "tokens": 78, "cc": 2, "nest": 3, "execution_time": 0.016665, "novelty": 0.31745953877763344}}, {"code": "def findReplaceString(S, indexes, sources, targets):\n    result = list(S)\n    for i, x, y in sorted(zip(indexes, sources, targets), reverse=True):\n        if S[i:i+len(x)] == x:\n            result[i:i+len(x)] = [y]\n    return ''.join(result)", "passed": true, "score": {"loc": 6, "tokens": 80, "cc": 2, "nest": 3, "execution_time": 0.016517, "novelty": 0.3217998723817804}}, {"code": "def findReplaceString(S: str, indexes: List[int], sources: List[str], targets: List[str]) -> str:\n    result = list(S)\n    for i, x, y in sorted(zip(indexes, sources, targets), reverse=True):\n        if S[i:i+len(x)] == x:\n            result[i:i+len(x)] = [y]\n    return ''.join(result)", "passed": false, "score": {"loc": 6, "tokens": 100, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.41007765633345317}}, {"code": "def findReplaceString(S, indexes, sources, targets):\n    # Create a list of tuples (start_index, source, target)\n    operations = sorted(zip(indexes, sources, targets))\n    \n    # Initialize the result string\n    result = []\n    i = 0\n    \n    # Process each operation\n    for start, source, target in operations:\n        # Add the part of S that is not being replaced\n        result.append(S[i:start])\n        \n        # Check if the source matches the substring of S starting at start\n        if S[start:start + len(source)] == source:\n            # Append the target to the result\n            result.append(target)\n        \n        # Move the index forward\n        i = start + len(source)\n    \n    # Add the remaining part of S\n    result.append(S[i:])\n    \n    # Join the parts to form the final result\n    return ''.join(result)", "passed": false, "score": {"loc": 20, "tokens": 174, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6923921457269104}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 11732, "entry_point": "stoneGameIII", "best_list": [{"code": "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [0] * (n + 1)\n    \n    for i in range(n - 1, -1, -1):\n        dp[i] = max(sum(stoneValue[i:i+k]) - dp[i+k] for k in range(1, 4) if i + k <= n)\n    \n    alice_score = dp[0]\n    bob_score = sum(stoneValue) - alice_score\n    \n    if alice_score > bob_score:\n        return \"Alice\"\n    elif alice_score < bob_score:\n        return \"Bob\"\n    else:\n        return \"Tie\"", "passed": true, "score": {"loc": 13, "tokens": 119, "cc": 3, "nest": 3, "execution_time": 0.016854, "novelty": 0.32662161196778383}}, {"code": "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        dp[i] = max(sum(stoneValue[i:i + k]) - dp[i + k] for k in range(1, 4))\n    alice_score = dp[0]\n    total_score = sum(stoneValue)\n    bob_score = total_score - alice_score\n    if alice_score > bob_score:\n        return \"Alice\"\n    elif alice_score < bob_score:\n        return \"Bob\"\n    else:\n        return \"Tie\"", "passed": false, "score": {"loc": 14, "tokens": 115, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.34058924483024855}}, {"code": "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [0] * (n + 1)\n    \n    for i in range(n - 1, -1, -1):\n        dp[i] = max(sum(stoneValue[i:i + k]) - dp[i + k] for k in range(1, 4))\n    \n    score = dp[0]\n    if score > 0:\n        return \"Alice\"\n    elif score < 0:\n        return \"Bob\"\n    else:\n        return \"Tie\"", "passed": false, "score": {"loc": 12, "tokens": 104, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.23281491047190017}}, {"code": "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [0] * (n + 1)\n    \n    for i in range(n - 1, -1, -1):\n        dp[i] = max(sum(stoneValue[i:i + k]) - dp[i + k] for k in range(1, 4))\n    \n    if dp[0] > 0:\n        return \"Alice\"\n    elif dp[0] < 0:\n        return \"Bob\"\n    else:\n        return \"Tie\"", "passed": false, "score": {"loc": 11, "tokens": 104, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.3358787819786161}}, {"code": "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    @lru_cache(None)\n    def dp(i):\n        if i == n:\n            return 0\n        return stoneValue[i] - min(dp(i + 1), dp(i + 2), dp(i + 3))\n    score = dp(0)\n    if score > 0:\n        return \"Alice\"\n    elif score < 0:\n        return \"Bob\"\n    else:\n        return \"Tie\"", "passed": false, "score": {"loc": 14, "tokens": 90, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7226178069432196}}, {"code": "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        dp[i] = max(sum(stoneValue[i:i + k]) - dp[i + k] for k in range(1, 4))\n    score_diff = dp[0]\n    if score_diff > 0:\n        return \"Alice\"\n    elif score_diff < 0:\n        return \"Bob\"\n    else:\n        return \"Tie\"", "passed": false, "score": {"loc": 12, "tokens": 104, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.2715077174302074}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 8}
{"id": 11818, "entry_point": "angleClock", "best_list": [{"code": "def angleClock(hour, minutes):\n    angle = abs(30 * hour - 5.5 * minutes)\n    return min(angle, 360 - angle)", "passed": true, "score": {"loc": 3, "tokens": 31, "cc": 0, "nest": 1, "execution_time": 0.016443, "novelty": 0.3783325470415495}}, {"code": "def angleClock(hour: int, minutes: int) -> float:\n    angle = abs(30 * hour - 5.5 * minutes)\n    return min(angle, 360 - angle)", "passed": true, "score": {"loc": 3, "tokens": 38, "cc": 0, "nest": 1, "execution_time": 0.016615, "novelty": 0.39416237807713017}}, {"code": "def angleClock(hour, minutes):\n    h_angle = (hour % 12) * 30 + minutes * 0.5\n    m_angle = minutes * 6\n    angle = abs(h_angle - m_angle)\n    return min(angle, 360 - angle)", "passed": true, "score": {"loc": 5, "tokens": 45, "cc": 0, "nest": 1, "execution_time": 0.016498, "novelty": 0.1853298391338134}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 11895, "entry_point": "numMusicPlaylists", "best_list": [{"code": "def numMusicPlaylists(N, L, K):\n    MOD = 10**9 + 7\n    dp = [[0] * (N + 1) for _ in range(L + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, L + 1):\n        for j in range(1, N + 1):\n            dp[i][j] = dp[i - 1][j - 1] * (N - j + 1) + dp[i - 1][j] * max(j - K, 0)\n            dp[i][j] %= MOD\n\n    return dp[L][N]", "passed": true, "score": {"loc": 9, "tokens": 137, "cc": 2, "nest": 3, "execution_time": 0.016501, "novelty": 0.3420047018688841}}, {"code": "def numMusicPlaylists(N, L, K):\n    MOD = 10**9 + 7\n    dp = [[0] * (N + 1) for _ in range(L + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, L + 1):\n        for j in range(1, N + 1):\n            dp[i][j] = dp[i - 1][j - 1] * (N - (j - 1)) + dp[i - 1][j] * max(0, j - K)\n            dp[i][j] %= MOD\n\n    return dp[L][N]", "passed": true, "score": {"loc": 9, "tokens": 139, "cc": 2, "nest": 3, "execution_time": 0.016762, "novelty": 0.3356493729227813}}, {"code": "def numMusicPlaylists(N, L, K):\n    MOD = 10**9 + 7\n    dp = [[0] * (N + 1) for _ in range(L + 1)]\n    dp[0][0] = 1\n    for i in range(1, L + 1):\n        for j in range(1, min(i, N) + 1):\n            dp[i][j] = dp[i - 1][j - 1] * (N - (j - 1)) % MOD\n            dp[i][j] = (dp[i][j] + dp[i - 1][j] * max(0, j - K)) % MOD\n    return dp[L][N]", "passed": true, "score": {"loc": 9, "tokens": 155, "cc": 2, "nest": 3, "execution_time": 0.016731, "novelty": 0.17340169590927323}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 11966, "entry_point": "tictactoe", "best_list": [{"code": "def tictactoe(moves):\n    board = [[' ' for _ in range(3)] for _ in range(3)]\n    players = ['A', 'B']\n    \n    for i, (row, col) in enumerate(moves):\n        board[row][col] = players[i % 2]\n        \n        if any(all(board[r][c] == board[row][col] for c in range(3)) for r in range(3)) or \\\n           any(all(board[r][c] == board[row][col] for r in range(3)) for c in range(3)) or \\\n           all(board[i][i] == board[row][col] for i in range(3)) or \\\n           all(board[i][2 - i] == board[row][col] for i in range(3)):\n            return players[i % 2]\n    \n    return \"Pending\" if len(moves) < 9 else \"Draw\"", "passed": true, "score": {"loc": 11, "tokens": 223, "cc": 3, "nest": 3, "execution_time": 0.016719, "novelty": 0.7770286721315476}}, {"code": "def tictactoe(moves):\n    board = [[' ' for _ in range(3)] for _ in range(3)]\n    player = 'A'\n    \n    for move in moves:\n        row, col = move\n        board[row][col] = player\n        \n        # Check rows and columns\n        if all(board[row][i] == player for i in range(3)) or \\\n           all(board[i][col] == player for i in range(3)):\n            return player\n        \n        # Check diagonals\n        if row == col and all(board[i][i] == player for i in range(3)):\n            return player\n        if row + col == 2 and all(board[i][2 - i] == player for i in range(3)):\n            return player\n        \n        player = 'B' if player == 'A' else 'A'\n    \n    if len(moves) < 9:\n        return \"Pending\"\n    return \"Draw\"", "passed": true, "score": {"loc": 19, "tokens": 200, "cc": 8, "nest": 3, "execution_time": 0.016753, "novelty": 0.6668223537522021}}, {"code": "def tictactoe(moves):\n    board = [' '] * 9\n    player = 'A'\n    for move in moves:\n        index = move[0] * 3 + move[1]\n        board[index] = player\n        if check_winner(board):\n            return player\n        player = 'B' if player == 'A' else 'A'\n    return 'Draw' if len(moves) == 9 else 'Pending'\n\ndef check_winner(board):\n    winning_lines = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8],  # rows\n        [0, 3, 6], [1, 4, 7], [2, 5, 8],  # columns\n        [0, 4, 8], [2, 4, 6]              # diagonals\n    ]\n    for line in winning_lines:\n        if board[line[0]] == board[line[1]] == board[line[2]] != ' ':\n            return True\n    return False", "passed": true, "score": {"loc": 20, "tokens": 202, "cc": 4, "nest": 3, "execution_time": 0.016672, "novelty": 0.7113015176425959}}, {"code": "def tictactoe(moves):\n    board = [[\" \" for _ in range(3)] for _ in range(3)]\n    player = \"X\"\n    \n    for row, col in moves:\n        board[row][col] = player\n        if check_winner(board, player):\n            return player\n        player = \"O\" if player == \"X\" else \"X\"\n    \n    if len(moves) == 9:\n        return \"Draw\"\n    return \"Pending\"\n\ndef check_winner(board, player):\n    for row in board:\n        if all(cell == player for cell in row):\n            return True\n    for col in range(3):\n        if all(board[row][col] == player for row in range(3)):\n            return True\n    if board[0][0] == board[1][1] == board[2][2] == player:\n        return True\n    if board[0][2] == board[1][1] == board[2][0] == player:\n        return True\n    return False", "passed": false, "score": {"loc": 23, "tokens": 218, "cc": 9, "nest": 3, "execution_time": 10.0, "novelty": 0.6440511780862794}}, {"code": "def tictactoe(moves):\n    board = [[\" \"] * 3 for _ in range(3)]\n    player = \"X\"\n    \n    for move in moves:\n        row, col = move\n        board[row][col] = player\n        if check_winner(board, player):\n            return player\n        player = \"O\" if player == \"X\" else \"X\"\n    \n    return \"Pending\" if len(moves) < 9 else \"Draw\"\n\ndef check_winner(board, player):\n    # Check rows\n    for row in board:\n        if all(cell == player for cell in row):\n            return True\n    \n    # Check columns\n    for col in range(3):\n        if all(board[row][col] == player for row in range(3)):\n            return True\n    \n    # Check diagonals\n    if all(board[i][i] == player for i in range(3)):\n        return True\n    if all(board[i][2 - i] == player for i in range(3)):\n        return True\n    \n    return False", "passed": false, "score": {"loc": 25, "tokens": 209, "cc": 8, "nest": 3, "execution_time": 10.0, "novelty": 0.654539685355723}}, {"code": "def tictactoe(moves):\n    board = [[' ' for _ in range(3)] for _ in range(3)]\n    players = ['X', 'O']\n    \n    for i, (r, c) in enumerate(moves):\n        board[r][c] = players[i % 2]\n    \n    def check_winner():\n        for row in board:\n            if row[0] == row[1] == row[2] != ' ':\n                return row[0]\n        for col in range(3):\n            if board[0][col] == board[1][col] == board[2][col] != ' ':\n                return board[0][col]\n        if board[0][0] == board[1][1] == board[2][2] != ' ':\n            return board[0][0]\n        if board[0][2] == board[1][1] == board[2][0] != ' ':\n            return board[0][2]\n        return None\n    \n    winner = check_winner()\n    if winner:\n        return winner\n    if len(moves) < 9:\n        return \"Pending\"\n    return \"Draw\"", "passed": false, "score": {"loc": 23, "tokens": 257, "cc": 9, "nest": 4, "execution_time": 10.0, "novelty": 0.7526381386930021}}, {"code": "def tictactoe(moves):\n    board = [[\" \"] * 3 for _ in range(3)]\n    for i, (r, c) in enumerate(moves):\n        board[r][c] = \"AB\"[i % 2]\n    \n    def check_winner(player):\n        for i in range(3):\n            if all(board[i][j] == player for j in range(3)) or \\\n               all(board[j][i] == player for j in range(3)):\n                return True\n        if board[0][0] == board[1][1] == board[2][2] == player or \\\n           board[0][2] == board[1][1] == board[2][0] == player:\n            return True\n        return False\n    \n    if check_winner(\"A\"):\n        return \"A\"\n    if check_winner(\"B\"):\n        return \"B\"\n    if len(moves) == 9:\n        return \"Draw\"\n    return \"Pending\"", "passed": false, "score": {"loc": 20, "tokens": 218, "cc": 9, "nest": 4, "execution_time": 10.0, "novelty": 0.6330839036585532}}, {"code": "def tictactoe(moves):\n    grid = [['' for _ in range(3)] for _ in range(3)]\n    players = ['A', 'B']\n    \n    for i, (row, col) in enumerate(moves):\n        grid[row][col] = players[i % 2]\n    \n    def check_winner(player):\n        # Check rows and columns\n        for i in range(3):\n            if all(grid[i][j] == player for j in range(3)) or all(grid[j][i] == player for j in range(3)):\n                return True\n        # Check diagonals\n        if all(grid[i][i] == player for i in range(3)) or all(grid[i][2 - i] == player for i in range(3)):\n            return True\n        return False\n    \n    for player in players:\n        if check_winner(player):\n            return player\n    \n    if len(moves) == 9:\n        return \"Draw\"\n    else:\n        return \"Pending\"", "passed": false, "score": {"loc": 21, "tokens": 215, "cc": 9, "nest": 4, "execution_time": 10.0, "novelty": 0.6242268335898568}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 12064, "entry_point": "validUtf8", "best_list": [{"code": "def validUtf8(data):\n    def count_ones(byte):\n        count = 0\n        while byte & 0b10000000:\n            byte <<= 1\n            count += 1\n        return count\n\n    i = 0\n    while i < len(data):\n        ones = count_ones(data[i])\n        if ones == 1 or ones > 4:\n            return False\n        if ones == 0:\n            i += 1\n        else:\n            if i + ones > len(data):\n                return False\n            for j in range(1, ones):\n                if data[i + j] & 0b11000000 != 0b10000000:\n                    return False\n            i += ones\n    return True", "passed": true, "score": {"loc": 22, "tokens": 118, "cc": 8, "nest": 5, "execution_time": 0.016606, "novelty": 0.762859442660082}}, {"code": "def validUtf8(data):\n    def bits(n):\n        return bin(n)[2:].zfill(8)[-8:]\n    \n    i = 0\n    while i < len(data):\n        byte = bits(data[i])\n        if byte.startswith('0'):\n            i += 1\n        elif byte.startswith('110'):\n            if i + 1 >= len(data) or not bits(data[i + 1]).startswith('10'):\n                return False\n            i += 2\n        elif byte.startswith('1110'):\n            if i + 2 >= len(data) or not all(bits(data[j]).startswith('10') for j in range(i + 1, i + 3)):\n                return False\n            i += 3\n        elif byte.startswith('11110'):\n            if i + 3 >= len(data) or not all(bits(data[j]).startswith('10') for j in range(i + 1, i + 4)):\n                return False\n            i += 4\n        else:\n            return False\n    return True", "passed": true, "score": {"loc": 23, "tokens": 234, "cc": 11, "nest": 7, "execution_time": 0.016709, "novelty": 0.8527794559490544}}, {"code": "def validUtf8(data):\n    state = 0\n    for byte in data:\n        if state == 0:\n            if (byte >> 5) == 0b110:\n                state = 1\n            elif (byte >> 4) == 0b1110:\n                state = 2\n            elif (byte >> 3) == 0b11110:\n                state = 3\n            elif (byte >> 7):\n                return False\n        elif state == 1:\n            if (byte >> 6) != 0b10:\n                return False\n            state = 0\n        elif state == 2:\n            if (byte >> 6) != 0b10:\n                return False\n            state = 1\n        elif state == 3:\n            if (byte >> 6) != 0b10:\n                return False\n            state = 2\n    return state == 0", "passed": true, "score": {"loc": 25, "tokens": 143, "cc": 12, "nest": 7, "execution_time": 0.016529, "novelty": 0.6750620719181493}}, {"code": "def validUtf8(data):\n    def _is_leading_byte(byte):\n        return byte >> 5 == 0b110\n\n    def _is_continuation_byte(byte):\n        return byte >> 6 == 0b10\n\n    i = 0\n    while i < len(data):\n        if not _is_leading_byte(data[i]):\n            return False\n        num_bytes = data[i] >> 3 & 0b11\n        if num_bytes < 2 or num_bytes > 4 or i + num_bytes > len(data):\n            return False\n        for j in range(1, num_bytes):\n            if not _is_continuation_byte(data[i + j]):\n                return False\n        i += num_bytes\n    return True", "passed": false, "score": {"loc": 17, "tokens": 118, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.6940995222451567}}, {"code": "def validUtf8(data):\n    states = [\n        lambda byte: (byte >> 7) == 0,\n        lambda byte: (byte >> 5) == 0b110,\n        lambda byte: (byte >> 4) == 0b1110,\n        lambda byte: (byte >> 3) == 0b11110\n    ]\n    state = 0\n    for byte in data:\n        if state == 0:\n            for i in range(4, -1, -1):\n                if states[i](byte):\n                    state = i\n                    break\n            else:\n                return False\n        elif not states[state - 1](byte):\n            return False\n        state -= 1\n    return state == 0", "passed": false, "score": {"loc": 20, "tokens": 129, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.7145823953199684}}, {"code": "def validUtf8(data):\n    mask1, mask2 = 1 << 7, 1 << 6\n    n = len(data)\n    \n    i = 0\n    while i < n:\n        if (data[i] & mask1) == 0:\n            i += 1\n        elif (data[i] & mask1) and not (data[i] & mask2):\n            return False\n        elif (data[i] & mask1) and (data[i] & mask2):\n            num_bytes = 2\n            while num_bytes > 1:\n                i += 1\n                if i == n or (data[i] & mask1) or not (data[i] & mask2):\n                    return False\n                num_bytes -= 1\n        else:\n            return False\n    return True", "passed": false, "score": {"loc": 19, "tokens": 140, "cc": 9, "nest": 7, "execution_time": 10.0, "novelty": 0.7715875642974435}}, {"code": "def validUtf8(data):\n    state = 0\n    for byte in data:\n        if state == 0:\n            if byte & 0b10000000 == 0:\n                state = 0\n            elif byte & 0b11111000 == 0b11100000:\n                state = 1\n            elif byte & 0b11110000 == 0b11110000:\n                state = 2\n            elif byte & 0b11111100 == 0b11111000:\n                state = 3\n            else:\n                return False\n        elif state == 1:\n            if byte & 0b11000000 != 0b10000000:\n                return False\n            state -= 1\n        elif state == 2:\n            if byte & 0b11000000 != 0b10000000:\n                return False\n            state -= 1\n        elif state == 3:\n            if byte & 0b11000000 != 0b10000000:\n                return False\n            state -= 1\n    return state == 0", "passed": false, "score": {"loc": 27, "tokens": 133, "cc": 12, "nest": 7, "execution_time": 10.0, "novelty": 0.7031943938782064}}, {"code": "def validUtf8(data):\n    def is_leading_byte(byte):\n        return byte >> 5 == 0b110\n    \n    def is_continuation_byte(byte):\n        return byte >> 6 == 0b10\n    \n    i = 0\n    while i < len(data):\n        if not is_leading_byte(data[i]):\n            return False\n        \n        num_bytes = 0\n        if (data[i] >> 3) == 0b1110:\n            num_bytes = 3\n        elif (data[i] >> 4) == 0b11110:\n            num_bytes = 4\n        elif (data[i] >> 5) == 0b110:\n            num_bytes = 1\n        else:\n            return False\n        \n        i += 1\n        for _ in range(num_bytes):\n            if i >= len(data) or not is_continuation_byte(data[i]):\n                return False\n            i += 1\n    \n    return True", "passed": false, "score": {"loc": 24, "tokens": 153, "cc": 8, "nest": 5, "execution_time": 10.0, "novelty": 0.679831529651919}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 12126, "entry_point": "isAlienSorted", "best_list": [{"code": "def isAlienSorted(words, order):\n    return all(words[i] <= words[i + 1] for i in range(len(words) - 1))", "passed": true, "score": {"loc": 2, "tokens": 36, "cc": 0, "nest": 1, "execution_time": 0.016591, "novelty": 0.641916585248403}}, {"code": "def isAlienSorted(words, order):\n    alien_order = {char: idx for idx, char in enumerate(order)}\n    return words == sorted(words, key=lambda word: [alien_order[char] for char in word])", "passed": true, "score": {"loc": 3, "tokens": 48, "cc": 0, "nest": 1, "execution_time": 0.016396, "novelty": 0.5317064019554449}}, {"code": "def isAlienSorted(words, order):\n    order_map = {char: idx for idx, char in enumerate(order)}\n    return words == sorted(words, key=lambda word: [order_map[char] for char in word])", "passed": true, "score": {"loc": 3, "tokens": 48, "cc": 0, "nest": 1, "execution_time": 0.016606, "novelty": 0.5572725743754627}}, {"code": "def isAlienSorted(words, order):\n    return all(order.index(w1[i]) < order.index(w2[i]) for w1, w2 in zip(words, words[1:]) for i in range(min(len(w1), len(w2))) if w1[i] != w2[i]) and all(order.index(w[i]) < order.index(w[i+1]) for w in words for i in range(len(w)-1))", "passed": false, "score": {"loc": 2, "tokens": 116, "cc": 1, "nest": 1, "execution_time": 10.0, "novelty": 0.8124478262854835}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 12174, "entry_point": "flipgame", "best_list": [{"code": "def flipgame(fronts, backs):\n    same = {f for f, b in zip(fronts, backs) if f == b}\n    return min((f for f in fronts + backs if f not in same), default=0)", "passed": true, "score": {"loc": 3, "tokens": 51, "cc": 0, "nest": 1, "execution_time": 0.016438, "novelty": 0.555248919715858}}, {"code": "def flipgame(fronts, backs):\n    same = {x for x, y in zip(fronts, backs) if x == y}\n    return min((x for x in fronts + backs if x not in same), default=0)", "passed": true, "score": {"loc": 3, "tokens": 51, "cc": 0, "nest": 1, "execution_time": 0.016584, "novelty": 0.4790629890097713}}, {"code": "def flipgame(fronts, backs):\n    same = {x for x, y in zip(fronts, backs) if x == y}\n    return min([x for x in fronts + backs if x not in same] or [0])", "passed": true, "score": {"loc": 3, "tokens": 51, "cc": 1, "nest": 1, "execution_time": 0.0168, "novelty": 0.5750309047299598}}, {"code": "def flipgame(fronts, backs):\n    not_on_front = set(b for a, b in zip(fronts, backs) if a != b)\n    return min(not_on_front.union(fronts), default=0)", "passed": false, "score": {"loc": 3, "tokens": 44, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5121551310607264}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 12253, "entry_point": "divisorGame", "best_list": [{"code": "def divisorGame(N):\n    return N % 2 == 0", "passed": true, "score": {"loc": 2, "tokens": 13, "cc": 0, "nest": 1, "execution_time": 0.016565, "novelty": 0.022822822822822664}}, {"code": "def divisorGame(N: int) -> bool:\n    return N % 2 == 0", "passed": true, "score": {"loc": 2, "tokens": 18, "cc": 0, "nest": 1, "execution_time": 0.01669, "novelty": 0.09129129129129132}}], "num_pass": 10, "num_uniq": 2, "num_fail": 0, "fail_uniq": 0}
{"id": 12339, "entry_point": "findTheDifference", "best_list": [{"code": "def findTheDifference(s, t):\n    return chr(sum(map(ord, t)) - sum(map(ord, s)))", "passed": true, "score": {"loc": 2, "tokens": 31, "cc": 0, "nest": 1, "execution_time": 0.016669, "novelty": 0.3465799516176171}}, {"code": "def findTheDifference(s, t):\n    return chr(sum(ord(c) for c in t) - sum(ord(c) for c in s))", "passed": true, "score": {"loc": 2, "tokens": 35, "cc": 0, "nest": 1, "execution_time": 0.016477, "novelty": 0.5359422389900053}}, {"code": "def findTheDifference(s: str, t: str) -> str:\n    return chr(sum(map(ord, t)) - sum(map(ord, s)))", "passed": true, "score": {"loc": 2, "tokens": 38, "cc": 0, "nest": 1, "execution_time": 0.016741, "novelty": 0.33592672952418756}}, {"code": "def findTheDifference(s: str, t: str) -> str:\n    return list((collections.Counter(t) - collections.Counter(s)).elements())[0]", "passed": false, "score": {"loc": 2, "tokens": 41, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6139883071387336}}], "num_pass": 9, "num_uniq": 6, "num_fail": 1, "fail_uniq": 1}
{"id": 12396, "entry_point": "canVisitAllRooms", "best_list": [{"code": "def canVisitAllRooms(rooms):\n    visited = set()\n    stack = [0]\n    \n    while stack:\n        room = stack.pop()\n        if room not in visited:\n            visited.add(room)\n            stack.extend(rooms[room])\n    \n    return len(visited) == len(rooms)", "passed": true, "score": {"loc": 9, "tokens": 58, "cc": 2, "nest": 3, "execution_time": 0.016696, "novelty": 0.08092883153207076}}, {"code": "def canVisitAllRooms(rooms):\n    stack, visited = [0], set([0])\n    while stack:\n        room = stack.pop()\n        for key in rooms[room]:\n            if key not in visited:\n                visited.add(key)\n                stack.append(key)\n    return len(visited) == len(rooms)", "passed": true, "score": {"loc": 9, "tokens": 67, "cc": 3, "nest": 4, "execution_time": 0.016578, "novelty": 0.3016699215860553}}, {"code": "def canVisitAllRooms(rooms):\n    visited = set([0])\n    stack = [0]\n    while stack:\n        room = stack.pop()\n        for key in rooms[room]:\n            if key not in visited:\n                visited.add(key)\n                stack.append(key)\n    return len(visited) == len(rooms)", "passed": true, "score": {"loc": 10, "tokens": 66, "cc": 3, "nest": 4, "execution_time": 0.016596, "novelty": 0.2372088146594853}}, {"code": "def canVisitAllRooms(rooms):\n    stack = [0]\n    visited = set()\n    while stack:\n        room = stack.pop()\n        if room not in visited:\n            visited.add(room)\n            stack.extend(rooms[room] - visited)\n    return len(visited) == len(rooms)", "passed": false, "score": {"loc": 9, "tokens": 60, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.15696547243485526}}, {"code": "def canVisitAllRooms(rooms):\n    visited = set()\n    stack = [0]\n    while stack:\n        room = stack.pop()\n        if room not in visited:\n            visited.add(room)\n            stack.extend(rooms[room] - visited)\n    return len(visited) == len(rooms)", "passed": false, "score": {"loc": 9, "tokens": 60, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.11714107920796435}}, {"code": "def canVisitAllRooms(rooms):\n    to_visit = {0}\n    visited = set()\n    \n    while to_visit:\n        room = to_visit.pop()\n        if room not in visited:\n            visited.add(room)\n            to_visit.update(rooms[room] - visited)\n    \n    return len(visited) == len(rooms)", "passed": false, "score": {"loc": 9, "tokens": 60, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.2110491769689048}}], "num_pass": 7, "num_uniq": 3, "num_fail": 3, "fail_uniq": 3}
{"id": 12414, "entry_point": "minMalwareSpread", "best_list": [{"code": "def minMalwareSpread(graph, initial):\n    n = len(graph)\n    colors = [-1] * n\n    color = 0\n    \n    def dfs(node, color):\n        colors[node] = color\n        for neighbor, connected in enumerate(graph[node]):\n            if connected and colors[neighbor] == -1:\n                dfs(neighbor, color)\n    \n    for i in range(n):\n        if colors[i] == -1:\n            dfs(i, color)\n            color += 1\n    \n    color_count = [0] * color\n    color_nodes = [[] for _ in range(color)]\n    \n    for i in range(n):\n        color_count[colors[i]] += 1\n        color_nodes[colors[i]].append(i)\n    \n    initial_set = set(initial)\n    initial_count = [0] * color\n    \n    for node in initial:\n        initial_count[colors[node]] += 1\n    \n    max_removed = 0\n    min_node = float('inf')\n    \n    for node in initial:\n        color_idx = colors[node]\n        if initial_count[color_idx] == 1:\n            if color_count[color_idx] > max_removed or (color_count[color_idx] == max_removed and node < min_node):\n                max_removed = color_count[color_idx]\n                min_node = node\n    \n    if min_node == float('inf'):\n        min_node = min(initial)\n    \n    return min_node", "passed": true, "score": {"loc": 33, "tokens": 257, "cc": 13, "nest": 4, "execution_time": 0.016948, "novelty": 0.7879799541951169}}, {"code": "def minMalwareSpread(graph, initial):\n    n = len(graph)\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        parent[find(x)] = find(y)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if graph[i][j] == 1:\n                union(i, j)\n    \n    component_size = [0] * n\n    malware_count = [0] * n\n    \n    for i in range(n):\n        component_size[find(i)] += 1\n    \n    for node in initial:\n        malware_count[find(node)] += 1\n    \n    result = (-1, float('inf'))\n    \n    for node in sorted(initial):\n        component = find(node)\n        if malware_count[component] == 1:\n            if component_size[component] > result[1] or (component_size[component] == result[1] and node < result[0]):\n                result = (node, component_size[component])\n    \n    return result[0]", "passed": false, "score": {"loc": 26, "tokens": 242, "cc": 11, "nest": 4, "execution_time": 10.0, "novelty": 0.6788200777530874}}, {"code": "def minMalwareSpread(graph, initial):\n    n = len(graph)\n    parent = list(range(n))\n    size = [1] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n            size[rootY] += size[rootX]\n\n    # Union nodes based on the graph\n    for i in range(n):\n        for j in range(i + 1, n):\n            if graph[i][j] == 1:\n                union(i, j)\n\n    # Count the number of malware nodes in each component\n    malware_count = [0] * n\n    for node in initial:\n        malware_count[find(node)] += 1\n\n    # Find the node with the minimum impact if removed\n    min_infected = float('inf')\n    result = min(initial)\n    for node in initial:\n        root = find(node)\n        if malware_count[root] == 1 and size[root] < min_infected:\n            min_infected = size[root]\n            result = node\n\n    return result", "passed": false, "score": {"loc": 32, "tokens": 243, "cc": 9, "nest": 4, "execution_time": 10.0, "novelty": 0.7178257595284456}}, {"code": "def minMalwareSpread(graph, initial):\n    from collections import defaultdict\n    \n    n = len(graph)\n    components = defaultdict(set)\n    color = 0\n    \n    def dfs(node, c):\n        if node in components[c]:\n            return\n        components[c].add(node)\n        for neighbor, connected in enumerate(graph[node]):\n            if connected:\n                dfs(neighbor, c)\n    \n    for i in range(n):\n        if i not in components[color]:\n            dfs(i, color)\n            color += 1\n    \n    size = [len(components[c]) for c in components]\n    malware_count = [sum(1 for node in comp if node in initial) for comp in components.values()]\n    \n    def _equivalent(lhs, rhs):\n        return lhs == rhs\n    \n    result = float('inf')\n    max_safe = 0\n    \n    for i in range(n):\n        if sum(1 for node in components[0] if node in initial) > 1:\n            if malware_count[i] == 1 and size[i] > max_safe:\n                max_safe = size[i]\n                result = min(result, i)\n            elif malware_count[i] == 1 and size[i] == max_safe:\n                result = min(result, i)\n        else:\n            result = min(result, i)\n    \n    return result", "passed": false, "score": {"loc": 32, "tokens": 259, "cc": 11, "nest": 5, "execution_time": 10.0, "novelty": 0.7812640271806196}}, {"code": "def minMalwareSpread(graph, initial):\n    n = len(graph)\n    infected_count = [0] * n\n    component_size = {}\n    \n    def dfs(node, component):\n        if node in component:\n            return\n        component.add(node)\n        component_size[component] = len(component)\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1:\n                dfs(neighbor, component)\n    \n    components = []\n    for node in range(n):\n        component = set()\n        dfs(node, component)\n        components.append(component)\n    \n    initial.sort()\n    for node in initial:\n        infected_count[node] += 1\n    \n    remove_node = -1\n    min_infected = float('inf')\n    for node in initial:\n        infected = 0\n        for component in components:\n            if node in component:\n                infected += component_size[component]\n                if infected_count[node] > 1:\n                    break\n        if infected < min_infected:\n            min_infected = infected\n            remove_node = node\n    \n    return remove_node", "passed": false, "score": {"loc": 33, "tokens": 185, "cc": 10, "nest": 5, "execution_time": 10.0, "novelty": 0.7531515183016038}}, {"code": "def minMalwareSpread(graph, initial):\n    n = len(graph)\n    parents = list(range(n))\n    \n    def find(x):\n        if parents[x] != x:\n            parents[x] = find(parents[x])\n        return parents[x]\n    \n    def union(x, y):\n        parents[find(x)] = find(y)\n    \n    # Union connected components\n    for i in range(n):\n        for j in range(i + 1, n):\n            if graph[i][j] == 1:\n                union(i, j)\n    \n    # Count nodes in each component\n    component_size = [0] * n\n    for i in range(n):\n        component_size[find(i)] += 1\n    \n    # Count initial nodes in each component\n    component_initial = [0] * n\n    for node in initial:\n        component_initial[find(node)] += 1\n    \n    # Remove one node from initial to minimize malware spread\n    removal_count = [0] * n\n    for node in initial:\n        if component_initial[find(node)] == 1:\n            removal_count[find(node)] += 1\n    \n    # Find the node with the maximum removal count\n    max_removal = max(removal_count)\n    result = min(initial)\n    for node in initial:\n        if removal_count[find(node)] == max_removal:\n            result = min(result, node)\n    \n    return result", "passed": false, "score": {"loc": 34, "tokens": 269, "cc": 10, "nest": 4, "execution_time": 10.0, "novelty": 0.6829508582243922}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 12424, "entry_point": "myAtoi", "best_list": [{"code": "def myAtoi(s: str) -> int:\n    s = s.strip()\n    if not s:\n        return 0\n    \n    result, i, sign = 0, 0, 1\n    if s[i] in \"+-\":\n        sign = 1 if s[i] == \"+\" else -1\n        i += 1\n    \n    while i < len(s) and s[i].isdigit():\n        result = result * 10 + int(s[i])\n        i += 1\n    \n    result = sign * result\n    result = max(-2**31, min(result, 2**31 - 1))\n    \n    return result", "passed": true, "score": {"loc": 14, "tokens": 129, "cc": 4, "nest": 2, "execution_time": 0.016571, "novelty": 0.6263605596217532}}, {"code": "def myAtoi(s):\n    s = s.strip()\n    if not s:\n        return 0\n    \n    sign = 1\n    if s[0] in \"+-\":\n        sign = -1 if s[0] == \"-\" else 1\n        s = s[1:]\n    \n    result = 0\n    for char in s:\n        if not char.isdigit():\n            break\n        result = result * 10 + int(char)\n    \n    result = sign * result\n    result = max(-2**31, min(result, 2**31 - 1))\n    return result", "passed": true, "score": {"loc": 16, "tokens": 112, "cc": 4, "nest": 3, "execution_time": 0.016652, "novelty": 0.5157529450934506}}, {"code": "def myAtoi(s: str) -> int:\n    s = s.lstrip()\n    if not s:\n        return 0\n    \n    sign = 1\n    if s[0] in \"+-\":\n        sign = -1 if s[0] == \"-\" else 1\n        s = s[1:]\n    \n    result = 0\n    for char in s:\n        if not char.isdigit():\n            break\n        result = result * 10 + int(char)\n    \n    result *= sign\n    result = max(-2**31, min(result, 2**31 - 1))\n    \n    return result", "passed": true, "score": {"loc": 16, "tokens": 116, "cc": 4, "nest": 3, "execution_time": 0.016596, "novelty": 0.5135652925899934}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 12495, "entry_point": "isNStraightHand", "best_list": [{"code": "def isNStraightHand(hand, W):\n    from collections import Counter\n    \n    count = Counter(hand)\n    for h in sorted(hand):\n        if count[h] > 0:\n            for i in range(W):\n                count[h + i] -= 1\n                if count[h + i] < 0:\n                    return False\n    return True", "passed": true, "score": {"loc": 10, "tokens": 65, "cc": 4, "nest": 5, "execution_time": 0.016696, "novelty": 0.4554801313396566}}, {"code": "from collections import Counter\n\ndef isNStraightHand(hand, W):\n    count = Counter(hand)\n    for card in sorted(count):\n        if count[card] > 0:\n            for i in range(W - 1, -1, -1):\n                count[card + i] -= 1\n                if count[card + i] < 0:\n                    return False\n    return True", "passed": true, "score": {"loc": 10, "tokens": 73, "cc": 4, "nest": 5, "execution_time": 0.016614, "novelty": 0.398337171027755}}, {"code": "from collections import Counter\n\ndef isNStraightHand(hand, W):\n    count = Counter(hand)\n    for card in sorted(hand):\n        if count[card] == 0:\n            continue\n        for next_card in range(card, card + W):\n            if count[next_card] == 0:\n                return False\n            count[next_card] -= 1\n    return True", "passed": true, "score": {"loc": 11, "tokens": 68, "cc": 4, "nest": 4, "execution_time": 0.016686, "novelty": 0.5583707490269587}}, {"code": "def isNStraightHand(hand, W):\n    if len(hand) % W != 0:\n        return False\n    \n    hand.sort()\n    hand_set = set(hand)\n    \n    while hand_set:\n        start = min(hand_set)\n        for i in range(W):\n            if start + i not in hand_set:\n                return False\n            hand_set.remove(start + i)\n    \n    return True", "passed": false, "score": {"loc": 12, "tokens": 69, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.6931601900385935}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 12520, "entry_point": "isIsomorphic", "best_list": [{"code": "def isIsomorphic(s, t):\n    return len(set(zip(s, t))) == len(set(s)) == len(set(t))", "passed": true, "score": {"loc": 2, "tokens": 39, "cc": 0, "nest": 1, "execution_time": 0.016534, "novelty": 0.6868442080115473}}, {"code": "def isIsomorphic(s, t):\n    s_to_t = {}\n    t_to_s = {}\n    for s_char, t_char in zip(s, t):\n        if s_char in s_to_t and s_to_t[s_char] != t_char:\n            return False\n        if t_char in t_to_s and t_to_s[t_char] != s_char:\n            return False\n        s_to_t[s_char] = t_char\n        t_to_s[t_char] = s_char\n    return True", "passed": true, "score": {"loc": 11, "tokens": 72, "cc": 5, "nest": 3, "execution_time": 0.016708, "novelty": 0.5115251947024922}}, {"code": "def isIsomorphic(s: str, t: str) -> bool:\n    s_to_t = {}\n    t_to_s = {}\n    \n    for s_char, t_char in zip(s, t):\n        if s_char in s_to_t and s_to_t[s_char] != t_char:\n            return False\n        if t_char in t_to_s and t_to_s[t_char] != s_char:\n            return False\n        s_to_t[s_char] = t_char\n        t_to_s[t_char] = s_char\n    \n    return True", "passed": true, "score": {"loc": 11, "tokens": 79, "cc": 5, "nest": 3, "execution_time": 0.016619, "novelty": 0.5174200035565375}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 12536, "entry_point": "permute", "best_list": [{"code": "def permute(nums):\n    if len(nums) == 1:\n        return [nums]\n    perms = []\n    for i in range(len(nums)):\n        for perm in permute(nums[:i] + nums[i+1:]):\n            perms.append([nums[i]] + perm)\n    return perms", "passed": true, "score": {"loc": 8, "tokens": 69, "cc": 3, "nest": 3, "execution_time": 0.016708, "novelty": 0.5284605472562169}}, {"code": "def permute(nums):\n    def backtrack(path, remaining):\n        if not remaining:\n            result.append(path)\n            return\n        for i in range(len(remaining)):\n            backtrack(path + [remaining[i]], remaining[:i] + remaining[i+1:])\n    \n    result = []\n    backtrack([], nums)\n    return result", "passed": true, "score": {"loc": 10, "tokens": 74, "cc": 2, "nest": 3, "execution_time": 0.01686, "novelty": 0.7190159302979484}}, {"code": "def permute(nums):\n    return _permute(nums)\n\ndef _permute(nums):\n    if len(nums) == 1:\n        return [nums]\n    perms = []\n    for i in range(len(nums)):\n        for perm in _permute(nums[:i] + nums[i+1:]):\n            perms.append([nums[i]] + perm)\n    return perms", "passed": true, "score": {"loc": 10, "tokens": 80, "cc": 3, "nest": 3, "execution_time": 0.016882, "novelty": 0.7597818100928752}}, {"code": "from itertools import permutations\n\ndef permute(nums):\n    return list(permutations(nums))", "passed": false, "score": {"loc": 3, "tokens": 18, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.4910388935085723}}], "num_pass": 6, "num_uniq": 5, "num_fail": 4, "fail_uniq": 1}
{"id": 12575, "entry_point": "minSubArrayLen", "best_list": [{"code": "def minSubArrayLen(s, nums):\n    left, total, min_len = 0, 0, float('inf')\n    for right in range(len(nums)):\n        total += nums[right]\n        while total >= s:\n            min_len = min(min_len, right - left + 1)\n            total -= nums[left]\n            left += 1\n    return min_len if min_len != float('inf') else 0", "passed": true, "score": {"loc": 9, "tokens": 85, "cc": 2, "nest": 3, "execution_time": 0.01655, "novelty": 0.3841824275784358}}, {"code": "def minSubArrayLen(s, nums):\n    min_len = float('inf')\n    start = 0\n    current_sum = 0\n    \n    for end in range(len(nums)):\n        current_sum += nums[end]\n        while current_sum >= s:\n            min_len = min(min_len, end - start + 1)\n            current_sum -= nums[start]\n            start += 1\n    \n    return min_len if min_len != float('inf') else 0", "passed": true, "score": {"loc": 11, "tokens": 83, "cc": 2, "nest": 3, "execution_time": 0.016511, "novelty": 0.34691070054288087}}, {"code": "def minSubArrayLen(s, nums):\n    min_length = float('inf')\n    left = 0\n    current_sum = 0\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        while current_sum >= s:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0", "passed": true, "score": {"loc": 11, "tokens": 83, "cc": 2, "nest": 3, "execution_time": 0.016671, "novelty": 0.36937216593880673}}, {"code": "def minSubArrayLen(s, nums):\n    def divide_and_conquer(nums, start, end, s):\n        if start > end:\n            return float('inf')\n        if start == end:\n            return nums[start] >= s\n        mid = (start + end) // 2\n        left_min_len = divide_and_conquer(nums, start, mid, s)\n        right_min_len = divide_and_conquer(nums, mid + 1, end, s)\n        if left_min_len != float('inf') or right_min_len != float('inf'):\n            return min(left_min_len, right_min_len)\n        cross_min_len = float('inf')\n        current_sum = 0\n        for i in range(mid, end, -1):\n            current_sum += nums[i]\n            if current_sum >= s:\n                cross_min_len = min(cross_min_len, end - i + 1)\n                break\n        current_sum = 0\n        for i in range(mid + 1, end + 1):\n            current_sum += nums[i]\n            if current_sum >= s:\n                cross_min_len = min(cross_min_len, i - mid)\n                break\n        return min(left_min_len, right_min_len, cross_min_len)\n    \n    result = divide_and_conquer(nums, 0, len(nums) - 1, s)\n    return result if result != float('inf') else 0", "passed": false, "score": {"loc": 27, "tokens": 241, "cc": 8, "nest": 4, "execution_time": 10.0, "novelty": 0.837405003852646}}, {"code": "def minSubArrayLen(s, nums):\n    def min_len(left, right):\n        if left > right:\n            return float('inf')\n        mid = (left + right) // 2\n        total = sum(nums[left:mid + 1])\n        if total == s:\n            return mid - left + 1\n        elif total < s:\n            return min(min_len(mid + 1, right), mid - left + 1 + min_len(left, mid - 1))\n        else:\n            return min_len(left, mid - 1)\n    \n    result = min_len(0, len(nums) - 1)\n    return result if result != float('inf') else 0", "passed": false, "score": {"loc": 14, "tokens": 133, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7272102581974134}}, {"code": "def minSubArrayLen(s, nums):\n    def divide_and_conquer(left, right):\n        if left > right:\n            return float('inf')\n        mid = (left + right) // 2\n        sum_left = sum(nums[left:mid+1])\n        sum_right = sum(nums[mid+1:right+1])\n        if sum_left >= s:\n            min_len_left = 1\n        else:\n            min_len_left = divide_and_conquer(left, mid)\n        if sum_right >= s:\n            min_len_right = 1\n        else:\n            min_len_right = divide_and_conquer(mid+1, right)\n        if sum_left + sum_right >= s:\n            min_len_cross = mid - left + 2\n        else:\n            min_len_cross = float('inf')\n        return min(min_len_left, min_len_right, min_len_cross)\n    \n    n = len(nums)\n    result = divide_and_conquer(0, n-1)\n    return result if result != float('inf') else 0", "passed": false, "score": {"loc": 23, "tokens": 170, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.758346899791704}}], "num_pass": 7, "num_uniq": 6, "num_fail": 3, "fail_uniq": 3}
{"id": 12613, "entry_point": "generate", "best_list": [{"code": "from math import comb\n\ndef generate(numRows):\n    return [[comb(n, k) for k in range(n + 1)] for n in range(numRows)]", "passed": true, "score": {"loc": 3, "tokens": 37, "cc": 0, "nest": 1, "execution_time": 0.016627, "novelty": 0.74109140333635}}, {"code": "def generate(numRows):\n    triangle = []\n    for row_num in range(numRows):\n        row = [1] * (row_num + 1)\n        for j in range(1, row_num):\n            row[j] = triangle[row_num - 1][j - 1] + triangle[row_num - 1][j]\n        triangle.append(row)\n    return triangle", "passed": true, "score": {"loc": 8, "tokens": 73, "cc": 2, "nest": 3, "execution_time": 0.01661, "novelty": 0.46503601355887303}}, {"code": "def generate(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i-1][j-1] + triangle[i-1][j]\n        triangle.append(row)\n    return triangle", "passed": true, "score": {"loc": 8, "tokens": 73, "cc": 2, "nest": 3, "execution_time": 0.016624, "novelty": 0.4353907844130812}}, {"code": "def generate(numRows):\n    def helper(row):\n        if len(row) == 1:\n            return [1]\n        return [1] + [row[i] + row[i + 1] for i in range(len(row) - 1)] + [1]\n    \n    result = [[1]]\n    for _ in range(1, numRows):\n        result.append(helper(result[-1]))\n    return result", "passed": false, "score": {"loc": 9, "tokens": 91, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.8006211487791625}}], "num_pass": 9, "num_uniq": 6, "num_fail": 1, "fail_uniq": 1}
{"id": 12646, "entry_point": "firstUniqChar", "best_list": [{"code": "def firstUniqChar(s):\n    for i, c in enumerate(s):\n        if s.count(c) == 1:\n            return i\n    return -1", "passed": true, "score": {"loc": 5, "tokens": 32, "cc": 2, "nest": 3, "execution_time": 0.016415, "novelty": 0.4294874156395585}}, {"code": "def firstUniqChar(s):\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    for index, char in enumerate(s):\n        if char_count[char] == 1:\n            return index\n    \n    return -1", "passed": true, "score": {"loc": 8, "tokens": 54, "cc": 3, "nest": 3, "execution_time": 0.016426, "novelty": 0.14571216227942818}}, {"code": "def firstUniqChar(s):\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    for i, char in enumerate(s):\n        if char_count[char] == 1:\n            return i\n    return -1", "passed": true, "score": {"loc": 8, "tokens": 54, "cc": 3, "nest": 3, "execution_time": 0.016436, "novelty": 0.14475911965860122}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 12665, "entry_point": "optimalDivision", "best_list": [{"code": "def optimalDivision(nums):\n    if len(nums) == 1:\n        return str(nums[0])\n    if len(nums) == 2:\n        return f\"{nums[0]}/{nums[1]}\"\n    return f\"{nums[0]}/({'/'.join(map(str, nums[1:]))})\"", "passed": true, "score": {"loc": 6, "tokens": 81, "cc": 2, "nest": 2, "execution_time": 0.016475, "novelty": 0.0011102230115562772}}, {"code": "def optimalDivision(nums):\n    if len(nums) == 1:\n        return str(nums[0])\n    elif len(nums) == 2:\n        return f\"{nums[0]}/{nums[1]}\"\n    return f\"{nums[0]}/({'/'.join(map(str, nums[1:]))})\"", "passed": true, "score": {"loc": 6, "tokens": 81, "cc": 2, "nest": 3, "execution_time": 0.016798, "novelty": 0.0022942249839719153}}, {"code": "def optimalDivision(nums):\n    if len(nums) == 1:\n        return str(nums[0])\n    elif len(nums) == 2:\n        return f\"{nums[0]}/{nums[1]}\"\n    else:\n        return f\"{nums[0]}/({'/'.join(map(str, nums[1:]))})\"", "passed": true, "score": {"loc": 7, "tokens": 83, "cc": 2, "nest": 3, "execution_time": 0.016686, "novelty": 0.0034794087892022763}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 12692, "entry_point": "numDistinct", "best_list": [{"code": "def numDistinct(s: str, t: str) -> int:\n    dp = [0] * (len(t) + 1)\n    dp[0] = 1\n    for char in s:\n        for j in range(len(t), 0, -1):\n            if t[j - 1] == char:\n                dp[j] += dp[j - 1]\n    return dp[-1]", "passed": true, "score": {"loc": 8, "tokens": 85, "cc": 3, "nest": 4, "execution_time": 0.016707, "novelty": 0.5503277179295591}}, {"code": "def numDistinct(s, t):\n    m, n = len(s), len(t)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(m):\n        for j in range(n, 0, -1):\n            if s[i] == t[j - 1]:\n                dp[j] += dp[j - 1]\n    return dp[n]", "passed": true, "score": {"loc": 9, "tokens": 90, "cc": 3, "nest": 4, "execution_time": 0.016621, "novelty": 0.34411456943651475}}, {"code": "def numDistinct(s: str, t: str) -> int:\n    m, n = len(s), len(t)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(m):\n        for j in range(n - 1, -1, -1):\n            if s[i] == t[j]:\n                dp[j + 1] += dp[j]\n    \n    return dp[n]", "passed": true, "score": {"loc": 9, "tokens": 98, "cc": 3, "nest": 4, "execution_time": 0.016738, "novelty": 0.372861947038428}}, {"code": "def numDistinct(s: str, t: str) -> int:\n    m, n = len(t), len(s)\n    dp = {0: 1}\n    for j in range(1, n + 1):\n        ndp = {0: dp[0]}\n        for i in range(1, m + 1):\n            ndp[i] = dp[i]\n            if t[i - 1] == s[j - 1]:\n                ndp[i] += dp[i - 1]\n        dp = ndp\n    return dp[m]", "passed": false, "score": {"loc": 11, "tokens": 114, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.4026221924660853}}, {"code": "def numDistinct(s: str, t: str) -> int:\n    dp = {0: 1}\n    for char in s:\n        for i in range(len(t), 0, -1):\n            dp[i] += dp[i - 1] if char == t[i - 1] else 0\n    return dp[len(t)]", "passed": false, "score": {"loc": 6, "tokens": 75, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5677109285121658}}], "num_pass": 8, "num_uniq": 7, "num_fail": 2, "fail_uniq": 2}
{"id": 12701, "entry_point": "numSubseq", "best_list": [{"code": "def numSubseq(nums, target):\n    nums.sort()\n    count, left, right = 0, 0, len(nums) - 1\n    while left <= right:\n        if nums[left] + nums[right] <= target:\n            count = (count + 2 ** (right - left)) % (10 ** 9 + 7)\n            left += 1\n        else:\n            right -= 1\n    return count", "passed": true, "score": {"loc": 10, "tokens": 84, "cc": 2, "nest": 3, "execution_time": 0.016604, "novelty": 0.3197684026961297}}, {"code": "def numSubseq(nums, target):\n    nums.sort()\n    count = 0\n    mod = 10**9 + 7\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        if nums[left] + nums[right] <= target:\n            count = (count + 2**(right - left)) % mod\n            left += 1\n        else:\n            right -= 1\n    return count", "passed": true, "score": {"loc": 12, "tokens": 84, "cc": 2, "nest": 3, "execution_time": 0.016666, "novelty": 0.618367055135486}}, {"code": "def numSubseq(nums, target):\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    mod = 10**9 + 7\n    count = 0\n    while left <= right:\n        if nums[left] + nums[right] > target:\n            right -= 1\n        else:\n            count = (count + pow(2, right - left, mod)) % mod\n            left += 1\n    return count", "passed": true, "score": {"loc": 12, "tokens": 85, "cc": 2, "nest": 3, "execution_time": 0.016533, "novelty": 0.182996274472079}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 12760, "entry_point": "minMoves2", "best_list": [{"code": "def minMoves2(nums):\n    nums.sort()\n    median = nums[len(nums) // 2]\n    return sum(abs(num - median) for num in nums)", "passed": true, "score": {"loc": 4, "tokens": 37, "cc": 0, "nest": 1, "execution_time": 0.016638, "novelty": 0.02897414460632275}}, {"code": "def minMoves2(nums):\n    nums.sort()\n    median = nums[len(nums) // 2]\n    return sum(abs(x - median) for x in nums)", "passed": true, "score": {"loc": 4, "tokens": 37, "cc": 0, "nest": 1, "execution_time": 0.016752, "novelty": 0.029633308881637732}}, {"code": "def minMoves2(nums):\n    nums.sort()\n    median = nums[len(nums) // 2]\n    moves = 0\n    for num in nums:\n        moves += abs(num - median)\n    return moves", "passed": true, "score": {"loc": 7, "tokens": 42, "cc": 1, "nest": 2, "execution_time": 0.016564, "novelty": 0.24399590421561235}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 12835, "entry_point": "majorityElement", "best_list": [{"code": "def majorityElement(nums):\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    return [num for num, c in count.items() if c > len(nums) // 3]", "passed": true, "score": {"loc": 5, "tokens": 54, "cc": 1, "nest": 2, "execution_time": 0.01656, "novelty": 0.5597045520255304}}, {"code": "def majorityElement(nums):\n    counts = {}\n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n    return [num for num, count in counts.items() if count > len(nums) // 3]", "passed": true, "score": {"loc": 5, "tokens": 54, "cc": 1, "nest": 2, "execution_time": 0.016765, "novelty": 0.5632299945387294}}, {"code": "def majorityElement(nums):\n    counts = {}\n    threshold = len(nums) // 3\n    result = []\n    \n    for num in nums:\n        counts[num] = counts.get(num, 0) + 1\n        if counts[num] > threshold and num not in result:\n            result.append(num)\n    \n    return result", "passed": true, "score": {"loc": 9, "tokens": 64, "cc": 3, "nest": 3, "execution_time": 0.016582, "novelty": 0.6369807771399916}}, {"code": "def majorityElement(nums):\n    candidates = {}\n    threshold = len(nums) // 3\n    \n    for num in nums:\n        if num in candidates:\n            candidates[num] += 1\n        else:\n            candidates[num] = 1\n        \n        if candidates[num] > threshold:\n            candidates[num] = 0\n    \n    return [num for num, count in candidates.items() if count > 0]", "passed": false, "score": {"loc": 11, "tokens": 76, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5794677430753554}}, {"code": "def majorityElement(nums):\n    count = {}\n    threshold = len(nums) // 3\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n        if count[num] > threshold:\n            count[num] = 0\n    return [num for num, cnt in count.items() if cnt > 0]", "passed": false, "score": {"loc": 11, "tokens": 76, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5636973220741525}}, {"code": "from collections import defaultdict\n\ndef majorityElement(nums):\n    count = defaultdict(int)\n    n = len(nums)\n    threshold = n // 3\n    \n    for num in nums:\n        count[num] += 1\n        if count[num] > threshold:\n            return [num]\n    \n    return []", "passed": false, "score": {"loc": 10, "tokens": 55, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6753765656904264}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 12881, "entry_point": "maxJumps", "best_list": [{"code": "def maxJumps(arr, d):\n    n = len(arr)\n    dp = [1] * n\n    \n    for i in range(n):\n        for j in range(i + 1, min(i + d + 1, n)):\n            if arr[i] <= arr[j]:\n                break\n            dp[i] = max(dp[i], dp[j] + 1)\n        \n        for j in range(i - 1, max(i - d - 1, -1), -1):\n            if arr[i] <= arr[j]:\n                break\n            dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)", "passed": true, "score": {"loc": 13, "tokens": 144, "cc": 5, "nest": 4, "execution_time": 0.016689, "novelty": 0.6561756396354349}}, {"code": "def maxJumps(arr, d):\n    n = len(arr)\n    dp = [1] * n\n    \n    def dfs(i):\n        if dp[i] > 1:\n            return dp[i]\n        mx = 0\n        for x in range(1, d + 1):\n            if i + x < n and arr[i + x] < arr[i]:\n                mx = max(mx, dfs(i + x))\n            else:\n                break\n        for x in range(1, d + 1):\n            if i - x >= 0 and arr[i - x] < arr[i]:\n                mx = max(mx, dfs(i - x))\n            else:\n                break\n        dp[i] = mx + 1\n        return dp[i]\n    \n    for i in range(n):\n        dfs(i)\n    \n    return max(dp)", "passed": true, "score": {"loc": 22, "tokens": 168, "cc": 8, "nest": 4, "execution_time": 0.01666, "novelty": 0.7281072242722931}}, {"code": "def maxJumps(arr, d):\n    n = len(arr)\n    dp = [1] * n\n    stack = []\n    for i in range(n):\n        while stack and arr[stack[-1]] < arr[i]:\n            j = stack.pop()\n            left = right = 0\n            if i - j <= d:\n                left = dp[j]\n            if j - stack[-1] <= d:\n                right = dp[stack[-1]]\n            dp[i] = max(dp[i], max(left, right) + 1)\n        stack.append(i)\n    return max(dp)", "passed": false, "score": {"loc": 15, "tokens": 130, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.6885214768295465}}, {"code": "def maxJumps(arr, d):\n    n = len(arr)\n    jumps = [1] * n\n    \n    for i in range(n):\n        for x in range(1, d + 1):\n            if i + x < n and arr[i] > arr[i + x]:\n                jumps[i] = max(jumps[i], jumps[i + x] + 1)\n            else:\n                break\n            if i - x >= 0 and arr[i] > arr[i - x]:\n                jumps[i] = max(jumps[i], jumps[i - x] + 1)\n            else:\n                break\n    \n    return max(jumps)", "passed": false, "score": {"loc": 14, "tokens": 133, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.525345214528935}}, {"code": "def maxJumps(arr, d):\n    n = len(arr)\n    dp = [1] * n\n    \n    def dfs(i):\n        if dp[i] > 1:\n            return dp[i]\n        for x in range(1, d + 1):\n            if i + x < n and arr[i] > arr[i + x]:\n                dp[i] = max(dp[i], dfs(i + x) + 1)\n            if i - x >= 0 and arr[i] > arr[i - x]:\n                dp[i] = max(dp[i], dfs(i - x) + 1)\n        return dp[i]\n    \n    return max(dfs(i) for i in range(n))", "passed": false, "score": {"loc": 13, "tokens": 153, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.7204790239552656}}, {"code": "from collections import defaultdict\n\ndef maxJumps(arr, d):\n    n = len(arr)\n    jumps = [1] * n\n    indices = defaultdict(list)\n    for i, x in enumerate(arr):\n        indices[x].append(i)\n    \n    for x in sorted(indices):\n        for i in indices[x]:\n            for j in range(1, d + 1):\n                if i + j < n and arr[i] > arr[i + j]:\n                    jumps[i] = max(jumps[i], jumps[i + j] + 1)\n                if i - j >= 0 and arr[i] > arr[i - j]:\n                    jumps[i] = max(jumps[i], jumps[i - j] + 1)\n    \n    return max(jumps)", "passed": false, "score": {"loc": 15, "tokens": 164, "cc": 8, "nest": 5, "execution_time": 10.0, "novelty": 0.7462145768957142}}, {"code": "def maxJumps(arr, d):\n    n = len(arr)\n    jumps = [1] * n\n    \n    def can_jump(i, j):\n        return 0 < abs(i - j) <= d and arr[i] > arr[j]\n    \n    for i in range(n):\n        for x in range(1, d + 1):\n            if i + x < n and can_jump(i, i + x):\n                jumps[i] = max(jumps[i], jumps[i + x] + 1)\n            if i - x >= 0 and can_jump(i, i - x):\n                jumps[i] = max(jumps[i], jumps[i - x] + 1)\n    \n    return max(jumps)", "passed": false, "score": {"loc": 12, "tokens": 151, "cc": 7, "nest": 4, "execution_time": 10.0, "novelty": 0.6735146714128368}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 8}
{"id": 12907, "entry_point": "minKBitFlips", "best_list": [{"code": "def minKBitFlips(A, K):\n    flips = 0\n    flip_state = [0] * len(A)\n    for i in range(len(A)):\n        if i >= K:\n            flip_state[i - K] = 0\n        if flip_state[i] % 2 == A[i]:\n            if i + K > len(A):\n                return -1\n            flip_state[i] = 1\n            flips += 1\n    return flips", "passed": true, "score": {"loc": 12, "tokens": 85, "cc": 4, "nest": 4, "execution_time": 0.016654, "novelty": 0.5112267280576275}}, {"code": "def minKBitFlips(A, K):\n    n = len(A)\n    flips = 0\n    flip_stack = []\n    \n    for i in range(n):\n        if flip_stack and flip_stack[0] == i - K:\n            flip_stack.pop(0)\n        \n        if len(flip_stack) % 2 == A[i]:\n            if i + K > n:\n                return -1\n            flips += 1\n            flip_stack.append(i)\n    \n    return flips", "passed": true, "score": {"loc": 13, "tokens": 84, "cc": 5, "nest": 4, "execution_time": 0.016682, "novelty": 0.4851179528275953}}, {"code": "def minKBitFlips(A, K):\n    n = len(A)\n    flips = 0\n    flip_at = [0] * (n + 1)\n    flip_count = 0\n    \n    for i in range(n):\n        flip_count += flip_at[i]\n        if (flip_count % 2) == A[i]:\n            if i + K > n:\n                return -1\n            flips += 1\n            flip_count += 1\n            flip_at[i + K] -= 1\n    \n    return flips", "passed": true, "score": {"loc": 14, "tokens": 88, "cc": 3, "nest": 4, "execution_time": 0.016561, "novelty": 0.3497515238951735}}, {"code": "def minKBitFlips(A, K):\n    n = len(A)\n    flips = 0\n    flip_at = [0] * (n + 1)\n    \n    for i in range(n):\n        flips += flip_at[i]\n        if (A[i] + flips) % 2 == 0:\n            if i + K > n:\n                return -1\n            flips += 1\n            flip_at[i + K] -= 1\n    \n    return flips", "passed": false, "score": {"loc": 12, "tokens": 83, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.30794390307361585}}, {"code": "def minKBitFlips(A, K):\n    n = len(A)\n    flips = 0\n    flip_stack = []\n    \n    for i in range(n):\n        if flip_stack and i >= flip_stack[0] + K:\n            flip_stack.pop(0)\n        \n        if flip_stack and i % 2 == flip_stack[0] % 2:\n            continue\n        \n        if i + K > n:\n            return -1\n        \n        flips += 1\n        flip_stack.append(i)\n    \n    return flips", "passed": false, "score": {"loc": 14, "tokens": 86, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.45701375306520364}}, {"code": "def minKBitFlips(A, K):\n    n = len(A)\n    flips = 0\n    flip_at = [0] * (n + 1)\n    \n    for i in range(n):\n        flips += flip_at[i]\n        if (flips % 2 == A[i]):\n            if (i + K > n):\n                return -1\n            flips += 1\n            flip_at[i + K] -= 1\n    \n    return flips", "passed": false, "score": {"loc": 12, "tokens": 83, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.2739417181391085}}, {"code": "def minKBitFlips(A, K):\n    n = len(A)\n    flip_count = 0\n    current_flips = 0\n    for i in range(n):\n        if i >= K:\n            current_flips ^= A[i - K]\n        if (A[i] ^ current_flips) == 0:\n            if i + K > n:\n                return -1\n            A[i] ^= 1\n            current_flips ^= 1\n            flip_count += 1\n    return flip_count", "passed": false, "score": {"loc": 14, "tokens": 83, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.503320568868155}}, {"code": "def minKBitFlips(A, K):\n    n = len(A)\n    flips = 0\n    flip_count = [0] * (n + 1)\n    \n    for i in range(n):\n        flip_count[i] += flip_count[i - 1]\n        if (A[i] + flip_count[i]) % 2 == 0:\n            if i + K > n:\n                return -1\n            flips += 1\n            flip_count[i + K] -= 1\n    \n    return flips", "passed": false, "score": {"loc": 12, "tokens": 91, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.3632204505551835}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 12974, "entry_point": "palindromePartition", "best_list": [{"code": "from functools import lru_cache\n\ndef palindromePartition(s: str, k: int) -> int:\n    @lru_cache(None)\n    def min_changes(i: int, j: int) -> int:\n        return 0 if i >= j else (min_changes(i + 1, j - 1) + (s[i] != s[j]))\n\n    @lru_cache(None)\n    def dp(i: int, k: int) -> int:\n        return min(dp(j, k - 1) + min_changes(j + 1, i) for j in range(k - 2, i)) if k > 1 else min_changes(0, i)\n\n    return dp(len(s) - 1, k)", "passed": true, "score": {"loc": 9, "tokens": 147, "cc": 0, "nest": 2, "execution_time": 0.016674, "novelty": 0.7827332178030928}}, {"code": "def palindromePartition(s, k):\n    n = len(s)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    for i in range(n, -1, -1):\n        for j in range(1, k + 1):\n            dp[i][j] = float('inf')\n            for l in range(i, n):\n                cost = sum(1 for x, y in zip(s[i:l], reversed(s[l:i-1:-1])) if x != y)\n                dp[i][j] = min(dp[i][j], cost + dp[l + 1][j - 1])\n    \n    return dp[0][k]", "passed": false, "score": {"loc": 10, "tokens": 166, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7397352625516629}}, {"code": "def palindromePartition(s: str, k: int) -> int:\n    n = len(s)\n    cost = [[0] * n for _ in range(n)]\n    \n    # Calculate the cost to make substring s[i:j+1] a palindrome\n    for i in range(n-1, -1, -1):\n        for j in range(i, n):\n            cost[i][j] = cost[i+1][j-1] + (s[i] != s[j])\n    \n    dp = [[float('inf')] * k for _ in range(n)]\n    \n    # Initialize the dp array\n    for i in range(n):\n        dp[i][0] = cost[0][i]\n    \n    # Fill the dp array\n    for i in range(1, n):\n        for j in range(1, min(i+1, k)):\n            for p in range(j-1, i):\n                dp[i][j] = min(dp[i][j], dp[p][j-1] + cost[p+1][i])\n    \n    return dp[n-1][k-1]", "passed": false, "score": {"loc": 17, "tokens": 255, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.7266337035484549}}, {"code": "def palindromePartition(s: str, k: int) -> int:\n    n = len(s)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    cost = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        cost[i][i] = 0\n        for j in range(i + 1, n):\n            cost[i][j] = cost[i + 1][j - 1] + (s[i] != s[j])\n    \n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            dp[i][j] = min(dp[i][j], min(dp[p][j - 1] + cost[p][i - 1] for p in range(j - 1, i)))\n    \n    return dp[n][k]", "passed": false, "score": {"loc": 13, "tokens": 223, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7643428807944299}}, {"code": "def palindromePartition(s: str, k: int) -> int:\n    n = len(s)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            for l in range(i):\n                dp[i][j] = min(dp[i][j], dp[l][j - 1] + sum(s[l] != s[i - 1 - m] for m in range(l, i)))\n\n    return dp[n][k]", "passed": false, "score": {"loc": 9, "tokens": 157, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.6715920273589828}}, {"code": "def palindromePartition(s: str, k: int) -> int:\n    n = len(s)\n    cost = [[0] * n for _ in range(n)]\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            cost[i][j] = cost[i + 1][j - 1] + (s[i] != s[j])\n    \n    dp = [float('inf')] * (k + 1)\n    dp[0] = 0\n    \n    for _ in range(1, k + 1):\n        for i in range(n):\n            dp[i + 1] = min(dp[i + 1], min(dp[j] + cost[j + 1][i] for j in range(i)))\n    \n    return dp[n]", "passed": false, "score": {"loc": 13, "tokens": 188, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7145318771476714}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 13042, "entry_point": "winnerSquareGame", "best_list": [{"code": "def winnerSquareGame(n):\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = any(not dp[i - j * j] for j in range(1, int(math.sqrt(i)) + 1))\n    return dp[n]", "passed": true, "score": {"loc": 5, "tokens": 70, "cc": 1, "nest": 2, "execution_time": 0.01647, "novelty": 0.5852531720099265}}, {"code": "def winnerSquareGame(n):\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = any(not dp[i - j * j] for j in range(1, int(i**0.5) + 1))\n    return dp[n]", "passed": true, "score": {"loc": 5, "tokens": 70, "cc": 1, "nest": 2, "execution_time": 0.016482, "novelty": 0.5189351393955758}}, {"code": "from functools import cache\n\n@cache\ndef winnerSquareGame(n):\n    if n == 0:\n        return False\n    return any(not winnerSquareGame(n - i * i) for i in range(1, int(n**0.5) + 1))", "passed": true, "score": {"loc": 6, "tokens": 52, "cc": 1, "nest": 2, "execution_time": 0.016719, "novelty": 0.6243956674209644}}, {"code": "import math\n\ndef winnerSquareGame(n):\n    @lru_cache(None)\n    def helper(n):\n        return any(not helper(n - j * j) for j in range(1, int(math.sqrt(n)) + 1))\n    \n    return helper(n)", "passed": false, "score": {"loc": 6, "tokens": 56, "cc": 0, "nest": 2, "execution_time": 10.0, "novelty": 0.7402550326124269}}, {"code": "def winnerSquareGame(n):\n    @cache\n    def can_win(x):\n        return any(not can_win(x - i * i) for i in range(1, int(x**0.5) + 1))\n    return can_win(n)", "passed": false, "score": {"loc": 5, "tokens": 51, "cc": 0, "nest": 2, "execution_time": 10.0, "novelty": 0.6424048153216573}}, {"code": "def winnerSquareGame(n: int) -> bool:\n    @cache\n    def helper(n: int) -> bool:\n        return any(not helper(n - i * i) for i in range(1, int(n**0.5) + 1))\n    return helper(n)", "passed": false, "score": {"loc": 5, "tokens": 61, "cc": 0, "nest": 2, "execution_time": 10.0, "novelty": 0.5924090693405}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 13114, "entry_point": "findSpecialInteger", "best_list": [{"code": "def findSpecialInteger(arr):\n    threshold = len(arr) // 4\n    for i in range(len(arr) - threshold):\n        if arr[i] == arr[i + threshold]:\n            return arr[i]", "passed": true, "score": {"loc": 5, "tokens": 47, "cc": 2, "nest": 3, "execution_time": 0.016561, "novelty": 0.22817726408657835}}, {"code": "def findSpecialInteger(arr):\n    n = len(arr)\n    quart = n // 4\n    for i in range(n - quart):\n        if arr[i] == arr[i + quart]:\n            return arr[i]", "passed": true, "score": {"loc": 6, "tokens": 47, "cc": 2, "nest": 3, "execution_time": 0.016638, "novelty": 0.3013117556986674}}, {"code": "def findSpecialInteger(arr):\n    n = len(arr)\n    threshold = n // 4\n    for i in range(n - threshold):\n        if arr[i] == arr[i + threshold]:\n            return arr[i]", "passed": true, "score": {"loc": 6, "tokens": 47, "cc": 2, "nest": 3, "execution_time": 0.016722, "novelty": 0.3234960289092448}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 13133, "entry_point": "minimumSwap", "best_list": [{"code": "def minimumSwap(s1: str, s2: str) -> int:\n    if (s1.count('x') + s2.count('x')) % 2 != 0:\n        return -1\n    mismatches = sum(1 for c1, c2 in zip(s1, s2) if c1 != c2)\n    return mismatches // 2 + mismatches % 2 * 2", "passed": true, "score": {"loc": 5, "tokens": 77, "cc": 1, "nest": 2, "execution_time": 0.016558, "novelty": 0.6807210561007504}}, {"code": "def minimumSwap(s1: str, s2: str) -> int:\n    count = {'x': 0, 'y': 0}\n    for a, b in zip(s1, s2):\n        if a != b:\n            count[a] += 1\n    if (count['x'] + count['y']) % 2 != 0:\n        return -1\n    return count['x'] // 2 + count['y'] // 2 + count['x'] % 2", "passed": true, "score": {"loc": 8, "tokens": 109, "cc": 3, "nest": 3, "execution_time": 0.016737, "novelty": 0.4881524900536205}}, {"code": "def minimumSwap(s1, s2):\n    count = {'x': 0, 'y': 0}\n    for c1, c2 in zip(s1, s2):\n        if c1 != c2:\n            count[c1] += 1\n    if (count['x'] + count['y']) % 2 != 0:\n        return -1\n    return count['x'] // 2 + count['y'] // 2 + count['x'] % 2 + count['y'] % 2", "passed": true, "score": {"loc": 8, "tokens": 111, "cc": 3, "nest": 3, "execution_time": 0.016694, "novelty": 0.47855377359983675}}, {"code": "def minimumSwap(s1: str, s2: str) -> int:\n    count = {'xx': 0, 'yy': 0, 'xy': 0, 'yx': 0}\n    for c1, c2 in zip(s1, s2):\n        count[c1 + c2] += 1\n    \n    xy = count['xy']\n    yx = count['yx']\n    \n    if (xy + yx) % 2 != 0:\n        return -1\n    \n    return xy // 2 + yx // 2 + xy % 2 + yx % 2", "passed": false, "score": {"loc": 9, "tokens": 112, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.5737443413770948}}, {"code": "def minimumSwap(s1: str, s2: str) -> int:\n    if len(s1) != len(s2):\n        return -1\n    \n    count = {'xx': 0, 'yy': 0, 'xy': 0, 'yx': 0}\n    for char1, char2 in zip(s1, s2):\n        count[char1 + char2] += 1\n    \n    if (count['xy'] + count['yx']) % 2 != 0:\n        return -1\n    \n    return count['xy'] // 2 + count['yx'] // 2 + count['xy'] % 2 + count['yx'] % 2", "passed": false, "score": {"loc": 9, "tokens": 141, "cc": 3, "nest": 2, "execution_time": 10.0, "novelty": 0.767046065279076}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 13165, "entry_point": "isRobotBounded", "best_list": [{"code": "def isRobotBounded(instructions: str) -> bool:\n    x, y, dx, dy = 0, 0, 0, 1\n    for i in instructions:\n        if i == 'L':\n            dx, dy = -dy, dx\n        elif i == 'R':\n            dx, dy = dy, -dx\n        else:\n            x, y = x + dx, y + dy\n    return (x, y) == (0, 0) or (dx, dy) != (0, 1)", "passed": true, "score": {"loc": 10, "tokens": 102, "cc": 4, "nest": 4, "execution_time": 0.016525, "novelty": 0.383469542978244}}, {"code": "def isRobotBounded(instructions: str) -> bool:\n    x, y, dx, dy = 0, 0, 0, 1\n    for i in instructions:\n        if i == 'G':\n            x, y = x + dx, y + dy\n        elif i == 'L':\n            dx, dy = -dy, dx\n        elif i == 'R':\n            dx, dy = dy, -dx\n    return (x, y) == (0, 0) or (dx, dy) != (0, 1)", "passed": true, "score": {"loc": 10, "tokens": 108, "cc": 5, "nest": 5, "execution_time": 0.016682, "novelty": 0.42839447545507914}}, {"code": "def isRobotBounded(instructions):\n    x, y = 0, 0\n    dx, dy = 0, 1\n    for i in instructions:\n        if i == 'L':\n            dx, dy = -dy, dx\n        elif i == 'R':\n            dx, dy = dy, -dx\n        else:\n            x, y = x + dx, y + dy\n    return (x, y) == (0, 0) or (dx, dy) != (0, 1)", "passed": true, "score": {"loc": 11, "tokens": 96, "cc": 4, "nest": 4, "execution_time": 0.016482, "novelty": 0.3987203429012752}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 13217, "entry_point": "thirdMax", "best_list": [{"code": "def thirdMax(nums):\n    first, second, third = float('-inf'), float('-inf'), float('-inf')\n    for num in nums:\n        if num > first:\n            first, second, third = num, first, second\n        elif first > num > second:\n            second, third = num, second\n        elif second > num > third:\n            third = num\n    return first if third == float('-inf') else third", "passed": true, "score": {"loc": 10, "tokens": 95, "cc": 4, "nest": 5, "execution_time": 0.016572, "novelty": 0.3544151358892502}}, {"code": "def thirdMax(nums):\n    first, second, third = float('-inf'), float('-inf'), float('-inf')\n    for num in nums:\n        if num > first:\n            first, second, third = num, first, second\n        elif first > num > second:\n            second, third = num, second\n        elif second > num > third:\n            third = num\n    return third if third != float('-inf') else first", "passed": true, "score": {"loc": 10, "tokens": 95, "cc": 4, "nest": 5, "execution_time": 0.016651, "novelty": 0.41582248281310363}}, {"code": "def thirdMax(nums):\n    first, second, third = float('-inf'), float('-inf'), float('-inf')\n    for num in nums:\n        if num not in {first, second, third}:\n            if num > first:\n                first, second, third = num, first, second\n            elif num > second:\n                second, third = num, second\n            elif num > third:\n                third = num\n    return first if third == float('-inf') else third", "passed": true, "score": {"loc": 11, "tokens": 103, "cc": 5, "nest": 6, "execution_time": 0.016673, "novelty": 0.5179251484786345}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 13384, "entry_point": "pushDominoes", "best_list": [{"code": "def pushDominoes(dominoes):\n    n = len(dominoes)\n    force = [0] * n\n    left = 0\n    for i in range(n):\n        if dominoes[i] == 'R':\n            left = n\n        elif dominoes[i] == 'L':\n            left = 0\n        else:\n            left = max(left - 1, 0)\n        force[i] += left\n    \n    right = 0\n    for i in range(n - 1, -1, -1):\n        if dominoes[i] == 'L':\n            right = n\n        elif dominoes[i] == 'R':\n            right = 0\n        else:\n            right = max(right - 1, 0)\n        force[i] -= right\n    \n    result = []\n    for f in force:\n        if f == 0:\n            result.append('.')\n        elif f > 0:\n            result.append('R')\n        else:\n            result.append('L')\n    \n    return ''.join(result)", "passed": true, "score": {"loc": 30, "tokens": 197, "cc": 9, "nest": 4, "execution_time": 0.016652, "novelty": 0.8069835532091119}}, {"code": "def pushDominoes(s):\n    s = \"L\" + s + \"R\"\n    result = []\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[j] == '.':\n            j += 1\n        if s[i] == s[j]:\n            result.append(s[i] * (j - i))\n        elif s[i] == 'L' and s[j] == 'R':\n            result.append('.' * (j - i))\n        else:\n            mid = (j - i - 1) // 2\n            result.append('R' * mid + '.' * (j - i - 2 * mid) + 'L' * mid)\n        i = j\n    return ''.join(result)", "passed": false, "score": {"loc": 17, "tokens": 176, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.8438616969291722}}, {"code": "def pushDominoes(dominoes: str) -> str:\n    n = len(dominoes)\n    result = list(dominoes)\n    i = 0\n    while i < n:\n        j = i\n        while j < n and result[j] == '.':\n            j += 1\n        if j == n:\n            break\n        if i == 0 and result[i] == '.':\n            if result[j] == 'L':\n                result[i:j] = ['L'] * (j - i)\n        elif result[i] == 'L':\n            if result[j] == 'L':\n                result[i:j] = ['L'] * (j - i)\n            elif result[j] == 'R':\n                pass\n        elif result[i] == 'R':\n            if result[j] == 'L':\n                mid = (j - i) // 2\n                result[i + mid] = result[j - mid] = 'R' if (j - i) % 2 == 0 else '.'\n            elif result[j] == 'R':\n                result[i:j] = ['R'] * (j - i)\n        i = j\n    return ''.join(result)", "passed": false, "score": {"loc": 26, "tokens": 261, "cc": 13, "nest": 7, "execution_time": 10.0, "novelty": 0.6812727341320501}}, {"code": "def pushDominoes(s: str) -> str:\n    n = len(s)\n    s = list('L' + s + 'R')\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n + 1 and s[j] == '.':\n            j += 1\n        if s[j] == 'L':\n            if s[i] == 'R':\n                mid = (j - i - 1) // 2\n                s[i + 1:i + 1 + mid] = 'R' * mid\n                s[i + 1 + mid:i + 1 + (j - i - 1) // 2 + 1] = 'L' * (j - i - 1 - 2 * mid)\n            i = j\n        else:\n            i = j\n    return ''.join(s[1:n+1])", "passed": false, "score": {"loc": 17, "tokens": 181, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.6978891588827021}}, {"code": "def pushDominoes(s: str) -> str:\n    result = list(s)\n    n = len(result)\n    i = 0\n    while i < n:\n        if result[i] == '.':\n            j = i + 1\n            while j < n and result[j] == '.':\n                j += 1\n            if i > 0 and result[i - 1] == 'R':\n                if j == n or result[j] == 'L':\n                    for k in range(i, j):\n                        result[k] = 'R' if i == k else 'L' if j == k else '.'\n                else:\n                    for k in range(i, j):\n                        result[k] = 'R' if (k - i) < (j - k) else 'L' if (k - i) > (j - k) else '.'\n            i = j\n        else:\n            i += 1\n    return ''.join(result)", "passed": false, "score": {"loc": 20, "tokens": 204, "cc": 10, "nest": 6, "execution_time": 10.0, "novelty": 0.6694029759975566}}, {"code": "def pushDominoes(s):\n    s = 'L' + s + 'R'\n    n = len(s)\n    i = 0\n    result = []\n    while i < n - 1:\n        j = i + 1\n        while j < n and s[j] == '.':\n            j += 1\n        if s[i] == s[j]:\n            result.append(s[i] * (j - i))\n        elif s[i] == 'L' and s[j] == 'R':\n            result.append('.' * (j - i))\n        else:\n            result.append('R' * ((j - i) // 2) + '.' * ((j - i) % 2) + 'L' * ((j - i) // 2))\n        i = j\n    return ''.join(result)", "passed": false, "score": {"loc": 17, "tokens": 184, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.6650672010571239}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 13401, "entry_point": "convertToTitle", "best_list": [{"code": "def convertToTitle(n):\n    if n == 0:\n        return \"\"\n    else:\n        return convertToTitle((n - 1) // 26) + chr((n - 1) % 26 + ord('A'))", "passed": true, "score": {"loc": 5, "tokens": 47, "cc": 1, "nest": 2, "execution_time": 0.016559, "novelty": 0.6072895786856045}}, {"code": "def convertToTitle(n):\n    result = []\n    while n > 0:\n        n -= 1\n        result.append(chr(n % 26 + 65))\n        n //= 26\n    return ''.join(result[::-1])", "passed": true, "score": {"loc": 7, "tokens": 51, "cc": 1, "nest": 2, "execution_time": 0.016609, "novelty": 0.1409674486498318}}, {"code": "def convertToTitle(n):\n    result = []\n    while n > 0:\n        n -= 1\n        result.append(chr(n % 26 + ord('A')))\n        n //= 26\n    return ''.join(reversed(result))", "passed": true, "score": {"loc": 7, "tokens": 53, "cc": 1, "nest": 2, "execution_time": 0.016789, "novelty": 0.17230826014253364}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 13418, "entry_point": "maxFreq", "best_list": [{"code": "def maxFreq(s, maxLetters, minSize, maxSize):\n    from collections import Counter\n    cnt = Counter(s[i:i+minSize] for i in range(len(s) - minSize + 1))\n    return max((cnt[w] for w in cnt if len(set(w)) <= maxLetters), default=0)", "passed": true, "score": {"loc": 4, "tokens": 72, "cc": 0, "nest": 1, "execution_time": 0.016822, "novelty": 0.49759438869390593}}, {"code": "def maxFreq(s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n    from collections import Counter\n    substr_count = Counter(s[i:i+minSize] for i in range(len(s) - minSize + 1))\n    return max((count for substring, count in substr_count.items() if len(set(substring)) <= maxLetters), default=0)", "passed": true, "score": {"loc": 4, "tokens": 86, "cc": 0, "nest": 1, "execution_time": 0.016625, "novelty": 0.5072041660770149}}, {"code": "def maxFreq(s, maxLetters, minSize, maxSize):\n    freq = {}\n    for i in range(len(s) - minSize + 1):\n        substring = s[i:i + minSize]\n        if len(set(substring)) <= maxLetters:\n            freq[substring] = freq.get(substring, 0) + 1\n    return max(freq.values()) if freq else 0", "passed": true, "score": {"loc": 7, "tokens": 81, "cc": 2, "nest": 3, "execution_time": 0.016678, "novelty": 0.4577800583415238}}, {"code": "def maxFreq(s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n    return max([s[i:i+minSize] for i in range(len(s)-minSize+1)].count(sub) for sub in set(s[i:i+minSize] for i in range(len(s)-minSize+1)) if len(set(sub)) <= maxLetters) if minSize <= len(s) <= maxSize else 0", "passed": false, "score": {"loc": 2, "tokens": 108, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7373620839404456}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 13420, "entry_point": "largestNumber", "best_list": [{"code": "def largestNumber(nums):\n    nums = list(map(str, nums))\n    nums.sort(key=lambda x: x*3, reverse=True)\n    return str(int(''.join(nums)))", "passed": true, "score": {"loc": 4, "tokens": 48, "cc": 0, "nest": 1, "execution_time": 0.016563, "novelty": 0.5856508385330357}}, {"code": "def largestNumber(nums):\n    from functools import cmp_to_key\n    nums = list(map(str, nums))\n    nums.sort(key=cmp_to_key(lambda x, y: int(y + x) - int(x + y)))\n    return str(int(''.join(nums)))", "passed": true, "score": {"loc": 5, "tokens": 63, "cc": 0, "nest": 1, "execution_time": 0.016802, "novelty": 0.5848516684373151}}, {"code": "from functools import cmp_to_key\n\ndef largestNumber(nums):\n    def compare(x, y):\n        return int(y + x) - int(x + y)\n    \n    nums = sorted(map(str, nums), key=cmp_to_key(compare))\n    return str(int(''.join(nums)))", "passed": true, "score": {"loc": 6, "tokens": 64, "cc": 0, "nest": 2, "execution_time": 0.016573, "novelty": 0.47715582271456336}}, {"code": "def largestNumber(nums):\n    nums = list(map(str, nums))\n    nums.sort(key=lambda x, y: y + x > x + y)\n    return ''.join(nums).lstrip('0') or '0'", "passed": false, "score": {"loc": 4, "tokens": 55, "cc": 1, "nest": 1, "execution_time": 10.0, "novelty": 0.5021352807110652}}, {"code": "def largestNumber(nums):\n    # Convert integers to strings for custom comparison\n    nums = list(map(str, nums))\n    # Define a custom comparator\n    def compare(x, y):\n        return (int(y + x) - int(x + y))\n    # Sort numbers based on the custom comparator\n    nums.sort(key=cmp_to_key(compare))\n    # Concatenate sorted numbers into a single string\n    result = ''.join(nums)\n    # Handle the edge case where the result is all zeros\n    return result if result[0] != '0' else '0'", "passed": false, "score": {"loc": 12, "tokens": 117, "cc": 0, "nest": 2, "execution_time": 10.0, "novelty": 0.40874141382417617}}, {"code": "from functools import cmp_to_key\n\ndef largestNumber(nums):\n    def compare(x, y):\n        return int(y + x) - int(x + y)\n    \n    nums = map(str, nums)\n    nums.sort(key=cmp_to_key(compare))\n    return str(int(''.join(nums)))", "passed": false, "score": {"loc": 7, "tokens": 65, "cc": 0, "nest": 2, "execution_time": 10.0, "novelty": 0.4571176466960898}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 13470, "entry_point": "monotoneIncreasingDigits", "best_list": [{"code": "def monotoneIncreasingDigits(N):\n    digits = list(map(int, str(N)))\n    n = len(digits)\n    \n    for i in range(n - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            digits[i - 1] -= 1\n            for j in range(i, n):\n                digits[j] = 9\n    \n    return int(''.join(map(str, digits)))", "passed": true, "score": {"loc": 9, "tokens": 95, "cc": 3, "nest": 4, "execution_time": 0.016615, "novelty": 0.6349787356793662}}, {"code": "def monotoneIncreasingDigits(N):\n    digits = list(map(int, str(N)))\n    n = len(digits)\n    for i in range(n-2, -1, -1):\n        if digits[i] > digits[i+1]:\n            digits[i] -= 1\n            for j in range(i+1, n):\n                digits[j] = 9\n    return int(''.join(map(str, digits)))", "passed": true, "score": {"loc": 9, "tokens": 96, "cc": 3, "nest": 4, "execution_time": 0.016742, "novelty": 0.6083795408814037}}, {"code": "def monotoneIncreasingDigits(N):\n    digits = list(str(N))\n    n = len(digits)\n    for i in range(n - 2, -1, -1):\n        if digits[i] > digits[i + 1]:\n            digits[i] = str(int(digits[i]) - 1)\n            for j in range(i + 1, n):\n                digits[j] = '9'\n    return int(''.join(digits))\n\ndef _equivalent(lhs, rhs):\n    return monotoneIncreasingDigits(lhs) == rhs", "passed": true, "score": {"loc": 11, "tokens": 114, "cc": 3, "nest": 4, "execution_time": 0.016711, "novelty": 0.6272143015078677}}, {"code": "def monotoneIncreasingDigits(N):\n    digits = list(str(N))\n    i = 1\n    while i < len(digits) and digits[i] >= digits[i - 1]:\n        i += 1\n    while i > 0 and digits[i] < digits[i - 1]:\n        digits[i - 1] = str(int(digits[i - 1]) - 1)\n        i -= 1\n    for j in range(i, len(digits)):\n        digits[j] = '9'\n    return int(''.join(digits))", "passed": false, "score": {"loc": 11, "tokens": 117, "cc": 5, "nest": 2, "execution_time": 10.0, "novelty": 0.6566882817712618}}, {"code": "def monotoneIncreasingDigits(N):\n    N = str(N)\n    stack = []\n    for i, digit in enumerate(N):\n        while stack and digit < stack[-1]:\n            stack.pop()\n        stack.append(digit)\n    result = ''.join(stack)\n    return int(result if len(result) == len(N) else result[:-1] + str(int(result[-1]) - 1))", "passed": false, "score": {"loc": 9, "tokens": 94, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7258698799710097}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 13481, "entry_point": "smallestDivisor", "best_list": [{"code": "def smallestDivisor(nums, threshold):\n    left, right = 1, max(nums)\n    while left < right:\n        mid = (left + right) // 2\n        if sum((n + mid - 1) // mid for n in nums) <= threshold:\n            right = mid\n        else:\n            left = mid + 1\n    return left", "passed": true, "score": {"loc": 9, "tokens": 67, "cc": 2, "nest": 3, "execution_time": 0.016666, "novelty": 0.5891961967092101}}, {"code": "def smallestDivisor(nums, threshold):\n    def sum_of_divided(divisor):\n        return sum((num + divisor - 1) // divisor for num in nums)\n\n    low, high = 1, max(nums)\n    while low < high:\n        mid = (low + high) // 2\n        if sum_of_divided(mid) > threshold:\n            low = mid + 1\n        else:\n            high = mid\n    return low", "passed": true, "score": {"loc": 11, "tokens": 77, "cc": 2, "nest": 3, "execution_time": 0.016529, "novelty": 0.4331058843378247}}, {"code": "def smallestDivisor(nums, threshold):\n    def sum_of_divided(divisor):\n        return sum((num + divisor - 1) // divisor for num in nums)\n\n    left, right = 1, max(nums)\n    while left < right:\n        mid = (left + right) // 2\n        if sum_of_divided(mid) > threshold:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": true, "score": {"loc": 11, "tokens": 77, "cc": 2, "nest": 3, "execution_time": 0.016724, "novelty": 0.3695552175316754}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 13495, "entry_point": "toHex", "best_list": [{"code": "def toHex(num):\n    if num == 0:\n        return \"0\"\n    hex_chars = \"0123456789abcdef\"\n    hex_str = \"\"\n    for _ in range(8):\n        hex_str = hex_chars[num & 15] + hex_str\n        num >>= 4\n    return hex_str.lstrip('0')", "passed": true, "score": {"loc": 9, "tokens": 57, "cc": 2, "nest": 2, "execution_time": 0.016598, "novelty": 0.4201652015491828}}, {"code": "def toHex(num):\n    if num == 0:\n        return \"0\"\n    hex_chars = \"0123456789abcdef\"\n    hex_string = \"\"\n    for _ in range(8):\n        hex_string = hex_chars[num & 15] + hex_string\n        num >>= 4\n    return hex_string.lstrip('0')", "passed": true, "score": {"loc": 9, "tokens": 57, "cc": 2, "nest": 2, "execution_time": 0.016679, "novelty": 0.41593817027212165}}, {"code": "def toHex(num):\n    if num == 0:\n        return '0'\n    hex_digits = \"0123456789abcdef\"\n    if num < 0:\n        num += 0x100000000\n    hex_str = ''\n    while num > 0:\n        hex_str = hex_digits[num % 16] + hex_str\n        num //= 16\n    return hex_str", "passed": true, "score": {"loc": 11, "tokens": 56, "cc": 3, "nest": 2, "execution_time": 0.016448, "novelty": 0.35544959678751653}}, {"code": "def toHex(number):\n    if number == 0:\n        return \"0\"\n    hex_digits = \"0123456789abcdef\"\n    if number < 0:\n        number += 1 << 32\n    return \"\".join(hex_digits[(number // (16 ** i)) % 16] for i in range(7, -1, -1))", "passed": false, "score": {"loc": 7, "tokens": 69, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.6004366155843408}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 1384, "entry_point": "replaceWords", "best_list": [{"code": "def replaceWords(dict, sentence):\n    words = sentence.split()\n    dict.sort(key=len)\n    for i, word in enumerate(words):\n        for root in dict:\n            if word.startswith(root):\n                words[i] = root\n                break\n    return ' '.join(words)", "passed": true, "score": {"loc": 9, "tokens": 61, "cc": 3, "nest": 4, "execution_time": 0.016689, "novelty": 0.3645086653382611}}, {"code": "def replaceWords(dict, sentence):\n    root_dict = set(dict)\n    words = sentence.split()\n    for i in range(len(words)):\n        for root in root_dict:\n            if words[i].startswith(root):\n                words[i] = root\n                break\n    return ' '.join(words)", "passed": true, "score": {"loc": 9, "tokens": 63, "cc": 3, "nest": 4, "execution_time": 0.016693, "novelty": 0.5893107680526464}}, {"code": "def replaceWords(dict, sentence):\n    root_set = set(dict)\n    words = sentence.split()\n    \n    def replace(word):\n        for i in range(1, len(word) + 1):\n            if word[:i] in root_set:\n                return word[:i]\n        return word\n    \n    return ' '.join(map(replace, words))", "passed": true, "score": {"loc": 9, "tokens": 72, "cc": 2, "nest": 4, "execution_time": 0.016705, "novelty": 0.6481152710419145}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 1388, "entry_point": "catMouseGame", "best_list": [{"code": "def catMouseGame(graph):\n    def dfs(mouse, cat, turn):\n        if (mouse, cat, turn) in memo:\n            return memo[(mouse, cat, turn)]\n        if mouse == 0:\n            result = 1\n        elif mouse == cat:\n            result = 2\n        elif turn == len(graph) * 2:\n            result = 0\n        else:\n            if turn % 2 == 0:\n                moves = graph[mouse]\n                result = 2\n                for next_mouse in moves:\n                    if dfs(next_mouse, cat, turn + 1) == 1:\n                        result = 1\n                        break\n                    if dfs(next_mouse, cat, turn + 1) == 0:\n                        result = 0\n            else:\n                moves = graph[cat] if cat != 0 else []\n                result = 1\n                for next_cat in moves:\n                    if dfs(mouse, next_cat, turn + 1) == 2:\n                        result = 2\n                    if dfs(mouse, next_cat, turn + 1) == 0:\n                        result = 0\n        memo[(mouse, cat, turn)] = result\n        return result\n\n    memo = {}\n    return dfs(1, 2, 0)", "passed": true, "score": {"loc": 32, "tokens": 218, "cc": 11, "nest": 8, "execution_time": 0.017007, "novelty": 0.7383724449337684}}, {"code": "def catMouseGame(graph):\n    n = len(graph)\n    DRAW = 0\n    MOUSE_WIN = 1\n    CAT_WIN = 2\n    state = [[[0] * n for _ in range(n)] for _ in range(n * 2)]\n    \n    def dfs(m, c, t):\n        if state[t][m][c]:\n            return state[t][m][c]\n        if t >= 2 * n * n:\n            state[t][m][c] = DRAW\n        elif m == 0:\n            state[t][m][c] = MOUSE_WIN\n        elif m == c:\n            state[t][m][c] = CAT_WIN\n        else:\n            if t % 2 == 0:\n                if any(dfs(nxt, c, t + 1) == MOUSE_WIN for nxt in graph[m]):\n                    state[t][m][c] = MOUSE_WIN\n                else:\n                    state[t][m][c] = CAT_WIN if all(dfs(nxt, c, t + 1) == CAT_WIN for nxt in graph[m]) else DRAW\n            else:\n                if any(dfs(m, nxt, t + 1) == CAT_WIN for nxt in graph[c] if nxt != 0):\n                    state[t][m][c] = CAT_WIN\n                else:\n                    state[t][m][c] = MOUSE_WIN if all(dfs(m, nxt, t + 1) == MOUSE_WIN for nxt in graph[c] if nxt != 0) else DRAW\n        return state[t][m][c]\n    \n    return dfs(1, 2, 0)", "passed": false, "score": {"loc": 28, "tokens": 335, "cc": 7, "nest": 7, "execution_time": 10.0, "novelty": 0.6665467548545103}}, {"code": "def catMouseGame(graph):\n    n = len(graph)\n    dp = [[[0] * 2 for _ in range(n)] for _ in range(n)]\n    \n    def move(m, c, t):\n        if dp[m][c][t] > 0:\n            return dp[m][c][t]\n        if m == 0:\n            dp[m][c][t] = 1\n        elif m == c:\n            dp[m][c][t] = 2\n        elif t == 2 * n - 1:\n            dp[m][c][t] = 0\n        else:\n            moves = graph[m] if t % 2 == 0 else [x for x in graph[c] if x != 0]\n            if all(move(m, c, t + 1) == 1 for move in moves):\n                dp[m][c][t] = 1\n            elif all(move(m, c, t + 1) == 2 for move in moves):\n                dp[m][c][t] = 2\n            else:\n                dp[m][c][t] = 0\n        return dp[m][c][t]\n    \n    return move(1, 2, 0)", "passed": false, "score": {"loc": 22, "tokens": 263, "cc": 6, "nest": 7, "execution_time": 10.0, "novelty": 0.5744795445318425}}, {"code": "def catMouseGame(graph):\n    n = len(graph)\n    memo = [[[0] * n for _ in range(n)] for _ in range(2 * n)]\n\n    def dfs(m, c, t):\n        if memo[m][c][t] > 0:\n            return memo[m][c][t]\n        if t >= 2 * n:\n            return 0\n        if m == 0:\n            memo[m][c][t] = 1\n        elif c == m:\n            memo[m][c][t] = 2\n        else:\n            mouse_turn = t % 2 == 0\n            if mouse_turn:\n                result = 2\n                for nei in graph[m]:\n                    if nei == 0:\n                        continue\n                    res = dfs(nei, c, t + 1)\n                    if res == 1:\n                        memo[m][c][t] = 1\n                        break\n                    elif res == 0:\n                        result = 0\n                if memo[m][c][t] == 0:\n                    memo[m][c][t] = result\n            else:\n                result = 1\n                for nei in graph[c]:\n                    if nei == m:\n                        continue\n                    res = dfs(m, nei, t + 1)\n                    if res == 2:\n                        memo[m][c][t] = 2\n                        break\n                    elif res == 0:\n                        result = 0\n                if memo[m][c][t] == 0:\n                    memo[m][c][t] = result\n        return memo[m][c][t]\n\n    return dfs(1, 2, 0)", "passed": false, "score": {"loc": 42, "tokens": 325, "cc": 15, "nest": 8, "execution_time": 10.0, "novelty": 0.6183976772118115}}, {"code": "def catMouseGame(graph):\n    n = len(graph)\n    dp = [[[0] * n for _ in range(n)] for _ in range(n * n * 2)]\n    \n    def dfs(m, c, t):\n        if dp[m][c][t] != 0:\n            return dp[m][c][t]\n        if m == 0:\n            dp[m][c][t] = 1\n        elif m == c:\n            dp[m][c][t] = 2\n        else:\n            if t % 2 == 0:\n                next_moves = graph[m]\n            else:\n                next_moves = graph[c]\n                next_moves.remove(0)\n            \n            if all(dfs(next_m, c, t + 1) == 1 for next_m in next_moves):\n                dp[m][c][t] = 1\n            elif all(dfs(m, next_c, t + 1) == 2 for next_c in next_moves):\n                dp[m][c][t] = 2\n            else:\n                dp[m][c][t] = 0\n        \n        return dp[m][c][t]\n    \n    return dfs(1, 2, 0)", "passed": false, "score": {"loc": 24, "tokens": 245, "cc": 6, "nest": 6, "execution_time": 10.0, "novelty": 0.5771402766472149}}, {"code": "def catMouseGame(graph):\n    n = len(graph)\n    DRAW, MOUSE, CAT = 0, 1, 2\n    dp = [[[-1] * 2 for _ in range(n)] for _ in range(n)]\n\n    def search(m, c, t):\n        if dp[m][c][t] != -1:\n            return dp[m][c][t]\n        if t == 2 * n:\n            dp[m][c][t] = DRAW\n        elif m == 0:\n            dp[m][c][t] = MOUSE\n        elif m == c:\n            dp[m][c][t] = CAT\n        else:\n            paths = []\n            if t % 2 == 0:  # Mouse's turn\n                paths = graph[m]\n            else:  # Cat's turn\n                paths = graph[c] if c != 0 else []\n            result = DRAW\n            for next_pos in paths:\n                next_t = t + 1\n                next_result = search(next_pos, c, next_t)\n                if next_result == MOUSE:\n                    result = MOUSE\n                    break\n                if next_result == CAT:\n                    paths.remove(next_pos)\n                    continue\n                if len(paths) == 1:\n                    result = CAT\n                    break\n            dp[m][c][t] = result\n        return dp[m][c][t]\n\n    return search(1, 2, 0)", "passed": false, "score": {"loc": 35, "tokens": 279, "cc": 9, "nest": 7, "execution_time": 10.0, "novelty": 0.6688492371641019}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 13515, "entry_point": "numRookCaptures", "best_list": [{"code": "def numRookCaptures(board):\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'R':\n                return sum(board[i][j+k] in 'Rp' for k in range(1, 8)) + sum(board[i+k][j] in 'Rp' for k in range(1, 8))\n    return 0", "passed": true, "score": {"loc": 6, "tokens": 90, "cc": 3, "nest": 4, "execution_time": 0.016864, "novelty": 0.751183405943431}}, {"code": "def numRookCaptures(board):\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'R':\n                return sum(board[i][j+x] == 'p' or board[i+x][j] == 'p' for x in range(1, 8) if board[i][j+x] != '.' or board[i+x][j] != '.')\n    return 0", "passed": true, "score": {"loc": 6, "tokens": 110, "cc": 5, "nest": 4, "execution_time": 0.016717, "novelty": 0.6922714259590887}}, {"code": "def numRookCaptures(board):\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'R':\n                return sum(1 for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)) \n                           for x, y in zip(range(i, 8, dx), range(j, 8, dy)) \n                           if board[x][y] in 'Rp')\n    return 0", "passed": true, "score": {"loc": 8, "tokens": 112, "cc": 3, "nest": 4, "execution_time": 0.0169, "novelty": 0.6727885901711999}}, {"code": "def numRookCaptures(board):\n    rows, cols = len(board), len(board[0])\n    r, c = next((i, j) for i in range(rows) for j in range(cols) if board[i][j] == 'R')\n    \n    def scan(dx, dy):\n        x, y = r + dx, c + dy\n        while 0 <= x < rows and 0 <= y < cols:\n            if board[x][y] in 'Rp':\n                return 1\n            if board[x][y] != '.':\n                break\n            x, y = x + dx, y + dy\n        return 0\n    \n    return sum(scan(dx, dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)])", "passed": false, "score": {"loc": 13, "tokens": 180, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.748016504698421}}, {"code": "def numRookCaptures(board):\n    for r, row in enumerate(board):\n        for c, cell in enumerate(row):\n            if cell == 'R':\n                directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n                captures = 0\n                for dr, dc in directions:\n                    i, j = r + dr, c + dc\n                    while 0 <= i < 8 and 0 <= j < 8:\n                        if board[i][j] in 'Rp':\n                            captures += board[i][j] == 'p'\n                            break\n                        i += dr\n                        j += dc\n                return captures", "passed": false, "score": {"loc": 15, "tokens": 138, "cc": 7, "nest": 7, "execution_time": 10.0, "novelty": 0.6868502965363621}}, {"code": "def numRookCaptures(board):\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'R':\n                return sum(1 for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0))\n                           if 0 <= i + di < 8 and 0 <= j + dj < 8 and (board[i + di][j + dj] == 'p' or board[i + di][j + dj] == 'B'))", "passed": false, "score": {"loc": 6, "tokens": 127, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.6487651247425337}}, {"code": "def numRookCaptures(board):\n    def find_rook():\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'R':\n                    return i, j\n    \n    def count_captures(i, j):\n        captures = 0\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            while 0 <= ni < 8 and 0 <= nj < 8:\n                if board[ni][nj] in ['B', 'p']:\n                    captures += board[ni][nj] == 'p'\n                    break\n                ni, nj = ni + di, nj + dj\n        return captures\n    \n    ri, rj = find_rook()\n    return count_captures(ri, rj)", "passed": false, "score": {"loc": 19, "tokens": 180, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.6849771701029455}}, {"code": "def numRookCaptures(board):\n    rows = len(board)\n    cols = len(board[0])\n    rook_pos = None\n    \n    # Find the position of the rook\n    for i in range(rows):\n        for j in range(cols):\n            if board[i][j] == 'R':\n                rook_pos = (i, j)\n                break\n        if rook_pos:\n            break\n    \n    # Directions: north, east, south, west\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    count = 0\n    \n    # Check each direction\n    for dr, dc in directions:\n        r, c = rook_pos\n        while 0 <= r + dr < rows and 0 <= c + dc < cols:\n            if board[r + dr][c + dc] == 'p':\n                count += 1\n                break\n            if board[r + dr][c + dc] == 'B':\n                break\n            r += dr\n            c += dc\n    \n    return count", "passed": false, "score": {"loc": 27, "tokens": 202, "cc": 9, "nest": 4, "execution_time": 10.0, "novelty": 0.825226813862052}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 13519, "entry_point": "checkPerfectNumber", "best_list": [{"code": "def checkPerfectNumber(n):\n    return n in {6, 28, 496, 8128, 33550336}", "passed": true, "score": {"loc": 2, "tokens": 20, "cc": 0, "nest": 1, "execution_time": 0.016556, "novelty": 0.7541989318133085}}, {"code": "def checkPerfectNumber(n):\n    if n < 6:\n        return False\n    sum_divisors = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors == n", "passed": true, "score": {"loc": 10, "tokens": 69, "cc": 4, "nest": 4, "execution_time": 0.016736, "novelty": 0.18771602281280053}}, {"code": "def checkPerfectNumber(n):\n    if n < 2:\n        return False\n    sum = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            sum += i\n            if i != n // i:\n                sum += n // i\n    return sum == n", "passed": true, "score": {"loc": 10, "tokens": 69, "cc": 4, "nest": 4, "execution_time": 0.016943, "novelty": 0.17563837035854724}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 13585, "entry_point": "profitableSchemes", "best_list": [{"code": "def profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    dp = [[0] * (G + 1) for _ in range(P + 1)]\n    dp[0][0] = 1\n    \n    for g, p in zip(group, profit):\n        for i in range(P, -1, -1):\n            for j in range(G, g - 1, -1):\n                dp[min(i + p, P)][j] = (dp[min(i + p, P)][j] + dp[i][j - g]) % MOD\n    \n    return sum(dp[P]) % MOD", "passed": true, "score": {"loc": 9, "tokens": 145, "cc": 3, "nest": 4, "execution_time": 0.016785, "novelty": 0.537369684314575}}, {"code": "def profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    dp = [[0] * (G + 1) for _ in range(P + 1)]\n    dp[0][0] = 1\n    \n    for g, p in zip(group, profit):\n        for i in range(P, -1, -1):\n            for j in range(G - g, -1, -1):\n                dp[min(i + p, P)][j + g] += dp[i][j]\n                dp[min(i + p, P)][j + g] %= MOD\n    \n    return sum(dp[P]) % MOD", "passed": true, "score": {"loc": 10, "tokens": 147, "cc": 3, "nest": 4, "execution_time": 0.016729, "novelty": 0.561769661500584}}, {"code": "def profitableSchemes(G, P, group, profit):\n    mod = 10**9 + 7\n    n = len(group)\n    dp = [[0] * (G + 1) for _ in range(P + 1)]\n    dp[0][0] = 1\n\n    for p, g in zip(profit, group):\n        for i in range(P, p - 1, -1):\n            for j in range(G, g - 1, -1):\n                dp[i][j] = (dp[i][j] + dp[i - p][j - g]) % mod\n\n    return sum(dp[p][g] for p in range(P + 1)) % mod", "passed": true, "score": {"loc": 10, "tokens": 152, "cc": 3, "nest": 4, "execution_time": 0.01665, "novelty": 0.587872971012507}}, {"code": "def profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    dp = [[0] * (P + 1) for _ in range(G + 1)]\n    dp[0][0] = 1\n\n    for g in range(G + 1):\n        for p in range(P + 1):\n            dp[g][p] = dp[g][p] + dp[g][p] % MOD\n            if g >= group[i] and p >= profit[i]:\n                dp[g][p] = (dp[g][p] + dp[g - group[i]][p - profit[i]]) % MOD\n\n    return sum(dp[G][p] for p in range(P + 1)) % MOD", "passed": false, "score": {"loc": 10, "tokens": 172, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.653184915893081}}, {"code": "def profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    n = len(group)\n    dp = [[0] * (G + 1) for _ in range(P + 1)]\n    dp[0][0] = 1\n\n    for g in range(G + 1):\n        for p in range(P, -1, -1):\n            for i in range(n):\n                if g >= group[i]:\n                    dp[min(p + profit[i], P)][g] = (dp[min(p + profit[i], P)][g] + dp[p][g - group[i]]) % MOD\n\n    return sum(dp[p][G] for p in range(P + 1)) % MOD", "passed": false, "score": {"loc": 11, "tokens": 172, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.6184214326842491}}, {"code": "def profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    n = len(group)\n    dp = [[0] * (P + 1) for _ in range(G + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for g in range(G, group[i] - 1, -1):\n            for p in range(P, -1, -1):\n                dp[g][p] = (dp[g][p] + dp[g - group[i]][max(0, p - profit[i])]) % MOD\n\n    return sum(dp[g][p] for g in range(G + 1) for p in range(P + 1)) % MOD", "passed": false, "score": {"loc": 10, "tokens": 170, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5621237067053355}}, {"code": "from functools import lru_cache\n\ndef profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    \n    @lru_cache(None)\n    def dp(i, group_left, profit_left):\n        if i == len(group):\n            return 1 if profit_left >= 0 else 0\n        if group_left < group[i]:\n            return dp(i + 1, group_left, profit_left)\n        return (dp(i + 1, group_left, profit_left) + dp(i + 1, group_left - group[i], profit_left - profit[i])) % MOD\n    \n    return dp(0, G, P)", "passed": false, "score": {"loc": 11, "tokens": 121, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7503392639262083}}, {"code": "def profitableSchemes(G, P, group, profit):\n    MOD = 10**9 + 7\n    n = len(group)\n    dp = [[0] * (P + 1) for _ in range(G + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        g, p = group[i], profit[i]\n        for j in range(G, g - 1, -1):\n            for k in range(P, -1, -1):\n                dp[j][k] = (dp[j][k] + dp[j-g][k-p]) % MOD\n\n    return sum(dp[g][p] for g in range(G + 1) for p in range(P, -1, -1)) % MOD", "passed": false, "score": {"loc": 11, "tokens": 173, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5832265405898431}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 13601, "entry_point": "wiggleMaxLength", "best_list": [{"code": "def wiggleMaxLength(nums):\n    if not nums:\n        return 0\n    up = down = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)", "passed": true, "score": {"loc": 10, "tokens": 73, "cc": 4, "nest": 4, "execution_time": 0.01673, "novelty": 0.0854931070201731}}, {"code": "def wiggleMaxLength(nums):\n    if not nums:\n        return 0\n    \n    up, down = 1, 1\n    \n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    \n    return max(up, down)", "passed": true, "score": {"loc": 10, "tokens": 75, "cc": 4, "nest": 4, "execution_time": 0.016641, "novelty": 0.0987668921737419}}, {"code": "def wiggleMaxLength(nums):\n    if not nums:\n        return 0\n    if len(nums) < 2:\n        return len(nums)\n    \n    up = down = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)", "passed": true, "score": {"loc": 12, "tokens": 86, "cc": 5, "nest": 4, "execution_time": 0.016658, "novelty": 0.8235329257858659}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 13610, "entry_point": "integerReplacement", "best_list": [{"code": "def integerReplacement(n):\n    if n == 1:\n        return 0\n    if n % 2 == 0:\n        return 1 + integerReplacement(n // 2)\n    else:\n        return 1 + min(integerReplacement(n + 1), integerReplacement(n - 1))", "passed": true, "score": {"loc": 7, "tokens": 53, "cc": 2, "nest": 2, "execution_time": 0.016593, "novelty": 0.6201468108165935}}, {"code": "def integerReplacement(n):\n    steps = 0\n    while n > 1:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n += 1 if n == 3 else -1\n        steps += 1\n    return steps", "passed": true, "score": {"loc": 9, "tokens": 47, "cc": 2, "nest": 3, "execution_time": 0.016759, "novelty": 0.31165432365916457}}, {"code": "def integerReplacement(n):\n    count = 0\n    while n > 1:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = n + 1 if n == 3 else n - 1\n        count += 1\n    return count", "passed": true, "score": {"loc": 9, "tokens": 49, "cc": 2, "nest": 3, "execution_time": 0.016723, "novelty": 0.38648980512198483}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 13691, "entry_point": "isBoomerang", "best_list": [{"code": "def isBoomerang(points):\n    return (points[1][0] - points[0][0]) * (points[2][1] - points[0][1]) != (points[2][0] - points[0][0]) * (points[1][1] - points[0][1])", "passed": true, "score": {"loc": 2, "tokens": 79, "cc": 0, "nest": 1, "execution_time": 0.016538, "novelty": 0.6633159502364385}}, {"code": "def isBoomerang(points):\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n    return (y2 - y1) * (x3 - x1) != (y3 - y1) * (x2 - x1)", "passed": true, "score": {"loc": 5, "tokens": 55, "cc": 0, "nest": 1, "execution_time": 0.016537, "novelty": 0.4499767404777141}}, {"code": "def isBoomerang(points):\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n    return (y2 - y1) * (x3 - x2) != (y3 - y2) * (x2 - x1)", "passed": true, "score": {"loc": 5, "tokens": 55, "cc": 0, "nest": 1, "execution_time": 0.016566, "novelty": 0.45279999004823224}}, {"code": "def isBoomerang(points):\n    return len(set(map(tuple, points))) == 3 and (points[2][1] - points[1][1]) * (points[1][0] - points[0][0]) != (points[1][1] - points[0][1]) * (points[2][0] - points[1][0])", "passed": false, "score": {"loc": 2, "tokens": 95, "cc": 1, "nest": 1, "execution_time": 10.0, "novelty": 0.7568816268053875}}, {"code": "def isBoomerang(points):\n    (x1, y1), (x2, y2), (x3, y3) = points\n    return (x2 - x1) * (y3 - y1) != (x3 - x1) * (y2 - y1)", "passed": false, "score": {"loc": 3, "tokens": 50, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5434701768459353}}, {"code": "def isBoomerang(points):\n    return len(set(map(tuple, points))) == 3", "passed": false, "score": {"loc": 2, "tokens": 22, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6753925863695001}}, {"code": "def isBoomerang(points):\n    return len(set(map(tuple, points))) == 3 and (points[0][0] * (points[1][1] - points[2][1]) + points[1][0] * (points[2][1] - points[0][1]) + points[2][0] * (points[0][1] - points[1][1])) != 0", "passed": false, "score": {"loc": 2, "tokens": 105, "cc": 1, "nest": 1, "execution_time": 10.0, "novelty": 0.7507559747961077}}], "num_pass": 6, "num_uniq": 4, "num_fail": 4, "fail_uniq": 4}
{"id": 13743, "entry_point": "singleNumber", "best_list": [{"code": "def singleNumber(nums):\n    ones, twos = 0, 0\n    for num in nums:\n        ones = (ones ^ num) & ~twos\n        twos = (twos ^ num) & ~ones\n    return ones", "passed": true, "score": {"loc": 6, "tokens": 40, "cc": 1, "nest": 2, "execution_time": 0.016597, "novelty": 0.5520402723050761}}, {"code": "def singleNumber(nums):\n    nums.sort()\n    for i in range(0, len(nums) - 2, 3):\n        if nums[i] != nums[i + 1]:\n            return nums[i]\n    return nums[-1]", "passed": true, "score": {"loc": 6, "tokens": 53, "cc": 2, "nest": 3, "execution_time": 0.016502, "novelty": 0.6682229097897265}}, {"code": "def singleNumber(nums):\n    return sorted(nums)[len(nums)//3]", "passed": false, "score": {"loc": 2, "tokens": 20, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.3168042091670954}}, {"code": "def singleNumber(nums):\n    return sorted(nums)[len(nums) // 3 * 2]", "passed": false, "score": {"loc": 2, "tokens": 22, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5210868191030351}}], "num_pass": 4, "num_uniq": 2, "num_fail": 6, "fail_uniq": 2}
{"id": 13768, "entry_point": "equalSubstring", "best_list": [{"code": "def equalSubstring(s, t, maxCost):\n    diff = [abs(ord(a) - ord(b)) for a, b in zip(s, t)]\n    left = res = 0\n    for right, d in enumerate(diff):\n        maxCost -= d\n        if maxCost < 0:\n            maxCost += diff[left]\n            left += 1\n        res = max(res, right - left + 1)\n    return res", "passed": true, "score": {"loc": 10, "tokens": 86, "cc": 2, "nest": 3, "execution_time": 0.016608, "novelty": 0.6054182870971205}}, {"code": "def equalSubstring(s, t, maxCost):\n    cost = 0\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        cost += abs(ord(s[right]) - ord(t[right]))\n        while cost > maxCost:\n            cost -= abs(ord(s[left]) - ord(t[left]))\n            left += 1\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length", "passed": true, "score": {"loc": 11, "tokens": 95, "cc": 2, "nest": 3, "execution_time": 0.016578, "novelty": 0.2341730737328208}}, {"code": "def equalSubstring(s, t, maxCost):\n    left = 0\n    max_length = 0\n    cost = 0\n\n    for right in range(len(s)):\n        cost += abs(ord(s[right]) - ord(t[right]))\n        while cost > maxCost:\n            cost -= abs(ord(s[left]) - ord(t[left]))\n            left += 1\n        max_length = max(max_length, right - left + 1)\n\n    return max_length", "passed": true, "score": {"loc": 11, "tokens": 95, "cc": 2, "nest": 3, "execution_time": 0.01665, "novelty": 0.24188873993315352}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 13866, "entry_point": "findLengthOfShortestSubarray", "best_list": [{"code": "def findLengthOfShortestSubarray(arr):\n    n = len(arr)\n    i, j = 0, n - 1\n    \n    while i < j and arr[i] <= arr[i + 1]:\n        i += 1\n    if i == j:\n        return 0\n    \n    while j > i and arr[j] >= arr[j - 1]:\n        j -= 1\n    \n    ans = min(j, n - i - 1)\n    l, r = 0, j\n    while l <= i and r < n:\n        if arr[l] <= arr[r]:\n            ans = min(ans, r - l - 1)\n            l += 1\n        else:\n            r += 1\n    \n    return ans", "passed": true, "score": {"loc": 18, "tokens": 138, "cc": 8, "nest": 3, "execution_time": 0.016672, "novelty": 0.2722897788616945}}, {"code": "def findLengthOfShortestSubarray(arr):\n    n = len(arr)\n    i, j = 0, n - 1\n    while i + 1 < n and arr[i] <= arr[i + 1]:\n        i += 1\n    if i == n - 1:\n        return 0\n    while j > 0 and arr[j - 1] <= arr[j]:\n        j -= 1\n    ans = min(n - i - 1, j)\n    l, r = 0, j\n    while l <= i and r < n:\n        if arr[l] <= arr[r]:\n            ans = min(ans, r - l - 1)\n            l += 1\n        else:\n            r += 1\n    return ans", "passed": true, "score": {"loc": 18, "tokens": 142, "cc": 8, "nest": 3, "execution_time": 0.016763, "novelty": 0.15456945930261246}}, {"code": "def findLengthOfShortestSubarray(arr):\n    n = len(arr)\n    i = 0\n    while i + 1 < n and arr[i] <= arr[i + 1]:\n        i += 1\n    if i == n - 1:\n        return 0\n    \n    j = n - 1\n    while j > 0 and arr[j - 1] <= arr[j]:\n        j -= 1\n    \n    ans = min(n - i - 1, j)\n    k = 0\n    while k <= i and j < n:\n        if arr[k] <= arr[j]:\n            ans = min(ans, j - k - 1)\n            k += 1\n        else:\n            j += 1\n    \n    return ans", "passed": true, "score": {"loc": 19, "tokens": 137, "cc": 8, "nest": 3, "execution_time": 0.016536, "novelty": 0.15571336702574323}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 13874, "entry_point": "subtractProductAndSum", "best_list": [{"code": "def subtractProductAndSum(n: int) -> int:\n    product = 1\n    summation = 0\n    for digit in str(n):\n        product *= int(digit)\n        summation += int(digit)\n    return product - summation", "passed": true, "score": {"loc": 7, "tokens": 43, "cc": 1, "nest": 2, "execution_time": 0.016645, "novelty": 0.37545124593252044}}, {"code": "def subtractProductAndSum(n):\n    product = 1\n    summation = 0\n    for digit in str(n):\n        digit = int(digit)\n        product *= digit\n        summation += digit\n    return product - summation", "passed": true, "score": {"loc": 8, "tokens": 38, "cc": 1, "nest": 2, "execution_time": 0.016624, "novelty": 0.3050955221014654}}, {"code": "def subtractProductAndSum(n):\n    digits = [int(d) for d in str(n)]\n    product = 1\n    summation = 0\n    for digit in digits:\n        product *= digit\n        summation += digit\n    return product - summation", "passed": true, "score": {"loc": 8, "tokens": 44, "cc": 1, "nest": 2, "execution_time": 0.016675, "novelty": 0.34692428742496473}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 13882, "entry_point": "maxWidthRamp", "best_list": [{"code": "def maxWidthRamp(A):\n    min_index = 0\n    max_width = 0\n    \n    for j in range(len(A)):\n        if A[j] < A[min_index]:\n            min_index = j\n        else:\n            max_width = max(max_width, j - min_index)\n    \n    return max_width", "passed": true, "score": {"loc": 9, "tokens": 51, "cc": 2, "nest": 3, "execution_time": 0.016504, "novelty": 0.5104276908912762}}, {"code": "def maxWidthRamp(A):\n    min_indices = []\n    max_width = 0\n    \n    for i, a in enumerate(A):\n        if not min_indices or A[min_indices[-1]] > a:\n            min_indices.append(i)\n    \n    for i in range(len(A) - 1, -1, -1):\n        while min_indices and A[min_indices[-1]] <= A[i]:\n            max_width = max(max_width, i - min_indices.pop())\n    \n    return max_width", "passed": true, "score": {"loc": 10, "tokens": 97, "cc": 6, "nest": 3, "execution_time": 0.016621, "novelty": 0.5807458815884993}}, {"code": "def maxWidthRamp(A):\n    min_stack = []\n    max_width = 0\n    \n    for j in range(len(A)):\n        if not min_stack or A[j] < A[min_stack[-1]]:\n            min_stack.append(j)\n    \n    for i in range(len(A) - 1, -1, -1):\n        while min_stack and A[i] >= A[min_stack[-1]]:\n            max_width = max(max_width, i - min_stack.pop())\n    \n    return max_width", "passed": true, "score": {"loc": 10, "tokens": 101, "cc": 6, "nest": 3, "execution_time": 0.016677, "novelty": 0.7140649801650666}}, {"code": "def maxWidthRamp(A):\n    min_vals = [A[0]]\n    for i in range(1, len(A)):\n        min_vals.append(min(min_vals[-1], A[i]))\n    \n    max_width = 0\n    j = len(A) - 1\n    for i in range(len(A) - 1, -1, -1):\n        while j > i and A[j] >= min_vals[i]:\n            max_width = max(max_width, j - i)\n            j -= 1\n    \n    return max_width", "passed": false, "score": {"loc": 11, "tokens": 107, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7648286934825529}}, {"code": "def maxWidthRamp(A):\n    min_index = float('inf')\n    max_width = 0\n    \n    for i in range(len(A)):\n        if A[i] < A[min_index]:\n            min_index = i\n        else:\n            max_width = max(max_width, i - min_index)\n    \n    return max_width", "passed": false, "score": {"loc": 9, "tokens": 56, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6128923297650898}}, {"code": "def maxWidthRamp(A):\n    min_left = []\n    curr_min = float('inf')\n    for i, a in enumerate(A):\n        if a < curr_min:\n            curr_min = a\n        min_left.append(curr_min)\n\n    max_ramp = 0\n    max_right = A[-1]\n    for i in range(len(A) - 1, -1, -1):\n        if A[i] > max_right:\n            max_right = A[i]\n        if min_left[i] <= max_right:\n            max_ramp = max(max_ramp, i - min_left[i])\n    return max_ramp", "passed": false, "score": {"loc": 15, "tokens": 109, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.7086872096390141}}, {"code": "def maxWidthRamp(A):\n    min_index = float('inf')\n    max_width = 0\n    \n    for j in range(len(A)):\n        min_index = min(min_index, A[j] - j)\n        max_width = max(max_width, A[j] - min_index)\n    \n    return max_width", "passed": false, "score": {"loc": 7, "tokens": 56, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.6413493245284763}}, {"code": "def maxWidthRamp(A):\n    min_index = float('inf')\n    max_width = 0\n    for j, a in enumerate(A):\n        if a < A[min_index]:\n            min_index = j\n        elif a >= A[min_index]:\n            max_width = max(max_width, j - min_index)\n    return max_width", "passed": false, "score": {"loc": 9, "tokens": 59, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.6125795459994814}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 13888, "entry_point": "rob", "best_list": [{"code": "def rob(nums):\n    a, b = 0, 0\n    for x in nums:\n        a, b = b, max(b, a + x)\n    return b", "passed": true, "score": {"loc": 5, "tokens": 34, "cc": 1, "nest": 2, "execution_time": 0.016444, "novelty": 0.5420887458469197}}, {"code": "def rob(nums):\n    prev1, prev2 = 0, 0\n    for num in nums:\n        prev1, prev2 = prev2, max(prev2, prev1 + num)\n    return prev2", "passed": true, "score": {"loc": 5, "tokens": 34, "cc": 1, "nest": 2, "execution_time": 0.016718, "novelty": 0.6023771990519287}}, {"code": "def rob(nums):\n    a, b = 0, 0\n    for n in nums:\n        a, b = b, max(b, a + n)\n    return b", "passed": true, "score": {"loc": 5, "tokens": 34, "cc": 1, "nest": 2, "execution_time": 0.016808, "novelty": 0.5415502632636691}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 13907, "entry_point": "licenseKeyFormatting", "best_list": [{"code": "def licenseKeyFormatting(S, K):\n    S = S.replace('-', '').upper()[::-1]\n    return '-'.join(S[i:i+K] for i in range(0, len(S), K))[::-1]", "passed": true, "score": {"loc": 3, "tokens": 67, "cc": 0, "nest": 1, "execution_time": 0.016731, "novelty": 0.40669659447587947}}, {"code": "def licenseKeyFormatting(S: str, K: int) -> str:\n    S = S.replace('-', '').upper()[::-1]\n    return '-'.join(S[i:i+K] for i in range(0, len(S), K))[::-1]", "passed": true, "score": {"loc": 3, "tokens": 74, "cc": 0, "nest": 1, "execution_time": 0.016654, "novelty": 0.4009365306774274}}, {"code": "def licenseKeyFormatting(S, K):\n    S = S.replace('-', '').upper()\n    result = []\n    i = len(S)\n    while i > 0:\n        result.append(S[max(0, i - K):i])\n        i -= K\n    return '-'.join(result[::-1])", "passed": true, "score": {"loc": 8, "tokens": 77, "cc": 1, "nest": 2, "execution_time": 0.016564, "novelty": 0.5364258096417502}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 13985, "entry_point": "isMatch", "best_list": [{"code": "def isMatch(s, p):\n    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n    dp[-1][-1] = True\n    for i in range(len(s), -1, -1):\n        for j in range(len(p) - 1, -1, -1):\n            match = i < len(s) and (s[i] == p[j] or p[j] == '?')\n            dp[i][j] = match and dp[i + 1][j + 1] or (p[j] == '*' and (dp[i + 1][j] or dp[i][j + 1]))\n    return dp[0][0]", "passed": true, "score": {"loc": 8, "tokens": 177, "cc": 8, "nest": 3, "execution_time": 0.016653, "novelty": 0.79694030261336}}, {"code": "def isMatch(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and p[j - 1] == '*'\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n            elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n    \n    return dp[m][n]", "passed": true, "score": {"loc": 13, "tokens": 219, "cc": 8, "nest": 5, "execution_time": 0.016807, "novelty": 0.7158628271331116}}, {"code": "def isMatch(s, p):\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    \n    for j in range(1, n + 1):\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 1]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] in {s[i - 1], '?'}:\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n    \n    return dp[m][n]", "passed": true, "score": {"loc": 14, "tokens": 206, "cc": 7, "nest": 5, "execution_time": 0.016716, "novelty": 0.6672940001650634}}, {"code": "def isMatch(s: str, p: str) -> bool:\n    return bool(re.fullmatch(p.replace('?', '.').replace('*', '.*'), s))", "passed": false, "score": {"loc": 2, "tokens": 50, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.49143662773694874}}, {"code": "def isMatch(s, p):\n    return bool(re.fullmatch(p.replace('?', '.').replace('*', '.*'), s))", "passed": false, "score": {"loc": 2, "tokens": 43, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5255394750377506}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 2}
{"id": 14040, "entry_point": "getHappyString", "best_list": [{"code": "def getHappyString(n, k):\n    if k > 3 * (2 ** (n - 1)):\n        return \"\"\n    return \"\".join(x for x in generate_happy_strings(n)[k - 1])\n\ndef generate_happy_strings(n):\n    if n == 1:\n        return [\"a\", \"b\", \"c\"]\n    prev = generate_happy_strings(n - 1)\n    return [c + s for s in prev for c in \"abc\" if c != s[0]]", "passed": true, "score": {"loc": 9, "tokens": 105, "cc": 2, "nest": 2, "execution_time": 0.016703, "novelty": 0.6819102934156496}}, {"code": "def getHappyString(n, k):\n    if k > 3 * (2 ** (n - 1)):\n        return \"\"\n    def generate_happy_strings(length, last_char):\n        if length == 1:\n            return ['a', 'b', 'c'] if last_char is None else [c for c in 'abc' if c != last_char]\n        return [char + s for char in 'abc' for s in generate_happy_strings(length - 1, char) if char != last_char]\n    happy_strings = generate_happy_strings(n, None)\n    return happy_strings[k - 1]", "passed": true, "score": {"loc": 9, "tokens": 117, "cc": 2, "nest": 3, "execution_time": 0.016667, "novelty": 0.6975557454606167}}, {"code": "def getHappyString(n: int, k: int) -> str:\n    def backtrack(path, last_char):\n        if len(path) == n:\n            results.append(path)\n            return\n        for char in ['a', 'b', 'c']:\n            if char != last_char:\n                backtrack(path + char, char)\n    \n    results = []\n    backtrack(\"\", \"\")\n    return results[k - 1] if k <= len(results) else \"\"", "passed": true, "score": {"loc": 11, "tokens": 100, "cc": 3, "nest": 4, "execution_time": 0.016521, "novelty": 0.6546042006064137}}, {"code": "def getHappyString(n, k):\n    total = 3 * 2 ** (n - 1)\n    if k > total:\n        return \"\"\n    \n    result = []\n    for i in range(n):\n        choices = ['a', 'b', 'c']\n        if result:\n            choices.remove(result[-1])\n        choices.remove(result[-2] if result else '')\n        result.append(choices[(k - 1) // (2 ** (n - i - 2))])\n        k %= 2 ** (n - i - 2)\n    \n    return ''.join(result)", "passed": false, "score": {"loc": 13, "tokens": 131, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7706424393166956}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 14195, "entry_point": "minAddToMakeValid", "best_list": [{"code": "def minAddToMakeValid(S):\n    balance = 0\n    additions = 0\n    for char in S:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            if balance > 0:\n                balance -= 1\n            else:\n                additions += 1\n    return additions + balance", "passed": true, "score": {"loc": 12, "tokens": 56, "cc": 4, "nest": 5, "execution_time": 0.01667, "novelty": 0.4602542889211141}}, {"code": "def minAddToMakeValid(s):\n    open_count = close_count = 0\n    for char in s:\n        if char == '(':\n            open_count += 1\n        else:\n            if open_count > 0:\n                open_count -= 1\n            else:\n                close_count += 1\n    return open_count + close_count", "passed": false, "score": {"loc": 11, "tokens": 49, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.48498752599084427}}, {"code": "def minAddToMakeValid(s: str) -> int:\n    balance = 0\n    open_count = 0\n    for char in s:\n        if char == '(':\n            open_count += 1\n        elif char == ')' and open_count > 0:\n            open_count -= 1\n        else:\n            balance += 1\n    return balance + open_count", "passed": false, "score": {"loc": 11, "tokens": 60, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.4647104130179103}}, {"code": "def minAddToMakeValid(s: str) -> int:\n    balance = 0\n    result = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            result += 1\n            balance = 0\n    return result + balance", "passed": false, "score": {"loc": 12, "tokens": 56, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.274653849293221}}, {"code": "def minAddToMakeValid(S: str) -> int:\n    balance = 0\n    result = 0\n    for char in S:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n            if balance < 0:\n                result += 1\n                balance = 0\n    return result + balance", "passed": false, "score": {"loc": 12, "tokens": 56, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.27659505898142356}}, {"code": "def minAddToMakeValid(S):\n    balance = 0\n    min_add = 0\n    for char in S:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n            if balance < 0:\n                min_add += 1\n                balance = 0\n    return min_add + balance", "passed": false, "score": {"loc": 12, "tokens": 51, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.3997168506215695}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 14198, "entry_point": "hIndex", "best_list": [{"code": "def hIndex(citations):\n    left, right = 0, len(citations)\n    while left < right:\n        mid = (left + right + 1) // 2\n        if citations[len(citations) - mid] < mid:\n            right = mid - 1\n        else:\n            left = mid\n    return left", "passed": true, "score": {"loc": 9, "tokens": 58, "cc": 2, "nest": 3, "execution_time": 0.016533, "novelty": 0.39034262104212436}}, {"code": "def hIndex(citations):\n    left, right = 0, len(citations)\n    while left < right:\n        mid = (left + right) // 2\n        if citations[mid] < len(citations) - mid:\n            left = mid + 1\n        else:\n            right = mid\n    return len(citations) - left", "passed": true, "score": {"loc": 9, "tokens": 61, "cc": 2, "nest": 3, "execution_time": 0.016663, "novelty": 0.38087900933498686}}, {"code": "def hIndex(citations):\n    left, right = 0, len(citations)\n    while left < right:\n        mid = (left + right) // 2\n        if citations[mid] >= len(citations) - mid:\n            right = mid\n        else:\n            left = mid + 1\n    return len(citations) - left", "passed": true, "score": {"loc": 9, "tokens": 62, "cc": 2, "nest": 3, "execution_time": 0.016589, "novelty": 0.3775675202226422}}, {"code": "def hIndex(citations):\n    n = len(citations)\n    left, right = 0, n\n    while left < right:\n        mid = (left + right) // 2\n        if citations[mid] >= n - mid:\n            right = mid\n        else:\n            left = mid + 1\n    return n - left\n\ndef _equivalent(_lhs, _rhs):\n    return _lhs == _rhs\n\n# Unit tests\nassert hIndex([0,1,3,5,6]) == 3\nassert hIndex([1,2,3]) == 3\nassert hIndex([0,0,0]) == 0\nassert hIndex([0]) == 0\nassert hIndex([1]) == 1\nassert hIndex([2, 2, 2]) == 2\nassert hIndex([1, 3, 3, 5, 6]) == 3\nassert hIndex([1, 2, 3, 4, 5]) == 5\nassert hIndex([1, 1, 2, 2, 3, 3, 4, 4]) == 4", "passed": false, "score": {"loc": 22, "tokens": 215, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6493632362968771}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 14259, "entry_point": "canArrange", "best_list": [{"code": "def canArrange(arr, k):\n    mod_counts = [0] * k\n    for num in arr:\n        mod_counts[(num % k + k) % k] += 1\n    \n    for i in range(1, k // 2 + 1):\n        if mod_counts[i] != mod_counts[k - i]:\n            return False\n    \n    return mod_counts[0] % 2 == 0", "passed": true, "score": {"loc": 8, "tokens": 76, "cc": 3, "nest": 3, "execution_time": 0.016518, "novelty": 0.07779621134107062}}, {"code": "def canArrange(arr, k):\n    counts = [0] * k\n    for num in arr:\n        counts[(num % k + k) % k] += 1\n    for i in range(1, k // 2 + 1):\n        if counts[i] != counts[k - i]:\n            return False\n    return counts[0] % 2 == 0", "passed": true, "score": {"loc": 8, "tokens": 76, "cc": 3, "nest": 3, "execution_time": 0.016572, "novelty": 0.07768684171923512}}, {"code": "def canArrange(arr, k):\n    remainders = [0] * k\n    for num in arr:\n        remainders[(num % k + k) % k] += 1\n    for i in range(1, k // 2 + 1):\n        if remainders[i] != remainders[k - i]:\n            return False\n    return remainders[0] % 2 == 0", "passed": true, "score": {"loc": 8, "tokens": 76, "cc": 3, "nest": 3, "execution_time": 0.016642, "novelty": 0.08643272493490173}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 14275, "entry_point": "minDifference", "best_list": [{"code": "def minDifference(nums):\n    nums.sort()\n    n = len(nums)\n    return min(nums[n-4]-nums[0], nums[n-3]-nums[1], nums[n-2]-nums[2], nums[n-1]-nums[3]) if n > 4 else 0", "passed": true, "score": {"loc": 4, "tokens": 74, "cc": 0, "nest": 1, "execution_time": 0.016755, "novelty": 0.7308292773246461}}, {"code": "def minDifference(nums):\n    if len(nums) <= 4:\n        return 0\n    nums.sort()\n    return min(nums[i + 4] - nums[i] for i in range(4))", "passed": true, "score": {"loc": 5, "tokens": 44, "cc": 1, "nest": 2, "execution_time": 0.016635, "novelty": 0.23199796284404972}}, {"code": "def minDifference(nums):\n    if len(nums) <= 4:\n        return 0\n    nums.sort()\n    return min(nums[i+4] - nums[i] for i in range(5))", "passed": true, "score": {"loc": 5, "tokens": 44, "cc": 1, "nest": 2, "execution_time": 0.016648, "novelty": 0.23209957337090026}}, {"code": "def minDifference(nums):\n    nums.sort()\n    return min(nums[-i] - nums[i-1] for i in range(1, 5))", "passed": false, "score": {"loc": 3, "tokens": 36, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7173347815795768}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 1454, "entry_point": "numSteps", "best_list": [{"code": "def numSteps(s):\n    s = list(s)\n    steps = 0\n    while len(s) > 1:\n        if s[-1] == '0':\n            s.pop()\n        else:\n            i = len(s) - 1\n            while i >= 0 and s[i] == '1':\n                s[i] = '0'\n                i -= 1\n            if i >= 0:\n                s[i] = '1'\n            else:\n                s.insert(0, '1')\n        steps += 1\n    return steps", "passed": true, "score": {"loc": 17, "tokens": 110, "cc": 5, "nest": 4, "execution_time": 0.016472, "novelty": 0.7228137072762604}}, {"code": "def numSteps(s: str) -> int:\n    count = 0\n    num = int(s, 2)\n    while num > 1:\n        if num % 2 == 0:\n            num //= 2\n        else:\n            num += 1\n        count += 1\n    return count", "passed": false, "score": {"loc": 10, "tokens": 52, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.36576607907093683}}, {"code": "def numSteps(s: str) -> int:\n    return sum(1 for _ in (lambda x: (x // 2, x + 1)[x % 2] until x == 1)(int(s, 2)))", "passed": false, "score": {"loc": 2, "tokens": 52, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.9796722311196776}}, {"code": "def numSteps(s):\n    steps = 0\n    while len(s) > 1:\n        if s[-1] == '0':\n            s = s[:-1]\n        else:\n            s = bin(int(s, 2) + 1)[2:]\n        steps += 1\n    return steps", "passed": false, "score": {"loc": 9, "tokens": 62, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5763663190085164}}, {"code": "def numSteps(s: str) -> int:\n    steps = 0\n    while s != \"1\":\n        if s[-1] == \"0\":\n            s = s[:-1]\n        else:\n            s = bin(int(s, 2) + 1)[2:]\n        steps += 1\n    return steps", "passed": false, "score": {"loc": 9, "tokens": 67, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6415293769031456}}, {"code": "def numSteps(s):\n    count = 0\n    while len(s) > 1:\n        if s[-1] == '0':\n            s = s[:-1]\n        else:\n            s = bin(int(s, 2) + 1)[2:]\n        count += 1\n    return count", "passed": false, "score": {"loc": 9, "tokens": 62, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.577000502282996}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 8}
{"id": 1490, "entry_point": "maxPower", "best_list": [{"code": "def maxPower(s):\n    max_count = current_count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            current_count += 1\n        else:\n            max_count = max(max_count, current_count)\n            current_count = 1\n    return max(max_count, current_count)", "passed": true, "score": {"loc": 9, "tokens": 62, "cc": 2, "nest": 3, "execution_time": 0.016669, "novelty": 0.18765464052917613}}, {"code": "def maxPower(s):\n    max_len = 0\n    current_len = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    return max(max_len, current_len)", "passed": true, "score": {"loc": 10, "tokens": 63, "cc": 2, "nest": 3, "execution_time": 0.016601, "novelty": 0.1757260699037566}}, {"code": "def maxPower(s):\n    max_count = 0\n    current_count = 1\n\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            current_count += 1\n        else:\n            max_count = max(max_count, current_count)\n            current_count = 1\n\n    return max(max_count, current_count)", "passed": true, "score": {"loc": 10, "tokens": 63, "cc": 2, "nest": 3, "execution_time": 0.0167, "novelty": 0.16982134125094406}}, {"code": "def maxPower(s: str) -> int:\n    max_len = 0\n    current_len = 1\n\n    for i, (char1, char2) in enumerate(s):\n        if char1 == char2:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n\n    return max(max_len, current_len)", "passed": false, "score": {"loc": 10, "tokens": 61, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.2466652288708171}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 14508, "entry_point": "splitArray", "best_list": [{"code": "def splitArray(nums, m):\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n    \n    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(i, m) + 1):\n            for k in range(i):\n                dp[i][j] = min(dp[i][j], max(dp[k][j - 1], prefix_sum[i] - prefix_sum[k]))\n    \n    return dp[n][m]", "passed": true, "score": {"loc": 12, "tokens": 171, "cc": 4, "nest": 4, "execution_time": 0.016792, "novelty": 0.76586939565799}}, {"code": "def splitArray(nums, m):\n    n = len(nums)\n    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    prefix_sum = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n    \n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(i, m) + 1):\n            for k in range(i):\n                dp[i][j] = min(dp[i][j], max(dp[k][j - 1], prefix_sum[i] - prefix_sum[k]))\n    \n    return dp[n][m]", "passed": true, "score": {"loc": 12, "tokens": 177, "cc": 4, "nest": 4, "execution_time": 0.016779, "novelty": 0.8013581161426879}}, {"code": "def splitArray(nums, m):\n    def canSplit(max_sum):\n        count, current_sum = 1, 0\n        for num in nums:\n            if current_sum + num > max_sum:\n                count += 1\n                current_sum = num\n            else:\n                current_sum += num\n        return count <= m\n\n    left, right = max(nums), sum(nums)\n    while left < right:\n        mid = (left + right) // 2\n        if canSplit(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left", "passed": true, "score": {"loc": 18, "tokens": 97, "cc": 4, "nest": 4, "execution_time": 0.01663, "novelty": 0.21931217877991338}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 14517, "entry_point": "addDigits", "best_list": [{"code": "def addDigits(num):\n    return num % 9 or 9 if num else 0", "passed": true, "score": {"loc": 2, "tokens": 16, "cc": 1, "nest": 1, "execution_time": 0.016749, "novelty": 0.4492856956760529}}, {"code": "def addDigits(num):\n    return 1 + (num - 1) % 9 if num else 0", "passed": true, "score": {"loc": 2, "tokens": 20, "cc": 0, "nest": 1, "execution_time": 0.016548, "novelty": 0.379983166461034}}, {"code": "def addDigits(num):\n    return (num - 1) % 9 + 1 if num > 0 else 0", "passed": true, "score": {"loc": 2, "tokens": 22, "cc": 0, "nest": 1, "execution_time": 0.01666, "novelty": 0.5906811769440006}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 14528, "entry_point": "mirrorReflection", "best_list": [{"code": "def mirrorReflection(p, q):\n    while q % p:\n        q, p = p, q % p\n    if q == 0:\n        return 0\n    return 1 if (p // q) % 2 else 2", "passed": true, "score": {"loc": 6, "tokens": 43, "cc": 2, "nest": 2, "execution_time": 0.016501, "novelty": 0.49298909023688475}}, {"code": "def mirrorReflection(p, q):\n    while p % 2 == 0 and q % 2 == 0:\n        p //= 2\n        q //= 2\n    if p % 2 == 1 and q % 2 == 0:\n        return 0\n    if p % 2 == 0 and q % 2 == 1:\n        return 2\n    return 1", "passed": true, "score": {"loc": 9, "tokens": 69, "cc": 6, "nest": 2, "execution_time": 0.016631, "novelty": 0.6127933869419204}}, {"code": "def mirrorReflection(p, q):\n    while q and p % q:\n        p, q = q, p % q\n    if p // q % 2 == 0:\n        return 0\n    elif q == 0:\n        return 2\n    else:\n        return 1", "passed": false, "score": {"loc": 9, "tokens": 49, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.5612275860148634}}, {"code": "def mirrorReflection(p, q):\n    while q % p == 0:\n        q //= 2\n    return (q % 2) + (1 if p % 2 == 1 else 0)", "passed": false, "score": {"loc": 4, "tokens": 40, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.5334449944340534}}, {"code": "def mirrorReflection(p, q):\n    while p % 2 == 0 and q % 2 == 0:\n        p //= 2\n        q //= 2\n    return 0 if p % 2 == 0 else (1 if q % 2 == 0 else 2)", "passed": false, "score": {"loc": 5, "tokens": 55, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.5334598839913878}}, {"code": "def mirrorReflection(p, q):\n    while q and q % p:\n        q %= p\n    return 1 if q == 0 else 2 if (p // q) % 2 else 0", "passed": false, "score": {"loc": 4, "tokens": 39, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.5413198233373113}}, {"code": "def mirrorReflection(p, q):\n    while q % p:\n        q += p\n    return 2 if q // p % 2 else 1 if p // 2 % 2 else 0", "passed": false, "score": {"loc": 4, "tokens": 37, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.4898955085872668}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 8}
{"id": 14541, "entry_point": "predictPartyVictory", "best_list": [{"code": "def predictPartyVictory(senate: str) -> str:\n    while len(set(senate)) > 1:\n        senate = ''.join(c for c in senate if senate.count(c) > 1)\n    return 'Radiant' if 'R' in senate else 'Dire'", "passed": true, "score": {"loc": 4, "tokens": 58, "cc": 1, "nest": 2, "execution_time": 0.016669, "novelty": 0.7663467403155212}}, {"code": "def predictPartyVictory(senate):\n    R, D = [], []\n    for i, c in enumerate(senate):\n        if c == 'R':\n            R.append(i)\n        else:\n            D.append(i)\n    while R and D:\n        r, d = R.pop(0), D.pop(0)\n        if r < d:\n            R.append(r + len(senate))\n        else:\n            D.append(d + len(senate))\n    return \"Radiant\" if R else \"Dire\"", "passed": true, "score": {"loc": 14, "tokens": 108, "cc": 5, "nest": 3, "execution_time": 0.017412, "novelty": 0.4965503657359116}}, {"code": "def predictPartyVictory(senate):\n    radiant, dire = [], []\n    n = len(senate)\n    \n    for i, s in enumerate(senate):\n        if s == 'R':\n            radiant.append(i)\n        else:\n            dire.append(i)\n    \n    while radiant and dire:\n        r = radiant.pop(0)\n        d = dire.pop(0)\n        \n        if r < d:\n            radiant.append(r + n)\n        else:\n            dire.append(d + n)\n    \n    return \"Radiant\" if radiant else \"Dire\"", "passed": true, "score": {"loc": 16, "tokens": 107, "cc": 5, "nest": 3, "execution_time": 0.016818, "novelty": 0.4801598343690643}}, {"code": "def predictPartyVictory(senate):\n    radiant, dire = [], []\n    queue = list(senate)\n    \n    while queue:\n        for _ in range(len(queue)):\n            s = queue.pop(0)\n            if s == 'R':\n                if dire:\n                    dire.pop(0)\n                else:\n                    radiant.append('R')\n            else:\n                if radiant:\n                    radiant.pop(0)\n                else:\n                    dire.append('D')\n        queue = radiant + dire\n    \n    return \"Radiant\" if radiant else \"Dire\"", "passed": false, "score": {"loc": 18, "tokens": 106, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.678122658001598}}, {"code": "def predictPartyVictory(senate: str) -> str:\n    while len(set(senate)) > 1:\n        bans = [0, 0]\n        new_senate = []\n        for s in senate:\n            if s == 'R':\n                if bans[1] > 0:\n                    bans[1] -= 1\n                else:\n                    bans[0] += 1\n                    new_senate.append(s)\n            else:\n                if bans[0] > 0:\n                    bans[0] -= 1\n                else:\n                    bans[1] += 1\n                    new_senate.append(s)\n        senate = ''.join(new_senate)\n    return 'Radiant' if senate[0] == 'R' else 'Dire'", "passed": false, "score": {"loc": 19, "tokens": 135, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.8013398983178048}}, {"code": "def predictPartyVictory(senate: str) -> str:\n    radiant = [i for i, c in enumerate(senate) if c == 'R']\n    dire = [i for i, c in enumerate(senate) if c == 'D']\n    while radiant and dire:\n        r, d = radiant.pop(0), dire.pop(0)\n        if r < d:\n            radiant.append(r + len(senate))\n        else:\n            dire.append(d + len(senate))\n    return \"Radiant\" if radiant else \"Dire\"", "passed": false, "score": {"loc": 10, "tokens": 114, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.4946086334106684}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 14792, "entry_point": "minOperations", "best_list": [{"code": "def minOperations(nums):\n    d = 0\n    while max(nums) > 1:\n        d += sum(1 for x in nums if x & 1)\n        nums = [x // 2 for x in nums]\n        d += 1\n    return d + sum(nums)", "passed": true, "score": {"loc": 7, "tokens": 55, "cc": 1, "nest": 2, "execution_time": 0.016627, "novelty": 0.7628183634526189}}, {"code": "def minOperations(nums):\n    def steps(x):\n        ops = 0\n        while x > 0:\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x -= 1\n                ops += 1\n        return ops\n\n    return sum(map(steps, nums)) + max(nums).bit_length() - 1", "passed": true, "score": {"loc": 11, "tokens": 66, "cc": 2, "nest": 4, "execution_time": 0.016659, "novelty": 0.635910877729758}}, {"code": "def minOperations(nums):\n    max_double = 0\n    total_increments = 0\n    for num in nums:\n        double_count = 0\n        while num > 0:\n            if num % 2 == 0:\n                num //= 2\n                double_count += 1\n            else:\n                num -= 1\n                total_increments += 1\n        max_double = max(max_double, double_count)\n    return total_increments + max_double", "passed": true, "score": {"loc": 14, "tokens": 64, "cc": 3, "nest": 4, "execution_time": 0.016603, "novelty": 0.5317727751122356}}, {"code": "def minOperations(nums):\n    total = 0\n    max_double = 0\n    for num in nums:\n        ops = 0\n        while num > 0:\n            if num % 2 == 0:\n                num //= 2\n                ops += 1\n            else:\n                num -= 1\n                ops += 1\n        total += ops\n        max_double = max(max_double, ops)\n    return total + max_double - 1", "passed": false, "score": {"loc": 15, "tokens": 70, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5540886204730062}}, {"code": "def minOperations(nums):\n    from math import log2\n    return sum(max(int(log2(num)), num.bit_length() - 1) for num in nums) + sum(nums)", "passed": false, "score": {"loc": 3, "tokens": 41, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7287445397166105}}, {"code": "def minOperations(nums):\n    from math import ceil, log2\n    return sum(max(ceil(log2(n)), n.bit_count() - 1) for n in nums)", "passed": false, "score": {"loc": 3, "tokens": 38, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6795172145704227}}, {"code": "def minOperations(nums):\n    from math import ceil, log2\n    return sum(nums) + sum(ceil(log2(n)) for n in nums if n > 1)", "passed": false, "score": {"loc": 3, "tokens": 36, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7153678765661857}}, {"code": "def minOperations(nums):\n    operations = 0\n    max_double = 0\n    for num in nums:\n        double = 0\n        while num > 0:\n            if num % 2 == 1:\n                num -= 1\n                operations += 1\n            else:\n                num //= 2\n                double += 1\n        operations += double\n        max_double = max(max_double, double)\n    operations += max_double - 1\n    return operations", "passed": false, "score": {"loc": 16, "tokens": 72, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5896366869686489}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 14820, "entry_point": "validIPAddress", "best_list": [{"code": "import re\n\ndef validIPAddress(IP):\n    if len(IP) > 39:\n        return \"Neither\"\n    if IP.count('.') == 3:\n        return \"IPv4\" if all(_is_valid_ipv4_octet(octet) for octet in IP.split('.')) else \"Neither\"\n    if IP.count(':') == 7:\n        return \"IPv6\" if all(_is_valid_ipv6_group(group) for group in IP.split(':')) else \"Neither\"\n    return \"Neither\"\n\ndef _is_valid_ipv4_octet(octet):\n    return octet.isdigit() and 0 <= int(octet) <= 255 and not (len(octet) > 1 and octet.startswith('0'))\n\ndef _is_valid_ipv6_group(group):\n    return len(group) <= 4 and all(c in '0123456789ABCDEFabcdef' for c in group)", "passed": true, "score": {"loc": 13, "tokens": 173, "cc": 6, "nest": 2, "execution_time": 0.01673, "novelty": 0.7455595712981598}}, {"code": "import re\n\ndef validIPAddress(IP):\n    def isIPv4(s):\n        try:\n            return str(int(s)) == s and 0 <= int(s) <= 255\n        except:\n            return False\n\n    def isIPv6(s):\n        return len(s) <= 4 and all(c in '0123456789ABCDEFabcdef' for c in s)\n\n    if IP.count('.') == 3 and all(isIPv4(p) for p in IP.split('.')):\n        return 'IPv4'\n    if IP.count(':') == 7 and all(isIPv6(p) for p in IP.split(':')):\n        return 'IPv6'\n    return 'Neither'", "passed": true, "score": {"loc": 14, "tokens": 145, "cc": 8, "nest": 3, "execution_time": 0.016648, "novelty": 0.6374750493717674}}, {"code": "import re\n\ndef validIPAddress(IP):\n    if '.' in IP:\n        parts = IP.split('.')\n        if len(parts) != 4:\n            return \"Neither\"\n        for part in parts:\n            if not part.isdigit() or int(part) < 0 or int(part) > 255 or (len(part) > 1 and part[0] == '0'):\n                return \"Neither\"\n        return \"IPv4\"\n    elif ':' in IP:\n        parts = IP.split(':')\n        if len(parts) != 8:\n            return \"Neither\"\n        for part in parts:\n            if not re.match('^[0-9a-fA-F]{1,4}$', part):\n                return \"Neither\"\n        return \"IPv6\"\n    else:\n        return \"Neither\"", "passed": true, "score": {"loc": 20, "tokens": 169, "cc": 10, "nest": 5, "execution_time": 0.016806, "novelty": 0.559457265200466}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 14846, "entry_point": "countLargestGroup", "best_list": [{"code": "def countLargestGroup(n):\n    from collections import Counter\n    count = Counter(sum(map(int, str(i))) for i in range(1, n + 1))\n    max_size = max(count.values())\n    return sum(1 for size in count.values() if size == max_size)", "passed": true, "score": {"loc": 5, "tokens": 66, "cc": 0, "nest": 1, "execution_time": 0.016639, "novelty": 0.3955210970760563}}, {"code": "def countLargestGroup(n):\n    from collections import Counter\n    groups = Counter(sum(int(digit) for digit in str(i)) for i in range(1, n + 1))\n    max_size = max(groups.values())\n    return sum(1 for size in groups.values() if size == max_size)", "passed": true, "score": {"loc": 5, "tokens": 68, "cc": 0, "nest": 1, "execution_time": 0.016617, "novelty": 0.3831319671712705}}, {"code": "def countLargestGroup(n):\n    count = [0] * 37\n    for i in range(1, n + 1):\n        count[sum(int(digit) for digit in str(i))] += 1\n    max_size = max(count)\n    return count.count(max_size)", "passed": true, "score": {"loc": 6, "tokens": 58, "cc": 1, "nest": 2, "execution_time": 0.016565, "novelty": 0.6749132759480632}}, {"code": "def countLargestGroup(n):\n    from collections import Counter\n    from itertools import groupby\n    from operator import itemgetter\n    \n    # Calculate the sum of digits for each number from 1 to n\n    sums_of_digits = [sum(map(int, str(i))) for i in range(1, n + 1)]\n    \n    # Group numbers by the sum of their digits\n    grouped = groupby(sorted(sums_of_digits), itemgetter(0))\n    \n    # Count the size of each group\n    group_sizes = Counter(len(list(group)) for _, group in grouped)\n    \n    # Find the maximum group size\n    max_size = max(group_sizes.values())\n    \n    # Count how many groups have the maximum size\n    return sum(1 for size in group_sizes.values() if size == max_size)", "passed": false, "score": {"loc": 14, "tokens": 149, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6831687130998754}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 14927, "entry_point": "busyStudent", "best_list": [{"code": "def busyStudent(startTime, endTime, queryTime):\n    return sum(st <= queryTime <= et for st, et in zip(startTime, endTime))", "passed": true, "score": {"loc": 2, "tokens": 32, "cc": 0, "nest": 1, "execution_time": 0.016573, "novelty": 0.18048832834205442}}, {"code": "def busyStudent(startTime, endTime, queryTime):\n    return sum(st <= queryTime <= en for st, en in zip(startTime, endTime))", "passed": true, "score": {"loc": 2, "tokens": 32, "cc": 0, "nest": 1, "execution_time": 0.016594, "novelty": 0.18018433077403495}}, {"code": "def busyStudent(startTime, endTime, queryTime):\n    return sum(s <= queryTime <= e for s, e in zip(startTime, endTime))", "passed": true, "score": {"loc": 2, "tokens": 32, "cc": 0, "nest": 1, "execution_time": 0.016622, "novelty": 0.17889393648024443}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 155, "entry_point": "modifyString", "best_list": [{"code": "def modifyString(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == '?':\n            for ch in 'abc':\n                if (i == 0 or s[i-1] != ch) and (i == len(s) - 1 or s[i+1] != ch):\n                    s[i] = ch\n                    break\n    return ''.join(s)", "passed": true, "score": {"loc": 9, "tokens": 101, "cc": 7, "nest": 5, "execution_time": 0.016573, "novelty": 0.6023547004252303}}, {"code": "def modifyString(s):\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == '?':\n            options = set('abc')\n            if i > 0:\n                options.discard(s[i - 1])\n            if i < len(s) - 1:\n                options.discard(s[i + 1])\n            s[i] = next(iter(options))\n    return ''.join(s)", "passed": true, "score": {"loc": 11, "tokens": 99, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.5745249188155477}}, {"code": "def modifyString(s):\n    chars = list(s)\n    for i in range(len(chars)):\n        if chars[i] == '?':\n            options = 'abc'\n            if i > 0:\n                options = options.replace(chars[i-1], '')\n            if i < len(chars) - 1:\n                options = options.replace(chars[i+1], '')\n            chars[i] = options[0]\n    return ''.join(chars)", "passed": true, "score": {"loc": 11, "tokens": 103, "cc": 4, "nest": 4, "execution_time": 0.016589, "novelty": 0.3457089204648359}}, {"code": "def modifyString(s: str) -> str:\n    chars = list(s)\n    used_chars = set()\n    \n    for i in range(len(chars)):\n        if chars[i] == '?':\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if not (i > 0 and chars[i-1] == c) and (i < len(chars) - 1 and chars[i+1] == c):\n                    used_chars.add(c)\n                    chars[i] = c\n                    used_chars.remove(c)\n                    break\n    \n    return ''.join(chars)", "passed": false, "score": {"loc": 12, "tokens": 117, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.6822182136802968}}, {"code": "def modifyString(s):\n    chars = list(s)\n    for i in range(len(chars)):\n        if chars[i] == '?':\n            options = 'abc'\n            if i > 0:\n                options = options.replace(chars[i - 1], '')\n            if i < len(chars) - 1:\n                options = options.replace(chars[i + 1], '')\n            chars[i] = options[0]\n    return ''.join(chars)\n\n# Unit tests to satisfy:\ndef _equivalent(lhs, rhs):\n    return lhs == rhs\n\nassert _equivalent(modifyString(\"?zs\"), \"azs\")\nassert _equivalent(modifyString(\"ubv?w\"), \"ubvaw\")\nassert _equivalent(modifyString(\"j?qg??b\"), \"jaqgacb\")\nassert _equivalent(modifyString(\"??yw?ipkj?\"), \"acywaipkja\")", "passed": false, "score": {"loc": 18, "tokens": 191, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.459696067505742}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 15011, "entry_point": "balancedStringSplit", "best_list": [{"code": "def balancedStringSplit(s):\n    balance = count = 0\n    for char in s:\n        balance += 1 if char == 'R' else -1\n        if balance == 0:\n            count += 1\n    return count", "passed": true, "score": {"loc": 7, "tokens": 42, "cc": 2, "nest": 3, "execution_time": 0.01651, "novelty": 0.12898285232684226}}, {"code": "def balancedStringSplit(s):\n    count = balance = 0\n    for char in s:\n        balance += 1 if char == 'R' else -1\n        if balance == 0:\n            count += 1\n    return count", "passed": true, "score": {"loc": 7, "tokens": 42, "cc": 2, "nest": 3, "execution_time": 0.016633, "novelty": 0.1534295827499298}}, {"code": "def balancedStringSplit(s: str) -> int:\n    balance = count = 0\n    for char in s:\n        balance += 1 if char == 'R' else -1\n        if balance == 0:\n            count += 1\n    return count", "passed": true, "score": {"loc": 7, "tokens": 47, "cc": 2, "nest": 3, "execution_time": 0.016769, "novelty": 0.12522882609123287}}, {"code": "def balancedStringSplit(s):\n    balance = 0\n    count = 0\n    for char in s:\n        if char == 'L':\n            balance += 1\n        else:\n            balance -= 1\n        if balance == 0:\n            count += 1\n    return count", "passed": false, "score": {"loc": 11, "tokens": 47, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.20191745024074204}}, {"code": "def balancedStringSplit(s):\n    balance, count = 0, 0\n    for char in s:\n        if char == 'L':\n            balance += 1\n        else:\n            balance -= 1\n        if balance == 0:\n            count += 1\n    return count", "passed": false, "score": {"loc": 10, "tokens": 48, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.20974513309322007}}, {"code": "def balancedStringSplit(s: str) -> int:\n    balance = 0\n    count = 0\n    for char in s:\n        if char == 'L':\n            balance += 1\n        else:\n            balance -= 1\n        if balance == 0:\n            count += 1\n    return count", "passed": false, "score": {"loc": 11, "tokens": 52, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.19536828740633738}}, {"code": "def balancedStringSplit(s: str) -> int:\n    balance = 0\n    result = 0\n    for char in s:\n        if char == 'L':\n            balance += 1\n        else:\n            balance -= 1\n        if balance == 0:\n            result += 1\n    return result", "passed": false, "score": {"loc": 11, "tokens": 52, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.20395718092063264}}, {"code": "def balancedStringSplit(s: str) -> int:\n    count = 0\n    balance = 0\n    for char in s:\n        if char == 'L':\n            balance -= 1\n        else:\n            balance += 1\n        if balance == 0:\n            count += 1\n    return count", "passed": false, "score": {"loc": 11, "tokens": 52, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.21973813775228423}}], "num_pass": 5, "num_uniq": 4, "num_fail": 5, "fail_uniq": 5}
{"id": 15100, "entry_point": "lemonadeChange", "best_list": [{"code": "def lemonadeChange(bills):\n    five = ten = 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            if five == 0: return False\n            five -= 1\n            ten += 1\n        else:\n            if ten > 0 and five > 0:\n                ten -= 1\n                five -= 1\n            elif five >= 3:\n                five -= 3\n            else:\n                return False\n    return True", "passed": true, "score": {"loc": 18, "tokens": 83, "cc": 7, "nest": 6, "execution_time": 0.016513, "novelty": 0.19047667841584937}}, {"code": "def lemonadeChange(bills):\n    five, ten = 0, 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            if five == 0:\n                return False\n            five -= 1\n            ten += 1\n        else:\n            if ten > 0 and five > 0:\n                ten -= 1\n                five -= 1\n            elif five >= 3:\n                five -= 3\n            else:\n                return False\n    return True", "passed": true, "score": {"loc": 19, "tokens": 85, "cc": 7, "nest": 6, "execution_time": 0.016749, "novelty": 0.2016047520892964}}, {"code": "def lemonadeChange(bills):\n    five = ten = 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            if five == 0:\n                return False\n            five -= 1\n            ten += 1\n        elif bill == 20:\n            if ten > 0 and five > 0:\n                ten -= 1\n                five -= 1\n            elif five >= 3:\n                five -= 3\n            else:\n                return False\n    return True", "passed": true, "score": {"loc": 19, "tokens": 87, "cc": 8, "nest": 7, "execution_time": 0.016649, "novelty": 0.18130407006350535}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 15118, "entry_point": "match_arrays", "best_list": [{"code": "def match_arrays(arr1, arr2): return [sum(x in arr2 for x in arr1)]", "passed": true, "score": {"loc": 1, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 0.016691, "novelty": 0.5218459408460441}}, {"code": "def match_arrays(arr1, arr2):\n    return [len(set(arr1) & set(arr2))]", "passed": true, "score": {"loc": 2, "tokens": 23, "cc": 0, "nest": 1, "execution_time": 0.016709, "novelty": 0.2271250738633097}}, {"code": "def match_arrays(arr1, arr2):\n    return sum(1 for x in arr1 if x in arr2)", "passed": false, "score": {"loc": 2, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.4877799694712236}}, {"code": "def match_arrays(arr1, arr2):\n    count = 0\n    i = 0\n    while i < len(arr1):\n        if arr1[i] in arr2:\n            count += 1\n        i += 1\n    return count", "passed": false, "score": {"loc": 8, "tokens": 40, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6888434008898423}}, {"code": "def match_arrays(arr1, arr2):\n    return len(set(arr1) & set(arr2))", "passed": false, "score": {"loc": 2, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.19392793704423195}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 3}
{"id": 15121, "entry_point": "minEatingSpeed", "best_list": [{"code": "def minEatingSpeed(piles, H):\n    left, right = 1, max(piles)\n    while left < right:\n        mid = (left + right) // 2\n        if sum((pile + mid - 1) // mid for pile in piles) > H:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": true, "score": {"loc": 9, "tokens": 66, "cc": 2, "nest": 3, "execution_time": 0.016674, "novelty": 0.42476334605297106}}, {"code": "def minEatingSpeed(piles, H):\n    left, right = 1, max(piles)\n    while left < right:\n        mid = (left + right) // 2\n        if sum((pile - 1) // mid + 1 for pile in piles) > H:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": true, "score": {"loc": 9, "tokens": 66, "cc": 2, "nest": 3, "execution_time": 0.016727, "novelty": 0.4052943541786932}}, {"code": "def minEatingSpeed(piles, h):\n    left, right = 1, max(piles)\n    while left < right:\n        mid = (left + right) // 2\n        hours = sum((pile - 1) // mid + 1 for pile in piles)\n        if hours > h:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": true, "score": {"loc": 10, "tokens": 69, "cc": 2, "nest": 3, "execution_time": 0.016783, "novelty": 0.5881962074071284}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 15268, "entry_point": "maxDiff", "best_list": [{"code": "def maxDiff(num):\n    s = str(num)\n    max_val = int(s.replace(s[0], '9') if s[0] != '9' else s)\n    min_val = int('1' + s[1:].replace(s[1], '0') if s[0] == '1' else s.replace(s[0], '1'))\n    return max_val - min_val", "passed": true, "score": {"loc": 5, "tokens": 96, "cc": 0, "nest": 1, "execution_time": 0.01676, "novelty": 0.6052484122780214}}, {"code": "def maxDiff(num):\n    digits = list(str(num))\n    max_val = int(''.join('9' if d != digits[0] else '9' for d in digits))\n    min_val = int(''.join('1' if d != digits[0] else '1' for d in digits) if digits[0] != '1' else \n                   ''.join('0' if d != digits[1] else '0' for d in digits[1:]))\n    return max_val - min_val", "passed": true, "score": {"loc": 6, "tokens": 119, "cc": 0, "nest": 1, "execution_time": 0.016592, "novelty": 0.6667772028028196}}, {"code": "def maxDiff(num):\n    num_str = str(num)\n    max_val = int(num_str.replace(num_str[0], '9'))\n    if num_str[0] == '1':\n        min_val = int(num_str.replace(num_str[1], '0'))\n    else:\n        min_val = int(num_str.replace(num_str[0], '1'))\n    return max_val - min_val", "passed": true, "score": {"loc": 8, "tokens": 83, "cc": 1, "nest": 2, "execution_time": 0.016423, "novelty": 0.6019111942151059}}, {"code": "def maxDiff(num):\n    num_str = str(num)\n    max_val = int(''.join('9' if d == num_str[0] else '9' if d == max_d else d for d in num_str))\n    min_val = int(''.join('1' if i == 0 and d != '1' else '0' if d == max_d else d for i, d in enumerate(num_str)))\n    return max_val - min_val", "passed": false, "score": {"loc": 5, "tokens": 99, "cc": 1, "nest": 1, "execution_time": 10.0, "novelty": 0.6397003082376138}}, {"code": "def maxDiff(num):\n    digits = list(str(num))\n    max_num = digits[:]\n    min_num = digits[:]\n    \n    for i, digit in enumerate(digits):\n        if digit != '9':\n            max_num = [str(9) if x == digit else x for x in digits]\n            break\n    \n    for i, digit in enumerate(digits):\n        if digit == '1' and i != 0:\n            min_num = [str(0) if x == digit else x for x in digits]\n            break\n        if digit != '0' and digit != digits[0]:\n            min_num = [str(1) if x == digit else x for x in digits]\n            break\n    \n    return int(''.join(max_num)) - int(''.join(min_num))", "passed": false, "score": {"loc": 16, "tokens": 166, "cc": 7, "nest": 3, "execution_time": 10.0, "novelty": 0.7823186311457656}}, {"code": "def maxDiff(num):\n    num_str = str(num)\n    max_val = int(num_str.replace(num_str[0], '9'))\n    min_val = int(num_str.replace(num_str[0], '1')) if num_str[0] != '1' else int(num_str.replace(num_str[1], '0'))\n    for char in set(num_str):\n        min_val = min(min_val, int(num_str.replace(char, '0')) if char != '0' else int(num_str.replace(char, '1')))\n    return max_val - min_val", "passed": false, "score": {"loc": 7, "tokens": 128, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.6414972057955275}}, {"code": "def maxDiff(num: int) -> int:\n    s = str(num)\n    max_val = int(''.join(str(9 if d != s[0] else 1) if d != '1' and d != '0' else d for d in s))\n    min_val = int(''.join(str(1 if d == s[0] else 0) if d == s[0] and s[0] != '1' else str(1 if d != '0' and d != '1' else 0) if d != '0' and d != '1' else d for d in s))\n    return max_val - min_val", "passed": false, "score": {"loc": 5, "tokens": 150, "cc": 4, "nest": 1, "execution_time": 10.0, "novelty": 0.7415594929384829}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 15315, "entry_point": "missingNumber", "best_list": [{"code": "def missingNumber(nums):\n    return len(nums) * (len(nums) + 1) // 2 - sum(nums)", "passed": true, "score": {"loc": 2, "tokens": 28, "cc": 0, "nest": 1, "execution_time": 0.016585, "novelty": 0.5611069201363161}}, {"code": "def missingNumber(nums):\n    return list(set(range(len(nums) + 1)) - set(nums))[0]", "passed": true, "score": {"loc": 2, "tokens": 30, "cc": 0, "nest": 1, "execution_time": 0.01661, "novelty": 0.6188353063976734}}, {"code": "def missingNumber(nums):\n    n = len(nums)\n    return n * (n + 1) // 2 - sum(nums)", "passed": true, "score": {"loc": 3, "tokens": 28, "cc": 0, "nest": 1, "execution_time": 0.016529, "novelty": 0.4180113623305638}}, {"code": "def missingNumber(nums):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == mid:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left", "passed": false, "score": {"loc": 9, "tokens": 57, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7092711010153268}}], "num_pass": 9, "num_uniq": 6, "num_fail": 1, "fail_uniq": 1}
{"id": 15438, "entry_point": "subsets", "best_list": [{"code": "def subsets(nums):\n    dp = [[]]\n    for num in nums:\n        dp += [s + [num] for s in dp]\n    return dp", "passed": true, "score": {"loc": 5, "tokens": 33, "cc": 1, "nest": 2, "execution_time": 0.016437, "novelty": 0.3534331856789864}}, {"code": "def subsets(nums):\n    result = [[]]\n    for num in nums:\n        result += [subset + [num] for subset in result]\n    return result", "passed": true, "score": {"loc": 5, "tokens": 33, "cc": 1, "nest": 2, "execution_time": 0.016541, "novelty": 0.34016714676390225}}, {"code": "def subsets(nums):\n    result = [[]]\n    for num in nums:\n        result += [s + [num] for s in result]\n    return result", "passed": true, "score": {"loc": 5, "tokens": 33, "cc": 1, "nest": 2, "execution_time": 0.016864, "novelty": 0.3414014876440281}}, {"code": "def subsets(nums):\n    return [[]] + [[num] + s for num in nums for s in subsets(nums[1:])]", "passed": false, "score": {"loc": 2, "tokens": 34, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6932618092814162}}], "num_pass": 9, "num_uniq": 5, "num_fail": 1, "fail_uniq": 1}
{"id": 15494, "entry_point": "minTaps", "best_list": [{"code": "def minTaps(n: int, ranges: list[int]) -> int:\n    intervals = sorted((max(0, i - r), min(n, i + r)) for i, r in enumerate(ranges))\n    cover, end, taps = 0, 0, 0\n    i = 0\n    while cover < n:\n        while i < len(intervals) and intervals[i][0] <= cover:\n            end = max(end, intervals[i][1])\n            i += 1\n        if end == cover:\n            return -1\n        cover = end\n        taps += 1\n    return taps", "passed": true, "score": {"loc": 13, "tokens": 125, "cc": 4, "nest": 3, "execution_time": 0.016459, "novelty": 0.6469158146459314}}, {"code": "def minTaps(n, ranges):\n    intervals = []\n    for i, r in enumerate(ranges):\n        intervals.append((max(0, i - r), min(n, i + r)))\n    intervals.sort()\n\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for start, end in intervals:\n        if dp[start] == float('inf'):\n            continue\n        for j in range(start + 1, end + 1):\n            dp[j] = min(dp[j], dp[start] + 1)\n\n    return dp[n] if dp[n] != float('inf') else -1", "passed": true, "score": {"loc": 13, "tokens": 149, "cc": 4, "nest": 3, "execution_time": 0.0167, "novelty": 0.6375163826393371}}, {"code": "def minTaps(n, ranges):\n    intervals = sorted([(i - r, i + r) for i, r in enumerate(ranges) if r > 0])\n    end, farthest, taps = 0, 0, 0\n    i = 0\n    while i < len(intervals):\n        while i < len(intervals) and intervals[i][0] <= end:\n            farthest = max(farthest, intervals[i][1])\n            i += 1\n        if end == farthest:\n            return -1\n        taps += 1\n        end = farthest\n        if end >= n:\n            return taps\n    return -1", "passed": true, "score": {"loc": 15, "tokens": 123, "cc": 5, "nest": 3, "execution_time": 0.016445, "novelty": 0.5911277087871514}}, {"code": "def minTaps(n, ranges):\n    intervals = []\n    for i, r in enumerate(ranges):\n        if r > 0:\n            intervals.append((max(0, i - r), min(n, i + r)))\n    intervals.sort()\n\n    max_reach = 0\n    end = 0\n    taps = 0\n\n    for start, stop in intervals:\n        if start > end:\n            return -1\n        max_reach = max(max_reach, stop)\n        if end == start:\n            continue\n        end = max_reach\n        taps += 1\n        if end == n:\n            return taps\n\n    return -1", "passed": false, "score": {"loc": 20, "tokens": 113, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.6141129988975653}}, {"code": "def minTaps(n, ranges):\n    intervals = []\n    for i, r in enumerate(ranges):\n        if r > 0:\n            intervals.append([max(0, i - r), min(n, i + r)])\n    intervals.sort()\n    dp = [-1] * (n + 1)\n    dp[0] = 0\n    for i in range(n + 1):\n        if dp[i] == -1:\n            continue\n        left, right = i, min(n, i + 1)\n        while right <= n and (j := bisect_left(intervals, [left, float('inf')])) < len(intervals):\n            if intervals[j][0] <= right:\n                right = max(right, intervals[j][1])\n                if right == n:\n                    return dp[i] + 1\n            else:\n                break\n        if left < right:\n            dp[right] = dp[i] + 1\n    return dp[n]", "passed": false, "score": {"loc": 22, "tokens": 204, "cc": 9, "nest": 5, "execution_time": 10.0, "novelty": 0.7374976813486971}}, {"code": "def minTaps(n, ranges):\n    intervals = sorted([[i - r, i + r] for i, r in enumerate(ranges)])\n    end, farthest, count = 0, 0, 0\n    i = 0\n    while i < len(intervals) and end < n:\n        farthest = max(farthest, intervals[i][1])\n        if i == end:\n            end = farthest\n            count += 1\n            if i == end and end < n:\n                return -1\n        i += 1\n    return count if end >= n else -1", "passed": false, "score": {"loc": 13, "tokens": 113, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.577240761611989}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 15531, "entry_point": "originalDigits", "best_list": [{"code": "from collections import Counter\n\ndef originalDigits(s: str) -> str:\n    count = Counter(s)\n    result = [0] * 10\n    \n    # Unique characters\n    result[0] = count['z']\n    result[2] = count['w']\n    result[4] = count['u']\n    result[6] = count['x']\n    result[8] = count['g']\n    \n    # Characters that appear in only one digit\n    result[1] = count['o'] - result[0] - result[2] - result[4]\n    result[3] = count['h'] - result[8]\n    result[5] = count['f'] - result[4]\n    result[7] = count['s'] - result[6]\n    result[9] = count['i'] - result[5] - result[6] - result[8]\n    \n    return ''.join(str(i) * freq for i, freq in enumerate(result))", "passed": true, "score": {"loc": 17, "tokens": 216, "cc": 0, "nest": 1, "execution_time": 0.016882, "novelty": 0.5859374225967078}}, {"code": "def originalDigits(s: str) -> str:\n    from collections import Counter\n    \n    count = Counter(s)\n    result = [0] * 10\n    \n    # Unique characters for each digit\n    result[0] = count['z']\n    result[2] = count['w']\n    result[4] = count['u']\n    result[6] = count['x']\n    result[8] = count['g']\n    \n    # Characters that appear uniquely or after others\n    result[3] = count['h'] - result[8]\n    result[5] = count['f'] - result[4]\n    result[7] = count['s'] - result[6]\n    result[9] = count['i'] - result[5] - result[6] - result[8]\n    \n    result[1] = count['o'] - result[0] - result[2] - result[4]\n    \n    return ''.join(str(i) * freq for i, freq in enumerate(result))", "passed": true, "score": {"loc": 17, "tokens": 219, "cc": 0, "nest": 1, "execution_time": 0.016911, "novelty": 0.4043568653290385}}, {"code": "def originalDigits(s):\n    from collections import Counter\n    count = Counter(s)\n    result = [0] * 10\n    \n    # Unique characters that can be directly identified\n    result[0] = count['z']\n    result[2] = count['w']\n    result[4] = count['u']\n    result[6] = count['x']\n    result[8] = count['g']\n    \n    # Characters that can be identified after others\n    result[3] = count['h'] - result[8]\n    result[5] = count['f'] - result[4]\n    result[7] = count['s'] - result[6]\n    result[9] = count['i'] - result[5] - result[6] - result[8]\n    \n    # Characters that can be identified after others\n    result[1] = count['o'] - result[0] - result[2] - result[4]\n    \n    return ''.join(str(i) * freq for i, freq in enumerate(result))", "passed": true, "score": {"loc": 18, "tokens": 224, "cc": 0, "nest": 1, "execution_time": 0.016803, "novelty": 0.4074655085028913}}, {"code": "def originalDigits(s: str) -> str:\n    count = [0] * 10\n    char_count = [0] * 26\n    \n    for char in s:\n        char_count[ord(char) - ord('a')] += 1\n    \n    count[0] = char_count[2]  # zero\n    count[2] = char_count[4]  # two\n    count[4] = char_count[6]  # four\n    count[6] = char_count[8]  # six\n    count[8] = char_count[3] - count[2] - count[4] - count[6]  # eight\n    count[5] = char_count[5] - count[4]  # five\n    count[7] = char_count[7] - count[6]  # seven\n    count[3] = char_count[3] - count[2] - count[4] - count[6] - count[8]  # three\n    count[9] = char_count[9] - count[5] - count[6] - count[8]  # nine\n    count[1] = char_count[1] - count[3] - count[7]  # one\n    \n    return ''.join(str(digit) * freq for digit, freq in enumerate(count))", "passed": false, "score": {"loc": 16, "tokens": 249, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.867203220889657}}, {"code": "def originalDigits(s):\n    count = [0] * 10\n    count['z'] = s.count('z')\n    count['o'] = s.count('o') - count['z'] - count['w'] - count['u']\n    count['w'] = s.count('w')\n    count['h'] = s.count('h') - count['g']\n    count['u'] = s.count('u')\n    count['f'] = s.count('f') - count['u']\n    count['x'] = s.count('x')\n    count['s'] = s.count('s') - count['x']\n    count['g'] = s.count('g')\n    count['i'] = s.count('i') - count['x'] - count['g'] - count['z']\n    count['t'] = s.count('t') - count['w'] - count['g']\n\n    result = [str(digit) * freq for digit, freq in enumerate(count)]\n    return ''.join(result)", "passed": false, "score": {"loc": 15, "tokens": 282, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.8624577408525936}}, {"code": "def originalDigits(s: str) -> str:\n    counts = [0] * 10\n    mapping = {\n        \"z\": 0,\n        \"o\": 2,\n        \"w\": 2,\n        \"u\": 4,\n        \"x\": 6,\n        \"g\": 8,\n        \"s\": 7,\n        \"v\": 5,\n        \"i\": 9,\n    }\n    \n    for char, digit in mapping.items():\n        counts[digit] += s.count(char)\n    \n    counts[3] = s.count('h') - counts[8]\n    counts[5] -= counts[7]\n    counts[7] -= counts[6]\n    counts[9] -= counts[5]\n    \n    result = ''.join(str(digit) * count for digit, count in enumerate(counts))\n    return result", "passed": false, "score": {"loc": 21, "tokens": 172, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.8060486281403083}}, {"code": "def originalDigits(s):\n    from collections import Counter\n    count = Counter(s)\n    result = [0] * 10\n    \n    # Unique characters that identify each digit\n    unique_chars = {\n        0: 'z', 2: 'w', 4: 'u', 6: 'x', 8: 'g',\n        3: 'h', 5: 'f', 7: 's', 9: 'i'\n    }\n    \n    # Count the digits based on unique characters\n    for digit, char in unique_chars.items():\n        result[digit] = count[char]\n        for c in str(digit):\n            count[c] -= result[digit]\n    \n    # Remaining characters that can identify other digits\n    for digit in [1, 3, 5, 7, 9]:\n        result[digit] = count[str(digit)]\n    \n    # Convert result to string\n    return ''.join(str(digit) * count for digit, count in enumerate(result))", "passed": false, "score": {"loc": 19, "tokens": 195, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.8184928955791335}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 15597, "entry_point": "arrayPairSum", "best_list": [{"code": "def arrayPairSum(nums):\n    return sum(sorted(nums)[::2])", "passed": true, "score": {"loc": 2, "tokens": 19, "cc": 0, "nest": 1, "execution_time": 0.016442, "novelty": 0.38888246940801663}}, {"code": "def arrayPairSum(nums):\n    nums.sort()\n    return sum(nums[::2])", "passed": true, "score": {"loc": 3, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 0.016605, "novelty": 0.16123464170090807}}, {"code": "def arrayPairSum(nums):\n    nums.sort()\n    return sum(nums[i] for i in range(0, len(nums), 2))", "passed": true, "score": {"loc": 3, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016375, "novelty": 0.4779824351908668}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 15660, "entry_point": "leastBricks", "best_list": [{"code": "def leastBricks(wall):\n    edge_counts = {}\n    for row in wall:\n        position = 0\n        for width in row[:-1]:\n            position += width\n            edge_counts[position] = edge_counts.get(position, 0) + 1\n    return len(wall) - max(edge_counts.values() or [0])", "passed": true, "score": {"loc": 8, "tokens": 65, "cc": 3, "nest": 3, "execution_time": 0.016426, "novelty": 0.48242798105006013}}, {"code": "def leastBricks(wall):\n    edge_counts = {}\n    for row in wall:\n        edge = 0\n        for brick in row[:-1]:\n            edge += brick\n            edge_counts[edge] = edge_counts.get(edge, 0) + 1\n    return len(wall) - (max(edge_counts.values()) if edge_counts else 0)", "passed": true, "score": {"loc": 8, "tokens": 67, "cc": 2, "nest": 3, "execution_time": 0.016444, "novelty": 0.39223555172142976}}, {"code": "def leastBricks(wall):\n    from collections import Counter\n    edges = Counter()\n    for row in wall:\n        total = 0\n        for width in row[:-1]:\n            total += width\n            edges[total] += 1\n    return len(wall) - (max(edges.values()) if edges else 0)", "passed": true, "score": {"loc": 9, "tokens": 64, "cc": 2, "nest": 3, "execution_time": 0.016456, "novelty": 0.4664908315877463}}, {"code": "from collections import Counter\n\ndef leastBricks(wall):\n    edge_counts = Counter(sum(row[:-1]) for row in wall)\n    return len(wall) - (edge_counts.most_common(1)[0][1] if edge_counts else 0)", "passed": false, "score": {"loc": 4, "tokens": 52, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.4555055176725158}}, {"code": "def leastBricks(wall):\n    from collections import Counter\n    edge_counts = Counter(sum(wall[i][:-1]) for i in range(len(wall)))\n    return len(wall) - (max(edge_counts.values()) if edge_counts else 0)", "passed": false, "score": {"loc": 4, "tokens": 57, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.46135505491744355}}, {"code": "from collections import Counter\n\ndef leastBricks(wall):\n    edge_counts = Counter(sum(wall[i][:-1]) for i in range(len(wall)) if len(wall[i]) > 1)\n    return len(wall) - (max(edge_counts.values()) if edge_counts else 0)", "passed": false, "score": {"loc": 4, "tokens": 67, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.46331892290955}}, {"code": "def leastBricks(wall):\n    from collections import Counter\n    edge_counts = Counter(sum(row[:-1]) for row in wall)\n    return len(wall) - (edge_counts.most_common(1)[0][1] if edge_counts else 0)", "passed": false, "score": {"loc": 4, "tokens": 52, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.48609485990606716}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 15680, "entry_point": "numMagicSquaresInside", "best_list": [{"code": "def numMagicSquaresInside(grid):\n    rows, cols = len(grid), len(grid[0])\n    count = 0\n    \n    def is_magic(square):\n        target_sum = sum(square[0])\n        for row in square:\n            if sum(row) != target_sum:\n                return False\n        for col in range(3):\n            if sum(square[row][col] for row in range(3)) != target_sum:\n                return False\n        if sum(square[i][i] for i in range(3)) != target_sum:\n            return False\n        if sum(square[i][2-i] for i in range(3)) != target_sum:\n            return False\n        return True\n    \n    for r in range(rows - 2):\n        for c in range(cols - 2):\n            subgrid = [grid[r+i][c:c+3] for i in range(3)]\n            if sorted(sum(subgrid, [])) == list(range(1, 10)) and is_magic(subgrid):\n                count += 1\n    \n    return count", "passed": true, "score": {"loc": 22, "tokens": 218, "cc": 10, "nest": 4, "execution_time": 0.01669, "novelty": 0.6713779780258438}}, {"code": "def numMagicSquaresInside(grid):\n    count = 0\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    for i in range(rows - 2):\n        for j in range(cols - 2):\n            subgrid = [\n                grid[i][j:j+3], grid[i+1][j:j+3], grid[i+2][j:j+3]\n            ]\n            if is_magic_square(subgrid):\n                count += 1\n    \n    return count\n\ndef is_magic_square(subgrid):\n    flattened = [num for row in subgrid for num in row]\n    if sorted(flattened) != list(range(1, 10)):\n        return False\n    \n    target_sum = sum(subgrid[0])\n    for row in subgrid[1:]:\n        if sum(row) != target_sum:\n            return False\n    \n    for j in range(3):\n        if sum(subgrid[i][j] for i in range(3)) != target_sum:\n            return False\n    \n    if sum(subgrid[i][i] for i in range(3)) != target_sum:\n        return False\n    \n    if sum(subgrid[i][2-i] for i in range(3)) != target_sum:\n        return False\n    \n    return True", "passed": true, "score": {"loc": 28, "tokens": 250, "cc": 10, "nest": 4, "execution_time": 0.016874, "novelty": 0.8531464122560558}}, {"code": "def numMagicSquaresInside(grid):\n    def is_magic(square):\n        target = sum(square[0][:3])\n        for row in square:\n            if sum(row) != target:\n                return False\n        for col in range(3):\n            if sum(square[row][col] for row in range(3)) != target:\n                return False\n        if sum(square[i][i] for i in range(3)) != target:\n            return False\n        if sum(square[i][2-i] for i in range(3)) != target:\n            return False\n        return True\n\n    count = 0\n    for r in range(1, len(grid) - 1):\n        for c in range(1, len(grid[0]) - 1):\n            if grid[r][c] == 5:\n                subgrid = [grid[r-1][c-1:c+2], grid[r][c-1:c+2], grid[r+1][c-1:c+2]]\n                if set(map(sum, subgrid)) == {15} and is_magic(subgrid):\n                    count += 1\n    return count", "passed": false, "score": {"loc": 22, "tokens": 249, "cc": 11, "nest": 5, "execution_time": 10.0, "novelty": 0.7076663713443331}}, {"code": "def numMagicSquaresInside(grid):\n    def is_magic_square(subgrid):\n        if subgrid[1][1] != 5:\n            return False\n        nums = set(subgrid[i][j] for i in range(3) for j in range(3))\n        if len(nums) != 9 or 1 not in nums or 9 not in nums:\n            return False\n        return (sum(subgrid[i][j] for i in range(3)) == 15 for j in range(3)) and \\\n               (sum(subgrid[i][j] for i in range(3)) == 15 for i in range(3)) and \\\n               (subgrid[0][0] + subgrid[1][1] + subgrid[2][2] == 15) and \\\n               (subgrid[0][2] + subgrid[1][1] + subgrid[2][0] == 15)\n    \n    count = 0\n    rows, cols = len(grid), len(grid[0])\n    for i in range(rows - 2):\n        for j in range(cols - 2):\n            subgrid = [grid[i+x][j:y+3] for x, y in ((0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2))]\n            if is_magic_square(subgrid):\n                count += 1\n    return count", "passed": false, "score": {"loc": 19, "tokens": 322, "cc": 7, "nest": 4, "execution_time": 10.0, "novelty": 0.793867183713437}}, {"code": "def numMagicSquaresInside(grid):\n    rows, cols = len(grid), len(grid[0])\n    count = 0\n\n    def is_magic(subgrid):\n        magic_sum = sum(subgrid[0])\n        for row in subgrid:\n            if sum(row) != magic_sum:\n                return False\n        for col in range(3):\n            if sum(subgrid[row][col] for row in range(3)) != magic_sum:\n                return False\n        if sum(subgrid[i][i] for i in range(3)) != magic_sum:\n            return False\n        if sum(subgrid[i][2-i] for i in range(3)) != magic_sum:\n            return False\n        if 1 not in subgrid[0] or 2 not in subgrid[0] or 7 not in subgrid[0] or 6 not in subgrid[0] or 3 not in subgrid[0] or 8 not in subgrid[0] or 4 not in subgrid[0] or 5 not in subgrid[0]:\n            return False\n        return True\n\n    for i in range(rows - 2):\n        for j in range(cols - 2):\n            subgrid = [grid[i+k][j:j+3] for k in range(3)]\n            if is_magic(subgrid):\n                count += 1\n\n    return count", "passed": false, "score": {"loc": 24, "tokens": 263, "cc": 11, "nest": 4, "execution_time": 10.0, "novelty": 0.7112095036427336}}, {"code": "def numMagicSquaresInside(grid):\n    def is_magic(square):\n        if square[1] != 5:\n            return False\n        sums = {sum(square[i:i+3]) for i in (0, 3, 6)}\n        if len(sums) != 1:\n            return False\n        for i in range(3):\n            if sum(square[i::3]) != sums.pop():\n                return False\n        return True\n\n    count = 0\n    for i in range(len(grid) - 2):\n        for j in range(len(grid[0]) - 2):\n            square = [grid[i+k][j+l] for k in range(3) for l in range(3)]\n            if is_magic(square):\n                count += 1\n    return count", "passed": false, "score": {"loc": 18, "tokens": 163, "cc": 7, "nest": 4, "execution_time": 10.0, "novelty": 0.7326517268773844}}, {"code": "def numMagicSquaresInside(grid):\n    def is_magic(s):\n        if s[4] != 5 or 1 not in s or 9 not in s: return False\n        for i in range(3):\n            if sum(s[i*3:i*3+3]) != 15 or sum(s[j] for j in range(i, i+9, 3)) != 15: return False\n        return sum(s[::4]) == 15 and sum(s[2:8:2]) == 15\n    \n    count = 0\n    for i in range(len(grid) - 2):\n        for j in range(len(grid[0]) - 2):\n            s = set(grid[i+k][j:j+3] for k in range(3))\n            s = {num for row in s for num in row}\n            if len(s) == 9 and is_magic(s):\n                count += 1\n    return count", "passed": false, "score": {"loc": 14, "tokens": 205, "cc": 10, "nest": 4, "execution_time": 10.0, "novelty": 0.6632754401722656}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 8}
{"id": 15682, "entry_point": "numWays", "best_list": [{"code": "def numWays(s: str) -> int:\n    mod = 10**9 + 7\n    ones = s.count('1')\n    if ones % 3 != 0:\n        return 0\n    target = ones // 3\n    if target == 0:\n        return (len(s) - 1) * (len(s) - 2) // 2 % mod\n    i = j = k = -1\n    count = 0\n    for pos, char in enumerate(s):\n        if char == '1':\n            count += 1\n            if count == target and i == -1:\n                i = pos\n            elif count == 2 * target and j == -1:\n                j = pos\n            elif count == 3 * target:\n                k = pos\n                break\n    return (j - i) * (k - j) % mod", "passed": true, "score": {"loc": 21, "tokens": 165, "cc": 9, "nest": 6, "execution_time": 0.016599, "novelty": 0.6245125660048745}}, {"code": "def numWays(s):\n    count = s.count('1')\n    if count % 3 != 0:\n        return 0\n    if count == 0:\n        return (len(s) - 2) * (len(s) - 3) // 2 % (10**9 + 7)\n    ones_per_part = count // 3\n    first_part_end = s.index('1' * ones_per_part)\n    second_part_end = s.index('1' * ones_per_part, first_part_end + 1)\n    return (second_part_end - first_part_end) % (10**9 + 7)", "passed": false, "score": {"loc": 10, "tokens": 111, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.544326468278281}}, {"code": "def numWays(s):\n    ones = s.count('1')\n    if ones % 3 != 0:\n        return 0\n    \n    if ones == 0:\n        n = len(s) - 1\n        return (n * (n + 1) // 2) % (10**9 + 7)\n    \n    k = ones // 3\n    first = s.index('1') + 1\n    second = s.rindex('1') - 1\n    \n    count1 = 0\n    count2 = 0\n    \n    for i in range(first, second + 1):\n        if s[i] == '1':\n            count1 += 1\n    \n    for i in range(second, len(s) - 1):\n        if s[i] == '1':\n            count2 += 1\n    \n    return (count1 * count2) % (10**9 + 7)", "passed": false, "score": {"loc": 19, "tokens": 170, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.5699186479157932}}, {"code": "def numWays(s: str) -> int:\n    MOD = 10**9 + 7\n    ones = s.count('1')\n    if ones % 3 != 0:\n        return 0\n    if ones == 0:\n        return (len(s) - 2) * (len(s) - 3) // 2 % MOD\n    n = ones // 3\n    first = s.index('1') + s[s.index('1') + 1:].index('1') + 2\n    second = s.rindex('1') - s[:s.rindex('1') - 1].rindex('1') - 2\n    return first * second % MOD", "passed": false, "score": {"loc": 11, "tokens": 148, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.6174440915323832}}, {"code": "def numWays(s: str) -> int:\n    ones = s.count('1')\n    if ones % 3 != 0:\n        return 0\n    if ones == 0:\n        return (len(s) - 1) * (len(s) - 2) // 2 % 1_000_000_007\n    \n    part_ones = ones // 3\n    first_break = s.index('1' * part_ones) + part_ones\n    second_break = s.index('1' * part_ones, first_break) + part_ones\n    \n    return (second_break - first_break) * (len(s) - second_break) % 1_000_000_007", "passed": false, "score": {"loc": 10, "tokens": 113, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.5270367322431571}}, {"code": "def numWays(s):\n    MOD = 10**9 + 7\n    ones = s.count('1')\n    if ones % 3 != 0:\n        return 0\n    if ones == 0:\n        return (len(s) - 1) * (len(s) - 2) // 2 % MOD\n    target = ones // 3\n    first_cut = second_cut = -1\n    count = 0\n    for i, char in enumerate(s):\n        if char == '1':\n            count += 1\n            if count == target and first_cut == -1:\n                first_cut = i\n            elif count == 2 * target and second_cut == -1:\n                second_cut = i\n    return (second_cut - first_cut) * (len(s) - second_cut - 1) % MOD", "passed": false, "score": {"loc": 18, "tokens": 151, "cc": 8, "nest": 5, "execution_time": 10.0, "novelty": 0.5825617425961496}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 15727, "entry_point": "firstMissingPositive", "best_list": [{"code": "def firstMissingPositive(nums):\n    nums = set(nums)\n    i = 1\n    while True:\n        if i not in nums:\n            return i\n        i += 1", "passed": true, "score": {"loc": 7, "tokens": 30, "cc": 2, "nest": 3, "execution_time": 0.016752, "novelty": 0.6901115549533761}}, {"code": "def firstMissingPositive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1", "passed": true, "score": {"loc": 9, "tokens": 104, "cc": 5, "nest": 3, "execution_time": 0.016695, "novelty": 0.7260200178598106}}, {"code": "def firstMissingPositive(nums):\n    n = len(nums)\n    if 1 not in nums:\n        return 1\n    for i in range(n):\n        if nums[i] <= 0 or nums[i] > n:\n            nums[i] = 1\n    for i in range(n):\n        index = abs(nums[i]) - 1\n        nums[index] = -abs(nums[index])\n    for i in range(n):\n        if nums[i] > 0:\n            return i + 1\n    return n + 1", "passed": true, "score": {"loc": 14, "tokens": 106, "cc": 7, "nest": 3, "execution_time": 0.016821, "novelty": 0.45703058341569824}}, {"code": "def firstMissingPositive(nums):\n    n = len(nums)\n    if 1 not in nums:\n        return 1\n    \n    contains_one = 1 in nums\n    if not contains_one:\n        return 1\n    \n    nums = [0] + nums\n    n += 1\n    \n    for i in range(n):\n        if nums[i] <= 0 or nums[i] >= n:\n            nums[i] = n\n    \n    for i in range(1, n):\n        if abs(nums[i]) == n:\n            continue\n        index = abs(nums[i])\n        nums[index - 1] = -abs(nums[index - 1])\n    \n    for i in range(1, n):\n        if nums[i] > 0:\n            return i\n    \n    return n", "passed": false, "score": {"loc": 21, "tokens": 144, "cc": 9, "nest": 3, "execution_time": 10.0, "novelty": 0.7368973600630665}}], "num_pass": 9, "num_uniq": 6, "num_fail": 1, "fail_uniq": 1}
{"id": 15756, "entry_point": "findMinFibonacciNumbers", "best_list": [{"code": "def findMinFibonacciNumbers(k):\n    fibs = [1, 1]\n    while fibs[-1] < k:\n        fibs.append(fibs[-1] + fibs[-2])\n    \n    dp = [0] * (k + 1)\n    for i in range(1, k + 1):\n        dp[i] = min(dp[i - f] + 1 for f in fibs if f <= i)\n    \n    return dp[k]", "passed": true, "score": {"loc": 8, "tokens": 91, "cc": 2, "nest": 2, "execution_time": 0.016616, "novelty": 0.5179825417073001}}, {"code": "def findMinFibonacciNumbers(k):\n    fibs = [1, 1]\n    while fibs[-1] < k:\n        fibs.append(fibs[-1] + fibs[-2])\n    \n    count = 0\n    for f in reversed(fibs):\n        while k >= f:\n            k -= f\n            count += 1\n    return count", "passed": true, "score": {"loc": 10, "tokens": 65, "cc": 3, "nest": 3, "execution_time": 0.016588, "novelty": 0.3807999873179103}}, {"code": "def findMinFibonacciNumbers(k):\n    fibs = [1, 1]\n    while fibs[-1] < k:\n        fibs.append(fibs[-1] + fibs[-2])\n    count = 0\n    while k > 0:\n        count += k // fibs[-1]\n        k %= fibs[-1]\n        fibs.pop()\n    return count", "passed": true, "score": {"loc": 10, "tokens": 72, "cc": 2, "nest": 2, "execution_time": 0.016568, "novelty": 0.415936717343544}}, {"code": "def findMinFibonacciNumbers(k):\n    def generate_fibonacci(max_val):\n        fibs = [1, 1]\n        while fibs[-1] + fibs[-2] <= max_val:\n            fibs.append(fibs[-1] + fibs[-2])\n        return fibs\n    \n    fibs = generate_fibonacci(k)\n    count = 0\n    \n    while k > 0:\n        idx = bisect.bisect_right(fibs, k) - 1\n        k -= fibs[idx]\n        count += 1\n    \n    return count", "passed": false, "score": {"loc": 13, "tokens": 92, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.610071922272051}}, {"code": "def findMinFibonacciNumbers(k):\n    fibs = [0, 1]\n    while fibs[-1] < k:\n        fibs.append(fibs[-1] + fibs[-2])\n    \n    def helper(k):\n        if k == 0:\n            return 0\n        idx = bisect.bisect_right(fibs, k) - 1\n        return 1 + helper(k - fibs[idx])\n    \n    return helper(k)", "passed": false, "score": {"loc": 10, "tokens": 81, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5357733483109548}}, {"code": "def findMinFibonacciNumbers(k):\n    fibs = [0, 1]\n    while fibs[-1] < k:\n        fibs.append(fibs[-1] + fibs[-2])\n    fibs = fibs[:-1]\n    \n    count = 0\n    for num in reversed(fibs):\n        if num <= k:\n            k -= num\n            count += 1\n    return count", "passed": false, "score": {"loc": 11, "tokens": 73, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.425618667782649}}, {"code": "def findMinFibonacciNumbers(k):\n    fibs = [0, 1, 1]\n    while fibs[-1] < k:\n        fibs.append(fibs[-1] + fibs[-2])\n    \n    @cache\n    def dfs(n):\n        if n == 0:\n            return 0\n        return 1 + dfs(n - max(f for f in fibs if f <= n))\n    \n    return dfs(k)", "passed": false, "score": {"loc": 10, "tokens": 82, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5473916223342875}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 15774, "entry_point": "maxScoreSightseeingPair", "best_list": [{"code": "def maxScoreSightseeingPair(A):\n    max_i = A[0] + 0\n    max_score = 0\n    for j in range(1, len(A)):\n        max_score = max(max_score, max_i + A[j] - j)\n        max_i = max(max_i, A[j] + j)\n    return max_score", "passed": true, "score": {"loc": 7, "tokens": 60, "cc": 1, "nest": 2, "execution_time": 0.016558, "novelty": 0.37727735485533354}}, {"code": "def maxScoreSightseeingPair(A):\n    max_i = A[0] + 0\n    res = 0\n    for j in range(1, len(A)):\n        res = max(res, max_i + A[j] - j)\n        max_i = max(max_i, A[j] + j)\n    return res", "passed": true, "score": {"loc": 7, "tokens": 60, "cc": 1, "nest": 2, "execution_time": 0.016616, "novelty": 0.37552094817363213}}, {"code": "def maxScoreSightseeingPair(A):\n    res = 0\n    max_i_plus_A_i = A[0] + 0\n    for j in range(1, len(A)):\n        res = max(res, max_i_plus_A_i + A[j] - j)\n        max_i_plus_A_i = max(max_i_plus_A_i, A[j] + j)\n    return res", "passed": true, "score": {"loc": 7, "tokens": 60, "cc": 1, "nest": 2, "execution_time": 0.016642, "novelty": 0.3959959018800282}}, {"code": "def maxScoreSightseeingPair(A):\n    return reduce(lambda x, y: (x[0] + A[y[1]], y[1]), enumerate(A[1:]), (A[0] + 0, 0))[0]", "passed": false, "score": {"loc": 2, "tokens": 57, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6806971610618432}}], "num_pass": 9, "num_uniq": 6, "num_fail": 1, "fail_uniq": 1}
{"id": 15807, "entry_point": "maximalRectangle", "best_list": [{"code": "def maximalRectangle(matrix):\n    if not matrix:\n        return 0\n\n    max_area = 0\n    heights = [0] * (len(matrix[0]) + 1)\n    for row in matrix:\n        for j in range(len(matrix[0])):\n            heights[j] = heights[j] + 1 if row[j] == '1' else 0\n        stack = [-1]\n        for j in range(len(heights)):\n            while stack and heights[j] < heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = j - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(j)\n    return max_area", "passed": true, "score": {"loc": 16, "tokens": 147, "cc": 6, "nest": 4, "execution_time": 0.016788, "novelty": 0.6141157172768005}}, {"code": "def maximalRectangle(matrix):\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    heights = [0] * (n + 1)\n    max_area = 0\n    for i in range(m):\n        for j in range(n):\n            heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n        stack = [-1]\n        for k in range(n + 1):\n            while heights[k] < heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = k - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(k)\n    return max_area", "passed": true, "score": {"loc": 17, "tokens": 154, "cc": 5, "nest": 4, "execution_time": 0.016723, "novelty": 0.24450431419843377}}, {"code": "def maximalRectangle(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n\n    rows, cols = len(matrix), len(matrix[0])\n    heights = [0] * (cols + 1)\n    max_area = 0\n\n    for r in range(rows):\n        for c in range(cols):\n            heights[c] = heights[c] + 1 if matrix[r][c] == '1' else 0\n\n        stack = [-1]\n        for c in range(cols + 1):\n            while heights[c] < heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = c - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(c)\n\n    return max_area", "passed": true, "score": {"loc": 17, "tokens": 160, "cc": 6, "nest": 4, "execution_time": 0.016664, "novelty": 0.3556034098713138}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 15889, "entry_point": "sortString", "best_list": [{"code": "def sortString(s: str) -> str:\n    from collections import Counter\n    count = Counter(s)\n    result = []\n    while count:\n        for char in sorted(count):\n            result.append(char)\n            count[char] -= 1\n            if count[char] == 0:\n                del count[char]\n        for char in sorted(count, reverse=True):\n            result.append(char)\n            count[char] -= 1\n            if count[char] == 0:\n                del count[char]\n    return ''.join(result)", "passed": true, "score": {"loc": 16, "tokens": 110, "cc": 5, "nest": 4, "execution_time": 0.016732, "novelty": 0.30164624580691224}}, {"code": "def sortString(s: str) -> str:\n    from collections import Counter\n    c = Counter(s)\n    result = []\n    while c:\n        for char in sorted(c):\n            result.append(char)\n            c[char] -= 1\n            if c[char] == 0:\n                del c[char]\n        for char in sorted(c, reverse=True):\n            result.append(char)\n            c[char] -= 1\n            if c[char] == 0:\n                del c[char]\n    return ''.join(result)", "passed": true, "score": {"loc": 16, "tokens": 110, "cc": 5, "nest": 4, "execution_time": 0.016801, "novelty": 0.3149275212663174}}, {"code": "from collections import Counter\n\ndef sortString(s):\n    count = Counter(s)\n    result = []\n    reverse = False\n    \n    while count:\n        if reverse:\n            order = sorted(count.keys(), reverse=True)\n        else:\n            order = sorted(count.keys())\n        \n        for char in order:\n            result.append(char)\n            count[char] -= 1\n            if count[char] == 0:\n                del count[char]\n        \n        reverse = not reverse\n    \n    return ''.join(result)", "passed": true, "score": {"loc": 17, "tokens": 99, "cc": 4, "nest": 4, "execution_time": 0.016533, "novelty": 0.7310048331747063}}, {"code": "def sortString(s: str) -> str:\n    result = []\n    s_count = sorted(s)\n    while s_count:\n        for i in range(len(s_count)):\n            result.append(s_count[i])\n            s_count = s_count[:i] + s_count[i+1:]\n        for i in range(len(s_count) - 1, -1, -1):\n            result.append(s_count[i])\n            s_count = s_count[:i] + s_count[i+1:]\n    return ''.join(result)", "passed": false, "score": {"loc": 11, "tokens": 110, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6778302193314043}}, {"code": "def sortString(s):\n    result = []\n    count = [0] * 26\n    for char in s:\n        count[ord(char) - ord('a')] += 1\n    \n    while sum(count) > 0:\n        for i in range(26):\n            if count[i] > 0:\n                result.append(chr(i + ord('a')))\n                count[i] -= 1\n        for i in range(25, -1, -1):\n            if count[i] > 0:\n                result.append(chr(i + ord('a')))\n                count[i] -= 1\n    \n    return ''.join(result)", "passed": false, "score": {"loc": 15, "tokens": 139, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.6763917827936371}}, {"code": "def sortString(s: str) -> str:\n    count = [0] * 26\n    for char in s:\n        count[ord(char) - ord('a')] += 1\n    \n    result = []\n    while len(result) < len(s):\n        for i in range(26):\n            if count[i] > 0:\n                result.append(chr(ord('a') + i))\n                count[i] -= 1\n        for i in range(25, -1, -1):\n            if count[i] > 0:\n                result.append(chr(ord('a') + i))\n                count[i] -= 1\n    \n    return ''.join(result)", "passed": false, "score": {"loc": 15, "tokens": 147, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.7222886805687994}}], "num_pass": 7, "num_uniq": 5, "num_fail": 3, "fail_uniq": 3}
{"id": 15906, "entry_point": "peakIndexInMountainArray", "best_list": [{"code": "def peakIndexInMountainArray(arr):\n    return arr.index(max(arr))", "passed": true, "score": {"loc": 2, "tokens": 16, "cc": 0, "nest": 1, "execution_time": 0.016492, "novelty": 0.6332187823252464}}, {"code": "def peakIndexInMountainArray(arr):\n    for i in range(1, len(arr) - 1):\n        if arr[i - 1] < arr[i] > arr[i + 1]:\n            return i", "passed": true, "score": {"loc": 4, "tokens": 43, "cc": 2, "nest": 3, "execution_time": 0.016655, "novelty": 0.529584959897585}}, {"code": "def peakIndexInMountainArray(arr):\n    for i in range(1, len(arr) - 1):\n        if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n            return i", "passed": true, "score": {"loc": 4, "tokens": 48, "cc": 3, "nest": 3, "execution_time": 0.016426, "novelty": 0.5926252811449675}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 15974, "entry_point": "minRemoveToMakeValid", "best_list": [{"code": "def minRemoveToMakeValid(s):\n    stack = []\n    remove = set()\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                remove.add(i)\n    remove |= set(stack)\n    return ''.join(char for i, char in enumerate(s) if i not in remove)", "passed": true, "score": {"loc": 13, "tokens": 92, "cc": 4, "nest": 5, "execution_time": 0.016681, "novelty": 0.5130872717778234}}, {"code": "def minRemoveToMakeValid(s: str) -> str:\n    stack = []\n    result = list(s)\n    \n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                result[i] = ''\n    \n    for index in stack:\n        result[index] = ''\n    \n    return ''.join(result)", "passed": true, "score": {"loc": 14, "tokens": 90, "cc": 5, "nest": 5, "execution_time": 0.016666, "novelty": 0.5058715730477832}}, {"code": "def minRemoveToMakeValid(s):\n    stack = []\n    remove = set()\n    for i, c in enumerate(s):\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            if stack:\n                stack.pop()\n            else:\n                remove.add(i)\n    remove.update(stack)\n    return ''.join(c for i, c in enumerate(s) if i not in remove)\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "passed": true, "score": {"loc": 15, "tokens": 104, "cc": 4, "nest": 5, "execution_time": 0.016725, "novelty": 0.5531464302336059}}, {"code": "def minRemoveToMakeValid(s: str) -> str:\n    def validate(s: str) -> str:\n        stack = []\n        result = []\n        for char in s:\n            if char == '(':\n                stack.append(len(result))\n            elif char == ')' and stack:\n                result[stack.pop()] += char\n            elif char != ')':\n                result.append(char)\n        return ''.join(result)\n\n    return validate(s)", "passed": false, "score": {"loc": 13, "tokens": 100, "cc": 5, "nest": 6, "execution_time": 10.0, "novelty": 0.72426922494808}}, {"code": "def minRemoveToMakeValid(s: str) -> str:\n    result = []\n    open_count = 0\n    \n    for char in s:\n        if char == '(':\n            open_count += 1\n        elif char == ')':\n            if open_count > 0:\n                open_count -= 1\n                result.append(char)\n        else:\n            result.append(char)\n    \n    final_result = []\n    for char in reversed(result):\n        if char == '(' and open_count > 0:\n            open_count -= 1\n            continue\n        final_result.append(char)\n    \n    return ''.join(reversed(final_result))", "passed": false, "score": {"loc": 19, "tokens": 112, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.6115660430340883}}, {"code": "def minRemoveToMakeValid(s):\n    balance = 0\n    result = list(s)\n    open_indices = []\n    \n    for i, char in enumerate(s):\n        if char == '(':\n            open_indices.append(i)\n            balance += 1\n        elif char == ')':\n            if balance > 0:\n                balance -= 1\n            else:\n                result[i] = ''\n    \n    for i in open_indices:\n        if balance > 0:\n            balance -= 1\n        else:\n            result[i] = ''\n    \n    return ''.join(result)", "passed": false, "score": {"loc": 19, "tokens": 104, "cc": 6, "nest": 5, "execution_time": 10.0, "novelty": 0.6279026370006644}}, {"code": "def minRemoveToMakeValid(s: str) -> str:\n    balance = 0\n    result = []\n    for char in s:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            if balance > 0:\n                balance -= 1\n                result.append(char)\n        else:\n            result.append(char)\n    while balance > 0:\n        balance -= 1\n        result.pop()\n    return ''.join(result)\n\ndef _equivalent(lhs: str, rhs: str) -> bool:\n    return lhs == rhs", "passed": false, "score": {"loc": 18, "tokens": 108, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.6088283722375694}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 1641, "entry_point": "numOfSubarrays", "best_list": [{"code": "def numOfSubarrays(arr):\n    odd_count = 0\n    even_count = 1\n    total = 0\n    for num in arr:\n        if num % 2 == 0:\n            total += odd_count\n        else:\n            total += even_count\n            odd_count, even_count = even_count, odd_count + 1\n    return total % (10**9 + 7)", "passed": true, "score": {"loc": 11, "tokens": 58, "cc": 2, "nest": 3, "execution_time": 0.016501, "novelty": 0.4773888564349842}}, {"code": "def numOfSubarrays(arr):\n    MOD = 10**9 + 7\n    odd_count = prefix_sum = result = 0\n    \n    for num in arr:\n        prefix_sum += num\n        if prefix_sum % 2 == 0:\n            result = (result + odd_count) % MOD\n        else:\n            result = (result + 1 + odd_count) % MOD\n            odd_count += 1\n    \n    return result", "passed": true, "score": {"loc": 11, "tokens": 66, "cc": 2, "nest": 3, "execution_time": 0.016731, "novelty": 0.617943754966847}}, {"code": "def numOfSubarrays(arr):\n    count, prefix_sum, odd_count, even_count = 0, 0, 0, 1\n    for num in arr:\n        prefix_sum += num\n        if prefix_sum % 2 == 0:\n            count += odd_count\n            even_count += 1\n        else:\n            count += even_count\n            odd_count += 1\n    return count % (10**9 + 7)", "passed": true, "score": {"loc": 11, "tokens": 67, "cc": 2, "nest": 3, "execution_time": 0.016602, "novelty": 0.46284574501472386}}, {"code": "def numOfSubarrays(arr):\n    result, count, odd_count = 0, 0, 0\n    for num in arr:\n        count += num % 2\n        if count % 2 == 0:\n            odd_count += count // 2\n        else:\n            odd_count += (count + 1) // 2\n        result += odd_count\n        result %= 1000000007\n    return result", "passed": false, "score": {"loc": 11, "tokens": 66, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5573386449825395}}, {"code": "def numOfSubarrays(arr):\n    prefix_sums = [0]\n    for num in arr:\n        prefix_sums.append(prefix_sums[-1] + num)\n    \n    odd_count = 0\n    even_count = 0\n    result = 0\n    \n    for prefix_sum in prefix_sums:\n        if prefix_sum % 2 == 0:\n            even_count += 1\n        else:\n            result += even_count\n            odd_count += 1\n    \n    return result % (10**9 + 7)", "passed": false, "score": {"loc": 14, "tokens": 75, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.566006478681047}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 16032, "entry_point": "numTriplets", "best_list": [{"code": "def numTriplets(nums1, nums2):\n    def count_triplets(nums1, nums2):\n        count = 0\n        n = len(nums1)\n        m = len(nums2)\n        for i in range(n):\n            for j in range(m):\n                for k in range(j + 1, m):\n                    if nums1[i] * nums1[i] == nums2[j] * nums2[k]:\n                        count += 1\n        return count\n\n    return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)", "passed": true, "score": {"loc": 12, "tokens": 101, "cc": 4, "nest": 6, "execution_time": 0.016789, "novelty": 0.58541456763223}}, {"code": "def numTriplets(nums1, nums2):\n    def count_triplets(a, b):\n        count = 0\n        n, m = len(a), len(b)\n        for i in range(n):\n            target = a[i] ** 2\n            for j in range(m):\n                if b[j] > target:\n                    break\n                for k in range(j + 1, m):\n                    if b[k] > target // b[j]:\n                        break\n                    if b[j] * b[k] == target:\n                        count += 1\n        return count\n\n    return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)", "passed": true, "score": {"loc": 16, "tokens": 127, "cc": 6, "nest": 6, "execution_time": 0.01648, "novelty": 0.665334218259243}}, {"code": "def numTriplets(nums1, nums2):\n    def count_triplets(arr1, arr2):\n        count = 0\n        for i in range(len(arr1)):\n            target = arr1[i] ** 2\n            seen = {}\n            for j in range(len(arr2)):\n                if target % arr2[j] == 0:\n                    quotient = target // arr2[j]\n                    if quotient in seen:\n                        count += seen[quotient]\n                if arr2[j] not in seen:\n                    seen[arr2[j]] = 0\n                seen[arr2[j]] += 1\n        return count\n    \n    return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)", "passed": true, "score": {"loc": 16, "tokens": 130, "cc": 5, "nest": 6, "execution_time": 0.016502, "novelty": 0.669219175465187}}, {"code": "def numTriplets(nums1, nums2):\n    def count_pairs(nums1, nums2):\n        count = 0\n        num_dict = {}\n        for j in range(len(nums2)):\n            for k in range(j + 1, len(nums2)):\n                product = nums2[j] * nums2[k]\n                if product in num_dict:\n                    count += num_dict[product]\n        return count\n\n    return count_pairs(nums1, nums2) + count_pairs(nums2, nums1)", "passed": false, "score": {"loc": 11, "tokens": 88, "cc": 3, "nest": 5, "execution_time": 10.0, "novelty": 0.6172911063964195}}, {"code": "def numTriplets(nums1, nums2):\n    def count_triplets(a, b):\n        count = 0\n        n = len(a)\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    if a[i] * a[j] == b[k]:\n                        count += 1\n        return count\n\n    return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)", "passed": false, "score": {"loc": 11, "tokens": 94, "cc": 4, "nest": 6, "execution_time": 10.0, "novelty": 0.5240422094667292}}, {"code": "def numTriplets(nums1, nums2):\n    def countTriplets(arr1, arr2):\n        count = 0\n        n2 = len(arr2)\n        products = {}\n        for i in range(n2):\n            for j in range(i + 1, n2):\n                product = arr2[i] * arr2[j]\n                if product in products:\n                    count += products[product]\n                if arr2[i] % arr2[j] == 0:\n                    target = arr2[i] ** 2 // arr2[j]\n                    products[target] = products.get(target, 0) + 1\n        return count\n\n    return countTriplets(nums1, nums2) + countTriplets(nums2, nums1)", "passed": false, "score": {"loc": 15, "tokens": 132, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.6538315715565642}}, {"code": "def numTriplets(nums1, nums2):\n    def count_triplets(nums1, nums2):\n        count = 0\n        nums2.sort()\n        for num1 in nums1:\n            target = num1 * num1\n            left, right = 0, len(nums2) - 1\n            while left < right:\n                product = nums2[left] * nums2[right]\n                if product == target:\n                    count += right - left\n                    left += 1\n                elif product < target:\n                    left += 1\n                else:\n                    right -= 1\n        return count\n    \n    return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)", "passed": false, "score": {"loc": 18, "tokens": 109, "cc": 4, "nest": 6, "execution_time": 10.0, "novelty": 0.604270442572473}}, {"code": "def numTriplets(nums1, nums2):\n    def count_triplets(arr1, arr2):\n        count = 0\n        n1 = len(arr1)\n        n2 = len(arr2)\n        for i in range(n1):\n            target = arr1[i] ** 2\n            product_count = {}\n            for j in range(n2):\n                for k in range(j + 1, n2):\n                    product = arr2[j] * arr2[k]\n                    if product == target:\n                        count += product_count.get((arr2[j], arr2[k]), 0)\n                    product_count[(arr2[j], arr2[k])] = product_count.get((arr2[j], arr2[k]), 0) + 1\n        return count\n    \n    return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)", "passed": false, "score": {"loc": 16, "tokens": 161, "cc": 4, "nest": 6, "execution_time": 10.0, "novelty": 0.6877746874737027}}], "num_pass": 4, "num_uniq": 4, "num_fail": 6, "fail_uniq": 6}
{"id": 16043, "entry_point": "candy", "best_list": [{"code": "def candy(ratings):\n    n = len(ratings)\n    candies = [1] * n\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n    return sum(candies)", "passed": true, "score": {"loc": 10, "tokens": 110, "cc": 4, "nest": 3, "execution_time": 0.016553, "novelty": 0.04913266243744885}}, {"code": "def candy(ratings):\n    n = len(ratings)\n    candies = [1] * n\n    for i in range(n - 1):\n        if ratings[i + 1] > ratings[i]:\n            candies[i + 1] = candies[i] + 1\n    for i in range(n - 1, 0, -1):\n        if ratings[i - 1] > ratings[i]:\n            candies[i - 1] = max(candies[i - 1], candies[i] + 1)\n    return sum(candies)", "passed": true, "score": {"loc": 10, "tokens": 111, "cc": 4, "nest": 3, "execution_time": 0.016676, "novelty": 0.507936644696219}}, {"code": "def candy(ratings):\n    n = len(ratings)\n    if n == 0:\n        return 0\n    \n    candies = [1] * n\n    \n    # Left to right pass\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n    \n    # Right to left pass\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n    \n    return sum(candies)", "passed": true, "score": {"loc": 14, "tokens": 128, "cc": 5, "nest": 3, "execution_time": 0.016771, "novelty": 0.6110754826344802}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 16069, "entry_point": "lastStoneWeightII", "best_list": [{"code": "def lastStoneWeightII(stones):\n    total_sum = sum(stones)\n    target = total_sum // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for stone in stones:\n        for j in range(target, stone - 1, -1):\n            dp[j] = dp[j] or dp[j - stone]\n    \n    return total_sum - 2 * max(i for i, x in enumerate(dp) if x)", "passed": true, "score": {"loc": 9, "tokens": 91, "cc": 3, "nest": 3, "execution_time": 0.016564, "novelty": 0.08380894917747084}}, {"code": "def lastStoneWeightII(stones):\n    total = sum(stones)\n    target = total // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for stone in stones:\n        for j in range(target, stone - 1, -1):\n            dp[j] = dp[j] or dp[j - stone]\n    \n    return total - 2 * max(i for i, x in enumerate(dp) if x)", "passed": true, "score": {"loc": 9, "tokens": 91, "cc": 3, "nest": 3, "execution_time": 0.016746, "novelty": 0.08496920642455918}}, {"code": "def lastStoneWeightII(stones):\n    total_sum = sum(stones)\n    half_sum = total_sum // 2\n    dp = [False] * (half_sum + 1)\n    dp[0] = True\n    \n    for stone in stones:\n        for j in range(half_sum, stone - 1, -1):\n            dp[j] = dp[j] or dp[j - stone]\n    \n    return total_sum - 2 * max(i for i in range(half_sum + 1) if dp[i])", "passed": true, "score": {"loc": 9, "tokens": 94, "cc": 3, "nest": 3, "execution_time": 0.016682, "novelty": 0.31911251912268335}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 16077, "entry_point": "getPermutation", "best_list": [{"code": "from math import factorial\n\ndef getPermutation(n, k):\n    numbers = list(range(1, n + 1))\n    k -= 1\n    result = []\n    for i in range(n, 0, -1):\n        idx, k = divmod(k, factorial(i - 1))\n        result.append(numbers.pop(idx))\n    return ''.join(map(str, result))", "passed": true, "score": {"loc": 9, "tokens": 85, "cc": 1, "nest": 2, "execution_time": 0.016664, "novelty": 0.5550059663884459}}, {"code": "def getPermutation(n: int, k: int) -> str:\n    from math import factorial as fact\n\n    def get_kth_perm(numbers, k):\n        if len(numbers) == 1:\n            return numbers[0]\n        group_size = fact(len(numbers) - 1)\n        group_index = (k - 1) // group_size\n        remainder = k - group_index * group_size\n        return numbers[group_index] + get_kth_perm(numbers[:group_index] + numbers[group_index + 1:], remainder)\n\n    return get_kth_perm(list(map(str, range(1, n + 1))), k)", "passed": true, "score": {"loc": 10, "tokens": 117, "cc": 1, "nest": 3, "execution_time": 0.016686, "novelty": 0.7760468590351529}}, {"code": "import math\n\ndef getPermutation(n, k):\n    k -= 1\n    nums = list(range(1, n + 1))\n    result = []\n    for i in range(n, 0, -1):\n        fact = math.factorial(i - 1)\n        index = k // fact\n        k %= fact\n        result.append(str(nums.pop(index)))\n    return ''.join(result)", "passed": true, "score": {"loc": 11, "tokens": 86, "cc": 1, "nest": 2, "execution_time": 0.016755, "novelty": 0.5529741342088352}}, {"code": "import math\n\ndef getPermutation(n, k):\n    def get_permutation(nums, k):\n        if len(nums) == 1:\n            return nums[0]\n        \n        factor = math.factorial(len(nums) - 1)\n        index = (k - 1) // factor\n        \n        return nums[index] + get_permutation(nums[:index] + nums[index + 1:], k - index * factor)\n    \n    return get_permutation(list(range(1, n + 1)), k)", "passed": false, "score": {"loc": 9, "tokens": 100, "cc": 1, "nest": 3, "execution_time": 10.0, "novelty": 0.7318000179586771}}, {"code": "def getPermutation(n, k):\n    def factorial(num):\n        if num == 0:\n            return 1\n        result = 1\n        for i in range(2, num + 1):\n            result *= i\n        return result\n\n    def get_permutation(n, k, nums):\n        if n == 0:\n            return \"\"\n        index = (k - 1) // factorial(n - 1)\n        result = nums[index]\n        nums.remove(result)\n        return result + get_permutation(n - 1, k - index * factorial(n - 1), nums)\n\n    nums = list(range(1, n + 1))\n    return get_permutation(n, k, nums)", "passed": false, "score": {"loc": 17, "tokens": 133, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7899806851498898}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 16086, "entry_point": "maxCandies", "best_list": [{"code": "def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    collected_keys = set()\n    open_boxes = set(initialBoxes)\n    closed_boxes = set()\n    total_candies = 0\n\n    while open_boxes:\n        new_open_boxes = set()\n        for box in open_boxes:\n            if status[box] == 1 or box in collected_keys:\n                total_candies += candies[box]\n                for key in keys[box]:\n                    collected_keys.add(key)\n                for new_box in containedBoxes[box]:\n                    new_open_boxes.add(new_box)\n        open_boxes = new_open_boxes\n\n    return total_candies", "passed": true, "score": {"loc": 16, "tokens": 99, "cc": 6, "nest": 5, "execution_time": 0.01681, "novelty": 0.5358303372266341}}, {"code": "def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    collected_keys = set()\n    found_boxes = set(initialBoxes)\n    total_candies = 0\n    \n    while True:\n        new_boxes = set()\n        for box in found_boxes:\n            if (status[box] == 1 or box in collected_keys):\n                total_candies += candies[box]\n                for key in keys[box]:\n                    collected_keys.add(key)\n                for new_box in containedBoxes[box]:\n                    new_boxes.add(new_box)\n        if not new_boxes:\n            break\n        found_boxes = new_boxes\n    \n    return total_candies", "passed": true, "score": {"loc": 17, "tokens": 101, "cc": 7, "nest": 5, "execution_time": 0.017361, "novelty": 0.48379926191050693}}, {"code": "def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    collected_boxes = set(initialBoxes)\n    collected_keys = set()\n    total_candies = 0\n    opened_boxes = set()\n\n    while collected_boxes or opened_boxes:\n        new_boxes = set()\n        for box in collected_boxes | opened_boxes:\n            if box in opened_boxes:\n                continue\n            if status[box] == 1 or box in collected_keys:\n                total_candies += candies[box]\n                collected_keys.update(keys[box])\n                new_boxes.update(containedBoxes[box])\n                opened_boxes.add(box)\n        if not new_boxes:\n            break\n        collected_boxes = new_boxes\n\n    return total_candies", "passed": true, "score": {"loc": 19, "tokens": 110, "cc": 7, "nest": 4, "execution_time": 0.016793, "novelty": 0.6710777900606077}}, {"code": "def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    def dfs(boxes, collected_keys, open_boxes):\n        total_candies = 0\n        new_boxes = set()\n        for box in boxes:\n            if box in open_boxes or status[box] == 1:\n                total_candies += candies[box]\n                for key in keys[box]:\n                    collected_keys.add(key)\n                new_boxes.update(containedBoxes[box])\n            else:\n                new_boxes.add(box)\n        if not new_boxes:\n            return total_candies\n        return total_candies + dfs(new_boxes, collected_keys, collected_keys | new_boxes)\n    return dfs(set(initialBoxes), set(), set())", "passed": false, "score": {"loc": 16, "tokens": 123, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.7669331536070995}}, {"code": "def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    collected_boxes = set(initialBoxes)\n    collected_keys = set()\n    total_candies = 0\n\n    while collected_boxes:\n        new_boxes = set()\n        for box in collected_boxes:\n            if status[box] == 1 or box in collected_keys:\n                total_candies += candies[box]\n                new_boxes.update(containedBoxes[box])\n                for key in keys[box]:\n                    collected_keys.add(key)\n                collected_boxes.remove(box)\n        if new_boxes == collected_boxes:\n            break\n        collected_boxes.update(new_boxes)\n\n    return total_candies", "passed": false, "score": {"loc": 17, "tokens": 105, "cc": 6, "nest": 5, "execution_time": 10.0, "novelty": 0.5860162926954873}}, {"code": "def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    collected = 0\n    available_boxes = initialBoxes[:]\n    collected_keys = set()\n    all_boxes = set(range(len(status)))\n\n    while available_boxes:\n        new_boxes = []\n        for box in available_boxes:\n            if status[box] == 1 or box in collected_keys:\n                collected += candies[box]\n                collected_keys.update(keys[box])\n                new_boxes.extend(containedBoxes[box])\n            else:\n                new_boxes.append(box)\n        available_boxes = list(set(new_boxes) & all_boxes)\n\n    return collected", "passed": false, "score": {"loc": 16, "tokens": 111, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.6446909257428708}}, {"code": "from collections import deque\n\ndef maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    queue = deque(initialBoxes)\n    visited_boxes = set(initialBoxes)\n    collected_keys = set()\n    total_candies = 0\n    \n    while queue:\n        box = queue.popleft()\n        if status[box] == 1 or box in collected_keys:\n            total_candies += candies[box]\n            for next_box in containedBoxes[box]:\n                if next_box not in visited_boxes:\n                    visited_boxes.add(next_box)\n                    queue.append(next_box)\n            for key in keys[box]:\n                collected_keys.add(key)\n        else:\n            queue.append(box)\n    \n    return total_candies", "passed": false, "score": {"loc": 19, "tokens": 118, "cc": 6, "nest": 5, "execution_time": 10.0, "novelty": 0.666496564501501}}, {"code": "def maxCandies(status, candies, keys, containedBoxes, initialBoxes):\n    dp = [0] * len(status)\n    visited = set()\n    queue = initialBoxes[:]\n    while queue:\n        box = queue.pop()\n        if box in visited:\n            continue\n        visited.add(box)\n        dp[box] = candies[box]\n        for next_box in containedBoxes[box]:\n            queue.append(next_box)\n        for key in keys[box]:\n            status[key] = 1\n    return sum(dp)", "passed": false, "score": {"loc": 15, "tokens": 99, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.6886562012204334}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 16114, "entry_point": "arrayNesting", "best_list": [{"code": "def arrayNesting(A):\n    visited = set()\n    max_length = 0\n    for i in range(len(A)):\n        if i not in visited:\n            length = 0\n            while A[i] not in visited:\n                visited.add(A[i])\n                i = A[i]\n                length += 1\n            max_length = max(max_length, length)\n    return max_length", "passed": true, "score": {"loc": 12, "tokens": 72, "cc": 3, "nest": 4, "execution_time": 0.016729, "novelty": 0.43140911705000606}}, {"code": "def arrayNesting(A):\n    visited = set()\n    max_length = 0\n\n    for i in range(len(A)):\n        if i not in visited:\n            current_length = 0\n            x = i\n            while x not in visited:\n                visited.add(x)\n                x = A[x]\n                current_length += 1\n            max_length = max(max_length, current_length)\n\n    return max_length", "passed": true, "score": {"loc": 13, "tokens": 69, "cc": 3, "nest": 4, "execution_time": 0.016699, "novelty": 0.35425103522906043}}, {"code": "def arrayNesting(A):\n    visited = [False] * len(A)\n    longest = 0\n\n    for i in range(len(A)):\n        if not visited[i]:\n            length = 0\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                x = A[x]\n                length += 1\n            longest = max(longest, length)\n\n    return longest", "passed": true, "score": {"loc": 13, "tokens": 76, "cc": 3, "nest": 4, "execution_time": 0.016531, "novelty": 0.3620338231442938}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 16146, "entry_point": "mincostToHireWorkers", "best_list": [{"code": "from heapq import heappush, heappop\n\ndef mincostToHireWorkers(quality, wage, K):\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    min_cost = float('inf')\n    heap = []\n    \n    for ratio, q in workers:\n        total_quality += q\n        heappush(heap, -q)\n        if len(heap) > K:\n            total_quality += heappop(heap)\n        if len(heap) == K:\n            min_cost = min(min_cost, total_quality * ratio)\n    \n    return min_cost", "passed": true, "score": {"loc": 14, "tokens": 108, "cc": 3, "nest": 3, "execution_time": 0.016475, "novelty": 0.2766803634066801}}, {"code": "def mincostToHireWorkers(quality, wage, K):\n    from heapq import nlargest, heappush, heappop\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    max_quality_heap = []\n    min_cost = float('inf')\n    \n    for ratio, q in workers:\n        total_quality += q\n        heappush(max_quality_heap, -q)\n        \n        if len(max_quality_heap) > K:\n            total_quality += heappop(max_quality_heap)\n        \n        if len(max_quality_heap) == K:\n            min_cost = min(min_cost, total_quality * ratio)\n    \n    return min_cost", "passed": true, "score": {"loc": 14, "tokens": 110, "cc": 3, "nest": 3, "execution_time": 0.016532, "novelty": 0.5970033542480325}}, {"code": "import heapq\n\ndef mincostToHireWorkers(quality, wage, K):\n    unit_rates = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    min_cost = float('inf')\n    heap = []\n    \n    for rate, q in unit_rates:\n        total_quality += q\n        heapq.heappush(heap, -q)\n        if len(heap) > K:\n            total_quality += heapq.heappop(heap)\n        if len(heap) == K:\n            min_cost = min(min_cost, total_quality * rate)\n    \n    return min_cost if min_cost != float('inf') else -1", "passed": true, "score": {"loc": 14, "tokens": 121, "cc": 3, "nest": 3, "execution_time": 0.016562, "novelty": 0.2988757268370512}}, {"code": "from typing import List\n\ndef mincostToHireWorkers(quality: List[int], wage: List[int], K: int) -> float:\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    heap = []\n    cost = float('inf')\n    \n    for ratio, q in workers:\n        total_quality += q\n        heapq.heappush(heap, -q)\n        if len(heap) > K:\n            total_quality += heapq.heappop(heap)\n        if len(heap) == K:\n            cost = min(cost, total_quality * ratio)\n    \n    return cost", "passed": false, "score": {"loc": 14, "tokens": 125, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.269931024428431}}, {"code": "def mincostToHireWorkers(quality, wage, K):\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    quality_sum = 0\n    heap = []\n    min_cost = float('inf')\n    for ratio, q in workers:\n        quality_sum += q\n        heapq.heappush(heap, -q)\n        if len(heap) > K:\n            quality_sum += heapq.heappop(heap)\n        if len(heap) == K:\n            min_cost = min(min_cost, quality_sum * ratio)\n    return min_cost", "passed": false, "score": {"loc": 13, "tokens": 106, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.30090674448849764}}, {"code": "from heapq import nsmallest\n\ndef mincostToHireWorkers(quality, wage, K):\n    workers = sorted((wage / quality, quality) for wage, quality in zip(wage, quality))\n    total_quality = 0\n    max_heap = []\n    result = float('inf')\n    \n    for ratio, q in workers:\n        total_quality += q\n        nsmallest(K - 1, max_heap, key=lambda x: -x[0])\n        if len(max_heap) == K:\n            result = min(result, ratio * total_quality)\n            total_quality -= -heappop(max_heap)[0]\n    \n    return result if result != float('inf') else 0", "passed": false, "score": {"loc": 13, "tokens": 126, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.4227835624385484}}, {"code": "def mincostToHireWorkers(quality, wage, K):\n    unit_rates = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    max_heap = []\n    min_cost = float('inf')\n    \n    for rate, q in unit_rates:\n        total_quality += q\n        heapq.heappush(max_heap, -q)\n        if len(max_heap) > K:\n            total_quality += heapq.heappop(max_heap)\n        if len(max_heap) == K:\n            min_cost = min(min_cost, total_quality * rate)\n    \n    return min_cost", "passed": false, "score": {"loc": 13, "tokens": 106, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.22069749515563541}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 16248, "entry_point": "plusOne", "best_list": [{"code": "def plusOne(digits):\n    return list(map(int, str(int(''.join(map(str, digits))) + 1)))", "passed": true, "score": {"loc": 2, "tokens": 35, "cc": 0, "nest": 1, "execution_time": 0.016581, "novelty": 0.7619041842160288}}, {"code": "def plusOne(digits):\n    for i in range(len(digits) - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    return [1] + digits", "passed": true, "score": {"loc": 7, "tokens": 54, "cc": 2, "nest": 3, "execution_time": 0.016624, "novelty": 0.474401367853321}}, {"code": "def plusOne(digits):\n    carry = 1\n    for i in range(len(digits) - 1, -1, -1):\n        carry, digits[i] = divmod(digits[i] + carry, 10)\n    if carry:\n        digits.insert(0, 1)\n    return digits", "passed": true, "score": {"loc": 7, "tokens": 59, "cc": 2, "nest": 2, "execution_time": 0.016718, "novelty": 0.509750595996691}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 16283, "entry_point": "longestCommonPrefix", "best_list": [{"code": "def longestCommonPrefix(strs):\n    if not strs:\n        return \"\"\n    min_len = min(len(s) for s in strs)\n    for i in range(min_len):\n        if not all(s[i] == strs[0][i] for s in strs):\n            return strs[0][:i]\n    return strs[0][:min_len]", "passed": true, "score": {"loc": 8, "tokens": 75, "cc": 3, "nest": 3, "execution_time": 0.016711, "novelty": 0.693937269072228}}, {"code": "def longestCommonPrefix(strs):\n    if not strs:\n        return \"\"\n    shortest = min(strs, key=len)\n    for i, char in enumerate(shortest):\n        for other in strs:\n            if other[i] != char:\n                return shortest[:i]\n    return shortest", "passed": true, "score": {"loc": 9, "tokens": 55, "cc": 4, "nest": 4, "execution_time": 0.01689, "novelty": 0.5996110392239158}}, {"code": "def longestCommonPrefix(strs):\n    if not strs:\n        return \"\"\n    \n    prefix = strs[0]\n    for i in range(1, len(strs)):\n        while strs[i].find(prefix) != 0:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    return prefix", "passed": true, "score": {"loc": 10, "tokens": 63, "cc": 4, "nest": 4, "execution_time": 0.0167, "novelty": 0.2282161605916001}}, {"code": "def longestCommonPrefix(strs):\n    if not strs:\n        return \"\"\n    return min(strs, key=len) and all(s.startswith(min(strs, key=len)) for s in strs)", "passed": false, "score": {"loc": 4, "tokens": 43, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.7290499551806748}}], "num_pass": 9, "num_uniq": 3, "num_fail": 1, "fail_uniq": 1}
{"id": 16321, "entry_point": "primePalindrome", "best_list": [{"code": "def primePalindrome(N):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    while N < 10**8:\n        if is_prime(N) and is_palindrome(N):\n            return N\n        N += 1", "passed": true, "score": {"loc": 14, "tokens": 99, "cc": 6, "nest": 4, "execution_time": 0.016762, "novelty": 0.5021492860813619}}, {"code": "def primePalindrome(N):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    while N <= 10**8:\n        if is_prime(N) and is_palindrome(N):\n            return N\n        N += 1", "passed": true, "score": {"loc": 14, "tokens": 100, "cc": 6, "nest": 4, "execution_time": 0.016721, "novelty": 0.4992954397436862}}, {"code": "def primePalindrome(N):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    while True:\n        if N <= 11 and is_prime(N) and is_palindrome(N):\n            return N\n        N += 1\n        if 10**7 <= N < 10**8:\n            N = 10**8", "passed": true, "score": {"loc": 16, "tokens": 119, "cc": 7, "nest": 4, "execution_time": 0.016664, "novelty": 0.551412736362664}}, {"code": "def primePalindrome(N):\n    def is_prime(x):\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n\n    if N <= 2:\n        return 2\n    if 2 < N < 10:\n        return 11\n    if N < 100:\n        return 101\n\n    # Check numbers of length 2m and 2m+1\n    for m in range(1, 5):\n        for i in range(10**(m-1), 10**m):\n            s = str(i)\n            num = int(s + s[-2::-1])\n            if num >= N and is_prime(num):\n                return num\n            num = int(s + s[::-1])\n            if num >= N and is_prime(num):\n                return num", "passed": false, "score": {"loc": 26, "tokens": 200, "cc": 12, "nest": 4, "execution_time": 10.0, "novelty": 0.6890562625865891}}, {"code": "def primePalindrome(N: int) -> int:\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    n = N\n    while True:\n        if n >= 10**8:\n            n = 10**8\n        if n == reverse := int(str(n)[::-1]) and is_prime(n):\n            return n\n        n += 1", "passed": false, "score": {"loc": 17, "tokens": 136, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.9682295244272019}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 16353, "entry_point": "dayOfTheWeek", "best_list": [{"code": "def dayOfTheWeek(day, month, year):\n    if month < 3:\n        month += 12\n        year -= 1\n    K = year % 100\n    J = year // 100\n    f = day + 13 * (month + 1) // 5 + K + K // 4 + J // 4 - 2 * J\n    return [\"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"][f % 7]", "passed": true, "score": {"loc": 8, "tokens": 99, "cc": 1, "nest": 2, "execution_time": 0.01675, "novelty": 0.7722477166785747}}, {"code": "def dayOfTheWeek(day: int, month: int, year: int) -> str:\n    days_of_week = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    weekdays = (\"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n    t = (0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4)\n    y, m = year, month\n    if m < 3:\n        m += 12\n        y -= 1\n    h = (y + y // 4 - y // 100 + y // 400 + t[m - 1] + day) % 7\n    return days_of_week[h]", "passed": true, "score": {"loc": 10, "tokens": 164, "cc": 1, "nest": 2, "execution_time": 0.01676, "novelty": 0.7095094566780872}}, {"code": "def dayOfTheWeek(day, month, year):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    base_date = [1, 1, 1971]\n    base_day = 3  # 1971-01-01 was a Wednesday\n\n    def days_between_dates(date1, date2):\n        y1, m1, d1 = date1\n        y2, m2, d2 = date2\n        days_per_year = 365 + (y1 % 4 == 0 and y1 % 100 != 0 or y1 % 400 == 0)\n        days_per_month = [0, 31, 28 + (y1 % 4 == 0 and y1 % 100 != 0 or y1 % 400 == 0), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        return (days_per_year * (y2 - y1) + sum(days_per_month[m] for m in range(1, m2)) + d2 - d1)\n\n    days_diff = days_between_dates(base_date, [year, month, day])\n    return days[(base_day + days_diff) % 7]", "passed": true, "score": {"loc": 12, "tokens": 218, "cc": 4, "nest": 2, "execution_time": 0.01674, "novelty": 0.7451792360958537}}, {"code": "def dayOfTheWeek(day, month, year):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    month_offsets = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n        month_offsets[2] = 29\n    start_day = 5  # 1971-01-01 was a Friday\n    total_days = sum(month_offsets[:month]) + day + start_day - 1\n    return days[total_days % 7]", "passed": false, "score": {"loc": 8, "tokens": 137, "cc": 3, "nest": 2, "execution_time": 10.0, "novelty": 0.6351153785284123}}, {"code": "def dayOfTheWeek(day, month, year):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    def is_leap(year):\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n    \n    days_passed = 0\n    \n    for y in range(1971, year):\n        days_passed += 366 if is_leap(y) else 365\n    \n    for m in range(1, month):\n        days_passed += month_days[m - 1]\n        if m == 2 and is_leap(year):\n            days_passed += 1\n    \n    days_passed += day - 1\n    \n    return days[days_passed % 7]", "passed": false, "score": {"loc": 14, "tokens": 168, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.6712183336135245}}, {"code": "def dayOfTheWeek(day: int, month: int, year: int) -> str:\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    if year < 1971 or year > 2100:\n        raise ValueError(\"Year must be between 1971 and 2100\")\n    if month < 1 or month > 12:\n        raise ValueError(\"Month must be between 1 and 12\")\n    if day < 1 or day > 31:\n        raise ValueError(\"Day must be between 1 and 31\")\n    \n    def is_leap_year(year: int) -> bool:\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n    \n    days_in_month = [31, 28 if is_leap_year(year) else 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if day > days_in_month[month - 1]:\n        raise ValueError(\"Invalid day for the given month and year\")\n    \n    days_count = sum(days_in_month[:month - 1]) + day\n    start_day = 3  # 1971-01-01 was a Thursday\n    return days[(days_count + start_day) % 7]", "passed": false, "score": {"loc": 16, "tokens": 245, "cc": 9, "nest": 2, "execution_time": 10.0, "novelty": 0.7833877390285828}}, {"code": "import datetime\n\ndef dayOfTheWeek(day: int, month: int, year: int) -> str:\n    return [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"][datetime.date(year, month, day).weekday()]", "passed": false, "score": {"loc": 3, "tokens": 67, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7108912324307975}}, {"code": "def dayOfTheWeek(day, month, year):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    def is_leap_year(year):\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n    \n    def days_since_1971(year, month, day):\n        months = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        if is_leap_year(year):\n            months[2] = 29\n        days_passed = 0\n        for y in range(1971, year):\n            days_passed += 366 if is_leap_year(y) else 365\n        for m in range(1, month):\n            days_passed += months[m]\n        days_passed += day\n        return days_passed\n    \n    return days[days_since_1971(year, month, day) % 7]", "passed": false, "score": {"loc": 16, "tokens": 182, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.7071107327088159}}], "num_pass": 4, "num_uniq": 4, "num_fail": 6, "fail_uniq": 6}
{"id": 16402, "entry_point": "minSwap", "best_list": [{"code": "def minSwap(A, B):\n    n = len(A)\n    dp = [1, 0]\n    for i in range(1, n):\n        dp0, dp1 = float('inf'), float('inf')\n        if A[i] > A[i - 1] and B[i] > B[i - 1]:\n            dp0 = dp[0]\n            dp1 = dp[1] + 1\n        if A[i] > B[i - 1] and B[i] > A[i - 1]:\n            dp0 = min(dp0, dp[1])\n            dp1 = min(dp1, dp[0] + 1)\n        dp = [dp0, dp1]\n    return min(dp)", "passed": true, "score": {"loc": 13, "tokens": 148, "cc": 5, "nest": 3, "execution_time": 0.016633, "novelty": 0.7814457317706051}}, {"code": "def minSwap(A, B):\n    n = len(A)\n    swap = [1] * n\n    no_swap = [0] * n\n    no_swap[0] = 0\n    swap[0] = 1\n\n    for i in range(1, n):\n        if A[i] > A[i - 1] and B[i] > B[i - 1]:\n            no_swap[i] = no_swap[i - 1]\n            swap[i] = swap[i - 1] + 1\n        if A[i] > B[i - 1] and B[i] > A[i - 1]:\n            no_swap[i] = min(no_swap[i], swap[i - 1])\n            swap[i] = min(swap[i], no_swap[i - 1] + 1)\n\n    return min(no_swap[-1], swap[-1])", "passed": false, "score": {"loc": 14, "tokens": 179, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.3097292551702834}}, {"code": "def minSwap(A, B):\n    n = len(A)\n    swap = [1] * n\n    no_swap = [0] * n\n    \n    for i in range(1, n):\n        if A[i] > A[i - 1] and B[i] > B[i - 1]:\n            swap[i] = swap[i - 1] + 1\n            no_swap[i] = no_swap[i - 1]\n        if A[i] > B[i - 1] and B[i] > A[i - 1]:\n            swap[i] = min(swap[i], no_swap[i - 1] + 1)\n            no_swap[i] = min(no_swap[i], swap[i - 1])\n    \n    return min(swap[-1], no_swap[-1])", "passed": false, "score": {"loc": 12, "tokens": 167, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.26000766874359327}}, {"code": "def minSwap(A, B):\n    n = len(A)\n    swap = [1] * n\n    no_swap = [0] * n\n    swap[0] = 1\n    for i in range(1, n):\n        if A[i] > A[i - 1] and B[i] > B[i - 1]:\n            swap[i] = swap[i - 1] + 1\n            no_swap[i] = no_swap[i - 1]\n        if A[i] > B[i - 1] and B[i] > A[i - 1]:\n            swap[i] = min(swap[i], no_swap[i - 1] + 1)\n            no_swap[i] = min(no_swap[i], swap[i - 1])\n    return min(swap[-1], no_swap[-1])", "passed": false, "score": {"loc": 13, "tokens": 173, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.2525726605830303}}, {"code": "def minSwap(A, B):\n    n = len(A)\n    swap = [1] * n\n    noswap = [0] * n\n    swap[0] = 1\n    noswap[0] = 0\n    \n    for i in range(1, n):\n        if A[i] > A[i-1] and B[i] > B[i-1]:\n            swap[i] = swap[i-1] + 1\n            noswap[i] = noswap[i-1]\n        if A[i] > B[i-1] and B[i] > A[i-1]:\n            swap[i] = min(swap[i], noswap[i-1] + 1)\n            noswap[i] = min(noswap[i], swap[i-1])\n    \n    return min(swap[-1], noswap[-1])", "passed": false, "score": {"loc": 14, "tokens": 179, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.24783049680191815}}, {"code": "def minSwap(A, B):\n    n = len(A)\n    swap = 1\n    no_swap = 0\n    for i in range(1, n):\n        if A[i] <= A[i - 1] or B[i] <= B[i - 1]:\n            swap, no_swap = no_swap + 1, swap\n        else:\n            swap, no_swap = swap + 1, no_swap + 1\n    return min(swap, no_swap)", "passed": false, "score": {"loc": 10, "tokens": 86, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5403680419253347}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 6}
{"id": 16426, "entry_point": "findShortestSubArray", "best_list": [{"code": "def findShortestSubArray(nums):\n    degree = max(nums.count(x) for x in set(nums))\n    left, right = {}, {}\n    for i, x in enumerate(nums):\n        if x not in left:\n            left[x] = i\n        right[x] = i\n    return min(right[x] - left[x] + 1 for x in set(nums) if nums.count(x) == degree)", "passed": true, "score": {"loc": 8, "tokens": 93, "cc": 2, "nest": 3, "execution_time": 0.016639, "novelty": 0.7514450207746076}}, {"code": "def findShortestSubArray(nums):\n    from collections import defaultdict\n\n    num_to_indices = defaultdict(list)\n    for i, num in enumerate(nums):\n        num_to_indices[num].append(i)\n\n    degree = max(len(indices) for indices in num_to_indices.values())\n    min_length = float('inf')\n\n    for indices in num_to_indices.values():\n        if len(indices) == degree:\n            min_length = min(min_length, indices[-1] - indices[0] + 1)\n\n    return min_length", "passed": true, "score": {"loc": 11, "tokens": 99, "cc": 3, "nest": 3, "execution_time": 0.016566, "novelty": 0.6597564547484003}}, {"code": "from collections import defaultdict\n\ndef findShortestSubArray(nums):\n    num_positions = defaultdict(list)\n    for i, num in enumerate(nums):\n        num_positions[num].append(i)\n    \n    max_degree = max(len(positions) for positions in num_positions.values())\n    min_length = float('inf')\n    \n    for positions in num_positions.values():\n        if len(positions) == max_degree:\n            min_length = min(min_length, positions[-1] - positions[0] + 1)\n    \n    return min_length", "passed": true, "score": {"loc": 11, "tokens": 99, "cc": 3, "nest": 3, "execution_time": 0.016587, "novelty": 0.6601843955666035}}, {"code": "def findShortestSubArray(nums):\n    degree = 0\n    min_length = float('inf')\n    num_indices = {}\n\n    for i, num in enumerate(nums):\n        if num not in num_indices:\n            num_indices[num] = [i, i]\n        else:\n            num_indices[num][1] = i\n        count = num_indices[num][1] - num_indices[num][0] + 1\n        if count > degree:\n            degree = count\n            min_length = count\n        elif count == degree:\n            min_length = min(min_length, count)\n\n    return min_length", "passed": false, "score": {"loc": 16, "tokens": 104, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.6895178882076469}}, {"code": "def findShortestSubArray(nums):\n    from collections import defaultdict\n    \n    first_seen = defaultdict(int)\n    last_seen = defaultdict(int)\n    count = defaultdict(int)\n    degree = 0\n    min_length = float('inf')\n    \n    for i, num in enumerate(nums):\n        if num not in first_seen:\n            first_seen[num] = i\n        last_seen[num] = i\n        count[num] += 1\n        degree = max(degree, count[num])\n        \n        if count[num] == degree:\n            min_length = min(min_length, last_seen[num] - first_seen[num] + 1)\n    \n    return min_length", "passed": false, "score": {"loc": 16, "tokens": 114, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7009485604623941}}, {"code": "def findShortestSubArray(nums):\n    degree = 0\n    min_length = 0\n    num_positions = {}\n    \n    for i, num in enumerate(nums):\n        if num not in num_positions:\n            num_positions[num] = [i, i]\n        else:\n            num_positions[num][1] = i\n        \n        if num_positions[num][1] - num_positions[num][0] + 1 > degree:\n            degree = num_positions[num][1] - num_positions[num][0] + 1\n            min_length = i - num_positions[num][0] + 1\n        elif num_positions[num][1] - num_positions[num][0] + 1 == degree:\n            min_length = min(min_length, i - num_positions[num][0] + 1)\n    \n    return min_length", "passed": false, "score": {"loc": 15, "tokens": 148, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.754199352792241}}, {"code": "def findShortestSubArray(nums):\n    from collections import defaultdict\n\n    count = defaultdict(int)\n    first_seen = {}\n    degree = 0\n    min_length = float('inf')\n\n    for i, num in enumerate(nums):\n        if num not in first_seen:\n            first_seen[num] = i\n        count[num] += 1\n        degree = max(degree, count[num])\n\n    for i, num in enumerate(nums):\n        if count[num] == degree:\n            min_length = min(min_length, i - first_seen[num] + 1)\n\n    return min_length", "passed": false, "score": {"loc": 15, "tokens": 107, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.6528023355665101}}, {"code": "from collections import defaultdict\n\ndef findShortestSubArray(nums):\n    first = {}\n    count = defaultdict(int)\n    max_count = 0\n    min_length = float('inf')\n    \n    for i, num in enumerate(nums):\n        if num not in first:\n            first[num] = i\n        count[num] += 1\n        max_count = max(max_count, count[num])\n        \n        if count[num] == max_count:\n            min_length = min(min_length, i - first[num] + 1)\n    \n    return min_length", "passed": false, "score": {"loc": 14, "tokens": 97, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5493185817456211}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 16434, "entry_point": "checkSubarraySum", "best_list": [{"code": "def checkSubarraySum(nums, k):\n    seen_sums = {0: -1}\n    total_sum = 0\n    for i, num in enumerate(nums):\n        total_sum += num\n        if k != 0:\n            total_sum %= k\n        if total_sum in seen_sums and i - seen_sums[total_sum] > 1:\n            return True\n        if total_sum not in seen_sums:\n            seen_sums[total_sum] = i\n    return False", "passed": true, "score": {"loc": 12, "tokens": 73, "cc": 5, "nest": 3, "execution_time": 0.016475, "novelty": 0.24830301999215387}}, {"code": "def checkSubarraySum(nums, k):\n    remainder_dict = {0: -1}\n    total_sum = 0\n    for i, num in enumerate(nums):\n        total_sum += num\n        if k != 0:\n            total_sum %= k\n        if total_sum in remainder_dict:\n            if i - remainder_dict[total_sum] > 1:\n                return True\n        else:\n            remainder_dict[total_sum] = i\n    return False", "passed": true, "score": {"loc": 13, "tokens": 70, "cc": 4, "nest": 4, "execution_time": 0.016433, "novelty": 0.12425429295580703}}, {"code": "def checkSubarraySum(nums, k):\n    prefix_sum_mod = {0: -1}\n    total = 0\n    for i, num in enumerate(nums):\n        total += num\n        if k != 0:\n            total %= k\n        if total in prefix_sum_mod:\n            if i - prefix_sum_mod[total] > 1:\n                return True\n        else:\n            prefix_sum_mod[total] = i\n    return False", "passed": true, "score": {"loc": 13, "tokens": 70, "cc": 4, "nest": 4, "execution_time": 0.016527, "novelty": 0.25133727807369466}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 16436, "entry_point": "maxProfitAssignment", "best_list": [{"code": "def maxProfitAssignment(difficulty, profit, worker):\n    job_max_profit = [0] * (max(difficulty) + 1)\n    for d, p in zip(difficulty, profit):\n        job_max_profit[d] = max(job_max_profit[d], p)\n    for i in range(1, len(job_max_profit)):\n        job_max_profit[i] = max(job_max_profit[i], job_max_profit[i - 1])\n    return sum(job_max_profit[min(d, len(job_max_profit) - 1)] for d in worker)", "passed": true, "score": {"loc": 7, "tokens": 104, "cc": 2, "nest": 2, "execution_time": 0.016606, "novelty": 0.760683134185766}}, {"code": "def maxProfitAssignment(difficulty, profit, worker):\n    jobs = sorted(zip(difficulty, profit))\n    max_profit = 0\n    best_profit = 0\n    i = 0\n    \n    for w in worker:\n        while i < len(jobs) and jobs[i][0] <= w:\n            best_profit = max(best_profit, jobs[i][1])\n            i += 1\n        max_profit += best_profit\n    \n    return max_profit", "passed": true, "score": {"loc": 11, "tokens": 78, "cc": 3, "nest": 3, "execution_time": 0.016442, "novelty": 0.45240476433337595}}, {"code": "def maxProfitAssignment(difficulty, profit, worker):\n    jobs = sorted(zip(difficulty, profit))\n    max_profit = 0\n    best_profit = 0\n    i = 0\n\n    for ability in worker:\n        while i < len(jobs) and jobs[i][0] <= ability:\n            max_profit = max(max_profit, jobs[i][1])\n            i += 1\n        best_profit += max_profit\n\n    return best_profit", "passed": true, "score": {"loc": 11, "tokens": 78, "cc": 3, "nest": 3, "execution_time": 0.016615, "novelty": 0.4447851311020009}}, {"code": "def maxProfitAssignment(difficulty, profit, worker):\n    max_profit = 0\n    best_profit_so_far = 0\n    profit_for_difficulty = [(0, 0)]\n    \n    for d, p in zip(difficulty, profit):\n        if p > best_profit_so_far:\n            best_profit_so_far = p\n            profit_for_difficulty.append((d, best_profit_so_far))\n    \n    profit_for_difficulty.sort()\n    \n    total_profit = 0\n    \n    for w in worker:\n        index = bisect.bisect(profit_for_difficulty, (w, float('inf')))\n        if index > 0:\n            total_profit += profit_for_difficulty[index - 1][1]\n    \n    return total_profit", "passed": false, "score": {"loc": 15, "tokens": 106, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7602212545886847}}, {"code": "def maxProfitAssignment(difficulty, profit, worker):\n    profit_for_difficulty = {}\n    for d, p in zip(difficulty, profit):\n        profit_for_difficulty[d] = max(profit_for_difficulty.get(d, 0), p)\n    \n    max_profit_so_far = 0\n    for d in sorted(profit_for_difficulty):\n        max_profit_so_far = max(max_profit_so_far, profit_for_difficulty[d])\n        profit_for_difficulty[d] = max_profit_so_far\n    \n    total_profit = 0\n    for w in worker:\n        if w in profit_for_difficulty:\n            total_profit += profit_for_difficulty[w]\n        elif w > max(profit_for_difficulty.keys()):\n            total_profit += profit_for_difficulty[max(profit_for_difficulty.keys())]\n    \n    return total_profit", "passed": false, "score": {"loc": 15, "tokens": 120, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.7537580330847922}}, {"code": "def maxProfitAssignment(difficulty, profit, worker):\n    job_list = sorted(zip(difficulty, profit))\n    max_profit = 0\n    best_profit = 0\n    for diff, prof in job_list:\n        best_profit = max(best_profit, prof)\n        if diff <= worker[-1]:\n            for w in worker:\n                if w >= diff:\n                    max_profit += best_profit\n                else:\n                    break\n    return max_profit", "passed": false, "score": {"loc": 13, "tokens": 72, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.6579382789745936}}, {"code": "def maxProfitAssignment(difficulty, profit, worker):\n    max_profit = 0\n    worker.sort()\n    i = 0\n    for w in worker:\n        while i < len(difficulty) and difficulty[i] <= w:\n            max_profit = max(max_profit, profit[i])\n            i += 1\n    return worker[-1] * max_profit if worker else 0", "passed": false, "score": {"loc": 9, "tokens": 69, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5843155640244817}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 16495, "entry_point": "numOfSubarrays", "best_list": [{"code": "def numOfSubarrays(arr, k, threshold):\n    return sum(1 for i in range(len(arr) - k + 1) if sum(arr[i:i+k]) / k >= threshold)", "passed": true, "score": {"loc": 2, "tokens": 46, "cc": 0, "nest": 1, "execution_time": 0.016656, "novelty": 0.6989411383236075}}, {"code": "def numOfSubarrays(arr, k, threshold):\n    window_sum = sum(arr[:k])\n    result = int(window_sum >= threshold * k)\n    for i in range(k, len(arr)):\n        window_sum += arr[i] - arr[i - k]\n        result += int(window_sum >= threshold * k)\n    return result", "passed": true, "score": {"loc": 7, "tokens": 72, "cc": 1, "nest": 2, "execution_time": 0.016586, "novelty": 0.4837406130076335}}, {"code": "def numOfSubarrays(arr, k, threshold):\n    total = sum(arr[:k])\n    count = 1 if total / k >= threshold else 0\n    for i in range(k, len(arr)):\n        total += arr[i] - arr[i - k]\n        count += 1 if total / k >= threshold else 0\n    return count", "passed": true, "score": {"loc": 7, "tokens": 74, "cc": 1, "nest": 2, "execution_time": 0.016512, "novelty": 0.4156305613682715}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 16511, "entry_point": "breakPalindrome", "best_list": [{"code": "def breakPalindrome(palindrome):\n    n = len(palindrome)\n    if n == 1:\n        return \"\"\n    for i in range(n // 2):\n        if palindrome[i] != 'a':\n            return palindrome[:i] + 'a' + palindrome[i+1:]\n    return palindrome[:-1] + 'b'", "passed": true, "score": {"loc": 8, "tokens": 72, "cc": 3, "nest": 3, "execution_time": 0.016456, "novelty": 0.26153062632527824}}, {"code": "def breakPalindrome(palindrome):\n    n = len(palindrome)\n    if n <= 1:\n        return \"\"\n    for i in range(n // 2):\n        if palindrome[i] != 'a':\n            return palindrome[:i] + 'a' + palindrome[i+1:]\n    return palindrome[:-1] + 'b'", "passed": true, "score": {"loc": 8, "tokens": 72, "cc": 3, "nest": 3, "execution_time": 0.016626, "novelty": 0.029643388742695564}}, {"code": "def breakPalindrome(palindrome):\n    n = len(palindrome)\n    if n <= 1:\n        return \"\"\n    for i, c in enumerate(palindrome):\n        if c != 'a' and i != n // 2:\n            return palindrome[:i] + 'a' + palindrome[i+1:]\n    return palindrome[:-1] + 'b'", "passed": true, "score": {"loc": 8, "tokens": 76, "cc": 4, "nest": 3, "execution_time": 0.016535, "novelty": 0.1732357258693562}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 16643, "entry_point": "mutate_string", "best_list": [{"code": "def mutate_string(string, index, character):\n    return string[:index] + character + string[index+1:]", "passed": true, "score": {"loc": 2, "tokens": 26, "cc": 0, "nest": 1, "execution_time": 0.016516, "novelty": 0.4394537012129476}}, {"code": "def mutate_string(s, i, c):\n    return s[:i] + c + s[i+1:]", "passed": true, "score": {"loc": 2, "tokens": 26, "cc": 0, "nest": 1, "execution_time": 0.016684, "novelty": 0.2548881996209654}}, {"code": "def mutate_string(s, i, c):\n    l = list(s)\n    l[i] = c\n    return ''.join(l)", "passed": true, "score": {"loc": 4, "tokens": 30, "cc": 0, "nest": 1, "execution_time": 0.016567, "novelty": 0.44817456991100457}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 16789, "entry_point": "canThreePartsEqualSum", "best_list": [{"code": "def canThreePartsEqualSum(A):\n    total_sum = sum(A)\n    if total_sum % 3 != 0:\n        return False\n    \n    target = total_sum // 3\n    current_sum = 0\n    count = 0\n    \n    for num in A:\n        current_sum += num\n        if current_sum == target:\n            current_sum = 0\n            count += 1\n    \n    return count == 3", "passed": true, "score": {"loc": 13, "tokens": 61, "cc": 3, "nest": 3, "execution_time": 0.016803, "novelty": 0.11142625138401008}}, {"code": "def canThreePartsEqualSum(A):\n    total_sum = sum(A)\n    if total_sum % 3 != 0:\n        return False\n    \n    target = total_sum // 3\n    current_sum = 0\n    part_count = 0\n    \n    for num in A:\n        current_sum += num\n        if current_sum == target:\n            part_count += 1\n            current_sum = 0\n    \n    return part_count == 3 and current_sum == 0", "passed": true, "score": {"loc": 13, "tokens": 66, "cc": 4, "nest": 3, "execution_time": 0.016798, "novelty": 0.16638781082792065}}, {"code": "def canThreePartsEqualSum(A):\n    total_sum = sum(A)\n    if total_sum % 3 != 0:\n        return False\n    \n    target_sum = total_sum // 3\n    current_sum = 0\n    part_count = 0\n    \n    for num in A:\n        current_sum += num\n        if current_sum == target_sum:\n            current_sum = 0\n            part_count += 1\n            if part_count == 3:\n                return True\n    \n    return False", "passed": true, "score": {"loc": 15, "tokens": 66, "cc": 4, "nest": 4, "execution_time": 0.016689, "novelty": 0.15810046713610948}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 16793, "entry_point": "findTargetSumWays", "best_list": [{"code": "def findTargetSumWays(nums, S):\n    def dfs(i, target):\n        if i == len(nums):\n            return 1 if target == 0 else 0\n        return dfs(i + 1, target - nums[i]) + dfs(i + 1, target + nums[i])\n    \n    return dfs(0, S)", "passed": true, "score": {"loc": 6, "tokens": 69, "cc": 1, "nest": 3, "execution_time": 0.016699, "novelty": 0.773368940023918}}, {"code": "def findTargetSumWays(nums, S):\n    def count_ways(index, current_sum):\n        if index == len(nums):\n            return 1 if current_sum == S else 0\n        return count_ways(index + 1, current_sum + nums[index]) + count_ways(index + 1, current_sum - nums[index])\n    \n    return count_ways(0, 0)", "passed": true, "score": {"loc": 6, "tokens": 69, "cc": 1, "nest": 3, "execution_time": 0.016703, "novelty": 0.6933864662051119}}, {"code": "def findTargetSumWays(nums, S):\n    from collections import defaultdict\n    dp = defaultdict(int)\n    dp[0] = 1\n    for num in nums:\n        ndp = defaultdict(int)\n        for k, v in dp.items():\n            ndp[k + num] += v\n            ndp[k - num] += v\n        dp = ndp\n    return dp[S]", "passed": true, "score": {"loc": 11, "tokens": 72, "cc": 2, "nest": 3, "execution_time": 0.016566, "novelty": 0.6196383291282899}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 16899, "entry_point": "numberOfArithmeticSlices", "best_list": [{"code": "def numberOfArithmeticSlices(A):\n    n = len(A)\n    count, dp = 0, [0] * n\n    for i in range(2, n):\n        if A[i] - A[i - 1] == A[i - 1] - A[i - 2]:\n            dp[i] = dp[i - 1] + 1\n            count += dp[i]\n    return count", "passed": true, "score": {"loc": 8, "tokens": 83, "cc": 2, "nest": 3, "execution_time": 0.016481, "novelty": 0.48539180101863977}}, {"code": "def numberOfArithmeticSlices(A):\n    count = 0\n    current_length = 0\n    for i in range(2, len(A)):\n        if A[i] - A[i - 1] == A[i - 1] - A[i - 2]:\n            current_length += 1\n            count += current_length\n        else:\n            current_length = 0\n    return count", "passed": true, "score": {"loc": 10, "tokens": 68, "cc": 2, "nest": 3, "execution_time": 0.016502, "novelty": 0.5238841484911559}}, {"code": "def numberOfArithmeticSlices(A):\n    count = 0\n    current = 0\n    for i in range(2, len(A)):\n        if A[i] - A[i - 1] == A[i - 1] - A[i - 2]:\n            current += 1\n            count += current\n        else:\n            current = 0\n    return count", "passed": true, "score": {"loc": 10, "tokens": 68, "cc": 2, "nest": 3, "execution_time": 0.01665, "novelty": 0.4401316333562246}}, {"code": "def numberOfArithmeticSlices(A):\n    count = 0\n    n = len(A)\n    if n < 3:\n        return count\n    \n    for i in range(2, n):\n        if A[i] - A[i - 1] == A[i - 1] - A[i - 2]:\n            count += 1\n    \n    return count", "passed": false, "score": {"loc": 9, "tokens": 66, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.44737335345104356}}, {"code": "def numberOfArithmeticSlices(A):\n    return sum((len(list(g)) - 2) * (len(list(g)) - 3) // 2 for _, g in groupby(A, lambda x, y, z: x - y == y - z))", "passed": false, "score": {"loc": 2, "tokens": 61, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6876240333487813}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 2}
{"id": 16909, "entry_point": "defangIPaddr", "best_list": [{"code": "def defangIPaddr(address):\n    return address.replace(\".\", \"[.]\")", "passed": true, "score": {"loc": 2, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 0.016551, "novelty": 0.2406337085298832}}, {"code": "def defangIPaddr(address: str) -> str:\n    return address.replace('.', '[.]')", "passed": true, "score": {"loc": 2, "tokens": 26, "cc": 0, "nest": 1, "execution_time": 0.016455, "novelty": 0.16704714264237763}}, {"code": "def defangIPaddr(address: str) -> str:\n    return '[.]'.join(address.split('.'))", "passed": true, "score": {"loc": 2, "tokens": 29, "cc": 0, "nest": 1, "execution_time": 0.016499, "novelty": 0.21825282799904366}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 16958, "entry_point": "canReach", "best_list": [{"code": "def canReach(arr, start):\n    n = len(arr)\n    visited = set()\n    \n    def dfs(i):\n        if i < 0 or i >= n or i in visited:\n            return False\n        if arr[i] == 0:\n            return True\n        visited.add(i)\n        return dfs(i + arr[i]) or dfs(i - arr[i])\n    \n    return dfs(start)", "passed": true, "score": {"loc": 11, "tokens": 83, "cc": 4, "nest": 3, "execution_time": 0.016455, "novelty": 0.5215407965257135}}, {"code": "def canReach(arr, start):\n    n = len(arr)\n    visited = set()\n    \n    def dfs(index):\n        if index < 0 or index >= n or index in visited:\n            return False\n        if arr[index] == 0:\n            return True\n        visited.add(index)\n        return dfs(index + arr[index]) or dfs(index - arr[index])\n    \n    return dfs(start)", "passed": true, "score": {"loc": 11, "tokens": 83, "cc": 4, "nest": 3, "execution_time": 0.016572, "novelty": 0.5210852591012543}}, {"code": "def canReach(arr, start):\n    n = len(arr)\n    visited = [False] * n\n    \n    def dfs(index):\n        if index < 0 or index >= n or visited[index]:\n            return False\n        if arr[index] == 0:\n            return True\n        visited[index] = True\n        return dfs(index + arr[index]) or dfs(index - arr[index])\n    \n    return dfs(start)", "passed": true, "score": {"loc": 11, "tokens": 86, "cc": 4, "nest": 3, "execution_time": 0.016626, "novelty": 0.46472541680721136}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 16981, "entry_point": "longestWPI", "best_list": [{"code": "def longestWPI(hours):\n    score, max_length, prefix_sum = 0, 0, {0: -1}\n    for i, h in enumerate(hours):\n        score += 1 if h > 8 else -1\n        if score > 0:\n            max_length = i + 1\n        elif score - 1 in prefix_sum:\n            max_length = max(max_length, i - prefix_sum[score - 1])\n        if score not in prefix_sum:\n            prefix_sum[score] = i\n    return max_length", "passed": true, "score": {"loc": 11, "tokens": 89, "cc": 4, "nest": 4, "execution_time": 0.016614, "novelty": 0.446402624032875}}, {"code": "def longestWPI(hours):\n    prefix_sums = {}\n    balance = 0\n    max_length = 0\n    for i, hours in enumerate(hours, 1):\n        balance += 1 if hours > 8 else -1\n        if balance > 0:\n            max_length = i\n        elif balance - 1 in prefix_sums:\n            max_length = max(max_length, i - prefix_sums[balance - 1])\n        if balance not in prefix_sums:\n            prefix_sums[balance] = i\n    return max_length", "passed": true, "score": {"loc": 13, "tokens": 83, "cc": 4, "nest": 4, "execution_time": 0.016556, "novelty": 0.5718996654869926}}, {"code": "def longestWPI(hours):\n    prefix_sum = 0\n    max_length = 0\n    seen = {}\n    \n    for i, h in enumerate(hours):\n        prefix_sum += 1 if h > 8 else -1\n        if prefix_sum > 0:\n            max_length = i + 1\n        elif prefix_sum - 1 in seen:\n            max_length = max(max_length, i - seen[prefix_sum - 1])\n        if prefix_sum not in seen:\n            seen[prefix_sum] = i\n    \n    return max_length", "passed": true, "score": {"loc": 13, "tokens": 83, "cc": 4, "nest": 4, "execution_time": 0.016621, "novelty": 0.36830325204354}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 17015, "entry_point": "largestNumber", "best_list": [{"code": "def largestNumber(cost, target):\n    dp = [-1] * (target + 1)\n    dp[0] = 0\n    for i in range(1, target + 1):\n        dp[i] = -1\n        for j in range(9):\n            if i >= cost[j]:\n                if dp[i - cost[j]] != -1:\n                    dp[i] = max(dp[i], dp[i - cost[j]] * 10 + (j + 1))\n    return str(dp[target]) if dp[target] != -1 else \"0\"", "passed": true, "score": {"loc": 10, "tokens": 128, "cc": 4, "nest": 5, "execution_time": 0.016686, "novelty": 0.666453486802485}}, {"code": "from functools import lru_cache\n\ndef largestNumber(cost, target):\n    max_digit = max(range(9), key=lambda i: cost[i])\n    \n    @lru_cache(None)\n    def dp(t):\n        if t < 0:\n            return -1\n        if t == 0:\n            return 0\n        best = -1\n        for i in range(9):\n            if cost[i] <= t:\n                best = max(best, dp(t - cost[i]) * 10 + (i + 1))\n        return best\n    \n    result = dp(target)\n    if result == -1:\n        return \"0\"\n    return str(result)", "passed": true, "score": {"loc": 18, "tokens": 127, "cc": 5, "nest": 4, "execution_time": 0.016687, "novelty": 0.8246772429253847}}, {"code": "def largestNumber(cost, target):\n    dp = [-1] * (target + 1)\n    dp[0] = 0\n    for i in range(1, target + 1):\n        dp[i] = max((dp[i - c] + 1 if i - c >= 0 else -1) * 10 + d + 1 for c, d in zip(cost, range(1, 10)))\n    return str(max(dp[target], 0))", "passed": false, "score": {"loc": 6, "tokens": 101, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.6975264560694301}}, {"code": "def largestNumber(cost, target):\n    max_num = [0] * (target + 1)\n    max_comb = [[] for _ in range(target + 1)]\n    \n    for i, c in enumerate(cost):\n        for j in range(c, target + 1):\n            if max_num[j - c] + 1 > max_num[j]:\n                max_num[j] = max_num[j - c] + 1\n                max_comb[j] = [i + 1] + max_comb[j - c]\n            elif max_num[j - c] + 1 == max_num[j]:\n                max_comb[j] = max(max_comb[j], [i + 1] + max_comb[j - c], key=lambda x: int(''.join(map(str, x))))\n    \n    if max_num[target] == 0:\n        return \"0\"\n    \n    return ''.join(map(str, max_comb[target]))", "passed": false, "score": {"loc": 13, "tokens": 192, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.7849979083924842}}, {"code": "def largestNumber(cost, target):\n    dp = [\"\"] * (target + 1)\n    dp[0] = \"0\"\n\n    for t in range(1, target + 1):\n        for i, c in enumerate(cost, start=1):\n            if t >= c:\n                dp[t] = max(dp[t], dp[t - c] + str(i))\n\n    return dp[target]", "passed": false, "score": {"loc": 8, "tokens": 89, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5712648265687169}}, {"code": "def largestNumber(cost, target):\n    dp = [\"\"] * (target + 1)\n    dp[0] = \"0\"\n    \n    for t in range(1, target + 1):\n        for i, c in enumerate(cost):\n            if t >= c and dp[t - c] != \"0\":\n                new = dp[t - c] + str(i + 1)\n                if dp[t] == \"\" or new > dp[t]:\n                    dp[t] = new\n    \n    return dp[target]", "passed": false, "score": {"loc": 10, "tokens": 111, "cc": 6, "nest": 5, "execution_time": 10.0, "novelty": 0.477494736773176}}, {"code": "def largestNumber(cost, target):\n    dp = [0] + [\"-1\"] * target\n    \n    for n in range(1, target + 1):\n        for i in range(9):\n            if cost[i] <= n and dp[n - cost[i]] != \"-1\":\n                dp[n] = max(dp[n], dp[n - cost[i]] + str(i + 1))\n    \n    return \"0\" if dp[-1] == \"-1\" else dp[-1]", "passed": false, "score": {"loc": 7, "tokens": 118, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.5648180636107616}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 8}
{"id": 17051, "entry_point": "maxDistance", "best_list": [{"code": "def maxDistance(position, m):\n    position.sort()\n    n = len(position)\n    left, right = 1, position[-1] - position[0]\n    while left < right:\n        mid = (left + right + 1) // 2\n        balls, prev = 1, position[0]\n        for i in range(1, n):\n            if position[i] - prev >= mid:\n                balls += 1\n                prev = position[i]\n        if balls >= m:\n            left = mid\n        else:\n            right = mid - 1\n    return left", "passed": true, "score": {"loc": 16, "tokens": 111, "cc": 4, "nest": 4, "execution_time": 0.016715, "novelty": 0.5814095414864004}}, {"code": "def maxDistance(position, m):\n    def can_place_balls(mid):\n        count, prev = 1, position[0]\n        for i in range(1, len(position)):\n            if position[i] - prev >= mid:\n                count += 1\n                prev = position[i]\n        return count >= m\n\n    position.sort()\n    left, right = 0, position[-1] - position[0]\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_place_balls(mid):\n            left = mid\n        else:\n            right = mid - 1\n    return left", "passed": true, "score": {"loc": 17, "tokens": 119, "cc": 4, "nest": 4, "execution_time": 0.016711, "novelty": 0.7489914588514602}}, {"code": "def maxDistance(position, m):\n    position.sort()\n    def can_place_ball(mid):\n        count = 1\n        last_position = position[0]\n        for pos in position[1:]:\n            if pos - last_position >= mid:\n                count += 1\n                last_position = pos\n        return count >= m\n    \n    left, right = 1, position[-1] - position[0]\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_place_ball(mid):\n            left = mid\n        else:\n            right = mid - 1\n    return left", "passed": true, "score": {"loc": 18, "tokens": 108, "cc": 4, "nest": 4, "execution_time": 0.016617, "novelty": 0.32908910364060573}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 17079, "entry_point": "maskPII", "best_list": [{"code": "def maskPII(S):\n    if '@' in S:\n        name, domain = S.split('@')\n        return f\"{name[0]}*****{name[-1]}@{domain}\".lower()\n    else:\n        digits = ''.join(c for c in S if c.isdigit())\n        local = \"***-***-\" + digits[-4:]\n        if len(digits) > 10:\n            return f\"+{'*' * (len(digits) - 10)}-{local}\"\n        return local", "passed": true, "score": {"loc": 10, "tokens": 128, "cc": 2, "nest": 3, "execution_time": 0.01676, "novelty": 0.500497527010973}}, {"code": "def maskPII(S: str) -> str:\n    if '@' in S:\n        name, domain = S.split('@')\n        return f\"{name[0]}*****{name[-1]}@{domain}\".lower()\n    else:\n        digits = ''.join(filter(str.isdigit, S))\n        if len(digits) == 10:\n            return \"***-***-\" + digits[-4:]\n        else:\n            return \"+\" + \"*\" * (len(digits) - 10) + \"-***-***-\" + digits[-4:]", "passed": true, "score": {"loc": 10, "tokens": 143, "cc": 2, "nest": 3, "execution_time": 0.016781, "novelty": 0.36453747466018216}}, {"code": "import re\n\ndef maskPII(S):\n    if \"@\" in S:\n        name, domain = S.lower().split(\"@\")\n        return f\"{name[0]}*****{name[-1]}@{domain}\"\n    else:\n        digits = re.sub(r'\\D', '', S)\n        if len(digits) == 10:\n            return \"***-***-\" + digits[-4:]\n        else:\n            return \"+\" + \"*\" * (len(digits) - 10) + \"-***-***-\" + digits[-4:]", "passed": true, "score": {"loc": 11, "tokens": 141, "cc": 2, "nest": 3, "execution_time": 0.0167, "novelty": 0.3660914766536847}}, {"code": "def maskPII(S):\n    if '@' in S:\n        name = S.split('@')[0].lower()\n        return f\"{name[0]}*****{name[-1]}@{S.split('@')[1]}\"\n    else:\n        digits = ''.join(c for c in S if c.isdigit())\n        if len(digits) == 10:\n            return \"***-***-\" + digits[-4:]\n        else:\n            return \"+\" + \"*\" * (len(digits) - 10) + \"-***-***-\" + digits[-4:]", "passed": false, "score": {"loc": 10, "tokens": 152, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.33340463677052323}}, {"code": "def maskPII(S):\n    if S[0].isalpha():\n        name, domain = S.split('@')\n        return '{}*****{}@{}'.format(name[0].lower(), name[-1].lower(), domain.lower())\n    else:\n        digits = ''.join(filter(str.isdigit, S))\n        if len(digits) == 10:\n            return '***-***-{}'.format(digits[-4:])\n        else:\n            return '+{}-***-***-{}'.format('*' * (len(digits) - 10), digits[-4:])", "passed": false, "score": {"loc": 10, "tokens": 163, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6328871453971905}}, {"code": "def maskPII(S):\n    if '@' in S:\n        name = S.split('@')[0].lower()\n        return name[0] + '*****' + name[-1] + '@' + S.split('@')[1]\n    else:\n        digits = ''.join(c for c in S if c.isdigit())\n        local = \"***-***-\" + digits[-4:]\n        if len(digits) > 10:\n            return \"+\" + \"*\" * (len(digits) - 10) + \"-\" + local\n        else:\n            return local", "passed": false, "score": {"loc": 11, "tokens": 140, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.4924131504458178}}, {"code": "import re\n\ndef maskPII(S: str) -> str:\n    if '@' in S:\n        name = re.sub(r'\\W+', '', S).lower()\n        return f\"{name[0]}*****{name[-1]}@{S[S.index('@'):]}\"\n    else:\n        digits = re.sub(r'\\D', '', S)\n        if len(digits) == 10:\n            return \"***-***-\" + digits[-4:]\n        else:\n            return \"+\" + (len(digits) - 10) * '*' + \"-***-***-\" + digits[-4:]", "passed": false, "score": {"loc": 11, "tokens": 163, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.3664082518228917}}], "num_pass": 6, "num_uniq": 5, "num_fail": 4, "fail_uniq": 4}
{"id": 17135, "entry_point": "hasGroupsSizeX", "best_list": [{"code": "import collections\nimport math\n\ndef hasGroupsSizeX(deck):\n    counts = collections.Counter(deck).values()\n    return math.gcd(*counts) >= 2", "passed": true, "score": {"loc": 5, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016646, "novelty": 0.31949195346958226}}, {"code": "from collections import Counter\nfrom math import gcd\nfrom functools import reduce\n\ndef hasGroupsSizeX(deck):\n    counts = Counter(deck).values()\n    return reduce(gcd, counts) > 1", "passed": true, "score": {"loc": 6, "tokens": 37, "cc": 0, "nest": 1, "execution_time": 0.016699, "novelty": 0.16521261830194112}}, {"code": "from collections import Counter\nfrom math import gcd\nfrom functools import reduce\n\ndef hasGroupsSizeX(deck):\n    counts = Counter(deck).values()\n    return reduce(gcd, counts) >= 2", "passed": true, "score": {"loc": 6, "tokens": 38, "cc": 0, "nest": 1, "execution_time": 0.016545, "novelty": 0.16413764084544813}}, {"code": "from math import gcd\nfrom collections import Counter\n\ndef hasGroupsSizeX(deck):\n    counts = Counter(deck).values()\n    return reduce(gcd, counts) >= 2", "passed": false, "score": {"loc": 5, "tokens": 34, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.18314217123688403}}, {"code": "def hasGroupsSizeX(deck):\n    from math import gcd\n    from functools import reduce\n    counts = list(sorted(Counter(deck).values()))\n    return reduce(gcd, counts) > 1", "passed": false, "score": {"loc": 5, "tokens": 39, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5314386631756631}}], "num_pass": 8, "num_uniq": 5, "num_fail": 2, "fail_uniq": 2}
{"id": 17155, "entry_point": "wordPattern", "best_list": [{"code": "def wordPattern(pattern, str):\n    words = str.split()\n    if len(pattern) != len(words):\n        return False\n    char_to_word = {}\n    word_to_char = {}\n    for char, word in zip(pattern, words):\n        if char in char_to_word and char_to_word[char] != word:\n            return False\n        if word in word_to_char and word_to_char[word] != char:\n            return False\n        char_to_word[char] = word\n        word_to_char[word] = char\n    return True", "passed": true, "score": {"loc": 14, "tokens": 93, "cc": 6, "nest": 3, "execution_time": 0.016676, "novelty": 0.07298103935141009}}, {"code": "def wordPattern(pattern, str):\n    words = str.split()\n    if len(pattern) != len(words):\n        return False\n    pattern_to_word = {}\n    word_to_pattern = {}\n    for p, word in zip(pattern, words):\n        if p in pattern_to_word and pattern_to_word[p] != word:\n            return False\n        if word in word_to_pattern and word_to_pattern[word] != p:\n            return False\n        pattern_to_word[p] = word\n        word_to_pattern[word] = p\n    return True", "passed": true, "score": {"loc": 14, "tokens": 93, "cc": 6, "nest": 3, "execution_time": 0.016686, "novelty": 0.07355828674549036}}, {"code": "def wordPattern(pattern, str):\n    pattern_hash = {}\n    word_hash = {}\n    words = str.split()\n    \n    if len(pattern) != len(words):\n        return False\n    \n    for p, word in zip(pattern, words):\n        if p not in pattern_hash:\n            pattern_hash[p] = word\n        if word not in word_hash:\n            word_hash[word] = p\n        if pattern_hash[p] != word or word_hash[word] != p:\n            return False\n    \n    return True", "passed": true, "score": {"loc": 14, "tokens": 94, "cc": 6, "nest": 3, "execution_time": 0.016705, "novelty": 0.46588033402314466}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 17168, "entry_point": "thousandSeparator", "best_list": [{"code": "def thousandSeparator(n):\n    return \"{:,}\".format(n).replace(',', '.')", "passed": true, "score": {"loc": 2, "tokens": 29, "cc": 0, "nest": 1, "execution_time": 0.016487, "novelty": 0.2999506716447533}}, {"code": "def thousandSeparator(n: int) -> str:\n    return format(n, \",\").replace(\",\", \".\")", "passed": true, "score": {"loc": 2, "tokens": 31, "cc": 0, "nest": 1, "execution_time": 0.016781, "novelty": 0.5180316197138531}}, {"code": "def thousandSeparator(n: int) -> str:\n    return \"{:,}\".format(n).replace(',', '.')", "passed": true, "score": {"loc": 2, "tokens": 34, "cc": 0, "nest": 1, "execution_time": 0.016677, "novelty": 0.30454627259941136}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 17180, "entry_point": "maxUncrossedLines", "best_list": [{"code": "def maxUncrossedLines(A, B):\n    m, n = len(A), len(B)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m):\n        for j in range(n):\n            if A[i] == B[j]:\n                dp[i + 1][j + 1] = dp[i][j] + 1\n            else:\n                dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n    return dp[m][n]", "passed": true, "score": {"loc": 10, "tokens": 136, "cc": 3, "nest": 4, "execution_time": 0.016624, "novelty": 0.20460751509557318}}, {"code": "def maxUncrossedLines(A, B):\n    m, n = len(A), len(B)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if A[i - 1] == B[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]", "passed": true, "score": {"loc": 10, "tokens": 144, "cc": 3, "nest": 4, "execution_time": 0.016659, "novelty": 0.20595361716857052}}], "num_pass": 10, "num_uniq": 2, "num_fail": 0, "fail_uniq": 0}
{"id": 1791, "entry_point": "numPrimeArrangements", "best_list": [{"code": "def numPrimeArrangements(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    primes = sum(is_prime(i) for i in range(1, n + 1))\n    return (math.factorial(primes) * math.factorial(n - primes)) % (10**9 + 7)", "passed": true, "score": {"loc": 10, "tokens": 99, "cc": 3, "nest": 4, "execution_time": 0.016603, "novelty": 0.5434482210152065}}, {"code": "from math import factorial\n\ndef numPrimeArrangements(n):\n    is_prime = [False, False] + [True] * (n - 1)\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n + 1, i):\n                is_prime[j] = False\n    \n    prime_count = sum(is_prime)\n    non_prime_count = n - prime_count\n    \n    return (factorial(prime_count) * factorial(non_prime_count)) % (10**9 + 7)", "passed": true, "score": {"loc": 10, "tokens": 107, "cc": 3, "nest": 4, "execution_time": 0.016651, "novelty": 0.6515723658319164}}, {"code": "def numPrimeArrangements(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0], is_prime[1] = False, False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n + 1, i):\n                is_prime[j] = False\n    primes = sum(is_prime)\n    return (factorial(primes) * factorial(n - primes)) % (10**9 + 7)\n\nfrom math import factorial", "passed": true, "score": {"loc": 10, "tokens": 111, "cc": 3, "nest": 4, "execution_time": 0.016634, "novelty": 0.6498801388455665}}, {"code": "def numPrimeArrangements(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef num_prime_arrangements(n):\n    prime_count = sum(numPrimeArrangements(i) for i in range(1, n + 1))\n    non_prime_count = n - prime_count\n    return (factorial(prime_count) * factorial(non_prime_count)) % (10**9 + 7)\n\nfrom math import factorial", "passed": false, "score": {"loc": 18, "tokens": 133, "cc": 7, "nest": 3, "execution_time": 10.0, "novelty": 0.697585870402168}}, {"code": "def numPrimeArrangements(n: int) -> int:\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_count = sum(is_prime(i) for i in range(1, n + 1))\n    return (factorial(prime_count) * factorial(n - prime_count)) % (10**9 + 7)", "passed": false, "score": {"loc": 10, "tokens": 100, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.528600347806612}}, {"code": "from math import factorial\nfrom sympy import primerange\n\ndef numPrimeArrangements(n):\n    primes = list(primerange(1, n + 1))\n    prime_count = len(primes)\n    non_prime_count = n - prime_count\n    return (factorial(prime_count) * factorial(non_prime_count)) % (10**9 + 7)", "passed": false, "score": {"loc": 7, "tokens": 59, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6279245678287122}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 17751, "entry_point": "mctFromLeafValues", "best_list": [{"code": "def mctFromLeafValues(arr):\n    res, stack = 0, [float('inf')]\n    for a in arr:\n        while stack[-1] <= a:\n            b = stack.pop()\n            res += b * min(stack[-1], a)\n        stack.append(a)\n    while len(stack) > 2:\n        res += stack.pop() * stack[-1]\n    return res", "passed": true, "score": {"loc": 10, "tokens": 87, "cc": 3, "nest": 3, "execution_time": 0.01663, "novelty": 0.7855191149610629}}, {"code": "def mctFromLeafValues(arr):\n    stack, res = [], 0\n    for a in arr:\n        while stack and stack[-1] <= a:\n            mid = stack.pop()\n            if stack:\n                res += mid * min(stack[-1], a)\n            else:\n                res += mid * a\n        stack.append(a)\n    while len(stack) > 1:\n        res += stack.pop() * stack[-1]\n    return res", "passed": true, "score": {"loc": 13, "tokens": 94, "cc": 5, "nest": 4, "execution_time": 0.016551, "novelty": 0.31571356057347844}}, {"code": "def mctFromLeafValues(arr):\n    result = 0\n    stack = []\n    for num in arr:\n        while stack and stack[-1] <= num:\n            mid = stack.pop()\n            if stack:\n                result += mid * min(stack[-1], num)\n            else:\n                result += mid * num\n        stack.append(num)\n    while len(stack) > 1:\n        result += stack.pop() * stack[-1]\n    return result", "passed": true, "score": {"loc": 14, "tokens": 93, "cc": 5, "nest": 4, "execution_time": 0.01654, "novelty": 0.32189315196934887}}, {"code": "def mctFromLeafValues(arr):\n    stack = []\n    result = 0\n    for num in arr:\n        while stack and num >= stack[-1]:\n            mid = stack.pop()\n            if stack:\n                result += stack[-1] * mid\n            else:\n                result += mid * num\n        stack.append(num)\n    while len(stack) > 1:\n        result += stack[-2] * stack.pop()\n    return result", "passed": false, "score": {"loc": 14, "tokens": 88, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.4535041314797926}}, {"code": "def mctFromLeafValues(arr):\n    stack = []\n    result = 0\n    for value in arr:\n        while stack and stack[-1] <= value:\n            middle = stack.pop()\n            result += middle * min(stack[-1] if stack else float('inf'), value)\n        stack.append(value)\n    while len(stack) > 2:\n        result += stack.pop() * stack[-1]\n    return result", "passed": false, "score": {"loc": 11, "tokens": 91, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.47786248105932316}}, {"code": "def mctFromLeafValues(arr):\n    result = 0\n    while len(arr) > 1:\n        min_index = arr.index(min(arr))\n        if min_index > 0:\n            result += arr[min_index] * arr[min_index - 1]\n        else:\n            result += arr[min_index] * arr[min_index + 1]\n        arr.pop(min_index)\n    return result", "passed": false, "score": {"loc": 10, "tokens": 71, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.754497838950372}}, {"code": "def mctFromLeafValues(arr):\n    return sum(max(a, b) * c for a, b, c in zip(arr[:-2], arr[1:-1], arr[2:]))", "passed": false, "score": {"loc": 2, "tokens": 48, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7682919018015526}}, {"code": "def mctFromLeafValues(arr):\n    stack = []\n    res = 0\n    for num in arr:\n        while stack and stack[-1] <= num:\n            mid = stack.pop()\n            if not stack:\n                break\n            res += mid * min(stack[-1], num)\n        stack.append(num)\n    while len(stack) > 2:\n        res += stack.pop() * stack[-1]\n    return res", "passed": false, "score": {"loc": 13, "tokens": 87, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.5983604236912184}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 17811, "entry_point": "smallestRepunitDivByK", "best_list": [{"code": "def smallestRepunitDivByK(K):\n    return next((i for i in range(1, K + 1) if (10**i - 1) % K == 0), -1)", "passed": true, "score": {"loc": 2, "tokens": 41, "cc": 0, "nest": 1, "execution_time": 0.01646, "novelty": 0.6323922036751923}}, {"code": "def smallestRepunitDivByK(K):\n    remainder = 0\n    for length in range(1, K + 1):\n        remainder = (remainder * 10 + 1) % K\n        if remainder == 0:\n            return length\n    return -1", "passed": true, "score": {"loc": 7, "tokens": 43, "cc": 2, "nest": 3, "execution_time": 0.016639, "novelty": 0.5289752652391942}}, {"code": "def smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return -1\n    num, length = 1, 1\n    while num % K != 0:\n        num = (num * 10 + 1) % K\n        length += 1\n    return length", "passed": true, "score": {"loc": 8, "tokens": 56, "cc": 3, "nest": 2, "execution_time": 0.016515, "novelty": 0.31090736414947573}}, {"code": "def smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return -1\n    N, remainder = 1, 1\n    for length in range(1, K + 1):\n        if remainder == 0:\n            return length\n        remainder = (remainder * 10 + 1) % K\n    return -1", "passed": false, "score": {"loc": 9, "tokens": 65, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.4414587235952123}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 17900, "entry_point": "longestCommonSubsequence", "best_list": [{"code": "def longestCommonSubsequence(text1, text2):\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]", "passed": true, "score": {"loc": 10, "tokens": 144, "cc": 3, "nest": 4, "execution_time": 0.016732, "novelty": 0.13379295676245928}}, {"code": "def longestCommonSubsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]", "passed": true, "score": {"loc": 10, "tokens": 151, "cc": 3, "nest": 4, "execution_time": 0.01662, "novelty": 0.12852028991034858}}, {"code": "def longestCommonSubsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if text1[i] == text2[j]:\n                dp[i][j] = 1 + dp[i + 1][j + 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])\n    return dp[0][0]", "passed": true, "score": {"loc": 10, "tokens": 155, "cc": 3, "nest": 4, "execution_time": 0.016681, "novelty": 0.33927296155110853}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 17994, "entry_point": "isMatch", "best_list": [{"code": "def isMatch(s, p):\n    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n    dp[-1][-1] = True\n    for i in range(len(s), -1, -1):\n        for j in range(len(p) - 1, -1, -1):\n            first_match = i < len(s) and (s[i] == p[j] or p[j] == '.')\n            if j + 1 < len(p) and p[j + 1] == '*':\n                dp[i][j] = dp[i][j + 2] or (first_match and dp[i + 1][j])\n            else:\n                dp[i][j] = first_match and dp[i + 1][j + 1]\n    return dp[0][0]", "passed": true, "score": {"loc": 11, "tokens": 198, "cc": 9, "nest": 4, "execution_time": 0.016749, "novelty": 0.4356234486394297}}, {"code": "def isMatch(s, p):\n    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n    dp[-1][-1] = True\n    for i in range(len(s), -1, -1):\n        for j in range(len(p) - 1, -1, -1):\n            match = i < len(s) and (s[i] == p[j] or p[j] == '.')\n            if j+1 < len(p) and p[j+1] == '*':\n                dp[i][j] = dp[i][j+2] or (match and dp[i+1][j])\n            else:\n                dp[i][j] = match and dp[i+1][j+1]\n    return dp[0][0]", "passed": true, "score": {"loc": 11, "tokens": 198, "cc": 9, "nest": 4, "execution_time": 0.016861, "novelty": 0.23071965654192772}}, {"code": "def isMatch(s: str, p: str) -> bool:\n    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n    dp[-1][-1] = True\n    \n    for i in range(len(s), -1, -1):\n        for j in range(len(p) - 1, -1, -1):\n            match = i < len(s) and (s[i] == p[j] or p[j] == '.')\n            if j + 1 < len(p) and p[j + 1] == '*':\n                dp[i][j] = dp[i][j + 2] or (match and dp[i + 1][j])\n            else:\n                dp[i][j] = match and dp[i + 1][j + 1]\n    \n    return dp[0][0]", "passed": true, "score": {"loc": 11, "tokens": 205, "cc": 9, "nest": 4, "execution_time": 0.016703, "novelty": 0.22449236836905118}}, {"code": "def isMatch(s: str, p: str) -> bool:\n    def matches(i: int, j: int) -> bool:\n        return i < len(s) and (s[i] == p[j] or p[j] == '.')\n    \n    @lru_cache(None)\n    def dp(i: int, j: int) -> bool:\n        if j == len(p):\n            return i == len(s)\n        if j + 1 < len(p) and p[j + 1] == '*':\n            return dp(i, j + 2) or (i < len(s) and matches(i, j) and dp(i + 1, j))\n        return i < len(s) and matches(i, j) and dp(i + 1, j + 1)\n    \n    return dp(0, 0)", "passed": false, "score": {"loc": 11, "tokens": 185, "cc": 8, "nest": 3, "execution_time": 10.0, "novelty": 0.8157047283120679}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 1830, "entry_point": "largestSumOfAverages", "best_list": [{"code": "def largestSumOfAverages(A, K):\n    n = len(A)\n    dp = [[0] * n for _ in range(K + 1)]\n    for i in range(n):\n        dp[1][i] = sum(A[:i + 1]) / (i + 1)\n    for k in range(2, K + 1):\n        for i in range(n - 1, k - 2, -1):\n            dp[k][i] = max((sum(A[j:i + 1]) / (i - j + 1) + dp[k - 1][j - 1]) for j in range(i, k - 2, -1))\n    return dp[K][n - 1]", "passed": true, "score": {"loc": 9, "tokens": 161, "cc": 3, "nest": 3, "execution_time": 0.016741, "novelty": 0.691880753455082}}, {"code": "def largestSumOfAverages(A, K):\n    n = len(A)\n    dp = [[0] * n for _ in range(K + 1)]\n    prefix_sum = [0] * (n + 1)\n    \n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    for i in range(1, K + 1):\n        for j in range(i - 1, n):\n            for k in range(i - 2, j):\n                dp[i][j] = max(dp[i][j], dp[i - 1][k] + (prefix_sum[j + 1] - prefix_sum[k + 1]) / (j - k))\n    \n    return dp[K][n - 1]", "passed": true, "score": {"loc": 11, "tokens": 163, "cc": 4, "nest": 4, "execution_time": 0.016884, "novelty": 0.6288532307641983}}, {"code": "def largestSumOfAverages(A, K):\n    n = len(A)\n    dp = [[0] * (K + 1) for _ in range(n + 1)]\n    prefix_sum = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n        dp[i][1] = prefix_sum[i] / i\n    \n    for k in range(2, K + 1):\n        for i in range(k, n + 1):\n            for j in range(k - 1, i):\n                dp[i][k] = max(dp[i][k], dp[j][k - 1] + (prefix_sum[i] - prefix_sum[j]) / (i - j))\n    \n    return dp[n][K]", "passed": true, "score": {"loc": 12, "tokens": 181, "cc": 4, "nest": 4, "execution_time": 0.016622, "novelty": 0.6464389147427096}}, {"code": "def largestSumOfAverages(A, K):\n    from functools import lru_cache\n    @lru_cache(None)\n    def dfs(i, k):\n        if k == 1:\n            return sum(A[i:]) / (len(A) - i)\n        return max((sum(A[i:j]) / (j - i) + dfs(j, k - 1)) for j in range(i + 1, len(A)))\n    return dfs(0, K)", "passed": false, "score": {"loc": 8, "tokens": 100, "cc": 1, "nest": 3, "execution_time": 10.0, "novelty": 0.6406762175106095}}, {"code": "def largestSumOfAverages(A, K):\n    from functools import lru_cache\n    \n    @lru_cache(None)\n    def dfs(i, k):\n        if k == 1:\n            return sum(A[i:]) / (len(A) - i)\n        return max(dfs(j, k - 1) + sum(A[i:j]) / (j - i) for j in range(i + 1, len(A)))\n    \n    return dfs(0, K)", "passed": false, "score": {"loc": 8, "tokens": 98, "cc": 1, "nest": 3, "execution_time": 10.0, "novelty": 0.6715590561864853}}, {"code": "def largestSumOfAverages(A, K):\n    from functools import lru_cache\n\n    @lru_cache(None)\n    def dp(i, k):\n        if k == 1:\n            return sum(A[i:]) / (len(A) - i)\n        return max((sum(A[i:j]) / (j - i) + dp(j, k - 1)) for j in range(i + 1, len(A)))\n\n    return dp(0, K)", "passed": false, "score": {"loc": 8, "tokens": 100, "cc": 1, "nest": 3, "execution_time": 10.0, "novelty": 0.6389746718008653}}, {"code": "def largestSumOfAverages(A, K):\n    n = len(A)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n\n    @lru_cache(None)\n    def dp(i, k):\n        if k == 1:\n            return (prefix_sum[n] - prefix_sum[i]) / (n - i)\n        return max((prefix_sum[j] - prefix_sum[i]) / (j - i) + dp(j, k - 1) for j in range(i + 1, n + 1))\n\n    return dp(0, K)", "passed": false, "score": {"loc": 11, "tokens": 142, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.739400628287523}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 1834, "entry_point": "minCost", "best_list": [{"code": "def minCost(houses, cost, m, n, target):\n    def dfs(i, prev, neighborhoods):\n        if i == m:\n            return 0 if neighborhoods == target else float('inf')\n        if neighborhoods > target:\n            return float('inf')\n        if houses[i] != 0:\n            return dfs(i + 1, houses[i], neighborhoods + (houses[i] != prev))\n        return min(dfs(i + 1, j + 1, neighborhoods + (j + 1 != prev)) + cost[i][j] for j in range(n))\n\n    result = dfs(0, 0, 0)\n    return result if result != float('inf') else -1", "passed": true, "score": {"loc": 11, "tokens": 154, "cc": 3, "nest": 3, "execution_time": 0.016729, "novelty": 0.7891759169549539}}, {"code": "def minCost(houses, cost, m, n, target):\n    INF = float('inf')\n    dp = [[[INF] * n for _ in range(target + 1)] for _ in range(m + 1)]\n    \n    def dfs(i, t, prev):\n        if i == m or t < 0:\n            return 0 if t == 0 else INF\n        if houses[i] != 0:\n            return dfs(i + 1, t - (houses[i] != prev), houses[i])\n        min_cost = INF\n        for j in range(1, n + 1):\n            min_cost = min(min_cost, cost[i][j - 1] + dfs(i + 1, t - (j != prev), j))\n        return min_cost\n    \n    result = dfs(0, target, 0)\n    return result if result < INF else -1", "passed": true, "score": {"loc": 14, "tokens": 183, "cc": 4, "nest": 3, "execution_time": 0.016849, "novelty": 0.7308365189076672}}, {"code": "def minCost(houses, cost, m, n, target):\n    INF = float('inf')\n    dp = [[[INF] * (n + 1) for _ in range(target + 1)] for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(1, n + 1):\n            if houses[i] != 0 and houses[i] != j:\n                continue\n            c = 0 if houses[i] != 0 else cost[i][j - 1]\n            if i == 0:\n                dp[i][1][j] = c\n                continue\n            for k in range(1, target + 1):\n                for l in range(1, n + 1):\n                    if l != j:\n                        dp[i][k][j] = min(dp[i][k][j], dp[i - 1][k][l] + c)\n                    else:\n                        dp[i][k][j] = min(dp[i][k][j], dp[i - 1][k - 1][l] + c)\n    \n    result = min(dp[m - 1][target])\n    return result if result < INF else -1", "passed": true, "score": {"loc": 19, "tokens": 266, "cc": 8, "nest": 6, "execution_time": 0.016853, "novelty": 0.7755647430544076}}, {"code": "def minCost(houses, cost, m, n, target):\n    INF = float('inf')\n    dp = [[[INF] * n for _ in range(target + 1)] for _ in range(m + 1)]\n    dp[0][0][0] = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, target + 1):\n            for k in range(1, n + 1):\n                if houses[i - 1] != 0:\n                    if houses[i - 1] == k:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k])\n                    if j > 1:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][houses[i - 1]])\n                else:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + cost[i - 1][k - 1])\n                    if j > 1:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][h] + cost[i - 1][k - 1] for h in range(1, n + 1))\n\n    return min(dp[m][target]) if min(dp[m][target]) != INF else -1", "passed": false, "score": {"loc": 17, "tokens": 353, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.9898649222549891}}, {"code": "def minCost(houses, cost, m, n, target):\n    INF = float('inf')\n    dp = [[[INF] * n for _ in range(target + 1)] for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if houses[i] == j + 1:\n                dp[i][1][j] = 0\n            elif houses[i] == 0:\n                dp[i][1][j] = cost[i][j]\n    \n    for t in range(2, target + 1):\n        for i in range(t - 1, m):\n            for j in range(n):\n                for k in range(n):\n                    if j != k:\n                        dp[i][t][j] = min(dp[i][t][j], dp[i - 1][t - 1][k] + cost[i][j])\n                    else:\n                        dp[i][t][j] = min(dp[i][t][j], dp[i - 1][t][k] + cost[i][j])\n    \n    result = min(dp[m - 1][target])\n    return result if result != INF else -1", "passed": false, "score": {"loc": 19, "tokens": 279, "cc": 9, "nest": 6, "execution_time": 10.0, "novelty": 0.743097420715518}}, {"code": "def minCost(houses, cost, m, n, target):\n    dp = [[[float('inf')] * n for _ in range(target + 1)] for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if houses[i] == 0:\n                dp[i][1][j] = cost[i][j]\n            else:\n                dp[i][1][houses[i] - 1] = 0\n                \n    for t in range(2, target + 1):\n        for i in range(t - 1, m):\n            for j in range(n):\n                for k in range(n):\n                    if k == j:\n                        dp[i][t][j] = min(dp[i][t][j], dp[i - 1][t][k])\n                    else:\n                        dp[i][t][j] = min(dp[i][t][j], dp[i - 1][t - 1][k])\n                if houses[i] == 0:\n                    dp[i][t][j] += cost[i][j]\n    \n    result = min(dp[m - 1][target])\n    return result if result != float('inf') else -1", "passed": false, "score": {"loc": 20, "tokens": 289, "cc": 9, "nest": 6, "execution_time": 10.0, "novelty": 0.6947715545642502}}, {"code": "def minCost(houses, cost, m, n, target):\n    INF = float('inf')\n    dp = [[[INF] * n for _ in range(target + 1)] for _ in range(m + 1)]\n    dp[0][0][0] = 0\n    \n    for i in range(1, m + 1):\n        for j in range(1, target + 1):\n            for k in range(n):\n                if houses[i - 1] == 0:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + cost[i - 1][k])\n                    if k > 0:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k - 1] + cost[i - 1][k])\n                else:\n                    if houses[i - 1] - 1 == k:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k])\n                    else:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k] + cost[i - 1][k])\n    \n    ans = min(dp[m][target])\n    return ans if ans != INF else -1", "passed": false, "score": {"loc": 18, "tokens": 334, "cc": 6, "nest": 6, "execution_time": 10.0, "novelty": 0.7162298340159763}}, {"code": "def minCost(houses, cost, m, n, target):\n    INF = float('inf')\n    dp = [[[INF] * n for _ in range(target + 1)] for _ in range(m + 1)]\n    dp[0][0][0] = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, target + 1):\n            for k in range(1, n + 1):\n                if houses[i - 1] == 0:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + cost[i - 1][k - 1])\n                    if k > 1:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k - 1] + cost[i - 1][k - 1])\n                else:\n                    if houses[i - 1] == k:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k])\n                        if k > 1:\n                            dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k - 1])\n                    else:\n                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + cost[i - 1][k - 1])\n                        if k > 1:\n                            dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k - 1] + cost[i - 1][k - 1])\n\n    result = min(dp[m][target])\n    return result if result != INF else -1", "passed": false, "score": {"loc": 22, "tokens": 444, "cc": 8, "nest": 7, "execution_time": 10.0, "novelty": 0.7393516629195908}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 18055, "entry_point": "containsDuplicate", "best_list": [{"code": "def containsDuplicate(nums):\n    return len(nums) > len(set(nums))", "passed": true, "score": {"loc": 2, "tokens": 19, "cc": 0, "nest": 1, "execution_time": 0.016717, "novelty": 0.45835238609632545}}, {"code": "def containsDuplicate(nums):\n    return len(nums) != len(set(nums))", "passed": true, "score": {"loc": 2, "tokens": 20, "cc": 0, "nest": 1, "execution_time": 0.016617, "novelty": 0.4721471874463907}}, {"code": "def containsDuplicate(nums):\n    seen = {}\n    for num in nums:\n        if num in seen:\n            return True\n        seen[num] = True\n    return False", "passed": true, "score": {"loc": 7, "tokens": 30, "cc": 2, "nest": 3, "execution_time": 0.016573, "novelty": 0.4099670303024565}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 18061, "entry_point": "countOrders", "best_list": [{"code": "def countOrders(n):\n    MOD = 10**9 + 7\n    result = 1\n    for i in range(2, n + 1):\n        result = result * (2 * i - 1) * i % MOD\n    return result", "passed": true, "score": {"loc": 6, "tokens": 46, "cc": 1, "nest": 2, "execution_time": 0.016733, "novelty": 0.16907533924962947}}, {"code": "def countOrders(n):\n    MOD = 10**9 + 7\n    result = 1\n    for i in range(2, n + 1):\n        result = result * (2 * i - 1) * (2 * i) % MOD\n    return result", "passed": true, "score": {"loc": 6, "tokens": 50, "cc": 1, "nest": 2, "execution_time": 0.016567, "novelty": 0.1559418220646971}}, {"code": "def countOrders(n):\n    MOD = 10**9 + 7\n    result = 1\n    for i in range(2, n + 1):\n        result = result * (2*i * (2*i - 1)) % MOD\n    return result", "passed": true, "score": {"loc": 6, "tokens": 50, "cc": 1, "nest": 2, "execution_time": 0.016694, "novelty": 0.18303346793764042}}, {"code": "def countOrders(n):\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        dp[i] = (dp[i - 1] * (2 * i - 1) * (2 * i)) % MOD\n    \n    return dp[n]", "passed": false, "score": {"loc": 7, "tokens": 77, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.27837314027932847}}, {"code": "def countOrders(n):\n    MOD = 10**9 + 7\n    dp = [1] + [0] * n\n    for i in range(1, n):\n        dp[i + 1] = (dp[i] * (2 * i + 1) * (2 * i + 2)) % MOD\n    return dp[n]", "passed": false, "score": {"loc": 6, "tokens": 71, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.5083439469461293}}], "num_pass": 7, "num_uniq": 6, "num_fail": 3, "fail_uniq": 2}
{"id": 18079, "entry_point": "ladderLength", "best_list": [{"code": "def ladderLength(beginWord, endWord, wordList):\n    wordList = set(wordList)\n    if endWord not in wordList:\n        return 0\n    \n    queue = [(beginWord, 1)]\n    while queue:\n        word, length = queue.pop(0)\n        if word == endWord:\n            return length\n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                next_word = word[:i] + c + word[i+1:]\n                if next_word in wordList:\n                    wordList.remove(next_word)\n                    queue.append((next_word, length + 1))\n    return 0", "passed": true, "score": {"loc": 16, "tokens": 114, "cc": 6, "nest": 5, "execution_time": 0.016681, "novelty": 0.50518598341007}}, {"code": "from collections import deque\n\ndef ladderLength(beginWord, endWord, wordList):\n    word_set = set(wordList)\n    if endWord not in word_set:\n        return 0\n    \n    queue = deque([(beginWord, 1)])\n    while queue:\n        word, length = queue.popleft()\n        if word == endWord:\n            return length\n        for i in range(len(word)):\n            for char in 'abcdefghijklmnopqrstuvwxyz':\n                new_word = word[:i] + char + word[i+1:]\n                if new_word in word_set:\n                    queue.append((new_word, length + 1))\n                    word_set.remove(new_word)\n    return 0", "passed": true, "score": {"loc": 17, "tokens": 120, "cc": 6, "nest": 5, "execution_time": 0.016845, "novelty": 0.5393048239528585}}, {"code": "from collections import deque\n\ndef ladderLength(beginWord, endWord, wordList):\n    word_set = set(wordList)\n    if endWord not in word_set:\n        return 0\n    \n    queue = deque([(beginWord, 1)])\n    while queue:\n        current_word, level = queue.popleft()\n        if current_word == endWord:\n            return level\n        for i in range(len(current_word)):\n            for char in 'abcdefghijklmnopqrstuvwxyz':\n                next_word = current_word[:i] + char + current_word[i+1:]\n                if next_word in word_set:\n                    queue.append((next_word, level + 1))\n                    word_set.remove(next_word)\n    return 0", "passed": true, "score": {"loc": 17, "tokens": 120, "cc": 6, "nest": 5, "execution_time": 0.017108, "novelty": 0.5495685708965039}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 18095, "entry_point": "isPowerOfFour", "best_list": [{"code": "def isPowerOfFour(num):\n    return num > 0 and (num & (num - 1)) == 0 and num % 3 == 1", "passed": true, "score": {"loc": 2, "tokens": 30, "cc": 1, "nest": 1, "execution_time": 0.016456, "novelty": 0.13652036195317918}}, {"code": "def isPowerOfFour(num):\n    return num > 0 and (num & (num - 1)) == 0 and num & 0x55555555 == num", "passed": true, "score": {"loc": 2, "tokens": 30, "cc": 1, "nest": 1, "execution_time": 0.016492, "novelty": 0.11903167700050687}}, {"code": "powers = sorted([1, 4, 16, 64, 256, 1024, 4096, 16384, 65536, 262144, 1048576, 4194304, 16777216])\n\ndef isPowerOfFour(num):\n    return num > 0 and num in powers", "passed": true, "score": {"loc": 3, "tokens": 46, "cc": 1, "nest": 1, "execution_time": 0.01658, "novelty": 0.7461294101532648}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 18127, "entry_point": "generateMatrix", "best_list": [{"code": "def generateMatrix(n):\n    res = [[0] * n for _ in range(n)]\n    row, col, dr, dc = 0, 0, 0, 1\n    for num in range(1, n * n + 1):\n        res[row][col] = num\n        if not (0 <= row + dr < n and 0 <= col + dc < n and res[row + dr][col + dc] == 0):\n            dr, dc = dc, -dr\n        row, col = row + dr, col + dc\n    return res", "passed": true, "score": {"loc": 9, "tokens": 118, "cc": 3, "nest": 3, "execution_time": 0.016867, "novelty": 0.5096013233748939}}, {"code": "def generateMatrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    row, col = 0, 0\n    dr, dc = 0, 1\n    \n    for num in range(1, n * n + 1):\n        matrix[row][col] = num\n        if not (0 <= row + dr < n and 0 <= col + dc < n and matrix[row + dr][col + dc] == 0):\n            dr, dc = dc, -dr\n        row += dr\n        col += dc\n    \n    return matrix", "passed": true, "score": {"loc": 11, "tokens": 114, "cc": 3, "nest": 3, "execution_time": 0.016729, "novelty": 0.48161870210086777}}, {"code": "def generateMatrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    dr, dc = [0, 1, 0, -1], [1, 0, -1, 0]\n    r, c, di = 0, 0, 0\n    for i in range(1, n * n + 1):\n        matrix[r][c] = i\n        nr, nc = r + dr[di], c + dc[di]\n        if not (0 <= nr < n and 0 <= nc < n and matrix[nr][nc] == 0):\n            di = (di + 1) % 4\n            nr, nc = r + dr[di], c + dc[di]\n        r, c = nr, nc\n    return matrix", "passed": true, "score": {"loc": 12, "tokens": 162, "cc": 3, "nest": 3, "execution_time": 0.016686, "novelty": 0.41543645096391457}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 18154, "entry_point": "isPalindrome", "best_list": [{"code": "def isPalindrome(s):\n    filtered_chars = [char.lower() for char in s if char.isalnum()]\n    return filtered_chars == filtered_chars[::-1]", "passed": true, "score": {"loc": 3, "tokens": 36, "cc": 0, "nest": 1, "execution_time": 0.016677, "novelty": 0.36965623742568143}}, {"code": "def isPalindrome(s):\n    cleaned = ''.join(c.lower() for c in s if c.isalnum())\n    return cleaned == cleaned[::-1]", "passed": true, "score": {"loc": 3, "tokens": 40, "cc": 0, "nest": 1, "execution_time": 0.016632, "novelty": 0.32177239074357644}}, {"code": "def isPalindrome(s: str) -> bool:\n    filtered_chars = [char.lower() for char in s if char.isalnum()]\n    return filtered_chars == filtered_chars[::-1]", "passed": true, "score": {"loc": 3, "tokens": 41, "cc": 0, "nest": 1, "execution_time": 0.01654, "novelty": 0.3725806776469861}}, {"code": "def isPalindrome(s):\n    cleaned = (char.lower() for char in s if char.isalnum())\n    return cleaned == reversed(cleaned)", "passed": false, "score": {"loc": 3, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.39113663524813236}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 18180, "entry_point": "minDifficulty", "best_list": [{"code": "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n\n    dp = [[float('inf')] * (d + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for k in range(1, min(i, d) + 1):\n            max_diff = 0\n            for j in range(i, k - 1, -1):\n                max_diff = max(max_diff, jobDifficulty[j - 1])\n                dp[i][k] = min(dp[i][k], dp[j - 1][k - 1] + max_diff)\n\n    return dp[n][d]", "passed": true, "score": {"loc": 13, "tokens": 158, "cc": 4, "nest": 4, "execution_time": 0.016775, "novelty": 0.5598221535151537}}, {"code": "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n    \n    dp = [[float('inf')] * n for _ in range(d + 1)]\n    dp[1] = [max(jobDifficulty[:i + 1]) for i in range(n)]\n    \n    for k in range(2, d + 1):\n        for i in range(k - 1, n):\n            max_diff = 0\n            for j in range(i, k - 2, -1):\n                max_diff = max(max_diff, jobDifficulty[j])\n                dp[k][i] = min(dp[k][i], dp[k - 1][j - 1] + max_diff)\n    \n    return dp[d][n - 1]", "passed": true, "score": {"loc": 13, "tokens": 164, "cc": 4, "nest": 4, "execution_time": 0.016751, "novelty": 0.5830541696187338}}, {"code": "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n\n    dp = [[float('inf')] * n for _ in range(d + 1)]\n    dp[1][0] = jobDifficulty[0]\n\n    for i in range(1, n):\n        dp[1][i] = max(dp[1][i - 1], jobDifficulty[i])\n\n    for d in range(2, d + 1):\n        for i in range(d - 1, n):\n            for j in range(i, d - 2, -1):\n                dp[d][i] = min(dp[d][i], dp[d - 1][j - 1] + max(jobDifficulty[j:i + 1]))\n\n    return dp[d][n - 1]", "passed": true, "score": {"loc": 13, "tokens": 183, "cc": 5, "nest": 4, "execution_time": 0.016601, "novelty": 0.592021495254791}}, {"code": "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n\n    @lru_cache(None)\n    def dp(day, job):\n        if day == 1:\n            return max(jobDifficulty[job:])\n        max_difficulty = 0\n        result = float('inf')\n        for i in range(job, n - day + 1):\n            max_difficulty = max(max_difficulty, jobDifficulty[i])\n            result = min(result, max_difficulty + dp(day - 1, i + 1))\n        return result\n\n    return dp(d, 0)", "passed": false, "score": {"loc": 15, "tokens": 114, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6074033749168941}}, {"code": "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n\n    @cache\n    def dp(day, end):\n        if end == n - 1:\n            return max(jobDifficulty[end:])\n        return min(max(jobDifficulty[start:end+1]) + dp(day + 1, end) for start in range(end, n - d + day + 1))\n\n    return dp(0, 0)", "passed": false, "score": {"loc": 10, "tokens": 95, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6108962674693543}}, {"code": "from typing import List\n\ndef minDifficulty(jobDifficulty: List[int], d: int) -> int:\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n\n    @lru_cache(None)\n    def dp(i, k):\n        if k == 1:\n            return max(jobDifficulty[i:])\n        return min(dp(j, k-1) + max(jobDifficulty[i:j+1]) for j in range(i+1, n-k+2))\n\n    return dp(0, d)", "passed": false, "score": {"loc": 11, "tokens": 110, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6268840458553737}}, {"code": "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n    \n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for days in range(1, d + 1):\n        max_difficulty = 0\n        for j in range(days, n + 1):\n            max_difficulty = max(max_difficulty, jobDifficulty[j - 1])\n            dp[j] = min(dp[j], dp[j - 1] + max_difficulty)\n            for i in range(j - 2, days - 2, -1):\n                max_difficulty = max(max_difficulty, jobDifficulty[i])\n                dp[j] = min(dp[j], dp[i] + max_difficulty)\n    \n    return dp[n]", "passed": false, "score": {"loc": 15, "tokens": 157, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.6111354800353225}}, {"code": "def minDifficulty(jobDifficulty, d):\n    n = len(jobDifficulty)\n    if n < d:\n        return -1\n    \n    @lru_cache(None)\n    def dp(i, k):\n        if k == 1:\n            return max(jobDifficulty[i:])\n        return min(max(jobDifficulty[i:j]) + dp(j, k-1) for j in range(i+1, n-k+2))\n    \n    return dp(0, d)", "passed": false, "score": {"loc": 10, "tokens": 94, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5967080849763458}}], "num_pass": 5, "num_uniq": 4, "num_fail": 5, "fail_uniq": 5}
{"id": 18306, "entry_point": "isValid", "best_list": [{"code": "def isValid(s: str) -> bool:\n    while \"abc\" in s:\n        s = s.replace(\"abc\", \"\")\n    return s == \"\"", "passed": true, "score": {"loc": 4, "tokens": 37, "cc": 1, "nest": 2, "execution_time": 0.01659, "novelty": 0.2332235798257546}}, {"code": "def isValid(s):\n    stack = []\n    for char in s:\n        if char == 'c':\n            if len(stack) < 2 or stack[-2] != 'a' or stack[-1] != 'b':\n                return False\n            stack.pop()\n            stack.pop()\n        else:\n            stack.append(char)\n    return not stack", "passed": true, "score": {"loc": 11, "tokens": 76, "cc": 4, "nest": 4, "execution_time": 0.01664, "novelty": 0.6526931942485659}}, {"code": "def isValid(s: str) -> bool:\n    stack = []\n    for char in s:\n        if char == 'c':\n            if len(stack) < 2 or stack[-2] != 'a' or stack[-1] != 'b':\n                return False\n            stack.pop()\n            stack.pop()\n        else:\n            stack.append(char)\n    return not stack", "passed": true, "score": {"loc": 11, "tokens": 81, "cc": 4, "nest": 4, "execution_time": 0.016668, "novelty": 0.6286351190917091}}, {"code": "def isValid(s: str) -> bool:\n    stack = []\n    for char in s:\n        if char == 'a':\n            stack.append(char)\n        elif char == 'b':\n            if not stack or stack[-1] != 'a':\n                return False\n            stack.append(char)\n        elif char == 'c':\n            if not stack or stack[-1] != 'b':\n                return False\n            stack.pop()\n            if stack and stack[-1] == 'a':\n                stack.pop()\n    return not stack", "passed": false, "score": {"loc": 16, "tokens": 117, "cc": 10, "nest": 6, "execution_time": 10.0, "novelty": 0.7769472440720141}}], "num_pass": 9, "num_uniq": 3, "num_fail": 1, "fail_uniq": 1}
{"id": 18318, "entry_point": "longestOnes", "best_list": [{"code": "def longestOnes(A, K):\n    max_ones = start = 0\n    for end, value in enumerate(A):\n        K -= 1 - value\n        if K < 0:\n            K += 1 - A[start]\n            start += 1\n        max_ones = max(max_ones, end - start + 1)\n    return max_ones", "passed": true, "score": {"loc": 9, "tokens": 61, "cc": 2, "nest": 3, "execution_time": 0.016522, "novelty": 0.5907908877402737}}, {"code": "def longestOnes(A, K):\n    max_ones = 0\n    left = 0\n    for right in range(len(A)):\n        if A[right] == 0:\n            K -= 1\n        while K < 0:\n            if A[left] == 0:\n                K += 1\n            left += 1\n        max_ones = max(max_ones, right - left + 1)\n    return max_ones", "passed": true, "score": {"loc": 12, "tokens": 74, "cc": 4, "nest": 4, "execution_time": 0.016634, "novelty": 0.3191705829125321}}, {"code": "def longestOnes(A, K):\n    left = 0\n    max_ones = 0\n    count_zeros = 0\n    \n    for right in range(len(A)):\n        if A[right] == 0:\n            count_zeros += 1\n        \n        while count_zeros > K:\n            if A[left] == 0:\n                count_zeros -= 1\n            left += 1\n        \n        max_ones = max(max_ones, right - left + 1)\n    \n    return max_ones", "passed": true, "score": {"loc": 13, "tokens": 77, "cc": 4, "nest": 4, "execution_time": 0.016643, "novelty": 0.30052299956749573}}, {"code": "from collections import deque\n\ndef longestOnes(A, K):\n    zero_indices = deque()\n    max_length = 0\n    \n    for i, num in enumerate(A):\n        if num == 0:\n            zero_indices.append(i)\n            if len(zero_indices) > K:\n                max_length = max(max_length, i - zero_indices.popleft())\n    \n    return max(max_length, len(A) - len(zero_indices))", "passed": false, "score": {"loc": 10, "tokens": 79, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7043014894568005}}, {"code": "from collections import deque\n\ndef longestOnes(A, K):\n    max_length = 0\n    zero_indices = deque()\n    \n    for i in range(len(A)):\n        if A[i] == 0:\n            zero_indices.append(i)\n        \n        if len(zero_indices) > K:\n            max_length = max(max_length, i - zero_indices[0] - 1)\n            zero_indices.popleft()\n    \n    max_length = max(max_length, len(A) - zero_indices[0] - 1)\n    \n    return max_length", "passed": false, "score": {"loc": 12, "tokens": 94, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.8121406029552156}}], "num_pass": 8, "num_uniq": 7, "num_fail": 2, "fail_uniq": 2}
{"id": 18327, "entry_point": "longestSubstring", "best_list": [{"code": "def longestSubstring(s, k):\n    from collections import Counter\n    \n    def helper(s, k):\n        count = Counter(s)\n        for c in set(s):\n            if count[c] < k:\n                return max(helper(sub, k) for sub in s.split(c))\n        return len(s)\n    \n    return helper(s, k)", "passed": true, "score": {"loc": 9, "tokens": 73, "cc": 2, "nest": 4, "execution_time": 0.016722, "novelty": 0.5022871955784214}}, {"code": "def longestSubstring(s: str, k: int) -> int:\n    from collections import Counter\n    \n    if len(s) < k:\n        return 0\n    \n    count = Counter(s)\n    for c in set(s):\n        if count[c] < k:\n            return max(longestSubstring(t, k) for t in s.split(c))\n    \n    return len(s)", "passed": true, "score": {"loc": 9, "tokens": 75, "cc": 3, "nest": 3, "execution_time": 0.016616, "novelty": 0.7427321962217703}}, {"code": "def longestSubstring(s: str, k: int) -> int:\n    if k <= 1:\n        return len(s)\n    count = {}\n    for char in s:\n        count[char] = count.get(char, 0) + 1\n    for char in count:\n        if count[char] < k:\n            return max(longestSubstring(sub, k) for sub in s.split(char))\n    return len(s)", "passed": true, "score": {"loc": 10, "tokens": 87, "cc": 4, "nest": 3, "execution_time": 0.01678, "novelty": 0.573823481366692}}, {"code": "def longestSubstring(s, k):\n    if k <= 1:\n        return len(s)\n    if not s:\n        return 0\n\n    count = [0] * 26\n    for char in s:\n        count[ord(char) - ord('a')] += 1\n\n    split_points = [0]\n    for i, char in enumerate(s):\n        if count[ord(char) - ord('a')] < k:\n            split_points.append(i + 1)\n\n    split_points.append(len(s))\n    max_length = 0\n    for i in range(1, len(split_points)):\n        sub_str = s[split_points[i-1]:split_points[i]]\n        if all(count[ord(char) - ord('a')] >= k for char in sub_str):\n            max_length = max(max_length, len(sub_str))\n\n    return max_length", "passed": false, "score": {"loc": 19, "tokens": 175, "cc": 7, "nest": 3, "execution_time": 10.0, "novelty": 0.8204088561169085}}, {"code": "def longestSubstring(s, k):\n    from collections import Counter\n\n    def at_least_k(s, k):\n        count = Counter(s)\n        return all(v >= k for v in count.values())\n\n    if len(s) < k:\n        return 0\n\n    for i in range(len(s)):\n        if at_least_k(s[i:], k):\n            return len(s[i:])\n        if s[i] not in [s[j] for j in range(i + 1, len(s)) if s[j] == s[i]]:\n            return max(longestSubstring(sub, k) for sub in s.split(s[i]))\n\n    return 0", "passed": false, "score": {"loc": 13, "tokens": 147, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7864567286758964}}, {"code": "def longestSubstring(s, k):\n    from collections import Counter\n    \n    if k == 0:\n        return 0\n    \n    char_count = Counter(s)\n    unique_chars = set(char_count)\n    \n    if len(unique_chars) <= 1:\n        if min(char_count.values()) >= k:\n            return len(s)\n        else:\n            return 0\n    \n    max_length = 0\n    for char in unique_chars:\n        if char_count[char] < k:\n            segments = s.split(char)\n            for segment in segments:\n                max_length = max(max_length, longestSubstring(segment, k))\n            return max_length\n    \n    return len(s)", "passed": false, "score": {"loc": 19, "tokens": 112, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.8202994607456708}}, {"code": "def longestSubstring(s: str, k: int) -> int:\n    if not s or k <= 0:\n        return 0\n\n    def helper(s, k):\n        count = [0] * 26\n        for char in s:\n            count[ord(char) - ord('a')] += 1\n\n        unique_chars = set(char for char in s if count[ord(char) - ord('a')] > 0)\n        if len(unique_chars) < k:\n            return 0\n\n        left = 0\n        result = 0\n        for right, char in enumerate(s):\n            count[ord(char) - ord('a')] -= 1\n            if count[ord(char) - ord('a')] == k - 1:\n                while left < right and count[ord(s[left]) - ord('a')] < k:\n                    count[ord(s[left]) - ord('a')] += 1\n                    left += 1\n                result = max(result, right - left + 1)\n        return result\n\n    return helper(s, k)", "passed": false, "score": {"loc": 21, "tokens": 224, "cc": 8, "nest": 5, "execution_time": 10.0, "novelty": 0.8069791297499513}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 18338, "entry_point": "validSquare", "best_list": [{"code": "def validSquare(p1, p2, p3, p4):\n    points = [p1, p2, p3, p4]\n    distances = []\n    \n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\n            distances.append(dist)\n    \n    distances.sort()\n    \n    return len(set(distances)) == 2 and distances[0] > 0", "passed": true, "score": {"loc": 9, "tokens": 125, "cc": 3, "nest": 3, "execution_time": 0.016596, "novelty": 0.7528392391993419}}, {"code": "def validSquare(p1, p2, p3, p4):\n    if p1 == p2 or p1 == p3 or p1 == p4 or p2 == p3 or p2 == p4 or p3 == p4:\n        return False\n    sides = set()\n    sides.add((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    sides.add((p1[0] - p3[0]) ** 2 + (p1[1] - p3[1]) ** 2)\n    sides.add((p1[0] - p4[0]) ** 2 + (p1[1] - p4[1]) ** 2)\n    sides.add((p2[0] - p3[0]) ** 2 + (p2[1] - p3[1]) ** 2)\n    sides.add((p2[0] - p4[0]) ** 2 + (p2[1] - p4[1]) ** 2)\n    sides.add((p3[0] - p4[0]) ** 2 + (p3[1] - p4[1]) ** 2)\n    return len(sides) == 2 and 0 not in sides", "passed": true, "score": {"loc": 11, "tokens": 267, "cc": 3, "nest": 2, "execution_time": 0.016738, "novelty": 0.9003569253153658}}, {"code": "def validSquare(p1, p2, p3, p4):\n    points = {tuple(p) for p in [p1, p2, p3, p4]}\n    if len(points) != 4:\n        return False\n    distances = set()\n    for p1 in points:\n        for p2 in points:\n            if p1 == p2:\n                continue\n            dist = (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n            distances.add(dist)\n    return len(distances) == 2 and 0 not in distances", "passed": true, "score": {"loc": 12, "tokens": 115, "cc": 5, "nest": 4, "execution_time": 0.0165, "novelty": 0.7038654178749754}}, {"code": "def validSquare(p1, p2, p3, p4):\n    if any(p == q for p, q in [(p1, p2), (p1, p3), (p1, p4), (p2, p3), (p2, p4), (p3, p4)]):\n        return False\n\n    def squared_distance(p, q):\n        return (p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2\n\n    distances = sorted([squared_distance(p, q) for p, q in combinations([p1, p2, p3, p4], 2)])\n    return distances[0] > 0 and distances[0] == distances[3] and distances[4] == distances[5] and distances[0] + distances[0] == distances[4]", "passed": false, "score": {"loc": 7, "tokens": 180, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.7445682736188854}}, {"code": "def validSquare(p1, p2, p3, p4):\n    points = sorted([p1, p2, p3, p4])\n    a = points[1][0] - points[0][0]\n    b = points[1][1] - points[0][1]\n    c = points[2][0] - points[0][0]\n    d = points[2][1] - points[0][1]\n    return (a != 0 and b != 0 and (a == c or b == d) and (a**2 + b**2 == c**2 + d**2))", "passed": false, "score": {"loc": 7, "tokens": 141, "cc": 2, "nest": 1, "execution_time": 10.0, "novelty": 0.8100254007008126}}, {"code": "def validSquare(p1, p2, p3, p4):\n    def distance(p1, p2):\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n    \n    points = [p1, p2, p3, p4]\n    dists = sorted([distance(p1, p2) for p1, p2 in combinations(points, 2)])\n    \n    return dists[0] > 0 and dists[:4] == dists[4:8] and dists[8] == 2 * dists[0]", "passed": false, "score": {"loc": 6, "tokens": 119, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.7103471190782692}}, {"code": "def validSquare(p1, p2, p3, p4):\n    def distance(p1, p2):\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n    points = {tuple(p1), tuple(p2), tuple(p3), tuple(p4)}\n    if len(points) != 4:\n        return False\n\n    dists = sorted([distance(p1, p2) for p1 in points for p2 in points if p1 < p2])\n    return dists[0] > 0 and dists[0] == dists[3] == dists[4] and dists[5] == dists[6] == dists[7]", "passed": false, "score": {"loc": 8, "tokens": 150, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.7532828116122366}}, {"code": "def validSquare(p1, p2, p3, p4):\n    points = {tuple(p) for p in [p1, p2, p3, p4]}\n    if len(points) != 4:\n        return False\n    distances = set()\n    for p1, p2 in combinations(points, 2):\n        dist = (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n        if dist == 0:\n            return False\n        distances.add(dist)\n    return len(distances) == 2", "passed": false, "score": {"loc": 11, "tokens": 113, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6771557756500597}}], "num_pass": 4, "num_uniq": 4, "num_fail": 6, "fail_uniq": 6}
{"id": 18370, "entry_point": "searchMatrix", "best_list": [{"code": "def searchMatrix(matrix, target):\n    for row in matrix:\n        if row and target >= row[0] and target <= row[-1]:\n            return target in row\n    return False", "passed": true, "score": {"loc": 5, "tokens": 39, "cc": 3, "nest": 3, "execution_time": 0.016605, "novelty": 0.7950012799985324}}, {"code": "def searchMatrix(matrix, target):\n    if not matrix or not matrix[0]:\n        return False\n    \n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        mid_value = matrix[mid // n][mid % n]\n        \n        if mid_value == target:\n            return True\n        elif mid_value < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False", "passed": true, "score": {"loc": 15, "tokens": 104, "cc": 5, "nest": 4, "execution_time": 0.016626, "novelty": 0.20098426109403345}}, {"code": "def searchMatrix(matrix, target):\n    if not matrix or not matrix[0]:\n        return False\n    \n    rows, cols = len(matrix), len(matrix[0])\n    left, right = 0, rows * cols - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        num = matrix[mid // cols][mid % cols]\n        \n        if num == target:\n            return True\n        elif num < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False", "passed": true, "score": {"loc": 15, "tokens": 104, "cc": 5, "nest": 4, "execution_time": 0.016686, "novelty": 0.17543103574270724}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 18408, "entry_point": "reverseParentheses", "best_list": [{"code": "def reverseParentheses(s: str) -> str:\n    stack = [[]]\n    for char in s:\n        if char == '(':\n            stack.append([])\n        elif char == ')':\n            inner = stack.pop()\n            stack[-1].extend(reversed(inner))\n        else:\n            stack[-1].append(char)\n    return ''.join(stack[0])", "passed": true, "score": {"loc": 11, "tokens": 88, "cc": 3, "nest": 4, "execution_time": 0.016702, "novelty": 0.46937794740991845}}, {"code": "def reverseParentheses(s):\n    stack = []\n    current = ''\n    for char in s:\n        if char == '(':\n            stack.append(current)\n            current = ''\n        elif char == ')':\n            current = stack.pop() + current[::-1]\n        else:\n            current += char\n    return current", "passed": true, "score": {"loc": 12, "tokens": 68, "cc": 3, "nest": 4, "execution_time": 0.016355, "novelty": 0.4397190646321588}}, {"code": "def reverseParentheses(s: str) -> str:\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append([])\n        elif char == ')':\n            reversed_part = stack.pop()[::-1]\n            if stack:\n                stack[-1].extend(reversed_part)\n            else:\n                stack.append(reversed_part)\n        else:\n            if stack:\n                stack[-1].append(char)\n            else:\n                stack.append([char])\n    return ''.join(stack[0])", "passed": true, "score": {"loc": 17, "tokens": 113, "cc": 5, "nest": 5, "execution_time": 0.016568, "novelty": 0.48796378018399766}}, {"code": "def reverseParentheses(s):\n    stack = ['']\n    for char in s:\n        if char == '(':\n            stack.append('')\n        elif char == ')':\n            reversed_sub = stack.pop()[::-1]\n            stack[-1].extend(reversed_sub)\n        else:\n            stack[-1].append(char)\n    return ''.join(stack[-1])\n\ndef _equivalent(_lhs, _rhs):\n    return _lhs == _rhs", "passed": false, "score": {"loc": 13, "tokens": 100, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.43372961211856564}}, {"code": "def reverseParentheses(s):\n    stack = []\n    for char in s:\n        if char == ')':\n            temp = ''\n            while stack[-1] != '(':\n                temp += stack.pop()\n            stack.pop()  # Remove '('\n            stack.append(temp[::-1])\n        else:\n            stack.append(char)\n    return ''.join(stack)", "passed": false, "score": {"loc": 12, "tokens": 85, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.47300595665389933}}, {"code": "def reverseParentheses(s):\n    stack = []\n    for char in s:\n        if char == ')':\n            reversed_substring = ''\n            while stack and stack[-1] != '(':\n                reversed_substring = stack.pop() + reversed_substring\n            stack.pop()  # Remove the '('\n            stack.extend(reversed_substring)\n        else:\n            stack.append(char)\n    return ''.join(stack)", "passed": false, "score": {"loc": 12, "tokens": 83, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.4876237217732201}}, {"code": "def reverseParentheses(s):\n    stack = []\n    current = []\n    for char in s:\n        if char == '(':\n            stack.append(''.join(current))\n            current = []\n        elif char == ')':\n            reversed_substring = ''.join(current)[::-1]\n            current = stack.pop() + reversed_substring\n        else:\n            current.append(char)\n    return ''.join(current)", "passed": false, "score": {"loc": 13, "tokens": 91, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5900811470794591}}, {"code": "def reverseParentheses(s):\n    stack = []\n    for char in s:\n        if char == ')':\n            chunk = ''\n            while stack[-1] != '(':\n                chunk += stack.pop()[0]\n            stack.pop()  # Remove the '('\n            stack.append([chunk[::-1]])\n        else:\n            stack.append([char])\n    return ''.join(chunk for chunk in stack)", "passed": false, "score": {"loc": 12, "tokens": 97, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5134887081212713}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 18435, "entry_point": "combinationSum4", "best_list": [{"code": "def combinationSum4(nums, target):\n    dp = {0: 1}\n    for i in range(1, target + 1):\n        dp[i] = sum(dp[i - num] for num in nums if i - num >= 0)\n    return dp[target]", "passed": true, "score": {"loc": 5, "tokens": 57, "cc": 1, "nest": 2, "execution_time": 0.016598, "novelty": 0.23035269246117762}}, {"code": "def combinationSum4(nums, target):\n    dp = {0: 1}\n    for t in range(1, target + 1):\n        dp[t] = sum(dp[t - n] for n in nums if t - n >= 0)\n    return dp[target]", "passed": true, "score": {"loc": 5, "tokens": 57, "cc": 1, "nest": 2, "execution_time": 0.016646, "novelty": 0.2325572559399266}}, {"code": "def combinationSum4(nums, target):\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for i in range(1, target + 1):\n        dp[i] = sum(dp[i - num] for num in nums if i - num >= 0)\n    return dp[target]", "passed": true, "score": {"loc": 6, "tokens": 67, "cc": 1, "nest": 2, "execution_time": 0.016552, "novelty": 0.17897412177716454}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 18498, "entry_point": "countSegments", "best_list": [{"code": "def countSegments(s):\n    return len([word for word in s.split() if word])", "passed": true, "score": {"loc": 2, "tokens": 23, "cc": 0, "nest": 1, "execution_time": 0.016539, "novelty": 0.624937757726233}}, {"code": "def countSegments(s):\n    return len(list(filter(None, s.split())))", "passed": true, "score": {"loc": 2, "tokens": 23, "cc": 0, "nest": 1, "execution_time": 0.016633, "novelty": 0.5385885167578904}}, {"code": "def countSegments(s: str) -> int:\n    return sum(1 for char in s.split() if char)", "passed": true, "score": {"loc": 2, "tokens": 26, "cc": 0, "nest": 1, "execution_time": 0.01662, "novelty": 0.614961288922147}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 1861, "entry_point": "average", "best_list": [{"code": "def average(salary):\n    return (sum(salary) - min(salary) - max(salary)) / (len(salary) - 2)", "passed": true, "score": {"loc": 2, "tokens": 32, "cc": 0, "nest": 1, "execution_time": 0.016476, "novelty": 0.37685665692823966}}, {"code": "def average(salary):\n    return (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)", "passed": true, "score": {"loc": 2, "tokens": 32, "cc": 0, "nest": 1, "execution_time": 0.016678, "novelty": 0.376214396170372}}, {"code": "def average(salary):\n    sorted_salary = sorted(salary)\n    return sum(sorted_salary[1:-1]) / len(sorted_salary[1:-1])", "passed": true, "score": {"loc": 3, "tokens": 34, "cc": 0, "nest": 1, "execution_time": 0.01652, "novelty": 0.736817489979336}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 1862, "entry_point": "getHint", "best_list": [{"code": "def getHint(secret, guess):\n    from collections import Counter\n    \n    bull = sum(s == g for s, g in zip(secret, guess))\n    count_s, count_g = Counter(secret), Counter(guess)\n    cow = sum((count_s & count_g).values()) - bull\n    return f\"{bull}A{cow}B\"", "passed": true, "score": {"loc": 6, "tokens": 73, "cc": 0, "nest": 1, "execution_time": 0.016769, "novelty": 0.4122476522751951}}, {"code": "def getHint(secret: str, guess: str) -> str:\n    from collections import Counter\n    \n    A = sum(s == g for s, g in zip(secret, guess))\n    secret_counts = Counter(secret)\n    guess_counts = Counter(guess)\n    B = sum((secret_counts & guess_counts).values()) - A\n    return f\"{A}A{B}B\"", "passed": true, "score": {"loc": 7, "tokens": 79, "cc": 0, "nest": 1, "execution_time": 0.016664, "novelty": 0.4106255838569448}}, {"code": "def getHint(secret: str, guess: str) -> str:\n    bull = sum(s == g for s, g in zip(secret, guess))\n    secret_freq = [0] * 10\n    guess_freq = [0] * 10\n    for s, g in zip(secret, guess):\n        if s != g:\n            secret_freq[int(s)] += 1\n            guess_freq[int(g)] += 1\n    cow = sum(min(sf, gf) for sf, gf in zip(secret_freq, guess_freq))\n    return f\"{bull}A{cow}B\"", "passed": true, "score": {"loc": 10, "tokens": 121, "cc": 2, "nest": 3, "execution_time": 0.016787, "novelty": 0.3836627819352322}}, {"code": "def getHint(secret, guess):\n    bulls = sum(s == g for s, g in zip(secret, guess))\n    counts_s = [0] * 10\n    counts_g = [0] * 10\n    for s, g in zip(secret, guess):\n        counts_s[int(s)] += 1\n        counts_g[int(g)] += 1\n    cows = sum(min(cs, cg) for cs, cg in zip(counts_s, counts_g)) - bulls\n    return f\"{bulls}A{cows}B\"", "passed": false, "score": {"loc": 9, "tokens": 110, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.3509441069241679}}, {"code": "def getHint(secret: str, guess: str) -> str:\n    bulls = sum(s == g for s, g in zip(secret, guess))\n    counts_s = [0] * 10\n    counts_g = [0] * 10\n    for s, g in zip(secret, guess):\n        counts_s[int(s)] += 1\n        counts_g[int(g)] += 1\n    cows = sum(min(cs, cg) for cs, cg in zip(counts_s, counts_g)) - bulls\n    return f\"{bulls}A{cows}B\"", "passed": false, "score": {"loc": 9, "tokens": 117, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.34387372388768167}}, {"code": "def getHint(secret, guess):\n    bull = sum(s == g for s, g in zip(secret, guess))\n    both = sum((collections.Counter(secret) & collections.Counter(guess)).values())\n    return f\"{bull}A{both - bull}B\"", "passed": false, "score": {"loc": 4, "tokens": 66, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.4207645840331323}}], "num_pass": 4, "num_uniq": 4, "num_fail": 6, "fail_uniq": 3}
{"id": 1879, "entry_point": "minPathSum", "best_list": [{"code": "def minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [float('inf')] * n\n    dp[0] = 0\n    for i in range(m):\n        dp[0] += grid[i][0]\n        for j in range(1, n):\n            dp[j] = min(dp[j], dp[j-1]) + grid[i][j]\n    return dp[-1]", "passed": true, "score": {"loc": 9, "tokens": 104, "cc": 2, "nest": 3, "execution_time": 0.016709, "novelty": 0.5780737441461765}}, {"code": "def minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n    for i in range(1, m):\n        grid[i][0] += grid[i-1][0]\n    for j in range(1, n):\n        grid[0][j] += grid[0][j-1]\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n    return grid[-1][-1]", "passed": true, "score": {"loc": 10, "tokens": 139, "cc": 4, "nest": 3, "execution_time": 0.016665, "novelty": 0.6161976597982927}}, {"code": "def minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(m):\n        for j in range(n):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n    \n    return dp[m-1][n-1]", "passed": true, "score": {"loc": 11, "tokens": 168, "cc": 4, "nest": 4, "execution_time": 0.01674, "novelty": 0.6328045449450272}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 18511, "entry_point": "isValid", "best_list": [{"code": "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    return not stack", "passed": true, "score": {"loc": 11, "tokens": 87, "cc": 3, "nest": 4, "execution_time": 0.016877, "novelty": 0.35536821692644205}}, {"code": "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            return False\n    return not stack", "passed": true, "score": {"loc": 12, "tokens": 92, "cc": 5, "nest": 5, "execution_time": 0.016616, "novelty": 0.0815975803757879}}, {"code": "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or mapping[char] != stack.pop():\n                return False\n        else:\n            return False\n    return not stack", "passed": true, "score": {"loc": 12, "tokens": 92, "cc": 5, "nest": 5, "execution_time": 0.016849, "novelty": 0.11312651697862286}}, {"code": "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or mapping[char] != stack.pop():\n                return False\n    return not stack", "passed": false, "score": {"loc": 10, "tokens": 88, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.1338694377645533}}], "num_pass": 9, "num_uniq": 3, "num_fail": 1, "fail_uniq": 1}
{"id": 18514, "entry_point": "isValid", "best_list": [{"code": "import re\n\ndef isValid(code):\n    stack, i = [], 0\n    while i < len(code):\n        if code[i] == '<':\n            if i + 1 < len(code) and code[i + 1] == '/':\n                if not stack:\n                    return False\n                end_tag = re.match(r'</([A-Z]{1,9})>', code[i:])\n                if not end_tag:\n                    return False\n                if end_tag.group(1) != stack.pop():\n                    return False\n                i = end_tag.end()\n            elif i + 2 < len(code) and code[i + 2] == '>':\n                tag = re.match(r'<([A-Z]{1,9})>', code[i:])\n                if not tag:\n                    return False\n                stack.append(tag.group(1))\n                i = tag.end()\n            else:\n                return False\n        else:\n            if not stack:\n                return False\n            i += 1\n    return not stack", "passed": true, "score": {"loc": 27, "tokens": 219, "cc": 11, "nest": 6, "execution_time": 0.016944, "novelty": 0.7271653912633578}}, {"code": "import re\n\ndef isValid(code: str) -> bool:\n    stack = []\n    i = 0\n    while i < len(code):\n        if code[i] == '<':\n            if i + 1 < len(code) and code[i+1] == '/':\n                if not stack:\n                    return False\n                tag = re.match(r'</([A-Z]{1,9})>', code[i:])\n                if not tag:\n                    return False\n                i += tag.end()\n                if stack.pop() != tag.group(1):\n                    return False\n            elif i + 9 < len(code) and re.match(r'<[A-Z]{1,9}>', code[i:]):\n                tag = re.match(r'<([A-Z]{1,9})>', code[i:])\n                i += tag.end()\n                stack.append(tag.group(1))\n            else:\n                return False\n        elif stack and i + 8 < len(code) and code[i:i+9] == '<![CDATA[':\n            i = code.find(']]>', i)\n            if i == -1:\n                return False\n            i += 3\n        else:\n            i += 1\n    return not stack", "passed": true, "score": {"loc": 29, "tokens": 285, "cc": 12, "nest": 5, "execution_time": 0.016872, "novelty": 0.7077452474043515}}, {"code": "def isValid(code):\n    stack, i = [], 0\n    while i < len(code):\n        if code[i] == '<':\n            if i + 1 == len(code) or code[i + 1] == '/':\n                if not stack:\n                    return False\n                tag_end = code.find('>', i)\n                if tag_end == -1:\n                    return False\n                tag = code[i + 2:tag_end]\n                if len(tag) == 0 or len(tag) > 9 or any(c.islower() for c in tag):\n                    return False\n                if stack.pop() != tag:\n                    return False\n                i = tag_end + 1\n            else:\n                tag_end = code.find('>', i)\n                if tag_end == -1 or i + 2 > tag_end or tag_end - i - 2 > 9:\n                    return False\n                tag = code[i + 1:tag_end]\n                if any(c.islower() for c in tag):\n                    return False\n                stack.append(tag)\n                i = tag_end + 1\n        elif stack:\n            i += 1\n        else:\n            return False\n    return not stack", "passed": true, "score": {"loc": 30, "tokens": 229, "cc": 13, "nest": 5, "execution_time": 0.016928, "novelty": 0.7765854504603824}}, {"code": "def isValid(code):\n    stack = []\n    i = 0\n    n = len(code)\n    \n    def skip_tag():\n        nonlocal i\n        start = i\n        i += 1\n        while i < n and code[i] != '>':\n            i += 1\n        if i == n:\n            return False\n        tag = code[start + 1:i]\n        i += 1\n        return tag and 1 <= len(tag) <= 9 and tag.isupper()\n    \n    def is_cdata():\n        nonlocal i\n        if code[i:i + 9] == \"<![CDATA[\":\n            i += 9\n            while i < n and code[i:i + 3] != \"]]>\":\n                i += 1\n            i += 3\n            return i < n\n        return False\n    \n    while i < n:\n        if code[i:i + 2] == \"<>\":\n            return False\n        if code[i] == '<':\n            i += 1\n            if code[i] == '/':\n                if not stack:\n                    return False\n                tag = stack.pop()\n                i += len(tag) + 2\n                if i == n or code[i] != '>':\n                    return False\n                i += 1\n            elif code[i] == '!':\n                if not is_cdata():\n                    return False\n            else:\n                if not skip_tag():\n                    return False\n                stack.append(code[i - len(tag):i])\n        else:\n            i += 1\n    \n    return not stack", "passed": false, "score": {"loc": 47, "tokens": 305, "cc": 17, "nest": 6, "execution_time": 10.0, "novelty": 0.7538612955819937}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 18562, "entry_point": "canPlaceFlowers", "best_list": [{"code": "def canPlaceFlowers(flowerbed, n):\n    planted = set()\n    for i in range(len(flowerbed)):\n        if flowerbed[i] == 0 and (i - 1 not in planted and i + 1 not in planted):\n            planted.add(i)\n            n -= 1\n    return n <= 0", "passed": true, "score": {"loc": 7, "tokens": 64, "cc": 4, "nest": 3, "execution_time": 0.016713, "novelty": 0.7171637439598337}}, {"code": "def canPlaceFlowers(flowerbed, n):\n    count = 0\n    flowerbed = [0] + flowerbed + [0]\n    for i in range(1, len(flowerbed) - 1):\n        if flowerbed[i - 1] == 0 and flowerbed[i] == 0 and flowerbed[i + 1] == 0:\n            flowerbed[i] = 1\n            count += 1\n    return count >= n", "passed": true, "score": {"loc": 8, "tokens": 81, "cc": 3, "nest": 3, "execution_time": 0.016656, "novelty": 0.4195512951330769}}, {"code": "def canPlaceFlowers(flowerbed, n):\n    for i, plot in enumerate(flowerbed):\n        if plot == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):\n            flowerbed[i] = 1\n            n -= 1\n        if n == 0:\n            return True\n    return False", "passed": true, "score": {"loc": 8, "tokens": 83, "cc": 6, "nest": 3, "execution_time": 0.016574, "novelty": 0.5824519239680421}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 18570, "entry_point": "maxTurbulenceSize", "best_list": [{"code": "def maxTurbulenceSize(A):\n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            current_len = current_len + 1 if current_len % 2 == 0 else 2\n        elif A[i] < A[i - 1]:\n            current_len = current_len + 1 if current_len % 2 == 1 else 2\n        else:\n            current_len = 1\n        max_len = max(max_len, current_len)\n    \n    return max_len", "passed": true, "score": {"loc": 12, "tokens": 94, "cc": 3, "nest": 4, "execution_time": 0.016541, "novelty": 0.325495609133038}}, {"code": "def maxTurbulenceSize(A):\n    n = len(A)\n    if n < 2:\n        return n\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, n):\n        if A[i] > A[i - 1]:\n            current_len = current_len + 1 if current_len % 2 == 0 else 2\n        elif A[i] < A[i - 1]:\n            current_len = current_len + 1 if current_len % 2 != 0 else 2\n        else:\n            current_len = 1\n        max_len = max(max_len, current_len)\n    \n    return max_len", "passed": true, "score": {"loc": 15, "tokens": 104, "cc": 4, "nest": 4, "execution_time": 0.016755, "novelty": 0.39654925955120257}}, {"code": "def maxTurbulenceSize(A):\n    n = len(A)\n    if n == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, n):\n        if A[i] > A[i - 1]:\n            current_len = current_len + 1 if current_len % 2 == 0 else 2\n        elif A[i] < A[i - 1]:\n            current_len = current_len + 1 if current_len % 2 == 1 else 2\n        else:\n            current_len = 1\n        max_len = max(max_len, current_len)\n    \n    return max_len", "passed": true, "score": {"loc": 15, "tokens": 105, "cc": 4, "nest": 4, "execution_time": 0.016696, "novelty": 0.4792236998220214}}, {"code": "def maxTurbulenceSize(arr):\n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_length += 1\n        elif arr[i] < arr[i - 1]:\n            current_length = 2\n        else:\n            current_length = 1\n        \n        max_length = max(max_length, current_length)\n    \n    return max_length", "passed": false, "score": {"loc": 12, "tokens": 73, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.38541684635197704}}, {"code": "def maxTurbulenceSize(A):\n    n = len(A)\n    if n == 1:\n        return 1\n    \n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, n):\n        if A[i] > A[i - 1]:\n            if current_length > 1 and (i - 2 >= 0 and A[i - 2] < A[i - 1]):\n                current_length += 1\n            else:\n                current_length = 2\n        elif A[i] < A[i - 1]:\n            if current_length > 1 and (i - 2 >= 0 and A[i - 2] > A[i - 1]):\n                current_length += 1\n            else:\n                current_length = 2\n        else:\n            current_length = 1\n        \n        max_length = max(max_length, current_length)\n    \n    return max_length", "passed": false, "score": {"loc": 21, "tokens": 151, "cc": 10, "nest": 5, "execution_time": 10.0, "novelty": 0.7419088091805297}}, {"code": "def maxTurbulenceSize(A):\n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            if current_len > 1:\n                current_len = 2\n            else:\n                current_len += 1\n        elif A[i] < A[i - 1]:\n            if current_len > 1:\n                current_len += 1\n            else:\n                current_len = 2\n        else:\n            current_len = 1\n        max_len = max(max_len, current_len)\n    \n    return max_len", "passed": false, "score": {"loc": 18, "tokens": 94, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.34719034274022686}}, {"code": "def maxTurbulenceSize(A):\n    n = len(A)\n    if n < 2:\n        return n\n    \n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, n):\n        if A[i] > A[i - 1]:\n            current_length = 2 if current_length == 1 else current_length + 1\n        elif A[i] < A[i - 1]:\n            current_length = current_length + 1 if current_length == 1 else 2\n        else:\n            current_length = 1\n        \n        max_length = max(max_length, current_length)\n    \n    return max_length", "passed": false, "score": {"loc": 15, "tokens": 100, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.48678019531586403}}, {"code": "def maxTurbulenceSize(A):\n    n = len(A)\n    if n < 2:\n        return n\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, n):\n        if A[i] > A[i-1]:\n            if current_len % 2 == 0:\n                current_len = 2\n            else:\n                current_len += 1\n        elif A[i] < A[i-1]:\n            if current_len % 2 == 1:\n                current_len = 2\n            else:\n                current_len += 1\n        else:\n            current_len = 1\n        \n        max_len = max(max_len, current_len)\n    \n    return max_len", "passed": false, "score": {"loc": 21, "tokens": 110, "cc": 6, "nest": 5, "execution_time": 10.0, "novelty": 0.5007098390121058}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 18605, "entry_point": "findNthDigit", "best_list": [{"code": "def findNthDigit(n: int) -> int:\n    digits = ''.join(map(str, range(1, n+1)))\n    return int(digits[n-1])", "passed": true, "score": {"loc": 3, "tokens": 42, "cc": 0, "nest": 1, "execution_time": 0.01656, "novelty": 0.6895792909604459}}, {"code": "def findNthDigit(n):\n    digits = ''\n    for i in range(1, 2147483648):\n        digits += str(i)\n        if len(digits) >= n:\n            return int(digits[n-1])", "passed": true, "score": {"loc": 6, "tokens": 46, "cc": 2, "nest": 3, "execution_time": 0.016553, "novelty": 0.7062497520537265}}, {"code": "def findNthDigit(n):\n    i = 1\n    while n > 9 * i * 10**(i-1):\n        n -= 9 * i * 10**(i-1)\n        i += 1\n    return int(str(10**(i-1) + (n - 1) // i)[(n - 1) % i])", "passed": true, "score": {"loc": 6, "tokens": 77, "cc": 1, "nest": 2, "execution_time": 0.01658, "novelty": 0.5405036133048091}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 18669, "entry_point": "minOperations", "best_list": [{"code": "def minOperations(n):\n    return n * n // 4", "passed": true, "score": {"loc": 2, "tokens": 13, "cc": 0, "nest": 1, "execution_time": 0.016463, "novelty": 0.02237136465324374}}, {"code": "def minOperations(n: int) -> int:\n    return n * n // 4", "passed": true, "score": {"loc": 2, "tokens": 18, "cc": 0, "nest": 1, "execution_time": 0.016467, "novelty": 0.08948545861297541}}], "num_pass": 10, "num_uniq": 2, "num_fail": 0, "fail_uniq": 0}
{"id": 18709, "entry_point": "repeatedNTimes", "best_list": [{"code": "def repeatedNTimes(A):\n    for i in range(len(A)):\n        if A[i] == A[i - 1] or A[i] == A[i - 2]:\n            return A[i]", "passed": true, "score": {"loc": 4, "tokens": 49, "cc": 3, "nest": 3, "execution_time": 0.016506, "novelty": 0.7035260380553321}}, {"code": "def repeatedNTimes(A):\n    A.sort()\n    for i in range(len(A) - 1):\n        if A[i] == A[i + 1]:\n            return A[i]", "passed": true, "score": {"loc": 5, "tokens": 43, "cc": 2, "nest": 3, "execution_time": 0.016551, "novelty": 0.6524909281577316}}, {"code": "def repeatedNTimes(A):\n    seen = set()\n    for num in A:\n        if num in seen:\n            return num\n        seen.add(num)", "passed": true, "score": {"loc": 6, "tokens": 29, "cc": 2, "nest": 3, "execution_time": 0.016429, "novelty": 0.1635767796676696}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 18742, "entry_point": "decodeString", "best_list": [{"code": "def decodeString(s):\n    stack, num, chars = [], 0, []\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == '[':\n            stack.append((num, chars))\n            num, chars = 0, []\n        elif c == ']':\n            prev_num, prev_chars = stack.pop()\n            chars = prev_chars + prev_num * chars\n        else:\n            chars.append(c)\n    return ''.join(chars)", "passed": true, "score": {"loc": 14, "tokens": 107, "cc": 4, "nest": 5, "execution_time": 0.016657, "novelty": 0.34145789629753875}}, {"code": "def decodeString(s):\n    num, cur = 0, ''\n    stack = []\n    for char in s:\n        if char.isdigit():\n            num = num * 10 + int(char)\n        elif char == '[':\n            stack.append((num, cur))\n            num, cur = 0, ''\n        elif char == ']':\n            prev_num, prev_cur = stack.pop()\n            cur = prev_cur + prev_num * cur\n        else:\n            cur += char\n    return cur", "passed": true, "score": {"loc": 15, "tokens": 98, "cc": 4, "nest": 5, "execution_time": 0.016663, "novelty": 0.2002934070493605}}, {"code": "def decodeString(s):\n    stack = []\n    current_num = 0\n    current_str = ''\n    \n    for char in s:\n        if char.isdigit():\n            current_num = current_num * 10 + int(char)\n        elif char == '[':\n            stack.append((current_num, current_str))\n            current_num = 0\n            current_str = ''\n        elif char == ']':\n            num, prev_str = stack.pop()\n            current_str = prev_str + current_str * num\n        else:\n            current_str += char\n    \n    return current_str", "passed": true, "score": {"loc": 17, "tokens": 96, "cc": 4, "nest": 5, "execution_time": 0.016612, "novelty": 0.21763915300770464}}, {"code": "def decodeString(s):\n    stack, num, cur = [], 0, ''\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c.isalpha():\n            cur += c\n        elif c == '[':\n            stack.append((num, cur))\n            num, cur = 0, ''\n        else:\n            pre_num, pre_cur = stack.pop()\n            cur = pre_cur + pre_num * cur\n    return cur", "passed": false, "score": {"loc": 14, "tokens": 98, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.4579143349600838}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 18955, "entry_point": "buddyStrings", "best_list": [{"code": "def buddyStrings(A, B):\n    if len(A) != len(B):\n        return False\n    \n    if A == B and len(set(A)) < len(A):\n        return True\n    \n    diff = [(a, b) for a, b in zip(A, B) if a != b]\n    \n    return len(diff) == 2 and diff[0] == diff[1][::-1]", "passed": true, "score": {"loc": 7, "tokens": 93, "cc": 4, "nest": 2, "execution_time": 0.016668, "novelty": 0.3671429679870214}}, {"code": "def buddyStrings(A: str, B: str) -> bool:\n    if len(A) != len(B):\n        return False\n\n    if A == B:\n        return len(set(A)) < len(A)\n\n    diffs = [(a, b) for a, b in zip(A, B) if a != b]\n    return len(diffs) == 2 and diffs[0] == diffs[1][::-1]", "passed": true, "score": {"loc": 7, "tokens": 98, "cc": 3, "nest": 2, "execution_time": 0.016671, "novelty": 0.36927234957419985}}, {"code": "def buddyStrings(A: str, B: str) -> bool:\n    if len(A) != len(B):\n        return False\n    if A == B:\n        return len(set(A)) < len(B)\n    diff = [(a, b) for a, b in zip(A, B) if a != b]\n    return len(diff) == 2 and diff[0] == diff[1][::-1]", "passed": true, "score": {"loc": 7, "tokens": 98, "cc": 3, "nest": 2, "execution_time": 0.016721, "novelty": 0.3734293982691105}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 18960, "entry_point": "lastStoneWeight", "best_list": [{"code": "def lastStoneWeight(stones):\n    while len(stones) > 1:\n        stones.sort()\n        x, y = stones.pop(), stones.pop()\n        stones.append(x - y)\n    return stones[0] if stones else 0", "passed": true, "score": {"loc": 6, "tokens": 51, "cc": 1, "nest": 2, "execution_time": 0.016514, "novelty": 0.41835951474999833}}, {"code": "def lastStoneWeight(stones):\n    while len(stones) > 1:\n        stones.append(stones.pop() - stones.pop())\n    return stones[0] if stones else 0", "passed": false, "score": {"loc": 4, "tokens": 39, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.15121888901972236}}, {"code": "def lastStoneWeight(stones):\n    while len(stones) > 1:\n        stones.sort()\n        x, y = stones[-2], stones.pop()\n        stones.append(y - x)\n    return stones[0] if stones else 0", "passed": false, "score": {"loc": 6, "tokens": 51, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.4349230182060251}}, {"code": "def lastStoneWeight(stones):\n    while len(stones) > 1:\n        stones.append(stones.pop() - stones.pop())\n    return stones[0]", "passed": false, "score": {"loc": 4, "tokens": 35, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.15126182933480448}}, {"code": "def lastStoneWeight(stones):\n    while len(stones) > 1:\n        stones.append(stones.pop() - stones.pop())\n        stones.sort()\n    return stones[0]", "passed": false, "score": {"loc": 5, "tokens": 40, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.26384084056486334}}, {"code": "def lastStoneWeight(stones):\n    while len(stones) > 1:\n        stones.append(stones.pop() - stones.pop())\n    return max(stones)\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "passed": false, "score": {"loc": 6, "tokens": 48, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.3364853059135472}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 5}
{"id": 18978, "entry_point": "maxSatisfaction", "best_list": [{"code": "def maxSatisfaction(satisfaction):\n    satisfaction.sort()\n    total_time, max_sum, current_sum = 0, 0, 0\n    for sat in reversed(satisfaction):\n        current_sum += sat\n        if current_sum > 0:\n            total_time += current_sum\n            max_sum = max(max_sum, total_time)\n    return max_sum", "passed": true, "score": {"loc": 9, "tokens": 53, "cc": 2, "nest": 3, "execution_time": 0.016743, "novelty": 0.5248108364644928}}, {"code": "def maxSatisfaction(satisfaction):\n    satisfaction.sort(reverse=True)\n    total, current, ans = 0, 0, 0\n    for s in satisfaction:\n        current += s\n        if current > 0:\n            total += current\n        else:\n            break\n    return total", "passed": true, "score": {"loc": 10, "tokens": 48, "cc": 2, "nest": 3, "execution_time": 0.016671, "novelty": 0.5974262382402709}}, {"code": "def maxSatisfaction(satisfaction):\n    satisfaction.sort()\n    total, max_sum = 0, 0\n    for i in range(len(satisfaction) - 1, -1, -1):\n        total += satisfaction[i]\n        if total > 0:\n            max_sum += total\n        else:\n            break\n    return max_sum", "passed": true, "score": {"loc": 10, "tokens": 58, "cc": 2, "nest": 3, "execution_time": 0.016736, "novelty": 0.3750797209499219}}, {"code": "def maxSatisfaction(satisfaction):\n    satisfaction.sort()\n    total, max_like_time = 0, 0\n    for i in range(len(satisfaction)):\n        total += satisfaction[i]\n        if total > 0:\n            max_like_time += total\n    return max_like_time", "passed": false, "score": {"loc": 8, "tokens": 47, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.40350500939540956}}, {"code": "def maxSatisfaction(satisfaction):\n    satisfaction.sort(reverse=True)\n    return sum(x for x in satisfaction if sum(satisfaction[i:] for i in range(len(satisfaction))) > 0)", "passed": false, "score": {"loc": 3, "tokens": 44, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6930856929085052}}, {"code": "def maxSatisfaction(satisfaction):\n    satisfaction.sort()\n    total, best, current = 0, 0, 0\n    for dish in satisfaction:\n        current += dish\n        if current > 0:\n            total += current\n            best = max(best, total)\n    return best", "passed": false, "score": {"loc": 9, "tokens": 50, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.513553605595497}}, {"code": "def maxSatisfaction(satisfaction):\n    satisfaction.sort()\n    total, current, result = 0, 0, 0\n    for i in range(len(satisfaction) - 1, -1, -1):\n        current += total + satisfaction[i]\n        if current <= 0:\n            break\n        result += current\n        total += satisfaction[i]\n    return result", "passed": false, "score": {"loc": 10, "tokens": 70, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5428157009485124}}, {"code": "def maxSatisfaction(satisfaction):\n    satisfaction.sort()\n    total_time, result = 0, 0\n    for i in range(len(satisfaction)):\n        if total_time + satisfaction[i] > 0:\n            total_time += satisfaction[i]\n            result += total_time\n        else:\n            break\n    return result", "passed": false, "score": {"loc": 10, "tokens": 55, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5656487400028707}}], "num_pass": 5, "num_uniq": 4, "num_fail": 5, "fail_uniq": 5}
{"id": 19090, "entry_point": "search", "best_list": [{"code": "def search(nums, target):\n    return target in nums", "passed": true, "score": {"loc": 2, "tokens": 12, "cc": 0, "nest": 1, "execution_time": 0.016645, "novelty": 0.48195023261438164}}, {"code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        if nums[left] == nums[mid] == nums[right]:\n            left, right = left + 1, right - 1\n        elif nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False", "passed": true, "score": {"loc": 19, "tokens": 144, "cc": 6, "nest": 5, "execution_time": 0.016748, "novelty": 0.737957846959526}}, {"code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return True\n        if nums[left] == nums[mid] == nums[right]:\n            left += 1\n            right -= 1\n        elif nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False", "passed": true, "score": {"loc": 20, "tokens": 141, "cc": 6, "nest": 5, "execution_time": 0.016747, "novelty": 0.6269531385772651}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 19253, "entry_point": "minCost", "best_list": [{"code": "def minCost(s, cost):\n    total_cost = 0\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[i] == s[j]:\n            j += 1\n        if j > i + 1:\n            total_cost += sum(cost[i:j]) - max(cost[i:j])\n        i = j\n    return total_cost", "passed": true, "score": {"loc": 11, "tokens": 84, "cc": 4, "nest": 3, "execution_time": 0.016789, "novelty": 0.46418456654091655}}, {"code": "def minCost(s, cost):\n    total_cost = 0\n    max_cost = 0\n    prev_char = None\n    \n    for char, c in zip(s, cost):\n        if char == prev_char:\n            total_cost += min(max_cost, c)\n            max_cost = max(max_cost, c)\n        else:\n            max_cost = c\n        prev_char = char\n    \n    return total_cost", "passed": true, "score": {"loc": 12, "tokens": 62, "cc": 2, "nest": 3, "execution_time": 0.01649, "novelty": 0.5672057070229319}}, {"code": "def minCost(s, cost):\n    total_cost = 0\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[j] == s[i]:\n            j += 1\n        if j > i + 1:\n            max_cost = max(cost[i:j])\n            total_cost += sum(cost[i:j]) - max_cost\n        i = j\n    return total_cost", "passed": true, "score": {"loc": 12, "tokens": 87, "cc": 4, "nest": 3, "execution_time": 0.016683, "novelty": 0.5004346490384559}}, {"code": "def minCost(s, cost):\n    total_cost = 0\n    max_cost = 0\n    current_char = None\n    \n    for char, c in zip(s, cost):\n        if char != current_char:\n            if current_char is not None:\n                total_cost += max_cost - cost[i-1]\n            current_char = char\n            max_cost = c\n        else:\n            max_cost = max(max_cost, c)\n    \n    if current_char is not None:\n        total_cost += max_cost - cost[-1]\n    \n    return total_cost", "passed": false, "score": {"loc": 15, "tokens": 86, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.6640543351589479}}, {"code": "def minCost(s: str, cost: List[int]) -> int:\n    total_cost = 0\n    max_cost = 0\n    prev_char = None\n    \n    for char, c in zip(s, cost):\n        if char == prev_char:\n            total_cost += max_cost\n            max_cost = max(max_cost, c)\n        else:\n            prev_char = char\n            max_cost = c\n    \n    total_cost += max_cost\n    return total_cost", "passed": false, "score": {"loc": 13, "tokens": 71, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5820662496223965}}, {"code": "def minCost(s, cost):\n    total_cost = 0\n    i = 0\n    while i < len(s):\n        max_cost = 0\n        max_index = i\n        j = i\n        while j < len(s) and s[i] == s[j]:\n            if cost[j] > max_cost:\n                max_cost = cost[j]\n                max_index = j\n            j += 1\n        total_cost += sum(cost[i:j]) - max_cost\n        i = j\n    return total_cost", "passed": false, "score": {"loc": 15, "tokens": 90, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.5532215551151329}}, {"code": "def minCost(s, cost):\n    total_cost = 0\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[j] == s[i]:\n            j += 1\n        if j - i > 1:\n            indices = list(range(i, j))\n            max_cost = max(cost[i:j])\n            total_cost += sum(cost[indices]) - max_cost\n        i = j\n    return total_cost", "passed": false, "score": {"loc": 13, "tokens": 96, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.5782763067229172}}, {"code": "def minCost(s: str, cost: List[int]) -> int:\n    total_cost = 0\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[i] == s[j]:\n            j += 1\n        if j - i > 1:\n            total_cost += sum(cost[i:j]) - max(cost[i:j])\n        i = j\n    return total_cost", "passed": false, "score": {"loc": 11, "tokens": 94, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.48605549488841937}}], "num_pass": 4, "num_uniq": 4, "num_fail": 6, "fail_uniq": 6}
{"id": 19257, "entry_point": "totalFruit", "best_list": [{"code": "def totalFruit(tree):\n    max_fruits = 0\n    basket = {}\n    left = 0\n\n    for right in range(len(tree)):\n        basket[tree[right]] = basket.get(tree[right], 0) + 1\n\n        while len(basket) > 2:\n            basket[tree[left]] -= 1\n            if basket[tree[left]] == 0:\n                del basket[tree[left]]\n            left += 1\n\n        max_fruits = max(max_fruits, right - left + 1)\n\n    return max_fruits", "passed": true, "score": {"loc": 13, "tokens": 104, "cc": 3, "nest": 4, "execution_time": 0.016632, "novelty": 0.6256199620049268}}, {"code": "from collections import defaultdict\n\ndef totalFruit(tree):\n    left = 0\n    max_fruits = 0\n    fruit_count = defaultdict(int)\n\n    for right, fruit in enumerate(tree):\n        fruit_count[fruit] += 1\n\n        while len(fruit_count) > 2:\n            fruit_count[tree[left]] -= 1\n            if fruit_count[tree[left]] == 0:\n                del fruit_count[tree[left]]\n            left += 1\n\n        max_fruits = max(max_fruits, right - left + 1)\n\n    return max_fruits", "passed": true, "score": {"loc": 14, "tokens": 95, "cc": 3, "nest": 4, "execution_time": 0.016546, "novelty": 0.44515531554906085}}, {"code": "def totalFruit(tree):\n    from collections import defaultdict\n\n    left = 0\n    fruit_count = defaultdict(int)\n    max_fruits = 0\n\n    for right, fruit in enumerate(tree):\n        fruit_count[fruit] += 1\n\n        while len(fruit_count) > 2:\n            fruit_count[tree[left]] -= 1\n            if fruit_count[tree[left]] == 0:\n                del fruit_count[tree[left]]\n            left += 1\n\n        max_fruits = max(max_fruits, right - left + 1)\n\n    return max_fruits", "passed": true, "score": {"loc": 14, "tokens": 95, "cc": 3, "nest": 4, "execution_time": 0.016595, "novelty": 0.5492324570645222}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 19261, "entry_point": "isAnagram", "best_list": [{"code": "def isAnagram(s, t):\n    return sorted(s) == sorted(t)", "passed": true, "score": {"loc": 2, "tokens": 19, "cc": 0, "nest": 1, "execution_time": 0.016557, "novelty": 0.1921406869320974}}, {"code": "def isAnagram(s: str, t: str) -> bool:\n    return sorted(s) == sorted(t)", "passed": true, "score": {"loc": 2, "tokens": 26, "cc": 0, "nest": 1, "execution_time": 0.016624, "novelty": 0.08944426929447324}}, {"code": "def isAnagram(s: str, t: str) -> bool:\n    return len(s) == len(t) and all(s.count(c) == t.count(c) for c in set(s))", "passed": true, "score": {"loc": 2, "tokens": 51, "cc": 1, "nest": 1, "execution_time": 0.016603, "novelty": 0.4931460474981926}}, {"code": "def isAnagram(s: str, t: str) -> bool:\n    return Counter(s) == Counter(t)", "passed": false, "score": {"loc": 2, "tokens": 26, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.10645366019234281}}, {"code": "def isAnagram(s: str, t: str) -> bool:\n    return s == t", "passed": false, "score": {"loc": 2, "tokens": 20, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.2771648764425224}}], "num_pass": 8, "num_uniq": 3, "num_fail": 2, "fail_uniq": 2}
{"id": 19340, "entry_point": "maxProfit", "best_list": [{"code": "def maxProfit(k, prices):\n    if k >= len(prices) // 2:\n        return sum(max(prices[i] - prices[i-1], 0) for i in range(1, len(prices)))\n    \n    dp = [[0] * len(prices) for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, len(prices)):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n    \n    return dp[k][len(prices) - 1]", "passed": true, "score": {"loc": 10, "tokens": 166, "cc": 3, "nest": 3, "execution_time": 0.016615, "novelty": 0.6918270075314144}}, {"code": "def maxProfit(k, prices):\n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i] - prices[i-1], 0) for i in range(1, n))\n    \n    profit = [[0] * n for _ in range(k + 1)]\n    \n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            profit[i][j] = max(profit[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, profit[i-1][j] - prices[j])\n    \n    return profit[k][n-1]", "passed": true, "score": {"loc": 11, "tokens": 157, "cc": 3, "nest": 3, "execution_time": 0.016704, "novelty": 0.08084454538103159}}, {"code": "def maxProfit(k, prices):\n    if not prices:\n        return 0\n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))\n    \n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    return dp[k][n - 1]", "passed": true, "score": {"loc": 13, "tokens": 163, "cc": 4, "nest": 3, "execution_time": 0.016598, "novelty": 0.6031917216580596}}, {"code": "def maxProfit(prices, k):\n    if not prices or k <= 0:\n        return 0\n    \n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i] - prices[i-1], 0) for i in range(1, n))\n    \n    profit = [[0] * n for _ in range(k + 1)]\n    \n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            profit[i][j] = max(profit[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, profit[i-1][j] - prices[j])\n    \n    return profit[k][n-1]", "passed": false, "score": {"loc": 13, "tokens": 168, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.6117007860635562}}, {"code": "def maxProfit(prices, k):\n    n = len(prices)\n    if n == 0:\n        return 0\n    \n    if k >= n // 2:\n        return sum(max(prices[i] - prices[i-1], 0) for i in range(1, n))\n    \n    profit = [[0] * n for _ in range(k + 1)]\n    \n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            profit[i][j] = max(profit[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, profit[i-1][j] - prices[j])\n    \n    return profit[k][n-1]", "passed": false, "score": {"loc": 13, "tokens": 165, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.10649203834038501}}], "num_pass": 8, "num_uniq": 7, "num_fail": 2, "fail_uniq": 2}
{"id": 19342, "entry_point": "bulbSwitch", "best_list": [{"code": "def bulbSwitch(n):\n    return int(n**0.5)", "passed": true, "score": {"loc": 2, "tokens": 16, "cc": 0, "nest": 1, "execution_time": 0.016779, "novelty": 0.0504782928623988}}, {"code": "import math\n\ndef bulbSwitch(n):\n    return int(math.sqrt(n))", "passed": true, "score": {"loc": 3, "tokens": 18, "cc": 0, "nest": 1, "execution_time": 0.01656, "novelty": 0.2847682119205298}}], "num_pass": 10, "num_uniq": 2, "num_fail": 0, "fail_uniq": 0}
{"id": 19557, "entry_point": "minDeletionSize", "best_list": [{"code": "def minDeletionSize(A):\n    delete = set()\n    for col in range(len(A[0])):\n        for row in range(1, len(A)):\n            if A[row][col] < A[row - 1][col] and col not in delete:\n                delete.add(col)\n                break\n    return len(delete)", "passed": true, "score": {"loc": 8, "tokens": 74, "cc": 4, "nest": 4, "execution_time": 0.01663, "novelty": 0.7400790132232657}}, {"code": "def minDeletionSize(A):\n    D = 0\n    i = 0\n    while i < len(A[0]):\n        j = 1\n        while j < len(A) and A[j-1][i] <= A[j][i]:\n            j += 1\n        if j == len(A):\n            i += 1\n        else:\n            D += 1\n            i += 1\n    return D", "passed": true, "score": {"loc": 13, "tokens": 82, "cc": 4, "nest": 3, "execution_time": 0.016639, "novelty": 0.7669027633618174}}, {"code": "def minDeletionSize(A):\n    n, m = len(A), len(A[0])\n    deletions = 0\n    i = 0\n    while i < m:\n        j = 1\n        while j < n and A[j][i] >= A[j-1][i]:\n            j += 1\n        if j == n:\n            i += 1\n        else:\n            deletions += 1\n            i += 1\n    return deletions", "passed": true, "score": {"loc": 14, "tokens": 86, "cc": 4, "nest": 3, "execution_time": 0.016619, "novelty": 0.7261530659149793}}, {"code": "def minDeletionSize(A):\n    def is_valid(A):\n        return all(A[i][j] <= A[i + 1][j] for i in range(len(A) - 1) for j in range(len(A[0])))\n\n    def min_deletion_size_recursive(A, j):\n        if j == len(A[0]):\n            return 0\n        if is_valid(A):\n            return 0\n        delete = min_deletion_size_recursive(A, j + 1)\n        keep = float('inf')\n        if all(A[i][j] <= A[i][j + 1] for i in range(len(A) - 1)):\n            for i in range(len(A) - 1):\n                A[i] = A[i][:j] + A[i][j + 1:]\n            keep = min_deletion_size_recursive(A, j + 1) + 1\n            for i in range(len(A) - 1):\n                A[i] = A[i][:j] + A[i][j + 1:] + A[i + 1][j]\n        return min(delete, keep)\n\n    return min_deletion_size_recursive(A, 0)", "passed": false, "score": {"loc": 18, "tokens": 252, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.8564727995821733}}, {"code": "def minDeletionSize(A):\n    N, M = len(A), len(A[0])\n    dp = [[0] * M for _ in range(N)]\n    for j in range(1, M):\n        dp[0][j] = dp[0][j-1] + 1 if A[0][j] >= A[0][j-1] else 0\n        for i in range(1, N):\n            if A[i][j] >= A[i][j-1]:\n                dp[i][j] = max(dp[i][j], dp[i][j-1], dp[i-1][j-1] + 1)\n            else:\n                dp[i][j] = max(dp[i][j], dp[i][j-1])\n    return M - dp[-1][-1]", "passed": false, "score": {"loc": 11, "tokens": 202, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.8088713375474801}}, {"code": "def minDeletionSize(A):\n    def is_sorted(A):\n        return all(A[i] <= A[i + 1] for i in range(len(A) - 1))\n\n    def helper(A, deletions):\n        if is_sorted(A):\n            return deletions\n        m, n = len(A), len(A[0])\n        min_deletions = float('inf')\n        for j in range(n):\n            if all(A[i][j] >= A[i - 1][j] for i in range(1, m)):\n                min_deletions = min(min_deletions, helper([a[:j] + a[j + 1:] for a in A], deletions + 1))\n        return min_deletions\n\n    return helper(A, 0)", "passed": false, "score": {"loc": 13, "tokens": 162, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.8248614403938561}}, {"code": "def minDeletionSize(A):\n    deletes = 0\n    sorted_col = [False] * len(A[0])\n    for col in range(len(A[0])):\n        if all(A[i][col] >= A[i-1][col] for i in range(1, len(A)) if not sorted_col[i-1]):\n            sorted_col = [True] * len(A)\n        else:\n            deletes += 1\n    return deletes", "passed": false, "score": {"loc": 9, "tokens": 97, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7610200871208014}}, {"code": "def minDeletionSize(A):\n    n, m = len(A), len(A[0])\n    dp = [[i] for i in range(m)]\n    for i in range(1, n):\n        for j in range(m):\n            if all(A[i][j] >= A[i-1][k] for k in dp[i-1]):\n                dp[i].append(j)\n    return m - len(max(dp, key=len))", "passed": false, "score": {"loc": 8, "tokens": 109, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7248611738469755}}], "num_pass": 4, "num_uniq": 4, "num_fail": 6, "fail_uniq": 6}
{"id": 19564, "entry_point": "numTeams", "best_list": [{"code": "def numTeams(rating):\n    n = len(rating)\n    result = 0\n    for i in range(1, n - 1):\n        smaller_before = sum(1 for x in rating[:i] if x < rating[i])\n        larger_before = i - smaller_before\n        smaller_after = sum(1 for x in rating[i+1:] if x < rating[i])\n        larger_after = n - i - 1 - smaller_after\n        result += smaller_before * larger_after + larger_before * smaller_after\n    return result", "passed": true, "score": {"loc": 10, "tokens": 97, "cc": 1, "nest": 2, "execution_time": 0.016776, "novelty": 0.5990437145000076}}, {"code": "def numTeams(rating):\n    n = len(rating)\n    count = 0\n    \n    for j in range(1, n - 1):\n        less_left = sum(1 for i in range(j) if rating[i] < rating[j])\n        greater_left = j - less_left\n        less_right = sum(1 for k in range(j + 1, n) if rating[k] < rating[j])\n        greater_right = n - j - 1 - less_right\n        \n        count += less_left * greater_right + greater_left * less_right\n    \n    return count", "passed": true, "score": {"loc": 10, "tokens": 103, "cc": 1, "nest": 2, "execution_time": 0.016601, "novelty": 0.5683740969224738}}, {"code": "def numTeams(rating):\n    n = len(rating)\n    count = 0\n    for j in range(1, n - 1):\n        smaller_before = sum(1 for i in range(j) if rating[i] < rating[j])\n        larger_before = j - smaller_before\n        smaller_after = sum(1 for k in range(j + 1, n) if rating[k] < rating[j])\n        larger_after = n - j - 1 - smaller_after\n        count += smaller_before * larger_after + larger_before * smaller_after\n    return count", "passed": true, "score": {"loc": 10, "tokens": 103, "cc": 1, "nest": 2, "execution_time": 0.016662, "novelty": 0.5553952347225329}}, {"code": "def numTeams(rating):\n    n = len(rating)\n    return sum((i, j, k) in ((0, 1, 2), (2, 1, 0)) for i in range(n) for j in range(i + 1, n) for k in range(j + 1, n) if rating[i] * rating[j] * rating[k] > 0 and rating[i] * rating[j] * rating[k] != rating[i] + rating[j] + rating[k] and rating[i] * rating[j] * rating[k] != rating[i] + rating[j] * rating[k] + rating[i] * rating[k] + rating[i] + rating[j] + rating[k])", "passed": false, "score": {"loc": 3, "tokens": 174, "cc": 1, "nest": 1, "execution_time": 10.0, "novelty": 0.8307872811665195}}, {"code": "def numTeams(rating):\n    n = len(rating)\n    count = 0\n    for j in range(1, n - 1):\n        greater_before = [x for x in rating[:j] if x > rating[j]]\n        greater_after = [x for x in rating[j+1:] if x > rating[j]]\n        lesser_before = [x for x in rating[:j] if x < rating[j]]\n        lesser_after = [x for x in rating[j+1:] if x < rating[j]]\n        count += len(greater_before) * len(greater_after) + len(lesser_before) * len(lesser_after)\n    return count", "passed": false, "score": {"loc": 10, "tokens": 135, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.6777223253656819}}, {"code": "def numTeams(rating):\n    n = len(rating)\n    count = 0\n\n    for j in range(1, n - 1):\n        left_less = sum(1 for i in range(j) if rating[i] < rating[j])\n        left_more = j - left_less\n        right_less = sum(1 for k in range(j + 1, n) if rating[j] < rating[k])\n        right_more = n - j - right_less\n        count += left_less * right_less + left_more * right_more\n\n    return count", "passed": false, "score": {"loc": 10, "tokens": 101, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.5697466191905789}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 19606, "entry_point": "permuteUnique", "best_list": [{"code": "from collections import Counter\n\ndef permuteUnique(nums):\n    def backtrack(path, count):\n        if len(path) == len(nums):\n            result.append(path)\n            return\n        for num in count:\n            if count[num] > 0:\n                count[num] -= 1\n                backtrack(path + [num], count)\n                count[num] += 1\n\n    result = []\n    backtrack([], Counter(nums))\n    return result", "passed": true, "score": {"loc": 14, "tokens": 90, "cc": 3, "nest": 4, "execution_time": 0.016747, "novelty": 0.6316844670587863}}, {"code": "def permuteUnique(nums):\n    def backtrack(path, counter, result):\n        if len(path) == len(nums):\n            result.append(path[:])\n            return\n        for num in counter:\n            if counter[num] > 0:\n                counter[num] -= 1\n                path.append(num)\n                backtrack(path, counter, result)\n                path.pop()\n                counter[num] += 1\n\n    from collections import Counter\n    counter = Counter(nums)\n    result = []\n    backtrack([], counter, result)\n    return result", "passed": true, "score": {"loc": 17, "tokens": 109, "cc": 3, "nest": 4, "execution_time": 0.016734, "novelty": 0.5782088052636829}}, {"code": "def permuteUnique(nums):\n    def backtrack(path, used):\n        if len(path) == len(nums):\n            result.append(path[:])\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i - 1] and not used[i - 1]):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path, used)\n            path.pop()\n            used[i] = False\n\n    result = []\n    nums.sort()\n    backtrack([], [False] * len(nums))\n    return result", "passed": true, "score": {"loc": 17, "tokens": 138, "cc": 5, "nest": 4, "execution_time": 0.016825, "novelty": 0.482362870869253}}, {"code": "from itertools import permutations\n\ndef permuteUnique(nums):\n    return list(set(permutations(nums)))", "passed": false, "score": {"loc": 3, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7840190975475555}}, {"code": "from typing import List\nfrom itertools import permutations\n\ndef permuteUnique(nums: List[int]) -> List[List[int]]:\n    return list(set(permutations(nums)))", "passed": false, "score": {"loc": 4, "tokens": 39, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.821492127448358}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 19608, "entry_point": "kthSmallest", "best_list": [{"code": "def kthSmallest(matrix, k):\n    return sorted(sum(matrix, []))[k - 1]", "passed": true, "score": {"loc": 2, "tokens": 24, "cc": 0, "nest": 1, "execution_time": 0.016543, "novelty": 0.7193672725903691}}, {"code": "import heapq\n\ndef kthSmallest(matrix, k):\n    min_heap = []\n    for row in matrix:\n        for num in row:\n            if len(min_heap) < k:\n                heapq.heappush(min_heap, -num)\n            elif -num > min_heap[0]:\n                heapq.heappop(min_heap)\n                heapq.heappush(min_heap, -num)\n    return -min_heap[0]", "passed": true, "score": {"loc": 11, "tokens": 71, "cc": 4, "nest": 5, "execution_time": 0.016543, "novelty": 0.8024773080928784}}, {"code": "def kthSmallest(matrix, k):\n    def quickselect(nums, k):\n        if len(nums) == 1:\n            return nums[0]\n        pivot = nums[len(nums) // 2]\n        lows = [el for el in nums if el < pivot]\n        highs = [el for el in nums if el > pivot]\n        pivots = [el for el in nums if el == pivot]\n        if k <= len(lows):\n            return quickselect(lows, k)\n        elif k > len(lows) + len(pivots):\n            return quickselect(highs, k - len(lows) - len(pivots))\n        else:\n            return pivots[0]\n    \n    nums = []\n    for row in matrix:\n        nums.extend(row)\n    return quickselect(nums, k - 1)", "passed": true, "score": {"loc": 18, "tokens": 159, "cc": 4, "nest": 4, "execution_time": 0.016782, "novelty": 0.8900608166590238}}, {"code": "def kthSmallest(matrix, k):\n    low, high = matrix[0][0], matrix[-1][-1]\n    while low < high:\n        mid = (low + high) // 2\n        if sum(row[bisect.bisect(row, mid)] for row in matrix) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low", "passed": false, "score": {"loc": 9, "tokens": 78, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.8036006886904664}}, {"code": "def kthSmallest(matrix, k):\n    n = len(matrix)\n    left, right = matrix[0][0], matrix[n-1][n-1]\n\n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        for i in range(n):\n            j = bisect.bisect_right(matrix[i], mid)\n            count += j\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left", "passed": false, "score": {"loc": 14, "tokens": 97, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7455954011861412}}, {"code": "def kthSmallest(matrix, k):\n    from heapq import heappush, heappop\n    n = len(matrix)\n    min_heap = []\n    for i in range(min(k, n)):\n        heappush(min_heap, (matrix[i][0], i, 0))\n    while k > 1:\n        _, i, j = heappop(min_heap)\n        if j + 1 < n:\n            heappush(min_heap, (matrix[i][j + 1], i, j + 1))\n        k -= 1\n    return min_heap[0][0]", "passed": false, "score": {"loc": 12, "tokens": 111, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7707266225552182}}, {"code": "import heapq\n\ndef kthSmallest(matrix, k):\n    n = len(matrix)\n    min_heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapq.heapify(min_heap)\n    \n    for _ in range(k):\n        val, i, j = heapq.heappop(min_heap)\n        if j + 1 < n:\n            heapq.heappush(min_heap, (matrix[i][j + 1], i, j + 1))\n    \n    return val", "passed": false, "score": {"loc": 10, "tokens": 99, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7294491682536254}}, {"code": "def kthSmallest(matrix, k):\n    elements = set()\n    for row in matrix:\n        elements.update(row)\n    return sorted(elements)[k-1]", "passed": false, "score": {"loc": 5, "tokens": 34, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.7013672586895195}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 19705, "entry_point": "minIncrementForUnique", "best_list": [{"code": "def minIncrementForUnique(A):\n    moves = 0\n    A.sort()\n    for i in range(1, len(A)):\n        if A[i] <= A[i - 1]:\n            moves += A[i - 1] - A[i] + 1\n            A[i] = A[i - 1] + 1\n    return moves", "passed": true, "score": {"loc": 8, "tokens": 72, "cc": 2, "nest": 3, "execution_time": 0.016648, "novelty": 0.34339466869686863}}, {"code": "def minIncrementForUnique(A):\n    A.sort()\n    moves = 0\n    for i in range(1, len(A)):\n        if A[i] <= A[i - 1]:\n            moves += A[i - 1] - A[i] + 1\n            A[i] = A[i - 1] + 1\n    return moves", "passed": true, "score": {"loc": 8, "tokens": 72, "cc": 2, "nest": 3, "execution_time": 0.016696, "novelty": 0.3205152840456694}}, {"code": "def minIncrementForUnique(A):\n    unique = set()\n    moves = 0\n    for num in A:\n        while num in unique:\n            num += 1\n            moves += 1\n        unique.add(num)\n    return moves", "passed": true, "score": {"loc": 9, "tokens": 40, "cc": 2, "nest": 3, "execution_time": 0.01648, "novelty": 0.6386381761830086}}, {"code": "def minIncrementForUnique(A):\n    from collections import Counter\n    cnt = Counter(A)\n    moves = 0\n    max_val = max(cnt)\n    for i in range(max_val):\n        if cnt[i] > 1:\n            moves += cnt[i] - 1\n            cnt[i+1] += cnt[i] - 1\n    return moves", "passed": false, "score": {"loc": 10, "tokens": 66, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5584196578876607}}], "num_pass": 9, "num_uniq": 6, "num_fail": 1, "fail_uniq": 1}
{"id": 19740, "entry_point": "rangeSum", "best_list": [{"code": "def rangeSum(nums, n, left, right):\n    mod = 10**9 + 7\n    subarray_sums = sorted(sum(nums[i:j+1]) for i in range(n) for j in range(i, n))\n    return sum(subarray_sums[left-1:right]) % mod", "passed": true, "score": {"loc": 4, "tokens": 66, "cc": 0, "nest": 1, "execution_time": 0.016628, "novelty": 0.6071790798685933}}, {"code": "def rangeSum(nums, n, left, right):\n    mod = 10**9 + 7\n    subarray_sums = sorted(sum(nums[j:j+i]) for i in range(1, n+1) for j in range(n-i+1))\n    return sum(subarray_sums[left-1:right]) % mod", "passed": true, "score": {"loc": 4, "tokens": 72, "cc": 0, "nest": 1, "execution_time": 0.016623, "novelty": 0.6282027613975076}}, {"code": "def rangeSum(nums, n, left, right):\n    subarray_sums = []\n    for i in range(n):\n        for j in range(i, n):\n            subarray_sums.append(sum(nums[i:j+1]))\n    subarray_sums.sort()\n    return sum(subarray_sums[left-1:right]) % (10**9 + 7)", "passed": true, "score": {"loc": 7, "tokens": 76, "cc": 2, "nest": 3, "execution_time": 0.016701, "novelty": 0.4769800522465393}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 19745, "entry_point": "nthMagicalNumber", "best_list": [{"code": "def nthMagicalNumber(N, A, B):\n    left, right = 0, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if mid // A + mid // B - mid // (A * B) < N:\n            left = mid + 1\n        else:\n            right = mid\n    return left % (10**9 + 7)", "passed": true, "score": {"loc": 9, "tokens": 78, "cc": 2, "nest": 3, "execution_time": 0.016725, "novelty": 0.6750044863506539}}, {"code": "def nthMagicalNumber(N, A, B):\n    MOD = 10**9 + 7\n    left, right = 1, N * min(A, B)\n    while left < right:\n        mid = (left + right) // 2\n        if mid // A + mid // B - mid // (A * B) < N:\n            left = mid + 1\n        else:\n            right = mid\n    return left % MOD", "passed": true, "score": {"loc": 10, "tokens": 83, "cc": 2, "nest": 3, "execution_time": 0.016462, "novelty": 0.7053954693298807}}, {"code": "def nthMagicalNumber(N, A, B):\n    def lcm(x, y):\n        from math import gcd\n        return x * y // gcd(x, y)\n    \n    LCM = lcm(A, B)\n    left, right = 0, N * min(A, B)\n    while left < right:\n        mid = (left + right) // 2\n        if mid // A + mid // B - mid // LCM < N:\n            left = mid + 1\n        else:\n            right = mid\n    return left % (10**9 + 7)", "passed": true, "score": {"loc": 13, "tokens": 110, "cc": 2, "nest": 3, "execution_time": 0.016624, "novelty": 0.647877917437653}}, {"code": "def nthMagicalNumber(N, A, B):\n    mod = 10**9 + 7\n    lcm = A * B // gcd(A, B)\n    count = lambda x: x // A + x // B - x // lcm\n    left, right = 0, N * min(A, B)\n    while left < right:\n        mid = (left + right) // 2\n        if count(mid) < N:\n            left = mid + 1\n        else:\n            right = mid\n    return left % mod", "passed": false, "score": {"loc": 12, "tokens": 101, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6989235805554885}}, {"code": "def nthMagicalNumber(N: int, A: int, B: int) -> int:\n    MOD = 10**9 + 7\n    lcm = A * B // math.gcd(A, B)\n    num_cycles = N // (lcm // A + lcm // B - 1)\n    remainder = N % (lcm // A + lcm // B - 1)\n    total = num_cycles * lcm\n    for _ in range(remainder):\n        if total % A == 0 or total % B == 0:\n            total += 1\n        else:\n            total += 1\n    return total % MOD", "passed": false, "score": {"loc": 12, "tokens": 119, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7640911028247759}}, {"code": "from math import gcd\n\ndef nthMagicalNumber(N, A, B):\n    lcm = A * B // gcd(A, B)\n    return (N // (A // gcd(A, B)) + N // (B // gcd(A, B)) - N // (lcm // gcd(A, B))) % (10**9 + 7)", "passed": false, "score": {"loc": 4, "tokens": 83, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6348493234561954}}, {"code": "def nthMagicalNumber(N, A, B):\n    MOD = 10**9 + 7\n    lcm = A * B // gcd(A, B)\n    k = (N * lcm) // (A + B - lcm)\n    remainder = N - k * (A + B - lcm)\n    return (k * lcm + min(remainder * A, remainder * B)) % MOD", "passed": false, "score": {"loc": 6, "tokens": 79, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7185167587285115}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 19746, "entry_point": "convertToBase7", "best_list": [{"code": "def convertToBase7(n):\n    if n < 0: return \"-\" + convertToBase7(-n)\n    if n < 7: return str(n)\n    return convertToBase7(n // 7) + str(n % 7)", "passed": true, "score": {"loc": 4, "tokens": 46, "cc": 2, "nest": 2, "execution_time": 0.016461, "novelty": 0.47687227665836707}}, {"code": "def convertToBase7(n):\n    if n < 0:\n        return '-' + convertToBase7(-n)\n    elif n < 7:\n        return str(n)\n    else:\n        return convertToBase7(n // 7) + str(n % 7)", "passed": true, "score": {"loc": 7, "tokens": 48, "cc": 2, "nest": 3, "execution_time": 0.016596, "novelty": 0.4830005439912253}}, {"code": "def convertToBase7(n):\n    if n == 0:\n        return \"0\"\n    if n < 0:\n        return \"-\" + convertToBase7(-n)\n    result = \"\"\n    while n > 0:\n        result = str(n % 7) + result\n        n //= 7\n    return result", "passed": true, "score": {"loc": 10, "tokens": 57, "cc": 3, "nest": 2, "execution_time": 0.016503, "novelty": 0.5684862383434272}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 19782, "entry_point": "lenLongestFibSubseq", "best_list": [{"code": "def lenLongestFibSubseq(A):\n    index = {x: i for i, x in enumerate(A)}\n    dp = {}\n    maxLength = 0\n    \n    for i in range(len(A)):\n        for j in range(i):\n            k = index.get(A[i] - A[j], -1)\n            if k < j:\n                dp[i, j] = dp.get((j, k), 2) + 1\n                maxLength = max(maxLength, dp[i, j])\n                \n    return maxLength", "passed": true, "score": {"loc": 11, "tokens": 108, "cc": 3, "nest": 4, "execution_time": 0.016314, "novelty": 0.6396185666322771}}, {"code": "def lenLongestFibSubseq(A):\n    n = len(A)\n    index = {x: i for i, x in enumerate(A)}\n    dp = {}\n    max_len = 0\n    \n    for k in range(2, n):\n        for j in range(1, k):\n            i = index.get(A[k] - A[j], -1)\n            if i >= 0 and i < j:\n                dp[(j, k)] = dp.get((i, j), 2) + 1\n                max_len = max(max_len, dp[(j, k)])\n                \n    return max_len", "passed": true, "score": {"loc": 12, "tokens": 124, "cc": 4, "nest": 4, "execution_time": 0.016628, "novelty": 0.3817713374900984}}, {"code": "def lenLongestFibSubseq(A):\n    n = len(A)\n    dp = {}\n    index = {x: i for i, x in enumerate(A)}\n    longest = 0\n    \n    for k in range(n):\n        for j in range(k):\n            i = index.get(A[k] - A[j], -1)\n            if i >= 0 and i < j:\n                dp[(j, k)] = dp.get((i, j), 2) + 1\n                longest = max(longest, dp[(j, k)])\n    \n    return longest if longest > 2 else 0", "passed": true, "score": {"loc": 12, "tokens": 126, "cc": 4, "nest": 4, "execution_time": 0.016862, "novelty": 0.3713846878550843}}, {"code": "def lenLongestFibSubseq(A):\n    n = len(A)\n    dp = {}\n    indices = {x: i for i, x in enumerate(A)}\n    max_length = 0\n\n    for i in range(2, n):\n        for j in range(1, i):\n            x, y = A[j], A[i]\n            z = x + y\n            if z in indices and indices[z] < j:\n                dp[(y, z)] = dp.get((x, y), 2) + 1\n                max_length = max(max_length, dp[(y, z)])\n\n    return max_length", "passed": false, "score": {"loc": 13, "tokens": 125, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.4969142162926843}}, {"code": "def lenLongestFibSubseq(A):\n    n = len(A)\n    index = {x: i for i, x in enumerate(A)}\n    dp = {}\n    max_length = 0\n\n    for i in range(2, n):\n        for j in range(1, i):\n            x = A[j] - A[i]\n            if x < A[j] and x in index:\n                dp[(i, j)] = dp.get((j, index[x]), 2) + 1\n                max_length = max(max_length, dp[(i, j)])\n\n    return max_length", "passed": false, "score": {"loc": 12, "tokens": 121, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.44955481162346833}}, {"code": "def lenLongestFibSubseq(A):\n    n = len(A)\n    idx = {x: i for i, x in enumerate(A)}\n    dp = [[2] * n for _ in range(n)]\n    result = 0\n    \n    for k in range(n):\n        for i in range(k):\n            j = idx.get(2 * A[k] - A[i], -1)\n            if j < i and j >= 0:\n                dp[i][k] = dp[j][i] + 1\n                result = max(result, dp[i][k])\n    \n    return result", "passed": false, "score": {"loc": 12, "tokens": 127, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.5140936803560121}}], "num_pass": 7, "num_uniq": 6, "num_fail": 3, "fail_uniq": 3}
{"id": 19885, "entry_point": "getSum", "best_list": [{"code": "def getSum(a, b):\n    return sum([a, b])", "passed": true, "score": {"loc": 2, "tokens": 17, "cc": 0, "nest": 1, "execution_time": 0.016498, "novelty": 0.4759672444783798}}, {"code": "def getSum(a: int, b: int) -> int:\n    return a + b", "passed": true, "score": {"loc": 2, "tokens": 19, "cc": 0, "nest": 1, "execution_time": 0.016602, "novelty": 0.5710544906898565}}, {"code": "def getSum(a: int, b: int) -> int:\n    return sum((a, b))", "passed": true, "score": {"loc": 2, "tokens": 24, "cc": 0, "nest": 1, "execution_time": 0.016515, "novelty": 0.5654314513150134}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 19899, "entry_point": "repeatedSubstringPattern", "best_list": [{"code": "def repeatedSubstringPattern(s):\n    return any(s[:i] * (len(s) // i) == s for i in range(1, len(s) // 2 + 1))", "passed": true, "score": {"loc": 2, "tokens": 45, "cc": 0, "nest": 1, "execution_time": 0.0167, "novelty": 0.6806202676711984}}, {"code": "def repeatedSubstringPattern(s):\n    n = len(s)\n    return s in (s + s)[1:-1]", "passed": true, "score": {"loc": 3, "tokens": 26, "cc": 0, "nest": 1, "execution_time": 0.016608, "novelty": 0.6522528886576084}}, {"code": "def repeatedSubstringPattern(s):\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0 and s[:i] * (n // i) == s:\n            return True\n    return False", "passed": true, "score": {"loc": 6, "tokens": 55, "cc": 3, "nest": 3, "execution_time": 0.01655, "novelty": 0.2532530845390196}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 19958, "entry_point": "findLength", "best_list": [{"code": "def findLength(A, B):\n    dp = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]\n    max_length = 0\n    \n    for i in range(1, len(A) + 1):\n        for j in range(1, len(B) + 1):\n            if A[i - 1] == B[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                max_length = max(max_length, dp[i][j])\n    \n    return max_length", "passed": true, "score": {"loc": 9, "tokens": 122, "cc": 3, "nest": 4, "execution_time": 0.016768, "novelty": 0.7271357333978368}}, {"code": "def findLength(A, B):\n    m, n = len(A), len(B)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if A[i - 1] == B[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                max_length = max(max_length, dp[i][j])\n\n    return max_length", "passed": true, "score": {"loc": 10, "tokens": 123, "cc": 3, "nest": 4, "execution_time": 0.016606, "novelty": 0.07433824928731292}}, {"code": "def findLength(A, B):\n    m, n = len(A), len(B)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxLength = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if A[i - 1] == B[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                maxLength = max(maxLength, dp[i][j])\n    return maxLength", "passed": true, "score": {"loc": 10, "tokens": 123, "cc": 3, "nest": 4, "execution_time": 0.016625, "novelty": 0.08197358344778705}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 19993, "entry_point": "threeConsecutiveOdds", "best_list": [{"code": "def threeConsecutiveOdds(arr):\n    for i in range(len(arr) - 2):\n        if arr[i] % 2 != 0 and arr[i + 1] % 2 != 0 and arr[i + 2] % 2 != 0:\n            return True\n    return False", "passed": true, "score": {"loc": 5, "tokens": 58, "cc": 3, "nest": 3, "execution_time": 0.016622, "novelty": 0.06867071006570113}}, {"code": "def threeConsecutiveOdds(arr):\n    for i in range(len(arr) - 2):\n        if arr[i] % 2 == 1 and arr[i + 1] % 2 == 1 and arr[i + 2] % 2 == 1:\n            return True\n    return False", "passed": true, "score": {"loc": 5, "tokens": 58, "cc": 3, "nest": 3, "execution_time": 0.016636, "novelty": 0.19559975532711527}}, {"code": "def threeConsecutiveOdds(arr):\n    count = 0\n    for num in arr:\n        if num % 2 == 1:\n            count += 1\n            if count == 3:\n                return True\n        else:\n            count = 0\n    return False", "passed": true, "score": {"loc": 10, "tokens": 41, "cc": 3, "nest": 4, "execution_time": 0.016455, "novelty": 0.5979417968239098}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 209, "entry_point": "pivotIndex", "best_list": [{"code": "def pivotIndex(nums):\n    total_sum = sum(nums)\n    left_sum = 0\n    for i, num in enumerate(nums):\n        if left_sum == total_sum - left_sum - num:\n            return i\n        left_sum += num\n    return -1", "passed": true, "score": {"loc": 8, "tokens": 44, "cc": 2, "nest": 3, "execution_time": 0.016558, "novelty": 0.017632742263944845}}, {"code": "def pivotIndex(nums):\n    total_sum = sum(nums)\n    left_sum = 0\n    for i, num in enumerate(nums):\n        right_sum = total_sum - left_sum - num\n        if left_sum == right_sum:\n            return i\n        left_sum += num\n    return -1", "passed": true, "score": {"loc": 9, "tokens": 47, "cc": 2, "nest": 3, "execution_time": 0.016544, "novelty": 0.1542244076888688}}], "num_pass": 10, "num_uniq": 2, "num_fail": 0, "fail_uniq": 0}
{"id": 20020, "entry_point": "numberWays", "best_list": [{"code": "def numberWays(hats):\n    mod = 10**9 + 7\n    n = len(hats)\n    hat_to_people = [[] for _ in range(41)]\n    for person, hat_list in enumerate(hats):\n        for hat in hat_list:\n            hat_to_people[hat].append(person)\n    \n    dp = [[0] * (1 << n) for _ in range(41)]\n    dp[0][0] = 1\n    \n    for hat in range(1, 41):\n        for state in range(1 << n):\n            dp[hat][state] = dp[hat - 1][state]\n            for person in hat_to_people[hat]:\n                if state & (1 << person):\n                    dp[hat][state] = (dp[hat][state] + dp[hat - 1][state ^ (1 << person)]) % mod\n    \n    return dp[40][(1 << n) - 1]", "passed": true, "score": {"loc": 16, "tokens": 194, "cc": 6, "nest": 5, "execution_time": 0.017073, "novelty": 0.5947503305856143}}, {"code": "def numberWays(hats):\n    MOD = 10**9 + 7\n    n = len(hats)\n    hat_to_people = [[] for _ in range(41)]\n    for i, hat_list in enumerate(hats):\n        for hat in hat_list:\n            hat_to_people[hat].append(i)\n    \n    dp = [0] * (1 << n)\n    dp[0] = 1\n    \n    for hat in range(1, 41):\n        for mask in range((1 << n) - 1, -1, -1):\n            dp[mask] += dp[mask]\n            for person in hat_to_people[hat]:\n                if mask & (1 << person):\n                    dp[mask] += dp[mask ^ (1 << person)]\n            dp[mask] %= MOD\n    \n    return dp[(1 << n) - 1]", "passed": true, "score": {"loc": 17, "tokens": 170, "cc": 6, "nest": 5, "execution_time": 0.016774, "novelty": 0.4620845792286953}}, {"code": "def numberWays(hats):\n    MOD = 10**9 + 7\n    n = len(hats)\n    hat_to_people = [[] for _ in range(41)]\n    for i, hat_list in enumerate(hats):\n        for hat in hat_list:\n            hat_to_people[hat].append(i)\n    \n    dp = [0] * (1 << n)\n    dp[0] = 1\n    \n    for hat in range(1, 41):\n        for mask in range((1 << n) - 1, -1, -1):\n            if dp[mask] == 0:\n                continue\n            for person in hat_to_people[hat]:\n                if mask & (1 << person) == 0:\n                    dp[mask | (1 << person)] = (dp[mask | (1 << person)] + dp[mask]) % MOD\n    \n    return dp[(1 << n) - 1]", "passed": true, "score": {"loc": 17, "tokens": 181, "cc": 7, "nest": 5, "execution_time": 0.016535, "novelty": 0.5150185037406336}}, {"code": "def numberWays(hats):\n    MOD = 10**9 + 7\n    n = len(hats)\n    hat_to_people = [[] for _ in range(41)]\n    for i, person in enumerate(hats):\n        for hat in person:\n            hat_to_people[hat].append(i)\n\n    @cache\n    def dp(hat, state):\n        if hat == 41:\n            return 1 if state == (1 << n) - 1 else 0\n        count = dp(hat + 1, state)\n        for person in hat_to_people[hat]:\n            if state & (1 << person) == 0:\n                count = (count + dp(hat + 1, state | (1 << person))) % MOD\n        return count\n\n    return dp(1, 0)", "passed": false, "score": {"loc": 17, "tokens": 152, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.5796197030093779}}, {"code": "from collections import defaultdict\nfrom functools import lru_cache\n\ndef numberWays(hats):\n    MOD = 10**9 + 7\n    n = len(hats)\n    hat_to_people = defaultdict(list)\n    \n    # Map hat to list of people who prefer it\n    for person, hat_list in enumerate(hats):\n        for hat in hat_list:\n            hat_to_people[hat].append(person)\n    \n    # Helper function to count ways using memoization\n    @lru_cache(None)\n    def count_ways(hat, people_mask):\n        if hat == 41:\n            return 1\n        if people_mask == 0:\n            return 0\n        \n        # Option 1: Skip the current hat\n        result = count_ways(hat + 1, people_mask)\n        \n        # Option 2: Assign the current hat to any of the remaining people\n        for person in hat_to_people[hat]:\n            if people_mask & (1 << person):\n                result = (result + count_ways(hat + 1, people_mask ^ (1 << person))) % MOD\n        \n        return result\n    \n    return count_ways(1, (1 << n) - 1)", "passed": false, "score": {"loc": 25, "tokens": 194, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.558106718255649}}, {"code": "from functools import lru_cache\nfrom typing import List\n\n@lru_cache(None)\ndef numberWays(hat: int, people: int) -> int:\n    if hat == 0:\n        return 1 if people == 0 else 0\n    if people == 0:\n        return 0\n    return numberWays(hat, people - 1) + numberWays(hat - 1, people - 1) * sum(1 for p in range(people) if hat in prefs[p])\n\ndef numberWays(hats: List[List[int]]) -> int:\n    prefs = [[] for _ in range(len(hats))]\n    for i, hat_list in enumerate(hats):\n        for hat in hat_list:\n            prefs[i].append(hat)\n    return numberWays(40, len(hats)) % (10**9 + 7)", "passed": false, "score": {"loc": 15, "tokens": 166, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.9162328205992142}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 20034, "entry_point": "canWinNim", "best_list": [{"code": "def canWinNim(n):\n    return n % 4 > 0", "passed": true, "score": {"loc": 2, "tokens": 12, "cc": 0, "nest": 1, "execution_time": 0.016522, "novelty": 0.04330357335212853}}, {"code": "def canWinNim(n):\n    return n % 4 != 0", "passed": true, "score": {"loc": 2, "tokens": 13, "cc": 0, "nest": 1, "execution_time": 0.01653, "novelty": 0.03648819631061584}}, {"code": "def canWinNim(n: int) -> bool:\n    return n % 4 != 0", "passed": true, "score": {"loc": 2, "tokens": 18, "cc": 0, "nest": 1, "execution_time": 0.016599, "novelty": 0.08186191728459447}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 20099, "entry_point": "strong_num", "best_list": [{"code": "def strong_num(num):\n    sum_of_factorials = sum(math.factorial(int(digit)) for digit in str(num))\n    return \"STRONG!!!!\" if sum_of_factorials == num else \"Not Strong !!\"\n\nimport unittest\nimport math\n\nclass TestStrongNum(unittest.TestCase):\n    def test_cases(self):\n        self.assertEqual(strong_num(1), \"STRONG!!!!\")\n        self.assertEqual(strong_num(123), \"Not Strong !!\")\n        self.assertEqual(strong_num(2), \"STRONG!!!!\")\n        self.assertEqual(strong_num(150), \"Not Strong !!\")\n\nif __name__ == \"__main__\":\n    unittest.main()", "passed": true, "score": {"loc": 13, "tokens": 144, "cc": 1, "nest": 1, "execution_time": 0.02749, "novelty": 0.8011537214186544}}, {"code": "def strong_num(number):\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n - 1)\n    \n    sum_of_factorials = sum(factorial(int(digit)) for digit in str(number))\n    return \"STRONG!!!!\" if sum_of_factorials == number else \"Not Strong !!\"", "passed": false, "score": {"loc": 8, "tokens": 70, "cc": 1, "nest": 3, "execution_time": 10.0, "novelty": 0.6665717571293063}}, {"code": "def strong_num(num):\n    return 'STRONG!!!!' if sum(int(math.factorial(int(digit))) for digit in str(num)) == num else 'Not Strong !!'", "passed": false, "score": {"loc": 2, "tokens": 47, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6112139526253033}}, {"code": "def strong_num(num):\n    temp = num\n    sum_fact = 0\n    while temp > 0:\n        digit = temp % 10\n        fact = 1\n        for i in range(1, digit + 1):\n            fact *= i\n        sum_fact += fact\n        temp //= 10\n    return \"STRONG!!!!\" if sum_fact == num else \"Not Strong !!\"", "passed": false, "score": {"loc": 11, "tokens": 70, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6419838205756765}}, {"code": "def strong_num(number):\n    return \"STRONG!!!!\" if sum(factorial(int(digit)) for digit in str(number)) == number else \"Not Strong !!\"\n\nfrom math import factorial", "passed": false, "score": {"loc": 3, "tokens": 46, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5629622442065234}}, {"code": "def strong_num(n):\n    def factorial(digit):\n        return 1 if digit == 0 else digit * factorial(digit - 1)\n    \n    sum_of_factorials = sum(factorial(int(digit)) for digit in str(n))\n    return \"STRONG!!!!\" if sum_of_factorials == n else \"Not Strong !!\"", "passed": false, "score": {"loc": 5, "tokens": 67, "cc": 0, "nest": 2, "execution_time": 10.0, "novelty": 0.5995403958961594}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 20133, "entry_point": "findMinMoves", "best_list": [{"code": "def findMinMoves(machines):\n    total_dresses = sum(machines)\n    n = len(machines)\n    if total_dresses % n != 0:\n        return -1\n    target = total_dresses // n\n    moves = 0\n    current = 0\n    for dresses in machines:\n        current += dresses - target\n        moves = max(moves, abs(current), dresses - target)\n    return moves", "passed": true, "score": {"loc": 12, "tokens": 69, "cc": 2, "nest": 2, "execution_time": 0.016572, "novelty": 0.33912464704749645}}, {"code": "def findMinMoves(machines):\n    total = sum(machines)\n    n = len(machines)\n    if total % n != 0:\n        return -1\n    target = total // n\n    moves = 0\n    current = 0\n    for i in range(n):\n        current += machines[i] - target\n        moves = max(moves, abs(current), machines[i] - target)\n    return moves", "passed": true, "score": {"loc": 12, "tokens": 78, "cc": 2, "nest": 2, "execution_time": 0.016747, "novelty": 0.2813149252023247}}, {"code": "def findMinMoves(machines):\n    n = len(machines)\n    total = sum(machines)\n    if total % n != 0:\n        return -1\n    \n    target = total // n\n    moves = 0\n    current = 0\n    \n    for i in range(n):\n        current += machines[i] - target\n        moves = max(moves, abs(current), machines[i] - target)\n    \n    return moves", "passed": true, "score": {"loc": 12, "tokens": 78, "cc": 2, "nest": 2, "execution_time": 0.016799, "novelty": 0.2862970373619572}}, {"code": "def findMinMoves(machines):\n    total_dresses = sum(machines)\n    n = len(machines)\n    if total_dresses % n != 0:\n        return -1\n    target = total_dresses // n\n    left_sum = 0\n    max_moves = 0\n    curr_moves = 0\n    for i in range(n):\n        left_sum += machines[i]\n        curr_moves = machines[i] - target + abs((left_sum - (i + 1) * target) - (total_dresses - left_sum - (n - i - 1) * target))\n        max_moves = max(max_moves, curr_moves)\n    return max_moves", "passed": false, "score": {"loc": 14, "tokens": 108, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.4262523733832154}}, {"code": "def findMinMoves(machines):\n    total_dresses = sum(machines)\n    n = len(machines)\n    \n    if total_dresses % n != 0:\n        return -1\n    \n    target = total_dresses // n\n    left_sum = 0\n    max_left = 0\n    moves = 0\n    \n    for i in range(n):\n        right_sum = total_dresses - left_sum - machines[i]\n        left_average = left_sum // (i + 1) if i > 0 else 0\n        right_average = right_sum // (n - i - 1) if i < n - 1 else 0\n        \n        max_left = max(max_left, abs(left_average - left_sum))\n        moves = max(moves, max(abs(target - machines[i]), max_left, right_average))\n        \n        left_sum += machines[i]\n    \n    return moves", "passed": false, "score": {"loc": 17, "tokens": 143, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.5312981219690449}}, {"code": "def findMinMoves(machines):\n    total_dresses = sum(machines)\n    n = len(machines)\n    \n    if total_dresses % n != 0:\n        return -1\n    \n    target = total_dresses // n\n    left_sum = 0\n    max_load = 0\n    moves = 0\n    \n    for i, dresses in enumerate(machines):\n        left_diff = left_sum - target * i\n        right_diff = (total_dresses - left_sum - dresses) - target * (n - i - 1)\n        moves = max(moves, abs(left_diff) + abs(right_diff))\n        max_load = max(max_load, dresses + left_diff - right_diff)\n        left_sum += dresses\n    \n    return max(moves, max_load)", "passed": false, "score": {"loc": 16, "tokens": 119, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.5266441334033464}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 20146, "entry_point": "trap", "best_list": [{"code": "def trap(height):\n    if not height:\n        return 0\n    \n    left_max = [0] * len(height)\n    right_max = [0] * len(height)\n    \n    left_max[0] = height[0]\n    for i in range(1, len(height)):\n        left_max[i] = max(left_max[i-1], height[i])\n    \n    right_max[-1] = height[-1]\n    for i in range(len(height)-2, -1, -1):\n        right_max[i] = max(right_max[i+1], height[i])\n    \n    water_trapped = 0\n    for i in range(len(height)):\n        water_trapped += min(left_max[i], right_max[i]) - height[i]\n    \n    return water_trapped", "passed": true, "score": {"loc": 15, "tokens": 158, "cc": 4, "nest": 2, "execution_time": 0.016705, "novelty": 0.7847398396976921}}, {"code": "def trap(height):\n    if not height:\n        return 0\n    \n    left, right = 0, len(height) - 1\n    left_max, right_max = height[left], height[right]\n    water_trapped = 0\n    \n    while left < right:\n        if left_max < right_max:\n            left += 1\n            left_max = max(left_max, height[left])\n            water_trapped += left_max - height[left]\n        else:\n            right -= 1\n            right_max = max(right_max, height[right])\n            water_trapped += right_max - height[right]\n    \n    return water_trapped", "passed": true, "score": {"loc": 16, "tokens": 102, "cc": 3, "nest": 3, "execution_time": 0.016574, "novelty": 0.75732071847768}}, {"code": "def trap(height):\n    if not height:\n        return 0\n    \n    n = len(height)\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    left_max[0] = height[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i - 1], height[i])\n    \n    right_max[n - 1] = height[n - 1]\n    for i in range(n - 2, -1, -1):\n        right_max[i] = max(right_max[i + 1], height[i])\n    \n    water_trapped = 0\n    for i in range(n):\n        water_trapped += min(left_max[i], right_max[i]) - height[i]\n    \n    return water_trapped", "passed": true, "score": {"loc": 16, "tokens": 151, "cc": 4, "nest": 2, "execution_time": 0.016571, "novelty": 0.5709113927464333}}, {"code": "def trap(height):\n    return sum(max(0, min(lmax, rmax) - h) for h, lmax, rmax in zip(height, itertools.accumulate(height, max), reversed(tuple(itertools.accumulate(height[::-1], max)))))", "passed": false, "score": {"loc": 2, "tokens": 64, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.8073903322870322}}, {"code": "def trap(height):\n    return sum((min(l, r) - h) * w for w, (l, r, h) in enumerate(zip((0,) + height, height + (0,), height)))", "passed": false, "score": {"loc": 2, "tokens": 54, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.8322399381099335}}], "num_pass": 8, "num_uniq": 7, "num_fail": 2, "fail_uniq": 2}
{"id": 20428, "entry_point": "knightDialer", "best_list": [{"code": "def knightDialer(n: int) -> int:\n    MOD = 10**9 + 7\n    dp = [1] * 10\n    moves = [4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [], [1, 7, 0], [2, 6], [1, 3], [2, 4]\n    \n    for _ in range(1, n):\n        dp = [sum(dp[move] for move in moves[i]) % MOD for i in range(10)]\n    \n    return sum(dp) % MOD", "passed": true, "score": {"loc": 7, "tokens": 132, "cc": 1, "nest": 2, "execution_time": 0.016627, "novelty": 0.56722084903583}}, {"code": "def knightDialer(n):\n    if n == 1:\n        return 10\n    \n    mod = 10**9 + 7\n    moves = [0, 4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [], [1, 7, 0], [2, 6], [1, 3], [2, 4]\n    dp = [1] * 10\n    \n    for _ in range(n - 1):\n        dp = [sum(dp[j] for j in moves[i]) % mod for i in range(10)]\n    \n    return sum(dp) % mod", "passed": true, "score": {"loc": 9, "tokens": 137, "cc": 2, "nest": 2, "execution_time": 0.016771, "novelty": 0.6826288929705742}}, {"code": "def knightDialer(n):\n    moves = {\n        1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [],\n        6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]\n    }\n    dp = [1] * 10\n    for _ in range(n - 1):\n        dp = [sum(dp[j] for j in moves[i]) % 1000000007 for i in range(10)]\n    return sum(dp) % 1000000007", "passed": true, "score": {"loc": 9, "tokens": 141, "cc": 1, "nest": 2, "execution_time": 0.016785, "novelty": 0.6057056167186115}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 20444, "entry_point": "reverseStr", "best_list": [{"code": "def reverseStr(s: str, k: int) -> str:\n    return s[:k][::-1] + s[k:2*k] + reverseStr(s[2*k:], k) if s else s", "passed": true, "score": {"loc": 2, "tokens": 53, "cc": 0, "nest": 1, "execution_time": 0.016707, "novelty": 0.5955238077172834}}, {"code": "def reverseStr(s: str, k: int) -> str:\n    return ''.join(s[i:i+k][::-1] + s[i+k:i+2*k] for i in range(0, len(s), 2*k))", "passed": true, "score": {"loc": 2, "tokens": 65, "cc": 0, "nest": 1, "execution_time": 0.016521, "novelty": 0.4155628453589023}}, {"code": "def reverseStr(s: str, k: int) -> str:\n    return ''.join(s[i:i+k][::-1] if i % (2*k) < k else s[i:i+k] for i in range(0, len(s), k))", "passed": true, "score": {"loc": 2, "tokens": 69, "cc": 0, "nest": 1, "execution_time": 0.016687, "novelty": 0.4752606592701122}}, {"code": "def reverseStr(s: str, k: int) -> str:\n    return ''.join(s[i:i + 2 * k][::-1] + s[i + 2 * k:i + 4 * k] for i in range(0, len(s), 4 * k))", "passed": false, "score": {"loc": 2, "tokens": 69, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.46529398347177753}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 20613, "entry_point": "regionsBySlashes", "best_list": [{"code": "def regionsBySlashes(grid):\n    n = len(grid)\n    parent = list(range(4 * n * n))\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        parent[find(x)] = find(y)\n\n    for i in range(n):\n        for j in range(n):\n            base = 4 * (i * n + j)\n            if grid[i][j] != '/':\n                union(base, base + 1)\n                union(base + 2, base + 3)\n            if grid[i][j] != '\\\\':\n                union(base, base + 2)\n                union(base + 1, base + 3)\n            if i > 0:\n                union(base, base - 4 * n + 2)\n            if j > 0:\n                union(base, base - 1)\n\n    return len(set(find(x) for x in range(4 * n * n)))", "passed": true, "score": {"loc": 23, "tokens": 221, "cc": 7, "nest": 4, "execution_time": 0.016833, "novelty": 0.4407581946106549}}, {"code": "def regionsBySlashes(grid):\n    N = len(grid)\n    parent = list(range(4 * N * N))\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n\n    for r in range(N):\n        for c in range(N):\n            base = 4 * (r * N + c)\n            if grid[r][c] in ['/', ' ']:\n                union(base, base + 1)\n                union(base + 2, base + 3)\n            if grid[r][c] in ['\\\\', ' ']:\n                union(base, base + 3)\n                union(base + 1, base + 2)\n            if r > 0:\n                union(base, base - 4 * N + 2)\n            if r < N - 1:\n                union(base + 2, base + 4 * N)\n            if c > 0:\n                union(base, base - 4 + 1)\n            if c < N - 1:\n                union(base + 1, base + 4 + 2)\n\n    return len(set(find(i) for i in range(4 * N * N)))", "passed": false, "score": {"loc": 30, "tokens": 281, "cc": 10, "nest": 4, "execution_time": 10.0, "novelty": 0.5157123068322247}}, {"code": "def regionsBySlashes(grid):\n    def dfs(i, j, di, dj):\n        if not (0 <= i < n and 0 <= j < n and not visited[i][j]):\n            return 0\n        visited[i][j] = True\n        return (dfs(i + di, j + dj, di, dj) for _ in range(4) if (di, dj) == (0, 1) or (di, dj) == (1, 0))\n    \n    n = len(grid)\n    visited = [[False] * n for _ in range(n)]\n    regions = 0\n    \n    for i in range(n):\n        for j in range(n):\n            if not visited[i][j]:\n                regions += 1\n                dfs(i, j, 0, 1)\n    \n    return regions", "passed": false, "score": {"loc": 15, "tokens": 173, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.838593012482092}}, {"code": "def regionsBySlashes(grid):\n    n = len(grid)\n    dsu = [i for i in range(4 * n * n)]\n\n    def find(x):\n        if dsu[x] != x:\n            dsu[x] = find(dsu[x])\n        return dsu[x]\n\n    def union(x, y):\n        dsu[find(x)] = find(y)\n\n    for i in range(n):\n        for j in range(n):\n            index = 4 * (i * n + j)\n            if grid[i][j] in '/ ':\n                union(index, index + 1)\n                union(index + 2, index + 3)\n            if grid[i][j] in '\\\\ ':\n                union(index, index + 2)\n                union(index + 1, index + 3)\n            if i + 1 < n:\n                union(index + 2, 4 * ((i + 1) * n + j))\n            if i - 1 >= 0:\n                union(index, 4 * ((i - 1) * n + j))\n            if j + 1 < n:\n                union(index + 1, 4 * (i * n + j + 1))\n            if j - 1 >= 0:\n                union(index + 3, 4 * (i * n + j - 1))\n\n    return len({find(i) for i in range(4 * n * n)})", "passed": false, "score": {"loc": 27, "tokens": 295, "cc": 9, "nest": 4, "execution_time": 10.0, "novelty": 0.46924659767639154}}, {"code": "def regionsBySlashes(grid):\n    n = len(grid)\n    parent = list(range(4 * n * n))\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX, rootY = find(x), find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n\n    for i in range(n):\n        for j in range(n):\n            idx = 4 * (i * n + j)\n            if i > 0:\n                union(idx + 0, idx - 4 + 2)\n            if j > 0:\n                union(idx + 3, idx - 4 + 1)\n            if grid[i][j] != '/':\n                union(idx + 0, idx + 1)\n                union(idx + 2, idx + 3)\n            if grid[i][j] != '\\\\':\n                union(idx + 0, idx + 2)\n                union(idx + 1, idx + 3)\n\n    return len({find(i) for i in range(4 * n * n)})", "passed": false, "score": {"loc": 25, "tokens": 241, "cc": 8, "nest": 4, "execution_time": 10.0, "novelty": 0.5363357512574386}}, {"code": "def regionsBySlashes(grid):\n    def count_regions(grid):\n        n = len(grid)\n        parent = list(range(4 * n * n))\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                parent[rootX] = rootY\n\n        for i in range(n):\n            for j in range(n):\n                root = 4 * (i * n + j)\n                if grid[i][j] == '/' or grid[i][j] == ' ':\n                    union(root, root + 1)\n                    union(root + 2, root + 3)\n                if grid[i][j] == '\\\\' or grid[i][j] == ' ':\n                    union(root, root + 3)\n                    union(root + 1, root + 2)\n\n                if i < n - 1:\n                    union(root + 2, (i + 1) * n * 4 + j * 4)\n                if i > 0:\n                    union(root, i * n * 4 + j * 4)\n                if j < n - 1:\n                    union(root + 3, i * n * 4 + (j + 1) * 4 + 1)\n                if j > 0:\n                    union(root + 1, i * n * 4 + j * 4 + 3)\n\n        return len(set(find(i) for i in range(4 * n * n)))", "passed": false, "score": {"loc": 31, "tokens": 331, "cc": 12, "nest": 5, "execution_time": 10.0, "novelty": 0.7887016411944336}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 20617, "entry_point": "canConstruct", "best_list": [{"code": "from collections import Counter\n\ndef canConstruct(s: str, k: int) -> bool:\n    if len(s) < k:\n        return False\n    odd_count = sum(1 for count in Counter(s).values() if count % 2 != 0)\n    return odd_count <= k", "passed": true, "score": {"loc": 6, "tokens": 58, "cc": 1, "nest": 2, "execution_time": 0.0167, "novelty": 0.38751176243457575}}, {"code": "from collections import Counter\n\ndef canConstruct(s: str, k: int) -> bool:\n    if len(s) < k:\n        return False\n    freq = Counter(s)\n    odd_count = sum(1 for count in freq.values() if count % 2 != 0)\n    return odd_count <= k", "passed": true, "score": {"loc": 7, "tokens": 61, "cc": 1, "nest": 2, "execution_time": 0.016541, "novelty": 0.4195111525745525}}, {"code": "def canConstruct(s, k):\n    return len(s) >= k and sum(v % 2 for v in collections.Counter(s).values()) <= k", "passed": false, "score": {"loc": 2, "tokens": 39, "cc": 1, "nest": 1, "execution_time": 10.0, "novelty": 0.5183450853204792}}, {"code": "def canConstruct(s: str, k: int) -> bool:\n    if len(s) < k:\n        return False\n    counts = [0] * 26\n    for char in s:\n        counts[ord(char) - ord('a')] += 1\n    odd_count = sum(1 for count in counts if count % 2 != 0)\n    return odd_count <= k", "passed": false, "score": {"loc": 8, "tokens": 76, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.3017501943076353}}, {"code": "def canConstruct(s: str, k: int) -> bool:\n    if k > len(s):\n        return False\n    count = [0] * 26\n    for char in s:\n        count[ord(char) - ord('a')] += 1\n    odd = sum(1 for c in count if c % 2 != 0)\n    return odd <= k", "passed": false, "score": {"loc": 8, "tokens": 76, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.27014786840415317}}, {"code": "def canConstruct(s: str, k: int) -> bool:\n    if k > len(s):\n        return False\n    odd_count = sum(1 for char, count in collections.Counter(s).items() if count % 2 != 0)\n    return odd_count <= k", "passed": false, "score": {"loc": 5, "tokens": 58, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.38223798861603864}}, {"code": "def canConstruct(s: str, k: int) -> bool:\n    if k > len(s):\n        return False\n    counts = [0] * 26\n    for char in s:\n        counts[ord(char) - ord('a')] += 1\n    odd = sum(1 for count in counts if count % 2 == 1)\n    return odd <= k", "passed": false, "score": {"loc": 8, "tokens": 76, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.2858893851127511}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 7}
{"id": 20623, "entry_point": "getProbability", "best_list": [{"code": "from math import comb\n\ndef getProbability(balls):\n    def dfs(i, n1, n2, c1, c2, tot):\n        if i == len(balls):\n            return 1 if c1 == c2 and n1 == n2 else 0\n        res = 0\n        for j in range(balls[i] + 1):\n            res += comb(balls[i], j) * dfs(i + 1, n1 + j, n2 + balls[i] - j, c1 + (j > 0), c2 + (balls[i] - j > 0), tot - balls[i])\n        return res\n    \n    total_ways = comb(sum(balls), sum(balls) // 2)\n    valid_ways = dfs(0, 0, 0, 0, 0, sum(balls))\n    return valid_ways / total_ways", "passed": true, "score": {"loc": 12, "tokens": 167, "cc": 3, "nest": 3, "execution_time": 0.016635, "novelty": 0.7700582697685694}}, {"code": "from math import comb\n\ndef getProbability(balls):\n    total_ways = comb(sum(balls), sum(balls) // 2)\n    valid_ways = 0\n    \n    def backtrack(index, box1, box2, count1, count2, balls1, balls2):\n        nonlocal valid_ways\n        if index == len(balls):\n            if count1 == count2 and len(box1) == len(box2):\n                valid_ways += comb(sum(balls1), sum(balls1) // 2) * comb(sum(balls2), sum(balls2) // 2)\n            return\n        for i in range(balls[index] + 1):\n            backtrack(index + 1, box1 + [i], box2 + [balls[index] - i], count1 + (i > 0), count2 + (balls[index] - i > 0), balls1 + [i], balls2 + [balls[index] - i])\n    \n    backtrack(0, [], [], 0, 0, [], [])\n    return valid_ways / total_ways", "passed": true, "score": {"loc": 14, "tokens": 209, "cc": 4, "nest": 4, "execution_time": 0.016829, "novelty": 0.7649817070099688}}, {"code": "from math import comb\n\ndef getProbability(balls):\n    n = sum(balls) // 2\n    total_ways = comb(sum(balls), n)\n    valid_ways = 0\n\n    def backtrack(i, box1, box2, balls1, balls2, distinct1, distinct2):\n        nonlocal valid_ways\n        if i == len(balls):\n            if distinct1 == distinct2:\n                valid_ways += comb(n, balls1) * comb(n, balls2)\n            return\n        for j in range(balls[i] + 1):\n            backtrack(i + 1, box1 + (j > 0), box2 + (j < balls[i]), balls1 + j, balls2 + balls[i] - j, distinct1 + (j > 0), distinct2 + (j < balls[i]))\n\n    backtrack(0, 0, 0, 0, 0, 0, 0)\n    return valid_ways / total_ways", "passed": true, "score": {"loc": 15, "tokens": 175, "cc": 3, "nest": 4, "execution_time": 0.016546, "novelty": 0.7296418718451854}}, {"code": "from math import comb\n\ndef getProbability(balls):\n    total = 0\n    valid = 0\n    n = sum(balls) // 2\n    distinct = len(balls)\n    \n    def backtrack(i, box1, box2, count1, count2, balls1, balls2):\n        nonlocal total, valid\n        if i == distinct:\n            total += comb(sum(balls1), balls1[0]) * comb(sum(balls2), balls2[0])\n            if count1 == count2:\n                valid += comb(sum(balls1), balls1[0]) * comb(sum(balls2), balls2[0])\n            return\n        for j in range(balls[i] + 1):\n            balls1.append(j)\n            balls2.append(balls[i] - j)\n            backtrack(i + 1, box1 + (j > 0), box2 + (j < balls[i]), count1 + (j > 0), count2 + (j < balls[i]), balls1, balls2)\n            balls1.pop()\n            balls2.pop()\n    \n    backtrack(0, 0, 0, 0, 0, [], [])\n    return valid / total", "passed": false, "score": {"loc": 21, "tokens": 232, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7668270606039249}}, {"code": "from math import comb\n\ndef getProbability(balls):\n    total_ways = comb(sum(balls), sum(balls) // 2)\n    valid_ways = 0\n    target_distinct = sum(1 for b in balls if b > 0)\n    \n    def backtrack(index, box1, box2, balls_left, distinct1, distinct2):\n        nonlocal valid_ways\n        if index == len(balls):\n            if distinct1 == distinct2 == target_distinct:\n                valid_ways += comb(balls_left, sum(box1)) * comb(balls_left - sum(box1), sum(box2))\n            return\n        for i in range(balls[index] + 1):\n            box1.append(i)\n            box2.append(balls[index] - i)\n            backtrack(index + 1, box1, box2, balls_left - 2 * i, distinct1 + (i > 0), distinct2 + ((balls[index] - i) > 0))\n            box1.pop()\n            box2.pop()\n    \n    backtrack(0, [], [], sum(balls), 0, 0)\n    return valid_ways / total_ways", "passed": false, "score": {"loc": 19, "tokens": 210, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7517272571823523}}, {"code": "def getProbability(balls):\n    from math import factorial as fact\n\n    def ways(arr):\n        return fact(sum(arr)) // prod(fact(x) for x in arr if x)\n\n    def helper(i, a, b):\n        if i == len(balls):\n            return 1 if a == b else 0\n        res = 0\n        for j in range(balls[i] + 1):\n            res += ways([a[0] + (j == 0), a[1] + (j == 1)]) * ways([b[0] + (j == 2), b[1] + (j == 3)]) * helper(i + 1, [a[0] + (j == 0), a[1] + (j == 1)], [b[0] + (j == 2), b[1] + (j == 3)])\n        return res\n\n    total = ways([0, 0]) ** 2\n    valid = helper(0, [0, 0], [0, 0])\n    return valid / total\n\ndef prod(iterable):\n    p = 1\n    for x in iterable:\n        p *= x\n    return p\n\ndef _equivalent(_lhs, _rhs):\n    return abs(_lhs - _rhs) < 1e-5", "passed": false, "score": {"loc": 21, "tokens": 280, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.8478478165625837}}, {"code": "from itertools import combinations_with_replacement\n\ndef getProbability(balls):\n    total_ways = 1\n    for b in balls:\n        total_ways *= (b * 2 + 1)\n    total_ways //= 2\n    \n    def combinations(arr, k):\n        if k == 0:\n            return [[]]\n        return [c for c in combinations_with_replacement(arr, k) for i in range(c[-1], len(arr)) if c[-1] == i or arr[i] > c[-1]]\n    \n    def factorial(n):\n        return 1 if n == 0 else n * factorial(n - 1)\n    \n    def binomial(n, k):\n        return factorial(n) // (factorial(k) * factorial(n - k))\n    \n    def ways_to_distribute(balls, box1, box2):\n        if len(box1) == len(box2) == len(balls):\n            return 1\n        if len(box1) > len(balls) // 2 or len(box2) > len(balls) // 2:\n            return 0\n        box1_count = len(set(box1))\n        box2_count = len(set(box2))\n        if box1_count != box2_count:\n            return 0\n        remaining_balls = [b - (box1.count(i) + box2.count(i)) for i, b in enumerate(balls)]\n        if any(b < 0 for b in remaining_balls):\n            return 0\n        return ways_to_distribute(balls, box1 + [remaining_balls[0]], box2)\n    \n    count = 0\n    for c in combinations(balls, len(balls) // 2):\n        count += ways_to_distribute(balls, c, [0] * len(balls))\n    \n    return count / total_ways", "passed": false, "score": {"loc": 31, "tokens": 337, "cc": 9, "nest": 3, "execution_time": 10.0, "novelty": 0.8682223103260648}}, {"code": "from itertools import permutations\n\ndef getProbability(balls):\n    total = factorial(sum(balls))\n    valid = 0\n    \n    for p in permutations(range(len(balls))):\n        box1 = [0] * len(balls)\n        box2 = [0] * len(balls)\n        for i, color in enumerate(p):\n            if (i // 2) % 2 == 0:\n                box1[color] += 1\n            else:\n                box2[color] += 1\n        \n        if len(set(box1)) == len(set(box2)):\n            valid += factorial(sum(box1)) * factorial(sum(box2))\n            for count in box1:\n                valid //= factorial(count)\n            for count in box2:\n                valid //= factorial(count)\n    \n    return valid / total", "passed": false, "score": {"loc": 19, "tokens": 161, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.8141987656123039}}], "num_pass": 4, "num_uniq": 4, "num_fail": 6, "fail_uniq": 6}
{"id": 20629, "entry_point": "oddEvenJumps", "best_list": [{"code": "def oddEvenJumps(A):\n    n = len(A)\n    odd = [0] * n\n    even = [0] * n\n    odd[-1] = even[-1] = 1\n    stack = []\n    for a, i in sorted((a, i) for i, a in enumerate(A)):\n        while stack and stack[-1] < i:\n            odd[stack.pop()] = i if not stack else stack[-1]\n        stack.append(i)\n    stack = []\n    for a, i in sorted((-a, i) for i, a in enumerate(A)):\n        while stack and stack[-1] < i:\n            even[stack.pop()] = i if not stack else stack[-1]\n        stack.append(i)\n    return sum(odd[i] and even[odd[i]] for i in range(n - 1)) + 1", "passed": true, "score": {"loc": 16, "tokens": 193, "cc": 7, "nest": 3, "execution_time": 0.01675, "novelty": 0.7833628027443755}}, {"code": "def oddEvenJumps(A):\n    n = len(A)\n    odd = [0] * n\n    even = [0] * n\n    odd[n-1] = 1\n    even[n-1] = 1\n    \n    indices = sorted(range(n), key=lambda i: A[i])\n    stack = []\n    for i in indices:\n        while stack and stack[-1] < i:\n            odd[stack.pop()] = even[i]\n        stack.append(i)\n    \n    indices.sort(key=lambda i: -A[i])\n    stack = []\n    for i in indices:\n        while stack and stack[-1] < i:\n            even[stack.pop()] = odd[i]\n        stack.append(i)\n    \n    return sum(odd[i] for i in range(n) if odd[i])", "passed": true, "score": {"loc": 19, "tokens": 174, "cc": 6, "nest": 3, "execution_time": 0.016637, "novelty": 0.592409810185792}}, {"code": "def oddEvenJumps(A):\n    n = len(A)\n    next_higher, next_lower = [0] * n, [0] * n\n    stack = []\n    for i in sorted(range(n), key=lambda i: A[i]):\n        while stack and stack[-1] < i:\n            next_higher[stack.pop()] = i\n        stack.append(i)\n    stack = []\n    for i in sorted(range(n), key=lambda i: -A[i]):\n        while stack and stack[-1] < i:\n            next_lower[stack.pop()] = i\n        stack.append(i)\n    odd, even = [0] * n, [0] * n\n    odd[n - 1], even[n - 1] = 1, 1\n    for i in range(n - 2, -1, -1):\n        odd[i] = even[next_higher[i]]\n        even[i] = odd[next_lower[i]]\n    return sum(odd)", "passed": true, "score": {"loc": 19, "tokens": 209, "cc": 7, "nest": 3, "execution_time": 0.016767, "novelty": 0.6309254276104219}}, {"code": "from sortedcontainers import SortedDict\n\ndef oddEvenJumps(A):\n    n = len(A)\n    odd_jump = [-1] * n\n    even_jump = [-1] * n\n    sd = SortedDict()\n    \n    def get_jump(target, direction):\n        if target in sd:\n            return sd[target]\n        if direction == 'odd':\n            key = sd.bisect_left(target)\n            if key < len(sd):\n                return sd.peekitem(key)[1]\n        else:\n            key = sd.bisect_right(target) - 1\n            if key >= 0:\n                return sd.peekitem(key)[1]\n        return -1\n    \n    for i in range(n-1, -1, -1):\n        sd[A[i]] = i\n        odd_jump[i] = get_jump(A[i], 'odd')\n        even_jump[i] = get_jump(A[i], 'even')\n        sd.pop(A[i])\n    \n    dp_odd = [False] * n\n    dp_even = [False] * n\n    dp_odd[-1] = dp_even[-1] = True\n    \n    for i in range(n-2, -1, -1):\n        dp_odd[i] = even_jump[i] != -1 and dp_even[even_jump[i]]\n        dp_even[i] = odd_jump[i] != -1 and dp_odd[odd_jump[i]]\n    \n    return sum(dp_odd)", "passed": false, "score": {"loc": 30, "tokens": 276, "cc": 8, "nest": 4, "execution_time": 10.0, "novelty": 0.8583344813193503}}, {"code": "def oddEvenJumps(A):\n    n = len(A)\n    odd_jump = [0] * n\n    even_jump = [0] * n\n    stack = []\n    stack2 = []\n    for i in range(n):\n        while stack and A[i] >= A[stack[-1]]:\n            stack.pop()\n        if stack:\n            odd_jump[stack[-1]] = i\n        stack.append(i)\n    for i in range(n):\n        while stack2 and A[i] <= A[stack2[-1]]:\n            stack2.pop()\n        if stack2:\n            even_jump[stack2[-1]] = i\n        stack2.append(i)\n    odd_jump[-1] = 1\n    even_jump[-1] = 1\n    for i in range(n-2, -1, -1):\n        odd_jump[i] = even_jump[odd_jump[i]]\n        even_jump[i] = odd_jump[even_jump[i]]\n    return sum(odd_jump)", "passed": false, "score": {"loc": 24, "tokens": 193, "cc": 9, "nest": 3, "execution_time": 10.0, "novelty": 0.6629358020651775}}, {"code": "from sortedcontainers import SortedList\n\ndef oddEvenJumps(A):\n    n = len(A)\n    next_greater = [None] * n\n    next_smaller = [None] * n\n    \n    stack = []\n    for i, a in enumerate(A):\n        while stack and A[stack[-1]] < a:\n            next_greater[stack.pop()] = i\n        stack.append(i)\n    \n    stack = []\n    for i, a in sorted(enumerate(A), key=lambda x: x[1], reverse=True):\n        while stack and A[stack[-1]] > a:\n            next_smaller[stack.pop()] = i\n        stack.append(i)\n    \n    odd = [False] * n\n    even = [False] * n\n    odd[-1] = even[-1] = True\n    \n    for i in range(n - 2, -1, -1):\n        if next_greater[i] is not None:\n            odd[i] = even[next_greater[i]]\n        if next_smaller[i] is not None:\n            even[i] = odd[next_smaller[i]]\n    \n    return sum(odd)", "passed": false, "score": {"loc": 24, "tokens": 225, "cc": 9, "nest": 3, "execution_time": 10.0, "novelty": 0.5961090475916475}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 20688, "entry_point": "numSquarefulPerms", "best_list": [{"code": "from itertools import permutations\n\ndef numSquarefulPerms(A):\n    return sum(1 for p in permutations(A) if all(int((p[i] + p[i + 1]) ** 0.5) ** 2 == p[i] + p[i + 1] for i in range(len(p) - 1)))", "passed": true, "score": {"loc": 3, "tokens": 75, "cc": 0, "nest": 1, "execution_time": 0.016683, "novelty": 0.7482186324932769}}, {"code": "def numSquarefulPerms(A):\n    from itertools import permutations\n    from math import isqrt\n\n    def is_perfect_square(n):\n        return isqrt(n) ** 2 == n\n\n    def is_squareful(seq):\n        return all(is_perfect_square(a + b) for a, b in zip(seq, seq[1:]))\n\n    return sum(1 for perm in permutations(A) if is_squareful(perm))", "passed": true, "score": {"loc": 8, "tokens": 79, "cc": 0, "nest": 2, "execution_time": 0.016693, "novelty": 0.6392079204063579}}, {"code": "from math import isqrt\nfrom itertools import permutations\n\ndef numSquarefulPerms(A):\n    def is_square(n):\n        return isqrt(n) ** 2 == n\n\n    res = 0\n    for perm in set(permutations(A)):\n        if all(is_square(perm[i] + perm[i+1]) for i in range(len(perm) - 1)):\n            res += 1\n    return res", "passed": true, "score": {"loc": 10, "tokens": 82, "cc": 2, "nest": 3, "execution_time": 0.0167, "novelty": 0.5918234977484946}}, {"code": "from collections import Counter\nimport math\nfrom itertools import permutations\n\ndef numSquarefulPerms(n):\n    root = int(math.isqrt(n))\n    return root * root == n\n\ndef numSquarefulPerms(A):\n    count = Counter()\n    for perm in permutations(A):\n        if all(numSquarefulPerms(perm[i] + perm[i + 1]) for i in range(len(perm) - 1)):\n            count[frozenset(perm)] += 1\n    return sum(count.values())", "passed": false, "score": {"loc": 12, "tokens": 103, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7458727914961906}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 20715, "entry_point": "maxCoins", "best_list": [{"code": "def maxCoins(piles):\n    piles.sort(reverse=True)\n    return sum(piles[1::2][:len(piles)//3])", "passed": true, "score": {"loc": 3, "tokens": 35, "cc": 0, "nest": 1, "execution_time": 0.016601, "novelty": 0.5574058725489666}}, {"code": "def maxCoins(piles):\n    piles.sort()\n    return sum(piles[i] for i in range(len(piles) // 3, len(piles), 2))", "passed": true, "score": {"loc": 3, "tokens": 39, "cc": 0, "nest": 1, "execution_time": 0.016589, "novelty": 0.14880515450775011}}, {"code": "def maxCoins(piles):\n    piles.sort()\n    total = 0\n    left, right = 0, len(piles) - 2\n    while left < right:\n        total += piles[right]\n        left += 1\n        right -= 2\n    return total", "passed": true, "score": {"loc": 9, "tokens": 48, "cc": 1, "nest": 2, "execution_time": 0.016634, "novelty": 0.6599492620852281}}, {"code": "def maxCoins(piles):\n    piles.sort(reverse=True)\n    return sum(piles[i] for i in range(1, len(piles), 2))", "passed": false, "score": {"loc": 3, "tokens": 36, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5942969334948878}}], "num_pass": 9, "num_uniq": 3, "num_fail": 1, "fail_uniq": 1}
{"id": 20718, "entry_point": "gcdOfStrings", "best_list": [{"code": "def gcdOfStrings(str1, str2):\n    if str1 + str2 != str2 + str1:\n        return \"\"\n    return str1[:gcd(len(str1), len(str2))]", "passed": true, "score": {"loc": 4, "tokens": 38, "cc": 1, "nest": 2, "execution_time": 0.01659, "novelty": 0.19757861422200584}}, {"code": "def gcdOfStrings(str1: str, str2: str) -> str:\n    if str1 + str2 != str2 + str1:\n        return \"\"\n    return str1[:gcd(len(str1), len(str2))]", "passed": true, "score": {"loc": 4, "tokens": 45, "cc": 1, "nest": 2, "execution_time": 0.016641, "novelty": 0.19708178282270172}}, {"code": "def gcdOfStrings(str1: str, str2: str) -> str:\n    if str1 + str2 != str2 + str1:\n        return \"\"\n    return str1[:math.gcd(len(str1), len(str2))]", "passed": true, "score": {"loc": 4, "tokens": 47, "cc": 1, "nest": 2, "execution_time": 0.01658, "novelty": 0.21639181311574407}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 20740, "entry_point": "hammingWeight", "best_list": [{"code": "def hammingWeight(n):\n    return bin(n).count('1')", "passed": true, "score": {"loc": 2, "tokens": 18, "cc": 0, "nest": 1, "execution_time": 0.016647, "novelty": 0.10957965175648576}}, {"code": "def hammingWeight(n: int) -> int:\n    return bin(n).count('1')", "passed": true, "score": {"loc": 2, "tokens": 23, "cc": 0, "nest": 1, "execution_time": 0.016724, "novelty": 0.10332843090760391}}, {"code": "def hammingWeight(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count", "passed": true, "score": {"loc": 6, "tokens": 25, "cc": 1, "nest": 2, "execution_time": 0.016477, "novelty": 0.6273067993629311}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 20777, "entry_point": "makeGood", "best_list": [{"code": "def makeGood(s):\n    stack = []\n    for char in s:\n        if stack and stack[-1].swapcase() == char:\n            stack.pop()\n        else:\n            stack.append(char)\n    return ''.join(stack)", "passed": true, "score": {"loc": 8, "tokens": 52, "cc": 3, "nest": 3, "execution_time": 0.01658, "novelty": 0.28307404722489893}}, {"code": "def makeGood(s: str) -> str:\n    stack = []\n    for char in s:\n        if stack and stack[-1].swapcase() == char:\n            stack.pop()\n        else:\n            stack.append(char)\n    return ''.join(stack)", "passed": true, "score": {"loc": 8, "tokens": 57, "cc": 3, "nest": 3, "execution_time": 0.016792, "novelty": 0.28223419194766897}}, {"code": "def makeGood(s):\n    stack = []\n    for char in s:\n        if stack and abs(ord(char) - ord(stack[-1])) == 32:\n            stack.pop()\n        else:\n            stack.append(char)\n    return ''.join(stack)", "passed": true, "score": {"loc": 8, "tokens": 59, "cc": 3, "nest": 3, "execution_time": 0.016718, "novelty": 0.32444849139203613}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 20923, "entry_point": "largestMultipleOfThree", "best_list": [{"code": "def largestMultipleOfThree(digits):\n    mod_sum = sum(digits) % 3\n    while mod_sum != 0:\n        for d in sorted(digits, reverse=True):\n            if d % 3 == mod_sum:\n                digits.remove(d)\n                mod_sum = sum(digits) % 3\n                break\n        else:\n            return \"\"\n    digits.sort(reverse=True)\n    return \"0\" if digits and digits[0] == 0 else \"\".join(map(str, digits))", "passed": true, "score": {"loc": 12, "tokens": 95, "cc": 4, "nest": 4, "execution_time": 0.016489, "novelty": 0.7144045170649427}}, {"code": "def largestMultipleOfThree(digits):\n    total_sum = sum(digits)\n    if total_sum % 3 == 0:\n        digits.sort(reverse=True)\n        return ''.join(map(str, digits)) or '0'\n    \n    target_remainder = total_sum % 3\n    for remove_count in range(1, 4):\n        for remove in combinations(digits, remove_count):\n            if sum(remove) % 3 == target_remainder:\n                remaining_digits = sorted(digits)\n                for d in remove:\n                    remaining_digits.remove(d)\n                remaining_digits.sort(reverse=True)\n                return ''.join(map(str, remaining_digits)) or '0'\n    \n    return ''", "passed": true, "score": {"loc": 15, "tokens": 126, "cc": 7, "nest": 5, "execution_time": 0.016627, "novelty": 0.7704592583353553}}, {"code": "def largestMultipleOfThree(digits):\n    sum_val = sum(digits)\n    while sum_val % 3 != 0:\n        for d in sorted(digits):\n            if sum_val % 3 == 1 and d % 3 == 1:\n                digits.remove(d)\n                sum_val -= d\n                break\n            elif sum_val % 3 == 2 and d % 3 == 2:\n                digits.remove(d)\n                sum_val -= d\n                break\n        else:\n            return \"\"\n    digits.sort(reverse=True)\n    return ''.join(map(str, digits)) if digits else \"0\"", "passed": true, "score": {"loc": 16, "tokens": 112, "cc": 6, "nest": 5, "execution_time": 0.016557, "novelty": 0.7349314030609297}}, {"code": "def largestMultipleOfThree(digits):\n    from collections import Counter\n    mod_counts = Counter(d % 3 for d in digits)\n    while mod_counts[1] % 3 == mod_counts[2] % 3 == 1:\n        mod_counts[1] -= 1\n        mod_counts[2] -= 1\n    while mod_counts[2] % 3 == mod_counts[1] % 3 == 2:\n        mod_counts[2] -= 1\n        mod_counts[1] -= 1\n    if mod_counts[1] % 3 == 2:\n        mod_counts[1] -= 2\n    elif mod_counts[2] % 3 == 2:\n        mod_counts[2] -= 2\n    if mod_counts[1] % 3 == 1:\n        mod_counts[1] -= 1\n    result = ''.join(str(d) * mod_counts[d % 3] for d in range(9, -1, -1))\n    return result if result and result[0] != '0' else '0'", "passed": false, "score": {"loc": 17, "tokens": 192, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.8003044211410815}}, {"code": "def largestMultipleOfThree(digits):\n    mod_counts = [sum(d % 3 == i for d in digits) for i in range(3)]\n    while mod_counts[2] % 3 != 0:\n        if mod_counts[2] > 0:\n            mod_counts[2] -= 1\n            mod_counts[digits.index(next(d for d in digits if d % 3 == 2))] -= 1\n        else:\n            if mod_counts[1] > 1:\n                mod_counts[1] -= 2\n                mod_counts[digits.index(next(d for d in digits if d % 3 == 1))] -= 1\n                mod_counts[digits.index(next(d for d in digits if d % 3 == 1))] -= 1\n            else:\n                return \"\"\n    if mod_counts[2] == 2:\n        mod_counts[2] -= 2\n        mod_counts[digits.index(next(d for d in digits if d % 3 == 2))] -= 1\n        mod_counts[digits.index(next(d for d in digits if d % 3 == 2))] -= 1\n    digits = [d for d in digits if d % 3 == 0]\n    digits.extend([d for d in digits if d % 3 == 1 and mod_counts[1] > 0])\n    digits.extend([d for d in digits if d % 3 == 2 and mod_counts[2] > 0])\n    digits.sort(reverse=True)\n    if not digits:\n        return \"0\"\n    return \"\".join(str(d) for d in digits)", "passed": false, "score": {"loc": 24, "tokens": 323, "cc": 7, "nest": 4, "execution_time": 10.0, "novelty": 0.8785612694875089}}, {"code": "def largestMultipleOfThree(digits):\n    mod_counts = [0] * 3\n    for digit in digits:\n        mod_counts[digit % 3] += 1\n    \n    while mod_counts[2] % 3 != 0:\n        if mod_counts[2] > 0:\n            mod_counts[2] -= 1\n        else:\n            if mod_counts[1] >= 2:\n                mod_counts[1] -= 2\n            elif mod_counts[0] >= 1:\n                mod_counts[0] -= 1\n            else:\n                break\n    \n    while mod_counts[1] % 3 != 0:\n        if mod_counts[1] > 0:\n            mod_counts[1] -= 1\n        else:\n            if mod_counts[0] >= 2:\n                mod_counts[0] -= 2\n            elif mod_counts[2] >= 1:\n                mod_counts[2] -= 1\n            else:\n                break\n    \n    result = ''.join(str(digit) * count for digit, count in enumerate(mod_counts[::-1]))\n    return result if result and result[0] != '0' else '0'", "passed": false, "score": {"loc": 26, "tokens": 200, "cc": 10, "nest": 5, "execution_time": 10.0, "novelty": 0.7525576681283863}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 20966, "entry_point": "containsPattern", "best_list": [{"code": "def containsPattern(arr, m, k):\n    n = len(arr)\n    return any(arr[i:i+m] * k == arr[i:i+m*k] for i in range(n - m*k + 1))", "passed": true, "score": {"loc": 3, "tokens": 55, "cc": 0, "nest": 1, "execution_time": 0.01656, "novelty": 0.6113693220717742}}, {"code": "def containsPattern(arr, m, k):\n    n = len(arr)\n    for i in range(n - m * k + 1):\n        pattern = arr[i:i + m]\n        if all(arr[i + j * m:i + (j + 1) * m] == pattern for j in range(1, k)):\n            return True\n    return False", "passed": true, "score": {"loc": 7, "tokens": 79, "cc": 2, "nest": 3, "execution_time": 0.017042, "novelty": 0.0930206881568112}}, {"code": "def containsPattern(arr, m, k):\n    n = len(arr)\n    if n < m * k:\n        return False\n    \n    for i in range(n - m * k + 1):\n        pattern = arr[i:i + m]\n        if all(arr[i + j * m:i + (j + 1) * m] == pattern for j in range(1, k)):\n            return True\n    \n    return False", "passed": true, "score": {"loc": 9, "tokens": 88, "cc": 3, "nest": 3, "execution_time": 0.016605, "novelty": 0.12490289884927563}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 2106, "entry_point": "numRescueBoats", "best_list": [{"code": "def numRescueBoats(people, limit):\n    people.sort()\n    i, j = 0, len(people) - 1\n    boats = 0\n    while i <= j:\n        if people[i] + people[j] <= limit:\n            i += 1\n        j -= 1\n        boats += 1\n    return boats", "passed": true, "score": {"loc": 10, "tokens": 62, "cc": 2, "nest": 3, "execution_time": 0.016585, "novelty": 0.02317451941547588}}, {"code": "def numRescueBoats(people, limit):\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n    while left <= right:\n        if people[left] + people[right] <= limit:\n            left += 1\n        right -= 1\n        boats += 1\n    return boats", "passed": true, "score": {"loc": 10, "tokens": 62, "cc": 2, "nest": 3, "execution_time": 0.016733, "novelty": 0.009489794368763627}}, {"code": "def numRescueBoats(people: List[int], limit: int) -> int:\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n    while left <= right:\n        if people[left] + people[right] <= limit:\n            left += 1\n        right -= 1\n        boats += 1\n    return boats", "passed": false, "score": {"loc": 10, "tokens": 72, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.0716657277238516}}], "num_pass": 9, "num_uniq": 2, "num_fail": 1, "fail_uniq": 1}
{"id": 2108, "entry_point": "canJump", "best_list": [{"code": "def canJump(nums):\n    return all(nums[i] >= i - (len(nums) - 1) for i in range(len(nums)))", "passed": true, "score": {"loc": 2, "tokens": 36, "cc": 0, "nest": 1, "execution_time": 0.016659, "novelty": 0.6613737379058611}}, {"code": "def canJump(nums):\n    max_reach = 0\n    for i, num in enumerate(nums):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + num)\n    return max_reach >= len(nums) - 1", "passed": true, "score": {"loc": 7, "tokens": 46, "cc": 2, "nest": 3, "execution_time": 0.016585, "novelty": 0.2653111568516997}}, {"code": "def canJump(nums):\n    max_reach = 0\n    for i in range(len(nums)):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + nums[i])\n    return max_reach >= len(nums) - 1", "passed": true, "score": {"loc": 7, "tokens": 50, "cc": 2, "nest": 3, "execution_time": 0.016456, "novelty": 0.3269091038807628}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 2124, "entry_point": "countPrimes", "best_list": [{"code": "def countPrimes(n):\n    if n <= 2:\n        return 0\n    primes = set(range(2, n))\n    for i in range(2, int(n**0.5) + 1):\n        if i in primes:\n            primes -= set(range(i*i, n, i))\n    return len(primes)", "passed": true, "score": {"loc": 8, "tokens": 71, "cc": 3, "nest": 3, "execution_time": 0.016486, "novelty": 0.46097250222206343}}, {"code": "def countPrimes(n):\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)", "passed": true, "score": {"loc": 10, "tokens": 83, "cc": 4, "nest": 4, "execution_time": 0.01655, "novelty": 0.24484184410050003}}, {"code": "def countPrimes(n):\n    if n <= 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            for j in range(i*i, n, i):\n                sieve[j] = False\n    return sum(sieve)", "passed": true, "score": {"loc": 10, "tokens": 83, "cc": 4, "nest": 4, "execution_time": 0.016634, "novelty": 0.2205142506083203}}, {"code": "def countPrimes(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef countPrimes(n):\n    count = 0\n    for num in range(2, n):\n        if countPrimes(num):\n            count += 1\n    return count", "passed": false, "score": {"loc": 13, "tokens": 77, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.575312364148848}}], "num_pass": 9, "num_uniq": 4, "num_fail": 1, "fail_uniq": 1}
{"id": 2132, "entry_point": "subarraysDivByK", "best_list": [{"code": "def subarraysDivByK(A, K):\n    count, prefix_sum, freq = 0, 0, {0: 1}\n    for num in A:\n        prefix_sum = (prefix_sum + num) % K\n        count += freq.get(prefix_sum, 0)\n        freq[prefix_sum] = freq.get(prefix_sum, 0) + 1\n    return count", "passed": true, "score": {"loc": 7, "tokens": 65, "cc": 1, "nest": 2, "execution_time": 0.016637, "novelty": 0.6822080422664464}}, {"code": "def subarraysDivByK(A, K):\n    count, total = 0, 0\n    mod_counts = {0: 1}\n    for num in A:\n        total += num\n        mod = total % K\n        count += mod_counts.get(mod, 0)\n        mod_counts[mod] = mod_counts.get(mod, 0) + 1\n    return count", "passed": true, "score": {"loc": 9, "tokens": 64, "cc": 1, "nest": 2, "execution_time": 0.016539, "novelty": 0.5376694143127569}}, {"code": "def subarraysDivByK(A, K):\n    prefix_sums = {0: 1}\n    total, count = 0, 0\n    for num in A:\n        total += num\n        remainder = total % K\n        count += prefix_sums.get(remainder, 0)\n        prefix_sums[remainder] = prefix_sums.get(remainder, 0) + 1\n    return count", "passed": true, "score": {"loc": 9, "tokens": 64, "cc": 1, "nest": 2, "execution_time": 0.016662, "novelty": 0.553312153572307}}, {"code": "def subarraysDivByK(A, K):\n    count, prefix_sum = 0, 0\n    prefix_sums = [0] * (K + 1)\n    for num in A:\n        prefix_sum = (prefix_sum + num % K + K) % K\n        count += prefix_sums[prefix_sum]\n        prefix_sums[prefix_sum] += 1\n    return count", "passed": false, "score": {"loc": 8, "tokens": 60, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.6998394995162223}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 2141, "entry_point": "checkRecord", "best_list": [{"code": "def checkRecord(s):\n    return s.count('A') < 2 and 'LLL' not in s", "passed": true, "score": {"loc": 2, "tokens": 24, "cc": 1, "nest": 1, "execution_time": 0.016634, "novelty": 0.4569709742642867}}, {"code": "def checkRecord(s):\n    return s.count('A') < 2 and s.count('LLL') == 0", "passed": true, "score": {"loc": 2, "tokens": 29, "cc": 1, "nest": 1, "execution_time": 0.016558, "novelty": 0.314737151881996}}, {"code": "def checkRecord(s):\n    return s.count('A') <= 1 and s.count('LLL') == 0", "passed": true, "score": {"loc": 2, "tokens": 30, "cc": 1, "nest": 1, "execution_time": 0.016597, "novelty": 0.30044690825183595}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 21051, "entry_point": "maxScore", "best_list": [{"code": "def maxScore(s):\n    return max(s[:i].count('0') + s[i:].count('1') for i in range(1, len(s)))", "passed": true, "score": {"loc": 2, "tokens": 47, "cc": 0, "nest": 1, "execution_time": 0.016702, "novelty": 0.381530879531513}}, {"code": "def maxScore(s: str) -> int:\n    return max(s[:i].count('0') + s[i:].count('1') for i in range(1, len(s)))", "passed": true, "score": {"loc": 2, "tokens": 52, "cc": 0, "nest": 1, "execution_time": 0.016547, "novelty": 0.40164373490638416}}, {"code": "def maxScore(s):\n    max_score = 0\n    for i in range(1, len(s)):\n        left_score = s[:i].count('0')\n        right_score = s[i:].count('1')\n        max_score = max(max_score, left_score + right_score)\n    return max_score", "passed": true, "score": {"loc": 7, "tokens": 62, "cc": 1, "nest": 2, "execution_time": 0.016707, "novelty": 0.6131651391559532}}, {"code": "def maxScore(s):\n    def count_ones(substring):\n        return substring.count('1')\n    \n    max_score = 0\n    for i in range(1, len(s)):\n        left = s[:i]\n        right = s[i:]\n        score = count_ones(left) + count_ones(right)\n        max_score = max(max_score, score)\n    \n    return max_score", "passed": false, "score": {"loc": 10, "tokens": 72, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.7259938404202191}}, {"code": "def maxScore(s):\n    result = -1\n    left_zeros = 0\n    ones_count = s.count('1')\n    \n    for i in range(len(s) - 1):\n        if s[i] == '0':\n            left_zeros += 1\n        else:\n            ones_count -= 1\n        result = max(result, left_zeros + ones_count)\n    \n    return result", "passed": false, "score": {"loc": 11, "tokens": 69, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7951009472416037}}, {"code": "def maxScore(s):\n    max_score = 0\n    ones_count = s.count('1')\n    zeros_count = 0\n    for i in range(len(s) - 1):\n        if s[i] == '0':\n            zeros_count += 1\n        else:\n            ones_count -= 1\n        max_score = max(max_score, zeros_count + ones_count)\n    return max_score", "passed": false, "score": {"loc": 11, "tokens": 68, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6618139394485925}}], "num_pass": 7, "num_uniq": 4, "num_fail": 3, "fail_uniq": 3}
{"id": 21133, "entry_point": "maximum69Number", "best_list": [{"code": "def maximum69Number(num):\n    return int(str(num).replace('6', '9', 1))", "passed": true, "score": {"loc": 2, "tokens": 27, "cc": 0, "nest": 1, "execution_time": 0.016647, "novelty": 0.22664280089609912}}, {"code": "def maximum69Number(num: int) -> int:\n    return int(str(num).replace('6', '9', 1))", "passed": true, "score": {"loc": 2, "tokens": 32, "cc": 0, "nest": 1, "execution_time": 0.016514, "novelty": 0.25610026903308203}}, {"code": "def maximum69Number(num):\n    digits = list(str(num))\n    if '6' in digits:\n        digits[digits.index('6')] = '9'\n    return int(''.join(digits))", "passed": true, "score": {"loc": 5, "tokens": 48, "cc": 1, "nest": 2, "execution_time": 0.016675, "novelty": 0.6921269477992874}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 21233, "entry_point": "largestPalindrome", "best_list": [{"code": "def largestPalindrome(n):\n    if n == 1: return 9\n    max_num = 10 ** n - 1\n    min_num = 10 ** (n - 1)\n    for i in range(max_num, min_num - 1, -1):\n        for j in range(i, min_num - 1, -1):\n            prod = i * j\n            if str(prod) == str(prod)[::-1]:\n                return prod % 1337", "passed": true, "score": {"loc": 9, "tokens": 89, "cc": 4, "nest": 4, "execution_time": 0.016571, "novelty": 0.26495422238159294}}, {"code": "def largestPalindrome(n):\n    if n == 1:\n        return 9\n    limit = 10**n - 1\n    for x in range(limit, limit//10, -1):\n        p = x\n        for y in range(x, limit//x + 1):\n            p = x * y\n            if str(p) == str(p)[::-1]:\n                return p % 1337", "passed": true, "score": {"loc": 10, "tokens": 83, "cc": 4, "nest": 4, "execution_time": 0.016752, "novelty": 0.3935893005450355}}, {"code": "def largestPalindrome(n):\n    if n == 1:\n        return 9\n    upper = 10**n - 1\n    lower = 10**(n-1)\n    for x in range(upper, lower, -1):\n        for y in range(x, lower, -1):\n            product = x * y\n            if str(product) == str(product)[::-1]:\n                return product % 1337", "passed": true, "score": {"loc": 10, "tokens": 85, "cc": 4, "nest": 4, "execution_time": 0.016534, "novelty": 0.26062868294249275}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 21304, "entry_point": "judgePoint24", "best_list": [{"code": "from itertools import permutations, combinations\n\ndef judgePoint24(nums):\n    def dfs(nums):\n        if len(nums) == 1:\n            return abs(nums[0] - 24) < 1e-6\n        \n        for a, b, *rest in permutations(nums):\n            for x in {a + b, a - b, a * b, b and a / b}:\n                if dfs([x] + rest):\n                    return True\n        return False\n    \n    return dfs(nums)", "passed": true, "score": {"loc": 11, "tokens": 96, "cc": 5, "nest": 5, "execution_time": 0.016907, "novelty": 0.6901591982131792}}, {"code": "from itertools import permutations\n\ndef judgePoint24(nums):\n    if len(nums) == 1:\n        return abs(nums[0] - 24) < 1e-6\n    \n    for i in range(len(nums)):\n        for j in range(len(nums)):\n            if i != j:\n                remaining = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                for a, b in ((nums[i], nums[j]), (nums[j], nums[i])):\n                    for op in (lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else None):\n                        if op is not None:\n                            if judgePoint24(remaining + [op(a, b)]):\n                                return True\n    return False", "passed": true, "score": {"loc": 14, "tokens": 193, "cc": 9, "nest": 8, "execution_time": 0.017516, "novelty": 0.5902566462154316}}, {"code": "from itertools import permutations\nfrom functools import reduce\n\ndef judgePoint24(nums):\n    def can_form_24(nums):\n        if len(nums) == 1:\n            return abs(nums[0] - 24) < 1e-6\n        \n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if i != j:\n                    remaining = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                    for op in (lambda a, b: a + b, lambda a, b: a - b, lambda a, b: a * b, lambda a, b: b - a if b != 0 else 0):\n                        new_nums = remaining + [op(nums[i], nums[j])]\n                        if can_form_24(new_nums):\n                            return True\n        return False\n    \n    return any(can_form_24(nums) for nums in permutations([4, 1, 8, 7]))", "passed": true, "score": {"loc": 16, "tokens": 198, "cc": 7, "nest": 7, "execution_time": 0.017122, "novelty": 0.6289021816661238}}, {"code": "def judgePoint24(nums):\n    def dfs(nums):\n        if len(nums) == 1:\n            return abs(nums[0] - 24) < 1e-6\n        \n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if i != j:\n                    remaining = nums[:i] + nums[i+1:j] + nums[j+1:]\n                    for op in (lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else float('inf')):\n                        if dfs(remaining + [op(nums[i], nums[j])]):\n                            return True\n        return False\n    \n    return dfs(nums)", "passed": false, "score": {"loc": 13, "tokens": 170, "cc": 6, "nest": 7, "execution_time": 10.0, "novelty": 0.6175236722680415}}, {"code": "import itertools\n\ndef judgePoint24(nums):\n    def dfs(nums):\n        if len(nums) == 1:\n            return abs(nums[0] - 24) < 1e-6\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                a, b = nums[i], nums[j]\n                rest = nums[:i] + nums[i + 1:j] + nums[j + 1:]\n                if dfs([a + b] + rest) or dfs([a - b] + rest) or dfs([b - a] + rest) or \\\n                   dfs([a * b] + rest) or (b != 0 and dfs([a / b] + rest)) or (a != 0 and dfs([b / a] + rest)):\n                    return True\n        return False\n    \n    return dfs(nums)\n\ndef _equivalent(_lhs, _rhs):\n    return judgePoint24(_lhs) == _rhs", "passed": false, "score": {"loc": 16, "tokens": 207, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.6631761247559669}}, {"code": "from itertools import permutations, combinations_with_replacement\nfrom operator import add, sub, mul, truediv\n\nEPSILON = 1e-6\n\ndef judgePoint24(nums):\n    operations = [add, sub, mul, truediv]\n    \n    def solve(nums):\n        if len(nums) == 1:\n            return abs(nums[0] - 24) < EPSILON\n        \n        for a, b, *rest in permutations(nums):\n            for op in operations:\n                if op is not truediv or b != 0:\n                    if solve([op(a, b)] + rest):\n                        return True\n        return False\n    \n    return solve(nums)\n\ndef _equivalent(lhs, rhs):\n    return judgePoint24(lhs) == rhs", "passed": false, "score": {"loc": 17, "tokens": 134, "cc": 6, "nest": 6, "execution_time": 10.0, "novelty": 0.8554310540776465}}, {"code": "from itertools import permutations, combinations\nimport math\n\ndef _equivalent(_lhs, _rhs):\n    return abs(_lhs - _rhs) < 1e-6\n\ndef judgePoint24(nums):\n    if len(nums) == 1:\n        return _equivalent(nums[0], 24)\n    \n    for (a, b), rest in combinations(permutations(nums), 2):\n        for (c,) in permutations(rest):\n            for op1 in '+-*/':\n                for op2 in '+-*/':\n                    if op1 != '*' or a != 0:\n                        lhs = eval(f\"{a}{op1}{b}\")\n                        if judgePoint24([lhs] + list(rest)):\n                            return True\n                    if op2 != '*' or c != 0:\n                        rhs = eval(f\"{a}{op2}{c}\")\n                        if judgePoint24([b, rhs] + list(rest[1:])):\n                            return True\n                    if op1 != '*' or b != 0:\n                        lhs = eval(f\"{b}{op1}{a}\")\n                        if judgePoint24([lhs] + list(rest)):\n                            return True\n                    if op2 != '*' or c != 0:\n                        rhs = eval(f\"{b}{op2}{c}\")\n                        if judgePoint24([a, rhs] + list(rest[1:])):\n                            return True\n    return False", "passed": false, "score": {"loc": 28, "tokens": 296, "cc": 17, "nest": 7, "execution_time": 10.0, "novelty": 0.8525217301475361}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 21392, "entry_point": "countTriplets", "best_list": [{"code": "def countTriplets(A):\n    count = 0\n    for i in range(len(A)):\n        for j in range(len(A)):\n            for k in range(len(A)):\n                if A[i] & A[j] & A[k] == 0:\n                    count += 1\n    return count", "passed": true, "score": {"loc": 8, "tokens": 67, "cc": 4, "nest": 5, "execution_time": 0.016655, "novelty": 0.29163729367095703}}, {"code": "def countTriplets(A):\n    count = 0\n    n = len(A)\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if A[i] & A[j] & A[k] == 0:\n                    count += 1\n    return count", "passed": true, "score": {"loc": 9, "tokens": 64, "cc": 4, "nest": 5, "execution_time": 0.016588, "novelty": 0.1774631548318888}}, {"code": "from collections import defaultdict\n\ndef countTriplets(A):\n    bit_count = defaultdict(int)\n    count = 0\n    for i in range(len(A)):\n        count += sum(bit_count[a & A[i]] for a in A)\n        for j in range(i):\n            bit_count[A[i] & A[j]] += 1\n    return count", "passed": false, "score": {"loc": 9, "tokens": 74, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5472452601897597}}, {"code": "def countTriplets(A):\n    from collections import defaultdict\n    \n    count = defaultdict(int)\n    triplets = 0\n    \n    for i in range(len(A)):\n        for j in range(len(A)):\n            x = A[i] & A[j]\n            if x == 0:\n                triplets += 1\n            else:\n                triplets += count[x]\n            count[x] += 1\n    \n    return triplets", "passed": false, "score": {"loc": 13, "tokens": 80, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5089059940795451}}, {"code": "def countTriplets(A):\n    count = 0\n    for i in range(len(A)):\n        for j in range(i, len(A)):\n            for k in range(j, len(A)):\n                if A[i] & A[j] & A[k] == 0:\n                    count += 1\n    return count", "passed": false, "score": {"loc": 8, "tokens": 71, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.29494738068624793}}, {"code": "def countTriplets(A):\n    from collections import Counter\n    count = 0\n    n = len(A)\n    for i in range(n):\n        for j in range(i, n):\n            for k in range(j, n):\n                if A[i] & A[j] & A[k] == 0:\n                    count += 1\n    return count", "passed": false, "score": {"loc": 10, "tokens": 72, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.21977094014998877}}, {"code": "def countTriplets(A):\n    count = 0\n    n = len(A)\n    for i in range(n):\n        for j in range(i, n):\n            for k in range(j, n):\n                if A[i] & A[j] & A[k] == 0:\n                    count += 1\n    return count", "passed": false, "score": {"loc": 9, "tokens": 68, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.18506359872060607}}], "num_pass": 5, "num_uniq": 2, "num_fail": 5, "fail_uniq": 5}
{"id": 21483, "entry_point": "decodeAtIndex", "best_list": [{"code": "def decodeAtIndex(S, K):\n    size = 0\n    for char in S:\n        if char.isdigit():\n            size *= int(char)\n        else:\n            size += 1\n    \n    for char in reversed(S):\n        K %= size\n        if K == 0 and char.isalpha():\n            return char\n        if char.isdigit():\n            size //= int(char)\n        else:\n            size -= 1", "passed": true, "score": {"loc": 15, "tokens": 83, "cc": 6, "nest": 3, "execution_time": 0.016562, "novelty": 0.30807646465409266}}, {"code": "def decodeAtIndex(S, K):\n    size = 0\n    for c in S:\n        if c.isdigit():\n            size *= int(c)\n        else:\n            size += 1\n    \n    for c in reversed(S):\n        K %= size\n        if K == 0 and c.isalpha():\n            return c\n        if c.isdigit():\n            size //= int(c)\n        else:\n            size -= 1", "passed": true, "score": {"loc": 15, "tokens": 83, "cc": 6, "nest": 3, "execution_time": 0.016659, "novelty": 0.3035520377273101}}, {"code": "def decodeAtIndex(S: str, K: int) -> str:\n    size = 0\n    for char in S:\n        if char.isdigit():\n            size *= int(char)\n        else:\n            size += 1\n    \n    for char in reversed(S):\n        K %= size\n        if K == 0 and char.isalpha():\n            return char\n        if char.isdigit():\n            size //= int(char)\n        else:\n            size -= 1", "passed": true, "score": {"loc": 15, "tokens": 90, "cc": 6, "nest": 3, "execution_time": 0.016778, "novelty": 0.31905217815841647}}, {"code": "def decodeAtIndex(S, K):\n    def decode(s, k, size):\n        if k <= size:\n            return s[k-1]\n        for i, c in enumerate(s):\n            if c.isdigit():\n                size //= int(c)\n                if k <= size:\n                    return decode(s[:i], k, size)\n                k %= size\n                if k == 0:\n                    k = size\n            else:\n                size += 1\n                if k == size:\n                    return c\n\n    size = 0\n    for c in S:\n        if c.isdigit():\n            size *= int(c)\n        else:\n            size += 1\n\n    return decode(S, K, size)", "passed": false, "score": {"loc": 23, "tokens": 139, "cc": 8, "nest": 5, "execution_time": 10.0, "novelty": 0.7414660049536863}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 2193, "entry_point": "orderlyQueue", "best_list": [{"code": "def orderlyQueue(S, K):\n    if K == 1:\n        return min(S[i:] + S[:i] for i in range(len(S)))\n    return ''.join(sorted(S))", "passed": true, "score": {"loc": 4, "tokens": 50, "cc": 1, "nest": 2, "execution_time": 0.016672, "novelty": 0.16474275267471739}}, {"code": "def orderlyQueue(S: str, K: int) -> str:\n    if K > 1:\n        return ''.join(sorted(S))\n    return min(S[i:] + S[:i] for i in range(len(S)))", "passed": true, "score": {"loc": 4, "tokens": 56, "cc": 1, "nest": 2, "execution_time": 0.016782, "novelty": 0.6572506393650496}}, {"code": "def orderlyQueue(S, K):\n    if K == 1:\n        return min(S[i:] + S[:i] for i in range(len(S)))\n    else:\n        return ''.join(sorted(S))", "passed": true, "score": {"loc": 5, "tokens": 52, "cc": 1, "nest": 2, "execution_time": 0.016621, "novelty": 0.16532638529897703}}, {"code": "def orderlyQueue(S, K):\n    if K == 1:\n        return ''.join(sorted(S))\n    return ''.join(sorted(S))", "passed": false, "score": {"loc": 4, "tokens": 36, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.48396844174401943}}], "num_pass": 9, "num_uniq": 4, "num_fail": 1, "fail_uniq": 1}
{"id": 21551, "entry_point": "maxDistToClosest", "best_list": [{"code": "def maxDistToClosest(seats):\n    max_distance = 0\n    last_person = -1\n    for i, seat in enumerate(seats):\n        if seat == 1:\n            if last_person == -1:\n                max_distance = i\n            else:\n                max_distance = max(max_distance, (i - last_person) // 2)\n            last_person = i\n    max_distance = max(max_distance, len(seats) - 1 - last_person)\n    return max_distance", "passed": true, "score": {"loc": 12, "tokens": 76, "cc": 3, "nest": 4, "execution_time": 0.01663, "novelty": 0.5481194051462892}}, {"code": "def maxDistToClosest(seats):\n    n = len(seats)\n    max_dist = 0\n    left = -1\n    for right in range(n):\n        if seats[right] == 1:\n            if left == -1:\n                max_dist = right\n            else:\n                max_dist = max(max_dist, (right - left) // 2)\n            left = right\n    max_dist = max(max_dist, n - 1 - left)\n    return max_dist", "passed": true, "score": {"loc": 13, "tokens": 80, "cc": 3, "nest": 4, "execution_time": 0.016577, "novelty": 0.5935936330417348}}, {"code": "def maxDistToClosest(seats):\n    n = len(seats)\n    max_dist = 0\n    last_person = -1\n    for i in range(n):\n        if seats[i] == 1:\n            if last_person == -1:\n                max_dist = i\n            else:\n                max_dist = max(max_dist, (i - last_person) // 2)\n            last_person = i\n    max_dist = max(max_dist, n - 1 - last_person)\n    return max_dist", "passed": true, "score": {"loc": 13, "tokens": 80, "cc": 3, "nest": 4, "execution_time": 0.016609, "novelty": 0.5388671528489346}}, {"code": "def maxDistToClosest(seats):\n    n = len(seats)\n    left = [-1] * n\n    right = [n] * n\n    \n    closest = float('inf')\n    for i in range(n):\n        if seats[i] == 1:\n            left[i] = closest\n            closest = i\n    closest = float('inf')\n    for i in range(n - 1, -1, -1):\n        if seats[i] == 1:\n            right[i] = closest\n            closest = i\n    \n    max_distance = 0\n    for i in range(n):\n        if seats[i] == 0:\n            distance = min(left[i], right[i])\n            max_distance = max(max_distance, distance)\n    \n    return max(max_distance, left[0], right[-1])", "passed": false, "score": {"loc": 20, "tokens": 161, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.731496068944725}}, {"code": "def maxDistToClosest(seats):\n    n = len(seats)\n    left, right = [0] * n, [0] * n\n    left[0] = float('-inf')\n    right[n-1] = float('inf')\n    \n    for i in range(1, n):\n        left[i] = i if seats[i] == 1 else left[i-1]\n    \n    for i in range(n-2, -1, -1):\n        right[i] = i if seats[i] == 1 else right[i+1]\n    \n    return max(min(i - left[i], right[i] - i) for i in range(n) if seats[i] == 0)", "passed": false, "score": {"loc": 10, "tokens": 155, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.7594318358713176}}, {"code": "def maxDistToClosest(seats):\n    n = len(seats)\n    left = [-1] * n\n    right = [n] * n\n    \n    for i in range(n):\n        if seats[i] == 1:\n            left[i] = i\n    \n    for i in range(n-1, -1, -1):\n        if seats[i] == 1:\n            right[i] = i\n    \n    max_dist = 0\n    for i in range(n):\n        if seats[i] == 0:\n            left_dist = i - left[i] if left[i] != -1 else float('inf')\n            right_dist = right[i] - i if right[i] != n else float('inf')\n            max_dist = max(max_dist, min(left_dist, right_dist))\n    \n    return max_dist", "passed": false, "score": {"loc": 17, "tokens": 163, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.6186408096083389}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 21618, "entry_point": "findKthLargest", "best_list": [{"code": "def findKthLargest(nums, k):\n    return sorted(nums)[-k]", "passed": true, "score": {"loc": 2, "tokens": 17, "cc": 0, "nest": 1, "execution_time": 0.016629, "novelty": 0.4849484567984107}}, {"code": "def findKthLargest(nums, k):\n    nums.sort()\n    return nums[-k]", "passed": true, "score": {"loc": 3, "tokens": 19, "cc": 0, "nest": 1, "execution_time": 0.016625, "novelty": 0.5135028577972389}}, {"code": "import heapq\n\ndef findKthLargest(nums, k):\n    return heapq.nlargest(k, nums)[-1]", "passed": true, "score": {"loc": 3, "tokens": 23, "cc": 0, "nest": 1, "execution_time": 0.01667, "novelty": 0.5140566838319093}}, {"code": "def findKthLargest(nums, k):\n    def partition(left, right, pivot_index):\n        pivot_value = nums[pivot_index]\n        nums[pivot_index], nums[right] = nums[right], nums[pivot_index]\n        store_index = left\n        for i in range(left, right):\n            if nums[i] > pivot_value:\n                nums[store_index], nums[i] = nums[i], nums[store_index]\n                store_index += 1\n        nums[store_index], nums[right] = nums[right], nums[store_index]\n        return store_index\n\n    def quickselect(left, right, k_smallest):\n        if left == right:\n            return nums[left]\n        pivot_index = left + (right - left) // 2\n        pivot_index = partition(left, right, pivot_index)\n        if k_smallest == pivot_index:\n            return nums[k_smallest]\n        elif k_smallest < pivot_index:\n            return quickselect(left, pivot_index - 1, k_smallest)\n        else:\n            return quickselect(pivot_index + 1, right, k_smallest)\n\n    return quickselect(0, len(nums) - 1, len(nums) - k)", "passed": false, "score": {"loc": 23, "tokens": 210, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.8626592000851679}}], "num_pass": 9, "num_uniq": 6, "num_fail": 1, "fail_uniq": 1}
{"id": 21666, "entry_point": "countArrangement", "best_list": [{"code": "def countArrangement(N):\n    def backtrack(i, nums):\n        if i > N:\n            return 1\n        return sum(backtrack(i + 1, nums[:j] + nums[j + 1:]) for j, num in enumerate(nums) if num % i == 0 or i % num == 0)\n    \n    return backtrack(1, list(range(1, N + 1)))", "passed": true, "score": {"loc": 6, "tokens": 85, "cc": 2, "nest": 3, "execution_time": 0.016692, "novelty": 0.5053313973208464}}, {"code": "def countArrangement(N):\n    def dfs(pos, nums):\n        if pos == 1:\n            return 1\n        return sum(dfs(pos - 1, nums[:i] + nums[i + 1:]) for i, num in enumerate(nums) if pos % num == 0 or num % pos == 0)\n    \n    return dfs(N, list(range(1, N + 1)))", "passed": true, "score": {"loc": 6, "tokens": 86, "cc": 2, "nest": 3, "execution_time": 0.016738, "novelty": 0.5936203442270134}}, {"code": "def countArrangement(N):\n    def dfs(i, nums):\n        if i == 1:\n            return 1\n        return sum(dfs(i - 1, nums[:j] + nums[j + 1:]) for j, num in enumerate(nums) if num % i == 0 or i % num == 0)\n    return dfs(N, list(range(1, N + 1)))", "passed": true, "score": {"loc": 6, "tokens": 86, "cc": 2, "nest": 3, "execution_time": 0.016758, "novelty": 0.573604643488592}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 21750, "entry_point": "greet", "best_list": [{"code": "def greet(name):\n    if name == \"Johnny\":\n        return ['Hello, my love!']\n    else:\n        return ['Hello, ' + name + '!']", "passed": true, "score": {"loc": 5, "tokens": 39, "cc": 1, "nest": 2, "execution_time": 0.016441, "novelty": 0.351835670208577}}, {"code": "def greet(name):\n    return ['Hello, ' + name + '!']", "passed": false, "score": {"loc": 2, "tokens": 19, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.3761295741325731}}, {"code": "def greet(name):\n    if name == \"Johnny\":\n        return \"Hello, Johnny! You are special to me.\"\n    else:\n        return f\"Hello, {name}!\"", "passed": false, "score": {"loc": 5, "tokens": 39, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.2544811484994466}}, {"code": "def greet(name):\n    return \"Hello, Johnny!\" if name == 'Johnny' else f\"Hello, {name}!\"", "passed": false, "score": {"loc": 2, "tokens": 30, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.26869693974131514}}, {"code": "def greet(name):\n    if name == \"Johnny\":\n        return \"Hello, Johnny! How are you today?\"\n    else:\n        return f\"Hello, {name}! Welcome back.\"", "passed": false, "score": {"loc": 5, "tokens": 41, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.26489395545889316}}, {"code": "def greet(name):\n    if name == 'Johnny':\n        return 'Hello, my love!'\n    else:\n        return f'Hello, {name}!'", "passed": false, "score": {"loc": 5, "tokens": 34, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.18180806530357874}}], "num_pass": 3, "num_uniq": 1, "num_fail": 7, "fail_uniq": 6}
{"id": 21777, "entry_point": "kSimilarity", "best_list": [{"code": "def kSimilarity(A: str, B: str) -> int:\n    def dfs(A, B, i, swaps):\n        if i == len(A):\n            return swaps\n        if A[i] == B[i]:\n            return dfs(A, B, i + 1, swaps)\n        j = i + 1\n        while j < len(A) and A[j] != B[i]:\n            j += 1\n        A = A[:i] + A[j] + A[i+1:j] + A[i] + A[j+1:]\n        return dfs(A, B, i + 1, swaps + 1)\n    \n    return dfs(A, B, 0, 0)", "passed": true, "score": {"loc": 12, "tokens": 151, "cc": 4, "nest": 3, "execution_time": 0.01675, "novelty": 0.6993906049627012}}, {"code": "def kSimilarity(A, B):\n    def dfs(i, A, B, swaps):\n        if i == len(A):\n            return swaps\n        if A[i] == B[i]:\n            return dfs(i + 1, A, B, swaps)\n        for j in range(i + 1, len(A)):\n            if A[j] == B[i] and A[j] != B[j]:\n                A = A[:i] + A[j] + A[i + 1:j] + A[i] + A[j + 1:]\n                result = dfs(i + 1, A, B, swaps + 1)\n                A = A[:i] + A[j] + A[i + 1:j] + A[i] + A[j + 1:]\n                return result\n\n    return dfs(0, A, B, 0)", "passed": true, "score": {"loc": 13, "tokens": 191, "cc": 5, "nest": 4, "execution_time": 0.016644, "novelty": 0.715321233900005}}, {"code": "def kSimilarity(A, B):\n    def dfs(i):\n        if i == len(A):\n            return 0\n        if A[i] == B[i]:\n            return dfs(i + 1)\n        min_swaps = float('inf')\n        for j in range(i + 1, len(A)):\n            if A[j] == B[i] and A[j] != B[j]:\n                A[i], A[j] = A[j], A[i]\n                min_swaps = min(min_swaps, dfs(i + 1))\n                A[i], A[j] = A[j], A[i]\n        return min_swaps + 1\n    \n    A, B = list(A), list(B)\n    return dfs(0)", "passed": true, "score": {"loc": 15, "tokens": 163, "cc": 5, "nest": 4, "execution_time": 0.016624, "novelty": 0.7059310714605852}}, {"code": "def kSimilarity(A, B):\n    def dfs(i):\n        if i == n:\n            return 0\n        if A[i] == B[i]:\n            return dfs(i + 1)\n        j = i + 1\n        while j < n and A[j] != B[i]:\n            j += 1\n        A[i], A[j] = A[j], A[i]\n        result = 1 + dfs(i + 1)\n        A[i], A[j] = A[j], A[i]\n        return result\n\n    n = len(A)\n    return dfs(0)", "passed": false, "score": {"loc": 15, "tokens": 127, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.6194762514119919}}, {"code": "from functools import lru_cache\n\ndef kSimilarity(A: str, B: str) -> int:\n    @lru_cache(None)\n    def dfs(a, b):\n        if a == b:\n            return 0\n        if a[0] == b[0]:\n            return dfs(a[1:], b[1:])\n        return 1 + min(dfs(a[:i] + a[i+1] + a[i], b[1:]) for i in range(1, len(a)) if a[i] == b[0])\n    \n    return dfs(A, B)", "passed": false, "score": {"loc": 10, "tokens": 129, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7594120974588044}}, {"code": "def kSimilarity(A, B):\n    def dfs(i):\n        if i == len(A):\n            return 0\n        if A[i] == B[i]:\n            return dfs(i + 1)\n        for j in range(i + 1, len(A)):\n            if A[j] == B[i] and A[j] != B[j]:\n                A[i], A[j] = A[j], A[i]\n                result = 1 + dfs(i + 1)\n                A[i], A[j] = A[j], A[i]\n                return result\n    return dfs(0)", "passed": false, "score": {"loc": 13, "tokens": 137, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.6411211861862923}}, {"code": "def kSimilarity(A, B):\n    queue = [(A, 0)]\n    visited = set([A])\n    while queue:\n        current, swaps = queue.pop(0)\n        if current == B:\n            return swaps\n        i = 0\n        while current[i] == B[i]:\n            i += 1\n        for j in range(i + 1, len(current)):\n            if current[j] == B[i] and current[j] != B[j] and current[j:] + current[i] not in visited:\n                visited.add(current[j:] + current[i])\n                queue.append((current[:i] + current[j] + current[i+1:j] + current[i], swaps + 1))", "passed": false, "score": {"loc": 14, "tokens": 167, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.7683978653165782}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 21845, "entry_point": "checkIfCanBreak", "best_list": [{"code": "def checkIfCanBreak(s1, s2):\n    s1, s2 = sorted(s1), sorted(s2)\n    return all(x >= y for x, y in zip(s1, s2)) or all(x <= y for x, y in zip(s1, s2))", "passed": true, "score": {"loc": 3, "tokens": 59, "cc": 1, "nest": 1, "execution_time": 0.016548, "novelty": 0.6172853474333586}}, {"code": "def checkIfCanBreak(s1: str, s2: str) -> bool:\n    s1, s2 = sorted(s1), sorted(s2)\n    return all(x >= y for x, y in zip(s1, s2)) or all(x <= y for x, y in zip(s1, s2))", "passed": true, "score": {"loc": 3, "tokens": 66, "cc": 1, "nest": 1, "execution_time": 0.01681, "novelty": 0.5869421828449377}}, {"code": "def checkIfCanBreak(s1, s2):\n    s1 = sorted(s1)\n    s2 = sorted(s2)\n    return all(x >= y for x, y in zip(s1, s2)) or all(x <= y for x, y in zip(s1, s2))", "passed": true, "score": {"loc": 4, "tokens": 58, "cc": 1, "nest": 1, "execution_time": 0.016512, "novelty": 0.4368266019443716}}, {"code": "def checkIfCanBreak(s1: str, s2: str) -> bool:\n    count1, count2 = [0] * 26, [0] * 26\n    for char in s1:\n        count1[ord(char) - ord('a')] += 1\n    for char in s2:\n        count2[ord(char) - ord('a')] += 1\n    \n    sum1, sum2 = 0, 0\n    greater1, greater2 = 0, 0\n    \n    for i in range(25, -1, -1):\n        sum1 += count1[i]\n        sum2 += count2[i]\n        greater1 += count1[i] > 0\n        greater2 += count2[i] > 0\n    \n    return (greater1 == 0 or greater2 == 0) and (sum1 >= sum2 or sum1 <= sum2)", "passed": false, "score": {"loc": 14, "tokens": 158, "cc": 6, "nest": 2, "execution_time": 10.0, "novelty": 0.8124122376128714}}, {"code": "def checkIfCanBreak(s1: str, s2: str) -> bool:\n    def can_break(count1, count2):\n        greater = 0\n        less = 0\n        for c in 'abcdefghijklmnopqrstuvwxyz':\n            if count1[c] > count2[c]:\n                greater += count1[c]\n            elif count1[c] < count2[c]:\n                less += count1[c]\n            if greater and less:\n                return False\n        return True\n\n    count1, count2 = [0] * 26, [0] * 26\n    for c in s1:\n        count1[ord(c) - ord('a')] += 1\n    for c in s2:\n        count2[ord(c) - ord('a')] += 1\n\n    return can_break(count1, count2) or can_break(count2, count1)", "passed": false, "score": {"loc": 18, "tokens": 154, "cc": 8, "nest": 5, "execution_time": 10.0, "novelty": 0.8318532831483011}}], "num_pass": 8, "num_uniq": 6, "num_fail": 2, "fail_uniq": 2}
{"id": 21849, "entry_point": "isHappy", "best_list": [{"code": "def isHappy(n):\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = sum(int(digit) ** 2 for digit in str(n))\n    return n == 1", "passed": true, "score": {"loc": 6, "tokens": 52, "cc": 2, "nest": 2, "execution_time": 0.0168, "novelty": 0.2529820269940978}}, {"code": "def isHappy(n):\n    def get_next(num):\n        return sum(int(char) ** 2 for char in str(num))\n    \n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = get_next(n)\n    return n == 1", "passed": true, "score": {"loc": 8, "tokens": 63, "cc": 2, "nest": 2, "execution_time": 0.016657, "novelty": 0.4982522942966514}}, {"code": "def isHappy(n):\n    def sum_of_squares(num):\n        return sum(int(digit) ** 2 for digit in str(num))\n    \n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = sum_of_squares(n)\n    return n == 1", "passed": true, "score": {"loc": 8, "tokens": 63, "cc": 2, "nest": 2, "execution_time": 0.016737, "novelty": 0.4989886117036213}}, {"code": "def isHappy(num):\n    return sum(int(digit) ** 2 for digit in str(num))\n\ndef isHappy(n):\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = isHappy(n)\n    return n == 1", "passed": false, "score": {"loc": 8, "tokens": 63, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.5470729724176933}}], "num_pass": 9, "num_uniq": 6, "num_fail": 1, "fail_uniq": 1}
{"id": 21964, "entry_point": "checkPossibility", "best_list": [{"code": "def checkPossibility(nums):\n    modified = False\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            if modified:\n                return False\n            if i > 1 and nums[i] < nums[i - 2]:\n                nums[i] = nums[i - 1]\n            modified = True\n    return True", "passed": true, "score": {"loc": 10, "tokens": 73, "cc": 5, "nest": 4, "execution_time": 0.016313, "novelty": 0.35953699406115647}}, {"code": "def checkPossibility(nums):\n    modified = False\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            if modified:\n                return False\n            modified = True\n            if i > 1 and nums[i - 2] > nums[i]:\n                nums[i] = nums[i - 1]\n    return True", "passed": true, "score": {"loc": 10, "tokens": 73, "cc": 5, "nest": 4, "execution_time": 0.016465, "novelty": 0.4159628609902509}}, {"code": "def checkPossibility(nums):\n    modified = False\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            if modified:\n                return False\n            if i >= 2 and nums[i] < nums[i - 2]:\n                nums[i] = nums[i - 1]\n            modified = True\n    return True", "passed": true, "score": {"loc": 10, "tokens": 74, "cc": 5, "nest": 4, "execution_time": 0.016351, "novelty": 0.4141002863129075}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 22136, "entry_point": "getLengthOfOptimalCompression", "best_list": [{"code": "def getLengthOfOptimalCompression(s, k):\n    n = len(s)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            cnt, dels = 0, 0\n            for l in range(i, 0, -1):\n                if s[l - 1] == s[i - 1]:\n                    cnt += 1\n                else:\n                    dels += 1\n                if j - dels >= 0:\n                    dp[i][j] = min(dp[i][j], dp[l - 1][j - dels] + 1 + (3 if cnt >= 100 else 2 if cnt >= 10 else 1 if cnt >= 2 else 0))\n    \n    return dp[n][k]", "passed": true, "score": {"loc": 15, "tokens": 191, "cc": 5, "nest": 5, "execution_time": 0.016719, "novelty": 0.2166312410880057}}, {"code": "def getLengthOfOptimalCompression(s: str, k: int) -> int:\n    n = len(s)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            cnt, dels = 0, 0\n            for l in range(i, 0, -1):\n                if s[l - 1] == s[i - 1]:\n                    cnt += 1\n                else:\n                    dels += 1\n                if j - dels >= 0:\n                    dp[i][j] = min(dp[i][j], dp[l - 1][j - dels] + 1 + (3 if cnt >= 100 else 2 if cnt >= 10 else 1 if cnt >= 2 else 0))\n    \n    return dp[n][k]", "passed": true, "score": {"loc": 15, "tokens": 198, "cc": 5, "nest": 5, "execution_time": 0.016762, "novelty": 0.20649329688092466}}, {"code": "def getLengthOfOptimalCompression(s, k):\n    n = len(s)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            count = 0\n            del_count = 0\n            for l in range(i, 0, -1):\n                if s[l - 1] == s[i - 1]:\n                    count += 1\n                else:\n                    del_count += 1\n                if j - del_count >= 0:\n                    dp[i][j] = min(dp[i][j], dp[l - 1][j - del_count] + 1 + (3 if count >= 100 else 2 if count >= 10 else 1 if count >= 2 else 0))\n\n    return dp[n][k]", "passed": true, "score": {"loc": 16, "tokens": 190, "cc": 5, "nest": 5, "execution_time": 0.016797, "novelty": 0.22234177912784625}}, {"code": "def getLengthOfOptimalCompression(s: str, k: int) -> int:\n    @cache\n    def dfs(i, k):\n        if k < 0:\n            return float('inf')\n        if i >= len(s):\n            return 0\n        res = float('inf')\n        del_cnt = 0\n        cnt = 0\n        for j in range(i, len(s)):\n            if s[j] == s[i]:\n                cnt += 1\n                res = min(res, dfs(j + 1, k - del_cnt) + 1 + (3 if cnt >= 100 else 2 if cnt >= 10 else 1 if cnt >= 2 else 0))\n            else:\n                del_cnt += 1\n                res = min(res, dfs(j + 1, k - del_cnt))\n        return res\n\n    return dfs(0, k)", "passed": false, "score": {"loc": 19, "tokens": 167, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.7290301282011171}}, {"code": "def getLengthOfOptimalCompression(s: str, k: int) -> int:\n    @lru_cache(None)\n    def dp(i: int, last: str, cnt: int, k: int) -> int:\n        if k < 0:\n            return float('inf')\n        if i == len(s):\n            return 0\n        if s[i] == last:\n            return dp(i + 1, last, cnt + 1, k)\n        return min(dp(i + 1, last, 1, k - 1), 1 + (1 if cnt >= 10 else 0) + (1 if cnt >= 100 else 0) + dp(i + 1, s[i], 1, k))\n    \n    return dp(0, '', 0, k)", "passed": false, "score": {"loc": 11, "tokens": 160, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7812213212791157}}], "num_pass": 8, "num_uniq": 7, "num_fail": 2, "fail_uniq": 2}
{"id": 22232, "entry_point": "minStartValue", "best_list": [{"code": "def minStartValue(nums):\n    min_sum = 0\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n    return 1 - min_sum", "passed": true, "score": {"loc": 7, "tokens": 33, "cc": 1, "nest": 2, "execution_time": 0.016771, "novelty": 0.48754324672461136}}, {"code": "def minStartValue(nums):\n    min_sum = 0\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n    return 1 - min_sum if min_sum < 1 else 1", "passed": true, "score": {"loc": 7, "tokens": 39, "cc": 1, "nest": 2, "execution_time": 0.016517, "novelty": 0.49786045934252554}}, {"code": "def minStartValue(nums):\n    min_sum = 0\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n    return 1 - min_sum if min_sum < 0 else 1", "passed": true, "score": {"loc": 7, "tokens": 39, "cc": 1, "nest": 2, "execution_time": 0.016766, "novelty": 0.4995186112441935}}, {"code": "def minStartValue(nums):\n    return max(1, 1 - sum(nums))", "passed": false, "score": {"loc": 2, "tokens": 18, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.40363825188651425}}, {"code": "def minStartValue(nums):\n    return 1 - min(0, sum(x for x in itertools.accumulate(nums)))", "passed": false, "score": {"loc": 2, "tokens": 27, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5962979110930275}}, {"code": "def minStartValue(nums):\n    return max(1, 1 - min(accumulate(nums)))", "passed": false, "score": {"loc": 2, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.4230871873299966}}], "num_pass": 6, "num_uniq": 4, "num_fail": 4, "fail_uniq": 3}
{"id": 22243, "entry_point": "countSubstrings", "best_list": [{"code": "def countSubstrings(s):\n    return sum(s[i:j] == s[i:j][::-1] for i in range(len(s)) for j in range(i+1, len(s)+1))", "passed": true, "score": {"loc": 2, "tokens": 56, "cc": 0, "nest": 1, "execution_time": 0.016591, "novelty": 0.6576695378030928}}, {"code": "def countSubstrings(s):\n    return sum(1 for i in range(len(s)) for j in range(i, len(s)) if s[i:j+1] == s[i:j+1][::-1])", "passed": true, "score": {"loc": 2, "tokens": 58, "cc": 0, "nest": 1, "execution_time": 0.016537, "novelty": 0.5984177496669367}}, {"code": "def countSubstrings(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if s[i:j] == s[i:j][::-1]:\n                count += 1\n    return count", "passed": true, "score": {"loc": 7, "tokens": 65, "cc": 3, "nest": 4, "execution_time": 0.016536, "novelty": 0.5456296371683117}}, {"code": "def countSubstrings(s: str) -> int:\n    def expand_around_center(left: int, right: int) -> set:\n        result = set()\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            result.add(s[left:right+1])\n            left -= 1\n            right += 1\n        return result\n\n    result = set()\n    for i in range(len(s)):\n        result.update(expand_around_center(i, i))\n        result.update(expand_around_center(i, i + 1))\n    return len(result)", "passed": false, "score": {"loc": 13, "tokens": 123, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7913894943546845}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 22282, "entry_point": "numSplits", "best_list": [{"code": "def numSplits(s):\n    left_counts, right_counts = {}, {}\n    for char in s:\n        right_counts[char] = right_counts.get(char, 0) + 1\n    good_splits = 0\n    left_set = set()\n    for char in s:\n        left_counts[char] = left_counts.get(char, 0) + 1\n        left_set.add(char)\n        right_counts[char] -= 1\n        if right_counts[char] == 0:\n            del right_counts[char]\n        if len(left_set) == len(right_counts):\n            good_splits += 1\n    return good_splits", "passed": true, "score": {"loc": 15, "tokens": 108, "cc": 4, "nest": 3, "execution_time": 0.016839, "novelty": 0.6019801211924465}}, {"code": "def numSplits(s: str) -> int:\n    left_counts, right_counts = {}, {}\n    for char in s:\n        right_counts[char] = right_counts.get(char, 0) + 1\n    left_distinct, right_distinct = 0, len(right_counts)\n    good_splits = 0\n    for char in s:\n        left_counts[char] = left_counts.get(char, 0) + 1\n        if left_counts[char] == 1:\n            left_distinct += 1\n        right_counts[char] -= 1\n        if right_counts[char] == 0:\n            right_distinct -= 1\n        if left_distinct == right_distinct:\n            good_splits += 1\n    return good_splits", "passed": true, "score": {"loc": 16, "tokens": 118, "cc": 5, "nest": 3, "execution_time": 0.016516, "novelty": 0.5723872352300747}}, {"code": "def numSplits(s: str) -> int:\n    left_counts = {}\n    right_counts = {}\n    for char in s:\n        right_counts[char] = right_counts.get(char, 0) + 1\n    result = 0\n    left_distinct = 0\n    right_distinct = len(right_counts)\n    for char in s:\n        left_counts[char] = left_counts.get(char, 0) + 1\n        if left_counts[char] == 1:\n            left_distinct += 1\n        right_counts[char] -= 1\n        if right_counts[char] == 0:\n            right_distinct -= 1\n        if left_distinct == right_distinct:\n            result += 1\n    return result", "passed": true, "score": {"loc": 18, "tokens": 116, "cc": 5, "nest": 3, "execution_time": 0.016648, "novelty": 0.5802268419849576}}, {"code": "def numSplits(s: str) -> int:\n    left_counts = [0] * 26\n    right_counts = [0] * 26\n    left_distinct = 0\n    right_distinct = 0\n    good_splits = 0\n\n    for char in s:\n        if right_counts[ord(char) - ord('a')] == 0:\n            right_distinct += 1\n        right_counts[ord(char) - ord('a')] += 1\n\n    for char in s:\n        left_counts[ord(char) - ord('a')] += 1\n        if left_counts[ord(char) - ord('a')] == 1:\n            left_distinct += 1\n        right_counts[ord(char) - ord('a')] -= 1\n        if right_counts[ord(char) - ord('a')] == 0:\n            right_distinct -= 1\n        if left_distinct == right_distinct:\n            good_splits += 1\n\n    return good_splits", "passed": false, "score": {"loc": 20, "tokens": 176, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.6361129707438222}}, {"code": "def numSplits(s: str) -> int:\n    left_count = [0] * 26\n    right_count = [0] * 26\n    left_set = set()\n    right_set = set()\n    result = 0\n    \n    for char in s:\n        right_count[ord(char) - ord('a')] += 1\n        right_set.add(char)\n    \n    for char in s:\n        left_count[ord(char) - ord('a')] += 1\n        right_count[ord(char) - ord('a')] -= 1\n        \n        if right_count[ord(char) - ord('a')] == 0:\n            right_set.remove(char)\n        \n        if len(left_set) == len(right_set):\n            result += 1\n    \n    return result", "passed": false, "score": {"loc": 17, "tokens": 148, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.6230400699153578}}, {"code": "def numSplits(s):\n    left_count = [0] * 26\n    right_count = [0] * 26\n    left_unique = 0\n    right_unique = 0\n    good_splits = 0\n    \n    for char in s:\n        right_count[ord(char) - ord('a')] += 1\n        if right_count[ord(char) - ord('a')] == 1:\n            right_unique += 1\n    \n    for char in s:\n        left_count[ord(char) - ord('a')] += 1\n        if left_count[ord(char) - ord('a')] == 1:\n            left_unique += 1\n        \n        right_count[ord(char) - ord('a')] -= 1\n        if right_count[ord(char) - ord('a')] == 0:\n            right_unique -= 1\n        \n        if left_unique == right_unique:\n            good_splits += 1\n    \n    return good_splits", "passed": false, "score": {"loc": 20, "tokens": 171, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.6598998627567602}}, {"code": "def numSplits(s):\n    left_counts, right_counts = set(), set()\n    left_count, right_count = 0, len(set(s))\n    good_splits = 0\n    \n    for char in s:\n        if char not in left_counts:\n            left_count += 1\n            left_counts.add(char)\n        if char in right_counts:\n            right_count -= 1\n        right_counts.add(char)\n        if left_count == right_count:\n            good_splits += 1\n            \n    return good_splits", "passed": false, "score": {"loc": 14, "tokens": 81, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.6623133712479554}}, {"code": "def numSplits(s: str) -> int:\n    left_count = [0] * 26\n    right_count = [0] * 26\n    left_distinct = 0\n    right_distinct = 0\n    result = 0\n\n    for char in s:\n        if right_count[ord(char) - ord('a')] == 0:\n            right_distinct += 1\n        right_count[ord(char) - ord('a')] += 1\n\n    for char in s:\n        left_count[ord(char) - ord('a')] += 1\n        if left_count[ord(char) - ord('a')] == 1:\n            left_distinct += 1\n        right_count[ord(char) - ord('a')] -= 1\n        if right_count[ord(char) - ord('a')] == 0:\n            right_distinct -= 1\n        if left_distinct == right_distinct:\n            result += 1\n\n    return result", "passed": false, "score": {"loc": 20, "tokens": 176, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.6199464469334814}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 22292, "entry_point": "strongPasswordChecker", "best_list": [{"code": "def strongPasswordChecker(s):\n    def has_lowercase(s):\n        return any(c.islower() for c in s)\n\n    def has_uppercase(s):\n        return any(c.isupper() for c in s)\n\n    def has_digit(s):\n        return any(c.isdigit() for c in s)\n\n    def has_three_repeating(s):\n        return any(s[i] == s[i+1] == s[i+2] for i in range(len(s) - 2))\n\n    if not (6 <= len(s) <= 20) or not has_lowercase(s) or not has_uppercase(s) or not has_digit(s) or has_three_repeating(s):\n        changes = 0\n        if len(s) < 6:\n            changes += 6 - len(s)\n        elif len(s) > 20:\n            changes += len(s) - 20\n        changes += sum(1 for c in set(s) if s.count(c) >= 3)\n        return max(changes, sum(1 for c in set(s) if s.count(c) >= 3))\n    return 0", "passed": true, "score": {"loc": 18, "tokens": 233, "cc": 4, "nest": 4, "execution_time": 0.016881, "novelty": 0.6128242083549943}}, {"code": "def strongPasswordChecker(s):\n    has_lower = has_upper = has_digit = False\n    length = len(s)\n    replace = delete = insert = 0\n    i = 0\n\n    while i < length:\n        if s[i].islower(): has_lower = True\n        if s[i].isupper(): has_upper = True\n        if s[i].isdigit(): has_digit = True\n\n        j = i\n        while j < length and s[j] == s[i]: j += 1\n        repeat = j - i\n        replace += repeat // 3\n        i = j\n\n    need = 3 - (has_lower + has_upper + has_digit)\n\n    if length < 6:\n        insert = max(0, 6 - length - need)\n        replace -= min(insert, replace)\n    elif length <= 20:\n        replace -= min(replace, need)\n    else:\n        delete = length - 20\n        replace -= delete // 3\n        replace -= min(delete % 3, need)\n\n    return max(insert, replace) + need", "passed": true, "score": {"loc": 25, "tokens": 197, "cc": 8, "nest": 3, "execution_time": 0.016817, "novelty": 0.8649951766858139}}, {"code": "def strongPasswordChecker(s):\n    def has_lowercase(s):\n        return any(char.islower() for char in s)\n\n    def has_uppercase(s):\n        return any(char.isupper() for char in s)\n\n    def has_digit(s):\n        return any(char.isdigit() for char in s)\n\n    def has_repeating(s):\n        return any(s[i] == s[i+1] == s[i+2] for i in range(len(s) - 2))\n\n    changes_needed = 0\n    lower, upper, digit = not has_lowercase(s), not has_uppercase(s), not has_digit(s)\n    repeating_groups = [0]\n    i = 0\n\n    while i < len(s):\n        j = i\n        while j < len(s) and s[j] == s[i]:\n            j += 1\n        group_length = j - i\n        changes_needed += group_length // 3\n        repeating_groups.append(group_length % 3)\n        i = j\n\n    min_removals = max(0, len(s) - 20)\n    changes_needed -= min_removals\n\n    for _ in range(min_removals):\n        repeating_groups.pop()\n        changes_needed -= 1\n        repeating_groups[-1] -= 1\n\n    while repeating_groups[-1] == 2:\n        repeating_groups[-1] -= 2\n        repeating_groups[-2] -= 1\n        changes_needed -= 1\n        if repeating_groups[-2] == 0:\n            repeating_groups.pop(-2)\n\n    return max(lower + upper + digit, changes_needed)", "passed": false, "score": {"loc": 34, "tokens": 296, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.6731388146417365}}, {"code": "def strongPasswordChecker(s: str) -> int:\n    if not 6 <= len(s) <= 20:\n        return max(6 - len(s), 20 - len(s))\n    \n    has_lower = has_upper = has_digit = False\n    for char in s:\n        if char.islower():\n            has_lower = True\n        elif char.isupper():\n            has_upper = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if not (has_lower and has_upper and has_digit):\n        return 3 - (has_lower + has_upper + has_digit)\n    \n    if len(s) <= 20:\n        repeat_count = [0]\n        for i in range(2, len(s)):\n            if s[i] == s[i - 1] == s[i - 2]:\n                repeat_count[-1] += 1\n            else:\n                if repeat_count[-1] >= 3:\n                    repeat_count.append(0)\n        \n        changes = 0\n        replacements = 0\n        for count in repeat_count:\n            if count >= 3:\n                changes += count // 3\n                replacements += count % 3\n        \n        for i in range(min(changes, len(s))):\n            s = s[:i * 3 + i] + 'x' + s[i * 3 + i + 1:]\n            replacements -= 1\n        \n        if replacements < 0:\n            return changes - replacements + 3 - (has_lower + has_upper + has_digit)\n        \n        return changes\n    \n    repeat_count = [0]\n    for i in range(3, len(s), 3):\n        if s[i] == s[i - 1] == s[i - 2]:\n            repeat_count[-1] += 1\n        else:\n            if repeat_count[-1] >= 3:\n                repeat_count.append(0)\n    \n    changes = 0\n    for count in repeat_count:\n        if count >= 3:\n            changes += count // 3\n            repeat_count.append(count % 3)\n    \n    while len(s) > 20:\n        i = 0\n        if repeat_count[i] % 3 == 0:\n            i = 1\n        elif repeat_count[i] % 3 == 1 and sum(count % 3 for count in repeat_count) > 2:\n            i = 2\n        repeat_count[i] -= 1", "passed": false, "score": {"loc": 52, "tokens": 432, "cc": 24, "nest": 5, "execution_time": 10.0, "novelty": 0.9021695322499532}}, {"code": "def strongPasswordChecker(s):\n    def has_lowercase(s):\n        return any(c.islower() for c in s)\n\n    def has_uppercase(s):\n        return any(c.isupper() for c in s)\n\n    def has_digit(s):\n        return any(c.isdigit() for c in s)\n\n    def has_three_repeating(s):\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] == s[i + 2]:\n                return True\n        return False\n\n    if not (6 <= len(s) <= 20):\n        return 20 - len(s) if len(s) < 6 else len(s) - 6\n\n    if not (has_lowercase(s) and has_uppercase(s) and has_digit(s)):\n        return 3 - sum(has_lowercase(s), has_uppercase(s), has_digit(s))\n\n    if not has_three_repeating(s):\n        return 0\n\n    changes = 0\n    while has_three_repeating(s):\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] == s[i + 2]:\n                s = s[:i] + s[i + 1:]\n                changes += 1\n                break\n\n    if len(s) < 6:\n        return max(6 - len(s), changes)\n    elif len(s) > 20:\n        return max(changes, len(s) - 20)\n    else:\n        return changes", "passed": false, "score": {"loc": 31, "tokens": 300, "cc": 11, "nest": 4, "execution_time": 10.0, "novelty": 0.6962821254161593}}, {"code": "def strongPasswordChecker(s):\n    def has_lowercase(s):\n        return any(c.islower() for c in s)\n\n    def has_uppercase(s):\n        return any(c.isupper() for c in s)\n\n    def has_digit(s):\n        return any(c.isdigit() for c in s)\n\n    def has_repeating_characters(s):\n        return any(s[i] == s[i+1] == s[i+2] for i in range(len(s) - 2))\n\n    if not (6 <= len(s) <= 20):\n        return float('inf')\n\n    if not has_lowercase(s) or not has_uppercase(s) or not has_digit(s):\n        return float('inf')\n\n    if not has_repeating_characters(s):\n        return 0\n\n    changes = 0\n    repeating_characters = [s[i] for i in range(len(s) - 2) if s[i] == s[i+1] == s[i+2]]\n\n    while repeating_characters:\n        if len(repeating_characters) >= 3:\n            changes += 1\n            repeating_characters = [c for c in repeating_characters if c != repeating_characters[0]]\n\n    return changes", "passed": false, "score": {"loc": 22, "tokens": 241, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.6228872055589305}}, {"code": "def strongPasswordChecker(s):\n    if not (6 <= len(s) <= 20):\n        return max(6 - len(s), 20 - len(s))\n\n    has_lower = any(c.islower() for c in s)\n    has_upper = any(c.isupper() for c in s)\n    has_digit = any(c.isdigit() for c in s)\n    if not (has_lower and has_upper and has_digit):\n        return 3 - sum(any(getattr(c, f\"is{i}\")() for c in s) for i in \"lowerupperdigit\")\n\n    changes = 0\n    i = 2\n    while i < len(s):\n        if s[i] == s[i-1] == s[i-2]:\n            length = 2\n            while i < len(s) and s[i] == s[i-1]:\n                length += 1\n                i += 1\n            changes += length // 3\n        else:\n            i += 1\n\n    missing_types = 0\n    has_lower = any(c.islower() for c in s)\n    has_upper = any(c.isupper() for c in s)\n    has_digit = any(c.isdigit() for c in s)\n    if not has_lower:\n        missing_types += 1\n    if not has_upper:\n        missing_types += 1\n    if not has_digit:\n        missing_types += 1\n\n    return max(changes, missing_types)", "passed": false, "score": {"loc": 30, "tokens": 280, "cc": 10, "nest": 4, "execution_time": 10.0, "novelty": 0.8812125880172488}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 8}
{"id": 22357, "entry_point": "maxScore", "best_list": [{"code": "def maxScore(cardPoints, k):\n    total = sum(cardPoints[:k])\n    max_score = total\n    for i in range(k):\n        total += cardPoints[-i - 1] - cardPoints[k - i - 1]\n        max_score = max(max_score, total)\n    return max_score", "passed": true, "score": {"loc": 7, "tokens": 58, "cc": 1, "nest": 2, "execution_time": 0.016551, "novelty": 0.29729752838799417}}, {"code": "def maxScore(cardPoints, k):\n    total_sum = sum(cardPoints[:k])\n    max_score = total_sum\n    for i in range(k):\n        total_sum += cardPoints[-i-1] - cardPoints[k-i-1]\n        max_score = max(max_score, total_sum)\n    return max_score", "passed": true, "score": {"loc": 7, "tokens": 58, "cc": 1, "nest": 2, "execution_time": 0.01667, "novelty": 0.22751144904012355}}, {"code": "def maxScore(cardPoints, k):\n    total_sum = sum(cardPoints[:k])\n    max_score = total_sum\n    for i in range(1, k + 1):\n        total_sum += cardPoints[-i] - cardPoints[k - i]\n        max_score = max(max_score, total_sum)\n    return max_score", "passed": true, "score": {"loc": 7, "tokens": 58, "cc": 1, "nest": 2, "execution_time": 0.016753, "novelty": 0.14114969303619285}}, {"code": "def maxScore(cardPoints, k):\n    n = len(cardPoints)\n    total_sum = sum(cardPoints)\n    min_sum = float('inf')\n    window_sum = 0\n    \n    for i in range(n - k, n):\n        window_sum += cardPoints[i]\n    \n    min_sum = min(min_sum, window_sum)\n    \n    for i in range(n - k, n + k - 1):\n        window_sum += cardPoints[i % n] - cardPoints[i - (n - k)]\n        min_sum = min(min_sum, window_sum)\n    \n    return total_sum - min_sum", "passed": false, "score": {"loc": 12, "tokens": 106, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.7456406197120398}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 22442, "entry_point": "findLeastNumOfUniqueInts", "best_list": [{"code": "from collections import Counter\n\ndef findLeastNumOfUniqueInts(arr, k):\n    count = Counter(arr)\n    least_common = count.most_common()[:-k-1:-1]\n    return len(count) - len(least_common)", "passed": true, "score": {"loc": 5, "tokens": 45, "cc": 0, "nest": 1, "execution_time": 0.016702, "novelty": 0.6276336127476422}}, {"code": "def findLeastNumOfUniqueInts(arr, k):\n    from collections import Counter\n    count = Counter(arr)\n    unique_counts = sorted(count.values())\n    for i, c in enumerate(unique_counts):\n        if k < c:\n            return len(unique_counts) - i\n        k -= c\n    return 0", "passed": true, "score": {"loc": 9, "tokens": 56, "cc": 2, "nest": 3, "execution_time": 0.016514, "novelty": 0.5088727011579173}}, {"code": "def findLeastNumOfUniqueInts(arr, k):\n    from collections import Counter\n    count = Counter(arr)\n    unique_counts = sorted(count.values())\n    for i, freq in enumerate(unique_counts):\n        if k >= freq:\n            k -= freq\n        else:\n            return len(unique_counts) - i\n    return 0", "passed": true, "score": {"loc": 10, "tokens": 59, "cc": 2, "nest": 3, "execution_time": 0.016639, "novelty": 0.4864471932678792}}, {"code": "def findLeastNumOfUniqueInts(arr, k):\n    count = [0] * (10**9 + 1)\n    for num in arr:\n        count[num] += 1\n    \n    freqs = sorted(count)\n    unique_count = sum(1 for f in freqs if f > 0)\n    \n    for freq in freqs:\n        if k >= freq:\n            k -= freq\n            unique_count -= 1\n        else:\n            break\n    \n    return unique_count", "passed": false, "score": {"loc": 13, "tokens": 78, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7671110817659205}}, {"code": "def findLeastNumOfUniqueInts(arr, k):\n    from collections import Counter\n    count = Counter(arr)\n    for num, freq in sorted(count.items(), key=lambda item: item[1]):\n        if k >= freq:\n            k -= freq\n        else:\n            return len(count) - k // freq\n    return 0", "passed": false, "score": {"loc": 9, "tokens": 66, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5302261587923401}}, {"code": "def findLeastNumOfUniqueInts(arr, k):\n    from collections import Counter\n    count = Counter(arr)\n    freqs = sorted(count.values())\n    for i, freq in enumerate(freqs):\n        k -= freq\n        if k < 0:\n            return len(freqs) - i - 1\n    return 0", "passed": false, "score": {"loc": 9, "tokens": 58, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.547212000938729}}, {"code": "from collections import Counter\n\ndef findLeastNumOfUniqueInts(arr, k):\n    freq = Counter(arr)\n    for num, count in sorted(freq.items(), key=lambda x: x[1]):\n        if k >= count:\n            k -= count\n        else:\n            return len(freq) - len(freq) + (k > 0)\n    return len(freq) - k > 0", "passed": false, "score": {"loc": 9, "tokens": 79, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5766818207785378}}, {"code": "def findLeastNumOfUniqueInts(arr, k):\n    count = [0] * (len(arr) + 1)\n    for num in arr:\n        count[num] += 1\n    count.sort()\n    for i in range(len(count)):\n        if count[i] == 0:\n            continue\n        if k >= count[i]:\n            k -= count[i]\n        else:\n            return len(count) - i\n    return 0", "passed": false, "score": {"loc": 13, "tokens": 87, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7518900167657278}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 22481, "entry_point": "maxAbsValExpr", "best_list": [{"code": "def maxAbsValExpr(arr1, arr2):\n    n = len(arr1)\n    return max(\n        max(arr1[i] + arr2[i] + i for i in range(n)) - min(arr1[j] + arr2[j] + j for j in range(n)),\n        max(arr1[i] + arr2[i] - i for i in range(n)) - min(arr1[j] + arr2[j] - j for j in range(n)),\n        max(arr1[i] - arr2[i] + i for i in range(n)) - min(arr1[j] - arr2[j] + j for j in range(n)),\n        max(arr1[i] - arr2[i] - i for i in range(n)) - min(arr1[j] - arr2[j] - j for j in range(n))\n    )", "passed": true, "score": {"loc": 8, "tokens": 193, "cc": 0, "nest": 1, "execution_time": 0.016668, "novelty": 0.8316623763413363}}, {"code": "def maxAbsValExpr(arr1, arr2):\n    max_val = float('-inf')\n    for i in range(4):\n        min_val = float('inf')\n        for j, (a, b) in enumerate(zip(arr1, arr2)):\n            val = (a if i % 2 == 0 else -a) + (b if (i // 2) % 2 == 0 else -b) + j\n            max_val = max(max_val, val - min_val)\n            min_val = min(min_val, val)\n    return max_val", "passed": true, "score": {"loc": 9, "tokens": 108, "cc": 2, "nest": 3, "execution_time": 0.016756, "novelty": 0.643572990379476}}, {"code": "def maxAbsValExpr(arr1, arr2):\n    n = len(arr1)\n    max_val = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff1 = abs(arr1[i] - arr1[j])\n            diff2 = abs(arr2[i] - arr2[j])\n            diff3 = abs(i - j)\n            max_val = max(max_val, diff1 + diff2 + diff3)\n    return max_val", "passed": true, "score": {"loc": 10, "tokens": 87, "cc": 2, "nest": 3, "execution_time": 0.016827, "novelty": 0.6583016206710668}}, {"code": "def maxAbsValExpr(arr1, arr2):\n    n = len(arr1)\n    max_val = float('-inf')\n    \n    for i in range(4):\n        val = float('-inf')\n        for j in range(n):\n            val = max(val, arr1[j] + arr2[j] + (1 if i & 1 else -1) * j)\n            if j >= 1:\n                max_val = max(max_val, val - arr1[j - 1] - arr2[j - 1] - (1 if i & 1 else -1) * (j - 1))\n    \n    return max_val", "passed": false, "score": {"loc": 10, "tokens": 124, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.6888376217725658}}, {"code": "def maxAbsValExpr(arr1, arr2):\n    n = len(arr1)\n    max_diff = 0\n    for i in range(4):\n        cur_max = float('-inf')\n        for j in range(n):\n            val = (i & 1) * arr1[j] + ((i >> 1) & 1) * arr2[j] + (i >> 2) * j\n            max_diff = max(max_diff, val - cur_max)\n            cur_max = max(cur_max, val)\n    return max_diff", "passed": false, "score": {"loc": 10, "tokens": 99, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6403214410244973}}, {"code": "def maxAbsValExpr(arr1, arr2):\n    n = len(arr1)\n    max_val = float('-inf')\n    for k in range(4):\n        min_val = float('inf')\n        for i in range(n):\n            val = (k & 1) * arr1[i] + (k & 2) * arr2[i] + (k & 4) * i\n            if val < min_val:\n                min_val = val\n            else:\n                max_val = max(max_val, val - min_val)\n    return max_val", "passed": false, "score": {"loc": 12, "tokens": 100, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.6671983125241143}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 22486, "entry_point": "minDeletionSize", "best_list": [{"code": "def minDeletionSize(A):\n    return sum(any(A[j][i] < A[j-1][i] for j in range(1, len(A))) for i in range(len(A[0])))", "passed": true, "score": {"loc": 2, "tokens": 55, "cc": 0, "nest": 1, "execution_time": 0.016622, "novelty": 0.7312261668054565}}, {"code": "def minDeletionSize(A):\n    delete = set()\n    for col in zip(*A):\n        if any(col[i] < col[i - 1] for i in range(1, len(col)) if i - 1 not in delete):\n            delete.add(col[0])\n    return len(delete)", "passed": true, "score": {"loc": 6, "tokens": 69, "cc": 2, "nest": 3, "execution_time": 0.016617, "novelty": 0.6042873561021593}}, {"code": "def minDeletionSize(A):\n    cols = len(A[0])\n    keep = [True] * cols\n    for r in range(1, len(A)):\n        for c in range(cols):\n            if keep[c] and A[r][c] < A[r-1][c]:\n                keep[c] = False\n    return sum(not k for k in keep)", "passed": true, "score": {"loc": 8, "tokens": 83, "cc": 4, "nest": 4, "execution_time": 0.016668, "novelty": 0.7695040570845897}}, {"code": "def minDeletionSize(A):\n    n, m = len(A), len(A[0])\n    deletions = 0\n    columns = list(zip(*A))\n    i = 0\n    while i < m:\n        valid = True\n        j = i + 1\n        while j < m:\n            if any(columns[j][k] < columns[i][k] for k in range(n)):\n                deletions += 1\n                valid = False\n                break\n            j += 1\n        if valid:\n            i = j\n        else:\n            i += 1\n    return deletions", "passed": false, "score": {"loc": 19, "tokens": 109, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.7166493225587882}}, {"code": "def minDeletionSize(A):\n    cols = list(zip(*A))\n    delete = set()\n    for i in range(1, len(cols)):\n        if any(col[j] < col[j-1] for j in range(1, len(col)) if j not in delete):\n            delete.add(i)\n    return len(delete)", "passed": false, "score": {"loc": 7, "tokens": 78, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7257227956936552}}, {"code": "def minDeletionSize(A):\n    m, n = len(A), len(A[0])\n    cols = list(range(n))\n    deleted = set()\n    \n    while cols:\n        valid = []\n        for col in cols:\n            if all(A[i][col] >= A[i - 1][col] for i in range(1, m) if col not in deleted):\n                valid.append(col)\n        if valid:\n            cols = valid\n        else:\n            deleted.add(cols[0])\n    \n    return len(deleted)", "passed": false, "score": {"loc": 14, "tokens": 113, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.7345885646690891}}, {"code": "def minDeletionSize(A):\n    cols = list(zip(*A))\n    deletions = 0\n    i = 0\n    while i < len(cols):\n        if i == 0 or all(cols[i][j] >= cols[i-1][j] for j in range(len(cols[i]))):\n            i += 1\n        else:\n            deletions += 1\n            cols = [(col[:j] + col[j+1:] if j == i else col) for col in cols]\n            i = 0\n    return deletions", "passed": false, "score": {"loc": 12, "tokens": 116, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7626242847474345}}, {"code": "def minDeletionSize(A):\n    dels = set()\n    for c in range(1, len(A[0])):\n        if any(A[r][c] < A[r][c - 1] for r in range(len(A)) if c - 1 not in dels):\n            dels.add(c)\n    return len(dels)", "passed": false, "score": {"loc": 6, "tokens": 77, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6513125933309756}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 22503, "entry_point": "longestSubarray", "best_list": [{"code": "def longestSubarray(nums, limit):\n    maxq, minq = [], []\n    i = 0\n    for j, num in enumerate(nums):\n        while maxq and num > nums[maxq[-1]]:\n            maxq.pop()\n        while minq and num < nums[minq[-1]]:\n            minq.pop()\n        maxq.append(j)\n        minq.append(j)\n        if nums[maxq[0]] - nums[minq[0]] > limit:\n            if maxq[0] == i:\n                maxq.pop(0)\n            if minq[0] == i:\n                minq.pop(0)\n            i += 1\n    return j - i + 1", "passed": true, "score": {"loc": 17, "tokens": 139, "cc": 8, "nest": 4, "execution_time": 0.016582, "novelty": 0.3847315587989715}}, {"code": "def longestSubarray(nums, limit):\n    min_stack, max_stack = [], []\n    left = 0\n    result = 0\n    \n    for right, num in enumerate(nums):\n        while min_stack and num < nums[min_stack[-1]]:\n            min_stack.pop()\n        while max_stack and num > nums[max_stack[-1]]:\n            max_stack.pop()\n        \n        min_stack.append(right)\n        max_stack.append(right)\n        \n        while nums[max_stack[0]] - nums[min_stack[0]] > limit:\n            left += 1\n            if min_stack[0] < left:\n                min_stack.pop(0)\n            if max_stack[0] < left:\n                max_stack.pop(0)\n        \n        result = max(result, right - left + 1)\n    \n    return result", "passed": true, "score": {"loc": 19, "tokens": 148, "cc": 8, "nest": 4, "execution_time": 0.016919, "novelty": 0.5355303783022061}}, {"code": "def longestSubarray(nums, limit):\n    max_dq = []\n    min_dq = []\n    left = 0\n    max_length = 0\n\n    for right, num in enumerate(nums):\n        while max_dq and num > max_dq[-1]:\n            max_dq.pop()\n        while min_dq and num < min_dq[-1]:\n            min_dq.pop()\n        max_dq.append(num)\n        min_dq.append(num)\n\n        while max_dq[0] - min_dq[0] > limit:\n            if max_dq[0] == nums[left]:\n                max_dq.pop(0)\n            if min_dq[0] == nums[left]:\n                min_dq.pop(0)\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length", "passed": true, "score": {"loc": 20, "tokens": 143, "cc": 8, "nest": 4, "execution_time": 0.016704, "novelty": 0.5076261319576199}}, {"code": "def longestSubarray(nums, limit):\n    from collections import deque\n    maxd = mind = i = 0\n    minq, maxq = deque(), deque()\n    for j, n in enumerate(nums):\n        while minq and n < nums[minq[-1]]:\n            minq.pop()\n        while maxq and n > nums[maxq[-1]]:\n            maxq.pop()\n        minq.append(j)\n        maxq.append(j)\n        if nums[maxq[0]] - nums[minq[0]] > limit:\n            i = minq.popleft() if nums[minq[0]] < nums[maxq[0]] else maxq.popleft()\n        maxd = max(maxd, j - i + 1)\n    return maxd", "passed": false, "score": {"loc": 15, "tokens": 152, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.7019167295855435}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 22519, "entry_point": "specialArray", "best_list": [{"code": "def specialArray(nums):\n    for x in range(len(nums) + 1):\n        if sum(1 for num in nums if num >= x) == x:\n            return x\n    return -1", "passed": true, "score": {"loc": 5, "tokens": 42, "cc": 2, "nest": 3, "execution_time": 0.01663, "novelty": 0.5004440227694296}}, {"code": "def specialArray(nums):\n    n = len(nums)\n    for x in range(n + 1):\n        if sum(1 for num in nums if num >= x) == x:\n            return x\n    return -1", "passed": true, "score": {"loc": 6, "tokens": 45, "cc": 2, "nest": 3, "execution_time": 0.016556, "novelty": 0.5145655634999107}}, {"code": "def specialArray(nums):\n    nums.sort()\n    n = len(nums)\n    left, right = 0, n\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] >= n - mid:\n            right = mid\n        else:\n            left = mid + 1\n    return n - left if left < n and nums[left] >= n - left else -1", "passed": true, "score": {"loc": 11, "tokens": 81, "cc": 3, "nest": 3, "execution_time": 0.016696, "novelty": 0.6265567276338901}}, {"code": "def specialArray(nums):\n    from collections import Counter\n    count = Counter(nums)\n    total = len(nums)\n    for x in range(total + 1):\n        while count[x]:\n            if total - count[x] < x:\n                return x\n            total -= count[x]\n            count[x] = 0\n    return -1", "passed": false, "score": {"loc": 11, "tokens": 66, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7264576044587354}}, {"code": "def specialArray(nums):\n    nums.sort()\n    n = len(nums)\n    left, right = 0, n\n    while left < right:\n        mid = (left + right) // 2\n        count = n - mid\n        if nums[mid] >= count:\n            right = mid\n        else:\n            left = mid + 1\n    return left if left < n and nums[left] == n - left else -1", "passed": false, "score": {"loc": 12, "tokens": 82, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5758792324923413}}, {"code": "def specialArray(nums):\n    nums.sort()\n    n = len(nums)\n    left, right = 0, n\n    while left <= right:\n        mid = (left + right) // 2\n        count = n - bisect_left(nums, mid)\n        if count == mid:\n            return mid\n        elif count < mid:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1", "passed": false, "score": {"loc": 14, "tokens": 78, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.6064766890346929}}, {"code": "def specialArray(nums):\n    nums.sort()\n    n = len(nums)\n    for x in range(n + 1):\n        i = bisect_left(nums, x)\n        if n - i == x:\n            return x\n    return -1", "passed": false, "score": {"loc": 8, "tokens": 48, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5439758527299021}}, {"code": "def specialArray(nums):\n    nums.sort()\n    for i in range(len(nums) + 1):\n        j = bisect_left(nums, i)\n        if len(nums) - j == i:\n            return i\n    return -1", "passed": false, "score": {"loc": 7, "tokens": 48, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.575728961216811}}], "num_pass": 4, "num_uniq": 3, "num_fail": 6, "fail_uniq": 6}
{"id": 22545, "entry_point": "maxProduct", "best_list": [{"code": "def maxProduct(nums):\n    return (sorted(nums)[-1] - 1) * (sorted(nums)[-2] - 1)", "passed": true, "score": {"loc": 2, "tokens": 32, "cc": 0, "nest": 1, "execution_time": 0.016523, "novelty": 0.5205448796280743}}, {"code": "def maxProduct(nums):\n    nums.sort()\n    return (nums[-1] - 1) * (nums[-2] - 1)", "passed": true, "score": {"loc": 3, "tokens": 31, "cc": 0, "nest": 1, "execution_time": 0.016631, "novelty": 0.6076047334525589}}, {"code": "def maxProduct(nums):\n    max1, max2 = max(nums), max([num for num in nums if num != max(nums)])\n    return (max1 - 1) * (max2 - 1)", "passed": true, "score": {"loc": 3, "tokens": 45, "cc": 0, "nest": 1, "execution_time": 0.01666, "novelty": 0.6710390607901016}}, {"code": "def maxProduct(nums):\n    return (max(nums) - 1) * (max(nums, key=nums.remove) - 1)", "passed": false, "score": {"loc": 2, "tokens": 30, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5662807235336276}}, {"code": "def maxProduct(nums):\n    a, b = max(nums), nums.pop(nums.index(a))\n    return (a-1) * (b-1)", "passed": false, "score": {"loc": 3, "tokens": 38, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5837367475557365}}, {"code": "def maxProduct(nums):\n    return (nums[0] - 1) * (nums[1] - 1)\n\ndef find_second_max(nums):\n    first, second = float('-inf'), float('-inf')\n    for num in nums:\n        if num > first:\n            second = first\n            first = num\n        elif num > second:\n            second = num\n    return (first - 1) * (second - 1)", "passed": false, "score": {"loc": 11, "tokens": 85, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.6870285261884843}}, {"code": "def maxProduct(nums):\n    return (heapq.nlargest(2, nums)[1] - 1) * (heapq.nlargest(2, nums)[0] - 1)", "passed": false, "score": {"loc": 2, "tokens": 38, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.609218289860432}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 22557, "entry_point": "minScoreTriangulation", "best_list": [{"code": "def minScoreTriangulation(A):\n    N = len(A)\n    dp = [[0] * N for _ in range(N)]\n    for length in range(2, N):\n        for i in range(N - length):\n            j = i + length\n            dp[i][j] = min(dp[i][k] + dp[k][j] + A[i] * A[k] * A[j] for k in range(i + 1, j))\n    return dp[0][N - 1]", "passed": true, "score": {"loc": 8, "tokens": 115, "cc": 2, "nest": 3, "execution_time": 0.016648, "novelty": 0.2270057517484081}}, {"code": "def minScoreTriangulation(A):\n    n = len(A)\n    dp = [[0] * n for _ in range(n)]\n    \n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = min(dp[i][k] + dp[k][j] + A[i] * A[k] * A[j] for k in range(i + 1, j))\n    \n    return dp[0][n - 1]", "passed": true, "score": {"loc": 8, "tokens": 121, "cc": 2, "nest": 3, "execution_time": 0.016587, "novelty": 0.2201706490506442}}, {"code": "def minScoreTriangulation(A):\n    N = len(A)\n    dp = [[0] * N for _ in range(N)]\n    \n    for length in range(3, N + 1):\n        for i in range(N - length + 1):\n            j = i + length - 1\n            dp[i][j] = min(dp[i][k] + dp[k][j] + A[i] * A[k] * A[j] for k in range(i + 1, j))\n    \n    return dp[0][N - 1]", "passed": true, "score": {"loc": 8, "tokens": 121, "cc": 2, "nest": 3, "execution_time": 0.016643, "novelty": 0.21920405500351792}}, {"code": "def minScoreTriangulation(A):\n    @lru_cache(None)\n    def dp(i, j):\n        if j - i < 2:\n            return 0\n        return min(dp(i, k) + dp(k, j) + A[i] * A[k] * A[j] for k in range(i + 1, j))\n    \n    return dp(0, len(A) - 1)", "passed": false, "score": {"loc": 7, "tokens": 83, "cc": 1, "nest": 3, "execution_time": 10.0, "novelty": 0.8091728553156581}}, {"code": "def minScoreTriangulation(A):\n    n = len(A)\n    dp = [[float('inf')] * n for _ in range(n)]\n    \n    for length in range(2, n):\n        for i in range(n - length):\n            j = i + length\n            for k in range(i + 1, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + A[i] * A[k] * A[j])\n    \n    return dp[0][n - 1]", "passed": false, "score": {"loc": 9, "tokens": 129, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7195703771398654}}], "num_pass": 8, "num_uniq": 4, "num_fail": 2, "fail_uniq": 2}
{"id": 22636, "entry_point": "maxProfit", "best_list": [{"code": "def maxProfit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    \n    return max_profit", "passed": true, "score": {"loc": 7, "tokens": 42, "cc": 1, "nest": 2, "execution_time": 0.016526, "novelty": 0.2829992213747381}}, {"code": "def maxProfit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        elif price - min_price > max_profit:\n            max_profit = price - min_price\n    return max_profit", "passed": true, "score": {"loc": 9, "tokens": 44, "cc": 3, "nest": 4, "execution_time": 0.016719, "novelty": 0.17928157906274533}}, {"code": "def maxProfit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    for i, price in enumerate(prices):\n        if price < min_price:\n            min_price = price\n        elif price - min_price > max_profit:\n            max_profit = price - min_price\n    return max_profit", "passed": true, "score": {"loc": 9, "tokens": 49, "cc": 3, "nest": 4, "execution_time": 0.016583, "novelty": 0.5861790904043713}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 22660, "entry_point": "longestPrefix", "best_list": [{"code": "def longestPrefix(s):\n    for i in range(len(s) - 1, 0, -1):\n        if s.startswith(s[i:]):\n            return s[i:]\n    return \"\"", "passed": true, "score": {"loc": 5, "tokens": 45, "cc": 2, "nest": 3, "execution_time": 0.016563, "novelty": 0.5040330815729674}}, {"code": "def longestPrefix(s: str) -> str:\n    for i in range(len(s) - 1, 0, -1):\n        if s.startswith(s[i:]):\n            return s[i:]\n    return \"\"", "passed": true, "score": {"loc": 5, "tokens": 50, "cc": 2, "nest": 3, "execution_time": 0.016549, "novelty": 0.5101011874246002}}, {"code": "def longestPrefix(s: str) -> str:\n    for i in range(len(s) - 1, 0, -1):\n        if s[:i] == s[-i:]:\n            return s[:i]\n    return \"\"", "passed": true, "score": {"loc": 5, "tokens": 53, "cc": 2, "nest": 3, "execution_time": 0.016655, "novelty": 0.5137289225793997}}, {"code": "def longestPrefix(s):\n    return max(s[:i] for i in range(1, len(s)) if s.startswith(s[i:]))", "passed": false, "score": {"loc": 2, "tokens": 38, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6869794190692236}}, {"code": "def longestPrefix(s):\n    return s[:next((i for i in range(len(s), 0, -1) if s.startswith(s[i:])), 0)]", "passed": false, "score": {"loc": 2, "tokens": 45, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6017517980339446}}], "num_pass": 8, "num_uniq": 6, "num_fail": 2, "fail_uniq": 2}
{"id": 22681, "entry_point": "longestPalindrome", "best_list": [{"code": "from collections import Counter\n\ndef longestPalindrome(s: str) -> int:\n    freq = Counter(s)\n    pairs = sum(v // 2 for v in freq.values()) * 2\n    has_odd = any(v % 2 for v in freq.values())\n    return pairs + has_odd", "passed": true, "score": {"loc": 6, "tokens": 60, "cc": 0, "nest": 1, "execution_time": 0.01653, "novelty": 0.6977980838935856}}, {"code": "def longestPalindrome(s: str) -> int:\n    from collections import Counter\n    count = Counter(s)\n    length = 0\n    hasOdd = False\n    for v in count.values():\n        length += v // 2 * 2\n        if v % 2 == 1:\n            hasOdd = True\n    return length + hasOdd", "passed": true, "score": {"loc": 10, "tokens": 60, "cc": 2, "nest": 3, "execution_time": 0.016739, "novelty": 0.5543829968520734}}, {"code": "def longestPalindrome(s):\n    from collections import Counter\n    freq = Counter(s)\n    length = 0\n    odd_found = False\n    for count in freq.values():\n        if count % 2 == 0:\n            length += count\n        else:\n            length += count - 1\n            odd_found = True\n    return length + odd_found", "passed": true, "score": {"loc": 12, "tokens": 58, "cc": 2, "nest": 3, "execution_time": 0.016655, "novelty": 0.3820857216756619}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 22688, "entry_point": "frequencySort", "best_list": [{"code": "def frequencySort(s):\n    from collections import Counter\n    return ''.join(c * freq for c, freq in Counter(s).most_common())", "passed": true, "score": {"loc": 3, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016579, "novelty": 0.13927649571732625}}, {"code": "from collections import Counter\n\ndef frequencySort(s):\n    return ''.join(char * freq for char, freq in Counter(s).most_common())", "passed": true, "score": {"loc": 3, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016581, "novelty": 0.2681022178843535}}, {"code": "def frequencySort(s):\n    from collections import Counter\n    return ''.join(char * freq for char, freq in Counter(s).most_common())", "passed": true, "score": {"loc": 3, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016629, "novelty": 0.2757690074881516}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 22700, "entry_point": "reorderedPowerOf2", "best_list": [{"code": "def reorderedPowerOf2(N):\n    return sorted(str(N)) in (sorted(str(1 << i)) for i in range(31))", "passed": true, "score": {"loc": 2, "tokens": 34, "cc": 0, "nest": 1, "execution_time": 0.016529, "novelty": 0.3967208622712236}}, {"code": "def reorderedPowerOf2(N):\n    return sorted(str(N)) in [sorted(str(1 << i)) for i in range(31)]", "passed": true, "score": {"loc": 2, "tokens": 34, "cc": 0, "nest": 1, "execution_time": 0.016673, "novelty": 0.39459102860297457}}, {"code": "def reorderedPowerOf2(N):\n    return sorted(str(N)) in [sorted(str(1 << i)) for i in range(30)]", "passed": true, "score": {"loc": 2, "tokens": 34, "cc": 0, "nest": 1, "execution_time": 0.016678, "novelty": 0.42716889149927906}}, {"code": "def reorderedPowerOf2(n):\n    def is_power_of_2(num):\n        return num > 0 and (num & (num - 1)) == 0\n\n    return is_power_of_2(int(''.join(sorted(str(n)))))\n\n# Unit tests\nassert reorderedPowerOf2(1) == True\nassert reorderedPowerOf2(10) == False\nassert reorderedPowerOf2(16) == True\nassert reorderedPowerOf2(24) == False\nassert reorderedPowerOf2(46) == True", "passed": false, "score": {"loc": 10, "tokens": 92, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.794480024540241}}, {"code": "from typing import Set\nfrom functools import reduce\nfrom operator import mul\n\ndef reorderedPowerOf2(N: int) -> bool:\n    digits = sorted(str(N))\n    powers_of_2_digits = {sorted(str(2**i)) for i in range(30)}\n    return digits in powers_of_2_digits", "passed": false, "score": {"loc": 7, "tokens": 57, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7472684813667241}}, {"code": "def reorderedPowerOf2(N):\n    count = [0] * 10\n    while N:\n        count[N % 10] += 1\n        N //= 10\n    return any(all(count[i] == count2[i] for i in range(10)) for count2 in [(1 << i).bit_count() for i in range(30)])", "passed": false, "score": {"loc": 6, "tokens": 76, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.7391596332128647}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 22796, "entry_point": "toGoatLatin", "best_list": [{"code": "def toGoatLatin(S):\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    return ' '.join((w if w[0] in vowels else w[1:] + w[0]) + 'ma' + (i + 1) * 'a' for i, w in enumerate(S.split()))", "passed": true, "score": {"loc": 3, "tokens": 104, "cc": 0, "nest": 1, "execution_time": 0.016649, "novelty": 0.7059722453986846}}, {"code": "def toGoatLatin(S):\n    words = S.split()\n    vowels = \"aeiouAEIOU\"\n    return \" \".join((w if w[0] in vowels else w[1:] + w[0]) + \"ma\" + (i + 1) * \"a\" for i, w in enumerate(words))", "passed": true, "score": {"loc": 4, "tokens": 69, "cc": 0, "nest": 1, "execution_time": 0.016683, "novelty": 0.6451469703959021}}, {"code": "def toGoatLatin(S):\n    def convert(word, idx):\n        if word[0].lower() in 'aeiou':\n            return word + 'ma' + 'a' * (idx + 1)\n        else:\n            return word[1:] + word[0] + 'ma' + 'a' * (idx + 1)\n    \n    return ' '.join(convert(word, idx) for idx, word in enumerate(S.split()))", "passed": true, "score": {"loc": 7, "tokens": 97, "cc": 1, "nest": 3, "execution_time": 0.016618, "novelty": 0.7718859309158957}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 22826, "entry_point": "countVowelPermutation", "best_list": [{"code": "def countVowelPermutation(n):\n    a, e, i, o, u = 1, 1, 1, 1, 1\n    MOD = 10**9 + 7\n    for _ in range(1, n):\n        a, e, i, o, u = (e + i + u) % MOD, (a + i) % MOD, (e + o) % MOD, i % MOD, (i + o) % MOD\n    return (a + e + i + o + u) % MOD", "passed": true, "score": {"loc": 6, "tokens": 104, "cc": 1, "nest": 2, "execution_time": 0.016642, "novelty": 0.5488446909021618}}, {"code": "def countVowelPermutation(n):\n    MOD = 10**9 + 7\n    a, e, i, o, u = 1, 1, 1, 1, 1\n    for _ in range(n - 1):\n        a, e, i, o, u = (e + i + u) % MOD, (a + i) % MOD, (e + o) % MOD, i % MOD, (i + o) % MOD\n    return (a + e + i + o + u) % MOD", "passed": true, "score": {"loc": 6, "tokens": 104, "cc": 1, "nest": 2, "execution_time": 0.01671, "novelty": 0.623515743830206}}, {"code": "def countVowelPermutation(n):\n    dp = [[0, 0, 0, 0, 0] for _ in range(n + 1)]\n    dp[1] = [1, 1, 1, 1, 1]\n    for i in range(2, n + 1):\n        dp[i][0] = dp[i - 1][1]\n        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % 1000000007\n        dp[i][2] = (dp[i - 1][1] + dp[i - 1][3] + dp[i - 1][4]) % 1000000007\n        dp[i][3] = (dp[i - 1][2] + dp[i - 1][4]) % 1000000007\n        dp[i][4] = dp[i - 1][0]\n    return sum(dp[n]) % 1000000007", "passed": true, "score": {"loc": 10, "tokens": 205, "cc": 1, "nest": 2, "execution_time": 0.016529, "novelty": 0.7398945466648377}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 22831, "entry_point": "searchInsert", "best_list": [{"code": "def searchInsert(nums, target):\n    left, right = 0, len(nums)\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "passed": true, "score": {"loc": 9, "tokens": 53, "cc": 2, "nest": 3, "execution_time": 0.016775, "novelty": 0.12266087166485573}}, {"code": "def searchInsert(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left", "passed": true, "score": {"loc": 11, "tokens": 69, "cc": 3, "nest": 4, "execution_time": 0.016636, "novelty": 0.07364481468067119}}], "num_pass": 10, "num_uniq": 2, "num_fail": 0, "fail_uniq": 0}
{"id": 22865, "entry_point": "superEggDrop", "best_list": [{"code": "def superEggDrop(K, N):\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    for m in range(1, N + 1):\n        for k in range(1, K + 1):\n            dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1\n            if dp[m][k] >= N:\n                return m", "passed": true, "score": {"loc": 7, "tokens": 99, "cc": 3, "nest": 4, "execution_time": 0.016656, "novelty": 0.7688455493343063}}, {"code": "def superEggDrop(K, N):\n    dp = [0] * (K + 1)\n    moves = 0\n    while dp[K] < N:\n        moves += 1\n        for k in range(K, 0, -1):\n            dp[k] += dp[k - 1] + 1\n    return moves", "passed": true, "score": {"loc": 8, "tokens": 63, "cc": 2, "nest": 3, "execution_time": 0.016542, "novelty": 0.47022695149916494}}, {"code": "def superEggDrop(K: int, N: int) -> int:\n    dp = [0] * (K + 1)\n    moves = 0\n    while dp[K] < N:\n        moves += 1\n        for k in range(K, 0, -1):\n            dp[k] += dp[k - 1] + 1\n    return moves", "passed": true, "score": {"loc": 8, "tokens": 70, "cc": 2, "nest": 3, "execution_time": 0.016563, "novelty": 0.4935516510763419}}, {"code": "def superEggDrop(K, N):\n    @lru_cache(None)\n    def dp(k, n):\n        if k == 1: return n\n        if n == 0: return 0\n        return min(max(dp(k-1, x-1), dp(k, n-x)) for x in range(1, n+1)) + 1\n    return dp(K, N)", "passed": false, "score": {"loc": 7, "tokens": 83, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7422109822279059}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 22949, "entry_point": "minimumTotal", "best_list": [{"code": "def minimumTotal(triangle):\n    n = len(triangle)\n    for row in range(n-2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += min(triangle[row+1][col], triangle[row+1][col+1])\n    return triangle[0][0]", "passed": true, "score": {"loc": 6, "tokens": 83, "cc": 2, "nest": 3, "execution_time": 0.016694, "novelty": 0.6157047102243445}}, {"code": "def minimumTotal(triangle):\n    for row in range(1, len(triangle)):\n        triangle[row][0] += triangle[row-1][0]\n        triangle[row][-1] += triangle[row-1][-1]\n        for col in range(1, row):\n            triangle[row][col] += min(triangle[row-1][col-1], triangle[row-1][col])\n    return min(triangle[-1])", "passed": true, "score": {"loc": 7, "tokens": 109, "cc": 2, "nest": 3, "execution_time": 0.016633, "novelty": 0.5910353333945803}}, {"code": "def minimumTotal(triangle):\n    for row in range(1, len(triangle)):\n        triangle[row][0] += triangle[row-1][0]\n        triangle[row][row] += triangle[row-1][row-1]\n        for col in range(1, row):\n            triangle[row][col] += min(triangle[row-1][col-1], triangle[row-1][col])\n    return min(triangle[-1])", "passed": true, "score": {"loc": 7, "tokens": 109, "cc": 2, "nest": 3, "execution_time": 0.016648, "novelty": 0.4022570707730879}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 2326, "entry_point": "hasAlternatingBits", "best_list": [{"code": "def hasAlternatingBits(n):\n    return all(a != b for a, b in zip(bin(n)[2:], bin(n)[3:]))", "passed": true, "score": {"loc": 2, "tokens": 39, "cc": 0, "nest": 1, "execution_time": 0.016664, "novelty": 0.6712420816443909}}, {"code": "def hasAlternatingBits(n):\n    return all(bin(n)[i] != bin(n)[i + 1] for i in range(len(bin(n)) - 2))", "passed": true, "score": {"loc": 2, "tokens": 43, "cc": 0, "nest": 1, "execution_time": 0.016641, "novelty": 0.673804145617679}}, {"code": "def hasAlternatingBits(n):\n    return all(_lhs != _rhs for _lhs, _rhs in zip(format(n, 'b'), format(n, 'b')[1:]))", "passed": true, "score": {"loc": 2, "tokens": 43, "cc": 0, "nest": 1, "execution_time": 0.016809, "novelty": 0.6987292205586936}}, {"code": "def hasAlternatingBits(n):\n    i = 1\n    while n > 0:\n        if n % 2 == i:\n            return False\n        i = 1 - i\n        n //= 2\n    return True", "passed": false, "score": {"loc": 8, "tokens": 36, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.47979958249582033}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 2342, "entry_point": "sumSubseqWidths", "best_list": [{"code": "def sumSubseqWidths(A):\n    MOD = 10**9 + 7\n    A.sort()\n    n = len(A)\n    total = 0\n    for i in range(n):\n        total = (total + (2**i - 2**(n-i-1)) * A[i]) % MOD\n    return total", "passed": true, "score": {"loc": 8, "tokens": 68, "cc": 1, "nest": 2, "execution_time": 0.016518, "novelty": 0.662105051344243}}, {"code": "def sumSubseqWidths(A):\n    A.sort()\n    n = len(A)\n    mod = 10**9 + 7\n    total = 0\n    for i in range(n):\n        total = (total + (2**i - 2**(n-i-1)) * A[i]) % mod\n    return total", "passed": true, "score": {"loc": 8, "tokens": 68, "cc": 1, "nest": 2, "execution_time": 0.016849, "novelty": 0.32905302701357375}}, {"code": "def sumSubseqWidths(A):\n    MOD = 10**9 + 7\n    A.sort()\n    n = len(A)\n    sum_widths = 0\n    for i in range(n):\n        sum_widths += (1 << i) * A[i] - (1 << (n - i - 1)) * A[i]\n    return sum_widths % MOD", "passed": true, "score": {"loc": 8, "tokens": 72, "cc": 1, "nest": 2, "execution_time": 0.016503, "novelty": 0.593345966300432}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 23123, "entry_point": "nextGreaterElement", "best_list": [{"code": "def nextGreaterElement(n):\n    digits = list(str(n))\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    if i == -1:\n        return -1\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    digits[i], digits[j] = digits[j], digits[i]\n    digits[i + 1:] = reversed(digits[i + 1:])\n    return int(''.join(digits)) if int(''.join(digits)) <= 2**31 - 1 else -1", "passed": true, "score": {"loc": 13, "tokens": 150, "cc": 4, "nest": 2, "execution_time": 0.016528, "novelty": 0.2719255344707179}}, {"code": "def nextGreaterElement(n):\n    digits = list(str(n))\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    if i == -1:\n        return -1\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    digits[i], digits[j] = digits[j], digits[i]\n    digits = digits[:i + 1] + digits[i + 1:][::-1]\n    return int(''.join(digits)) if int(''.join(digits)) <= 2**31 - 1 else -1", "passed": true, "score": {"loc": 13, "tokens": 155, "cc": 4, "nest": 2, "execution_time": 0.016709, "novelty": 0.27821794560328317}}, {"code": "def nextGreaterElement(n):\n    digits = list(str(n))\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    if i < 0:\n        return -1\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    digits[i], digits[j] = digits[j], digits[i]\n    digits[i + 1:] = reversed(digits[i + 1:])\n    result = int(''.join(digits))\n    return result if result <= 2**31 - 1 else -1", "passed": true, "score": {"loc": 14, "tokens": 142, "cc": 4, "nest": 2, "execution_time": 0.016572, "novelty": 0.22530206663475072}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 23150, "entry_point": "numFactoredBinaryTrees", "best_list": [{"code": "from collections import defaultdict\n\ndef numFactoredBinaryTrees(A):\n    MOD = 10 ** 9 + 7\n    A.sort()\n    dp = defaultdict(int)\n    for i, a in enumerate(A):\n        dp[a] = 1\n        for j, b in enumerate(A[:i]):\n            if a % b == 0:\n                c = a // b\n                if c in dp:\n                    dp[a] = (dp[a] + dp[b] * dp[c] * (2 if b != c else 1)) % MOD\n    return sum(dp.values()) % MOD", "passed": true, "score": {"loc": 13, "tokens": 123, "cc": 4, "nest": 5, "execution_time": 0.016679, "novelty": 0.5736919044237259}}, {"code": "def numFactoredBinaryTrees(A):\n    MOD = 10**9 + 7\n    A.sort()\n    n = len(A)\n    dp = [1] * n\n    index = {x: i for i, x in enumerate(A)}\n    \n    for i in range(n):\n        for j in range(i):\n            if A[i] % A[j] == 0:\n                right = A[i] // A[j]\n                if right in index:\n                    dp[i] = (dp[i] + dp[j] * dp[index[right]] * (2 if A[j] != right else 1)) % MOD\n    \n    return sum(dp) % MOD", "passed": true, "score": {"loc": 13, "tokens": 142, "cc": 4, "nest": 5, "execution_time": 0.016579, "novelty": 0.6434220685723386}}, {"code": "from collections import Counter\n\ndef numFactoredBinaryTrees(A):\n    MOD = 10 ** 9 + 7\n    A.sort()\n    A_set = set(A)\n    dp = Counter(A)\n    \n    for i in range(1, len(A)):\n        for j in range(i):\n            if A[i] % A[j] == 0:\n                b = A[i] // A[j]\n                if b in A_set:\n                    dp[A[i]] += dp[A[j]] * dp[b]\n                    dp[A[i]] %= MOD\n    \n    return sum(dp.values()) % MOD", "passed": true, "score": {"loc": 14, "tokens": 129, "cc": 4, "nest": 5, "execution_time": 0.016779, "novelty": 0.6840238884845669}}, {"code": "from functools import lru_cache\n\n@lru_cache(None)\ndef numFactoredBinaryTrees(self, A):\n    A = sorted(A)\n    n = len(A)\n    count = [1] * n\n    \n    for i in range(n):\n        for j in range(i):\n            if A[i] % A[j] == 0:\n                right = A[i] // A[j]\n                if right in A[j:]:\n                    k = A[j:].index(right)\n                    count[i] += count[j] * count[j + k] * (2 if j == j + k else 1)\n                    \n    return sum(count) % (10 ** 9 + 7)", "passed": false, "score": {"loc": 14, "tokens": 143, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.6012864454381268}}, {"code": "from collections import defaultdict\n\ndef numFactoredBinaryTrees(A):\n    A.sort()\n    n = len(A)\n    mod = 10 ** 9 + 7\n    dp = defaultdict(int)\n    for i, x in enumerate(A):\n        dp[x] = 1\n        for j in range(i):\n            if x % A[j] == 0:\n                k = x // A[j]\n                if k in dp:\n                    dp[x] = (dp[x] + dp[A[j]] * dp[k] * (1 if A[j] == k else 2)) % mod\n    return sum(dp.values()) % mod\n\ndef _equivalent(lhs, rhs):\n    if type(lhs) != type(rhs):\n        return False\n    if isinstance(lhs, dict):\n        return all(_equivalent(lhs[key], rhs[key]) for key in lhs if key in rhs) and all(_equivalent(lhs[key], rhs[key]) for key in rhs if key in lhs)\n    if isinstance(lhs, list):\n        return all(_equivalent(lhs[i], rhs[i]) for i in range(min(len(lhs), len(rhs))))\n    return lhs == rhs\n\n# Example usage:\nassert _equivalent(numFactoredBinaryTrees([2, 4]), 3)\nassert _equivalent(numFactoredBinaryTrees([2, 4, 5, 10]), 7)", "passed": false, "score": {"loc": 25, "tokens": 296, "cc": 8, "nest": 5, "execution_time": 10.0, "novelty": 0.7191927235751148}}, {"code": "def numFactoredBinaryTrees(A):\n    MOD = 10**9 + 7\n    A.sort()\n    dp = {}\n    for i, x in enumerate(A):\n        dp[x] = 1\n        for j in range(i):\n            if x % A[j] == 0:\n                right = x // A[j]\n                if right in dp:\n                    dp[x] = (dp[x] + dp[A[j]] * dp[right] * (2 if A[j] == right else 1)) % MOD\n    return sum(dp.values()) % MOD", "passed": false, "score": {"loc": 12, "tokens": 123, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.5974151015782746}}, {"code": "from typing import List\nfrom functools import lru_cache\n\nMOD = 10 ** 9 + 7\n\n@lru_cache(None)\ndef numFactoredBinaryTrees(A: List[int]) -> int:\n    A = sorted(A)\n    n = len(A)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if A[i] % A[j] == 0:\n                k = A[i] // A[j]\n                if k in A[:i]:\n                    dp[i] = (dp[i] + dp[j] * dp[A.index(k)] * (2 if A[j] == k else 1)) % MOD\n    return sum(dp) % MOD", "passed": false, "score": {"loc": 15, "tokens": 154, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.5546720755411537}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 23201, "entry_point": "tallestBillboard", "best_list": [{"code": "def tallestBillboard(rods):\n    dp = {0: 0}\n    for r in rods:\n        for d, h in list(dp.items()):\n            dp[d + r] = max(dp.get(d + r, 0), h)\n            dp[abs(d - r)] = max(dp.get(abs(d - r), 0), h + min(d, r))\n    return dp[0]", "passed": true, "score": {"loc": 7, "tokens": 94, "cc": 2, "nest": 3, "execution_time": 0.016755, "novelty": 0.2447620312895642}}, {"code": "def tallestBillboard(rods):\n    dp = {0: 0}\n    for r in rods:\n        new_dp = dp.copy()\n        for d, h in dp.items():\n            new_dp[d + r] = max(new_dp.get(d + r, 0), h + r)\n            new_dp[abs(d - r)] = max(new_dp.get(abs(d - r), 0), h)\n        dp = new_dp\n    return dp[0]", "passed": true, "score": {"loc": 9, "tokens": 96, "cc": 2, "nest": 3, "execution_time": 0.016494, "novelty": 0.2873794561472274}}, {"code": "def tallestBillboard(rods):\n    dp = {0: 0}\n    for r in rods:\n        new_dp = dp.copy()\n        for diff, taller in dp.items():\n            new_dp[diff + r] = max(new_dp.get(diff + r, 0), taller)\n            new_dp[abs(diff - r)] = max(new_dp.get(abs(diff - r), 0), taller + min(diff, r))\n        dp = new_dp\n    return dp[0]", "passed": true, "score": {"loc": 9, "tokens": 101, "cc": 2, "nest": 3, "execution_time": 0.01673, "novelty": 0.33889801574317024}}, {"code": "from functools import lru_cache\n\n@lru_cache(None)\ndef tallestBillboard(rods, diff=0):\n    if not rods:\n        return 0 if diff == 0 else float('-inf')\n    return max(tallestBillboard(rods[1:], diff + rods[0]),\n               tallestBillboard(rods[1:], diff - rods[0]),\n               tallestBillboard(rods[1:], diff) + (rods[0] if diff == 0 else 0))\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "passed": false, "score": {"loc": 10, "tokens": 111, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.8241197140966052}}], "num_pass": 9, "num_uniq": 5, "num_fail": 1, "fail_uniq": 1}
{"id": 23288, "entry_point": "mincostTickets", "best_list": [{"code": "def mincostTickets(days, costs):\n    MAX_DAY = 365\n    dp = [0] * (MAX_DAY + 1)\n    \n    for i in range(1, MAX_DAY + 1):\n        if i in days:\n            dp[i] = min(dp[i - 1] + costs[0], dp[max(i - 7, 0)] + costs[1], dp[max(i - 30, 0)] + costs[2])\n        else:\n            dp[i] = dp[i - 1]\n    \n    return dp[MAX_DAY]", "passed": true, "score": {"loc": 9, "tokens": 110, "cc": 2, "nest": 3, "execution_time": 0.016615, "novelty": 0.7597429106972601}}, {"code": "def mincostTickets(days, costs):\n    dp = [0] * (days[-1] + 1)\n    last_7 = last_30 = 0\n    for d in range(1, days[-1] + 1):\n        if d not in days:\n            dp[d] = dp[d - 1]\n        else:\n            last_7 = dp[max(0, d - 7)]\n            last_30 = dp[max(0, d - 30)]\n            dp[d] = min(dp[d - 1] + costs[0], last_7 + costs[1], last_30 + costs[2])\n    return dp[days[-1]]", "passed": true, "score": {"loc": 11, "tokens": 131, "cc": 2, "nest": 3, "execution_time": 0.016774, "novelty": 0.7953425746616491}}, {"code": "def mincostTickets(days, costs):\n    n = len(days)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    durations = [1, 7, 30]\n    \n    for i in range(1, n + 1):\n        for cost, duration in zip(costs, durations):\n            j = i\n            while j > 0 and days[i - 1] - days[j - 1] + 1 > duration:\n                j -= 1\n            dp[i] = min(dp[i], dp[j] + cost)\n    \n    return dp[n]", "passed": false, "score": {"loc": 12, "tokens": 123, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.7543929492830083}}, {"code": "def mincostTickets(days, costs):\n    n = len(days)\n    durations = [1, 7, 30]\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        min_cost = float('inf')\n        for j in range(3):\n            while i > 1 and days[i - 1] - days[i - durations[j] - 1] >= durations[j]:\n                i -= 1\n            min_cost = min(min_cost, dp[i - durations[j]] + costs[j])\n        dp[i] = min_cost\n\n    return dp[n]", "passed": false, "score": {"loc": 13, "tokens": 139, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.8067006484001547}}, {"code": "def mincostTickets(days, costs):\n    n = len(days)\n    durations = [1, 7, 30]\n    dp = [0] * (n + 1)\n    \n    for i in range(n):\n        j = i\n        for k in range(3):\n            while j < n and days[j] - days[i] < durations[k]:\n                j += 1\n            dp[j] = min(dp[j], dp[i] + costs[k])\n    \n    return dp[n]", "passed": false, "score": {"loc": 11, "tokens": 104, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.7341980827173764}}, {"code": "def mincostTickets(days, costs):\n    dp = [float('inf')] * (len(days) + 1)\n    dp[-1] = 0\n\n    for i in range(len(days) - 1, -1, -1):\n        dp[i] = min(dp[min(i + 1, len(days))], dp[min(i + 7, len(days))] + costs[1], dp[min(i + 30, len(days))] + costs[2])\n\n    return dp[0]", "passed": false, "score": {"loc": 6, "tokens": 120, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.7797508167459941}}, {"code": "def mincostTickets(days, costs):\n    max_day = days[-1]\n    dp = [0] * (max_day + 1)\n    \n    for i in range(1, max_day + 1):\n        if i in days:\n            dp[i] = min(dp[i - 1] + costs[0], dp[i - 7] + costs[1], dp[i - 30] + costs[2])\n        else:\n            dp[i] = dp[i - 1]\n    \n    return dp[max_day]\n\n# Example usage\nassert mincostTickets([1, 4, 6, 7, 8, 20], [2, 7, 15]) == 11\nassert mincostTickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 7, 15]) == 17", "passed": false, "score": {"loc": 12, "tokens": 175, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.751082235325304}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 8}
{"id": 23336, "entry_point": "mySqrt", "best_list": [{"code": "def mySqrt(x):\n    if x == 0:\n        return 0\n    guess = x\n    while True:\n        new_guess = (guess + x / guess) / 2\n        if abs(new_guess - guess) < 1e-10:\n            return int(new_guess)\n        guess = new_guess", "passed": true, "score": {"loc": 9, "tokens": 51, "cc": 3, "nest": 3, "execution_time": 0.016593, "novelty": 0.5062454077576679}}, {"code": "def mySqrt(x):\n    if x == 0:\n        return 0\n    guess = x / 2.0\n    while True:\n        new_guess = (guess + x / guess) / 2\n        if _equivalent(guess, new_guess):\n            return int(guess)\n        guess = new_guess", "passed": true, "score": {"loc": 9, "tokens": 51, "cc": 3, "nest": 3, "execution_time": 0.016876, "novelty": 0.5167283269593426}}, {"code": "def mySqrt(x):\n    if x == 0:\n        return 0\n    left, right = 1, x\n    while left < right:\n        mid = (left + right + 1) // 2\n        if mid * mid > x:\n            right = mid - 1\n        else:\n            left = mid\n    return left", "passed": true, "score": {"loc": 11, "tokens": 57, "cc": 3, "nest": 3, "execution_time": 0.016771, "novelty": 0.5741169537563722}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 23372, "entry_point": "findSubstringInWraproundString", "best_list": [{"code": "from collections import Counter\n\ndef findSubstringInWraproundString(p: str) -> int:\n    count = Counter()\n    max_len = 0\n    for i in range(len(p)):\n        if i > 0 and (ord(p[i]) - ord(p[i-1])) % 26 == 1:\n            max_len += 1\n        else:\n            max_len = 1\n        count[p[i]] = max(count[p[i]], max_len)\n    return sum(count.values())", "passed": true, "score": {"loc": 11, "tokens": 102, "cc": 3, "nest": 3, "execution_time": 0.016647, "novelty": 0.7098836220438904}}, {"code": "def findSubstringInWraproundString(p):\n    wrap = 'abcdefghijklmnopqrstuvwxyz'\n    max_len = [0] * 26\n    current_len = 0\n    last_char = -1\n    \n    for char in p:\n        char_idx = ord(char) - ord('a')\n        if (last_char == -1 or (last_char + 1) % 26 == char_idx):\n            current_len += 1\n        else:\n            current_len = 1\n        max_len[char_idx] = max(max_len[char_idx], current_len)\n        last_char = char_idx\n    \n    return sum(max_len)", "passed": false, "score": {"loc": 14, "tokens": 94, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7193119328735966}}, {"code": "def findSubstringInWraproundString(p):\n    count = [0] * 26\n    max_len = 0\n    for i in range(len(p)):\n        if i > 0 and (ord(p[i]) - ord(p[i-1]) == 1 or (p[i] == 'a' and p[i-1] == 'z')):\n            max_len += 1\n        else:\n            max_len = 1\n        count[ord(p[i]) - ord('a')] = max(count[ord(p[i]) - ord('a')], max_len)\n    return sum(count)", "passed": false, "score": {"loc": 10, "tokens": 133, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.5247461381147114}}, {"code": "from collections import Counter\n\ndef findSubstringInWraproundString(p: str) -> int:\n    if not p:\n        return 0\n    \n    max_len = [0] * 26\n    current_len = 1\n    \n    for i in range(1, len(p)):\n        if (ord(p[i]) - ord(p[i - 1]) + 26) % 26 == 1:\n            current_len += 1\n        else:\n            current_len = 1\n        \n        current_index = ord(p[i]) - ord('a')\n        max_len[current_index] = max(max_len[current_index], current_len)\n    \n    return sum(max_len)", "passed": false, "score": {"loc": 14, "tokens": 116, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6850267679910085}}, {"code": "def findSubstringInWraproundString(p):\n    max_len = [0] * 26\n    current_len = 1\n    prev_char = ord('z')\n    \n    for char in p:\n        char_code = ord(char)\n        if (char_code - prev_char) % 26 == 1:\n            current_len += 1\n        else:\n            current_len = 1\n        max_len[char_code - ord('a')] = max(max_len[char_code - ord('a')], current_len)\n        prev_char = char_code\n    \n    return sum(max_len)", "passed": false, "score": {"loc": 13, "tokens": 92, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5991438918354599}}, {"code": "def findSubstringInWraproundString(p: str) -> int:\n    dp = [0] * 26\n    max_len = 0\n    for i in range(len(p)):\n        max_len = max(max_len + 1, 1 if i == 0 or (ord(p[i]) - ord(p[i - 1])) % 26 == 1 else 1)\n        dp[ord(p[i]) - ord('a')] = max(dp[ord(p[i]) - ord('a')], max_len)\n    return sum(dp)", "passed": false, "score": {"loc": 7, "tokens": 119, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.6449353134436229}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 23403, "entry_point": "numSpecialEquivGroups", "best_list": [{"code": "def numSpecialEquivGroups(A):\n    return len({(''.join(sorted(s[::2])), ''.join(sorted(s[1::2]))) for s in A})", "passed": true, "score": {"loc": 2, "tokens": 50, "cc": 0, "nest": 1, "execution_time": 0.016389, "novelty": 0.6512916780936605}}, {"code": "def numSpecialEquivGroups(A):\n    def _signature(s):\n        even = sorted(s[::2])\n        odd = sorted(s[1::2])\n        return (tuple(even), tuple(odd))\n\n    signatures = {_signature(s) for s in A}\n    return len(signatures)", "passed": true, "score": {"loc": 7, "tokens": 64, "cc": 0, "nest": 2, "execution_time": 0.016709, "novelty": 0.723274198753669}}, {"code": "def numSpecialEquivGroups(A):\n    groups = set()\n    for s in A:\n        even = ''.join(sorted(s[::2]))\n        odd = ''.join(sorted(s[1::2]))\n        groups.add((even, odd))\n    return len(groups)", "passed": true, "score": {"loc": 7, "tokens": 66, "cc": 1, "nest": 2, "execution_time": 0.01672, "novelty": 0.5591271641941737}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 23468, "entry_point": "rankTeams", "best_list": [{"code": "def rankTeams(votes):\n    counts = {team: [0] * len(votes[0]) for team in votes[0]}\n    for vote in votes:\n        for rank, team in enumerate(vote):\n            counts[team][rank] -= 1\n    return ''.join(sorted(counts, key=counts.get))", "passed": true, "score": {"loc": 6, "tokens": 72, "cc": 2, "nest": 3, "execution_time": 0.016645, "novelty": 0.4818586723220031}}, {"code": "def rankTeams(votes):\n    n = len(votes[0])\n    team_votes = {team: [0] * n for team in votes[0]}\n    \n    for vote in votes:\n        for rank, team in enumerate(vote):\n            team_votes[team][rank] -= 1\n    \n    return ''.join(sorted(team_votes.keys(), key=team_votes.get))", "passed": true, "score": {"loc": 7, "tokens": 79, "cc": 2, "nest": 3, "execution_time": 0.016844, "novelty": 0.5678982956345753}}, {"code": "def rankTeams(votes):\n    counts = {team: [0] * len(votes[0]) for team in votes[0]}\n    for vote in votes:\n        for rank, team in enumerate(vote):\n            counts[team][rank] -= 1\n    teams = list(counts.keys())\n    teams.sort(key=lambda team: (counts[team], team))\n    return ''.join(teams)", "passed": true, "score": {"loc": 8, "tokens": 91, "cc": 2, "nest": 3, "execution_time": 0.016704, "novelty": 0.5386712140232202}}, {"code": "from collections import Counter\nfrom functools import cmp_to_key\n\ndef rankTeams(votes):\n    n = len(votes[0])\n    team_votes = Counter()\n    \n    for vote in votes:\n        for rank, team in enumerate(vote):\n            team_votes[team][rank] += 1\n    \n    def cmp(a, b):\n        for rank in range(n):\n            if team_votes[a][rank] != team_votes[b][rank]:\n                return team_votes[b][rank] - team_votes[a][rank]\n        return ord(a) - ord(b)\n    \n    return ''.join(sorted(votes[0], key=cmp_to_key(cmp)))", "passed": false, "score": {"loc": 14, "tokens": 134, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.7936885632636791}}, {"code": "from collections import defaultdict\n\ndef rankTeams(votes):\n    counts = defaultdict(lambda: [0] * len(votes[0]))\n    for vote in votes:\n        for rank, team in enumerate(vote):\n            counts[team][rank] -= 1\n    return ''.join(sorted(votes[0], key=lambda team: counts[team]))", "passed": false, "score": {"loc": 7, "tokens": 77, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.719130146649839}}, {"code": "def rankTeams(votes):\n    vote_count = {team: [0] * len(votes[0]) for team in votes[0]}\n    for vote in votes:\n        for rank, team in enumerate(vote):\n            vote_count[team][rank] -= 1\n    return ''.join(sorted(votes[0], key=vote_count.get))", "passed": false, "score": {"loc": 6, "tokens": 75, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.511736796571628}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 2363, "entry_point": "convert", "best_list": [{"code": "def convert(s: str, numRows: int) -> str:\n    if numRows == 1:\n        return s\n    \n    rows = [''] * numRows\n    row = 0\n    going_down = False\n    \n    for char in s:\n        rows[row] += char\n        if row == 0 or row == numRows - 1:\n            going_down = not going_down\n        row += 1 if going_down else -1\n    \n    return ''.join(rows)", "passed": true, "score": {"loc": 12, "tokens": 83, "cc": 4, "nest": 3, "execution_time": 0.016792, "novelty": 0.2877607426926688}}, {"code": "def convert(s, numRows):\n    if numRows == 1:\n        return s\n    rows = [''] * numRows\n    row, step = 0, 1\n    for char in s:\n        rows[row] += char\n        if row == 0:\n            step = 1\n        elif row == numRows - 1:\n            step = -1\n        row += step\n    return ''.join(rows)", "passed": true, "score": {"loc": 13, "tokens": 76, "cc": 4, "nest": 4, "execution_time": 0.016688, "novelty": 0.1487708613146036}}, {"code": "def convert(s, numRows):\n    if numRows == 1:\n        return s\n    \n    rows = [''] * numRows\n    index, step = 0, 1\n    \n    for char in s:\n        rows[index] += char\n        if index == 0:\n            step = 1\n        elif index == numRows - 1:\n            step = -1\n        index += step\n    \n    return ''.join(rows)", "passed": true, "score": {"loc": 13, "tokens": 76, "cc": 4, "nest": 4, "execution_time": 0.016703, "novelty": 0.08920518589201998}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 23516, "entry_point": "numTimesAllBlue", "best_list": [{"code": "def numTimesAllBlue(light):\n    max_seen = 0\n    result = 0\n    for i, l in enumerate(light, 1):\n        max_seen = max(max_seen, l)\n        result += max_seen == i\n    return result", "passed": true, "score": {"loc": 7, "tokens": 41, "cc": 1, "nest": 2, "execution_time": 0.016524, "novelty": 0.26026922337793756}}, {"code": "def numTimesAllBlue(light):\n    max_seen = current_max = result = 0\n    for i, l in enumerate(light, start=1):\n        max_seen = max(max_seen, l)\n        if max_seen == i:\n            result += 1\n    return result", "passed": true, "score": {"loc": 7, "tokens": 47, "cc": 2, "nest": 3, "execution_time": 0.01671, "novelty": 0.29383623570405626}}, {"code": "def numTimesAllBlue(light):\n    max_on = 0\n    count = 0\n    for i, l in enumerate(light, 1):\n        max_on = max(max_on, l)\n        if max_on == i:\n            count += 1\n    return count", "passed": true, "score": {"loc": 8, "tokens": 44, "cc": 2, "nest": 3, "execution_time": 0.01662, "novelty": 0.19025488680057867}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 23521, "entry_point": "maxLength", "best_list": [{"code": "def maxLength(arr):\n    def backtrack(start, current):\n        yield len(current)\n        for i in range(start, len(arr)):\n            if len(set(arr[i])) == len(arr[i]) and not any(char in current for char in arr[i]):\n                yield from backtrack(i + 1, current + arr[i])\n    \n    return max(backtrack(0, \"\"), default=0)", "passed": true, "score": {"loc": 7, "tokens": 98, "cc": 3, "nest": 4, "execution_time": 0.016723, "novelty": 0.547588676311742}}, {"code": "def maxLength(arr):\n    def backtrack(start, current, max_length):\n        max_length[0] = max(max_length[0], len(current))\n        for i in range(start, len(arr)):\n            if not set(arr[i]) | set(current):\n                backtrack(i + 1, current + arr[i], max_length)\n\n    max_length = [0]\n    backtrack(0, \"\", max_length)\n    return max_length[0]", "passed": true, "score": {"loc": 9, "tokens": 95, "cc": 2, "nest": 4, "execution_time": 0.016703, "novelty": 0.6267448720661313}}, {"code": "def maxLength(arr):\n    def backtrack(start, current):\n        max_length[0] = max(max_length[0], len(current))\n        for i in range(start, len(arr)):\n            if len(current) + len(arr[i]) == len(set(current + arr[i])):\n                backtrack(i + 1, current + arr[i])\n    \n    max_length = [0]\n    backtrack(0, \"\")\n    return max_length[0]", "passed": true, "score": {"loc": 9, "tokens": 102, "cc": 2, "nest": 4, "execution_time": 0.016673, "novelty": 0.5794387058807058}}, {"code": "def maxLength(arr):\n    def backtrack(index, current):\n        if index == len(arr):\n            return len(current)\n        include = 0\n        if all(c not in current for c in arr[index]):\n            include = backtrack(index + 1, current + arr[index])\n        exclude = backtrack(index + 1, current)\n        return max(include, exclude)\n\n    return backtrack(0, \"\")", "passed": false, "score": {"loc": 10, "tokens": 87, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6513969176942311}}, {"code": "def maxLength(arr):\n    def backtrack(start, current):\n        max_length = len(current)\n        for i in range(start, len(arr)):\n            if len(current) + len(arr[i]) == len(current + arr[i]) and all(char not in current for char in arr[i]):\n                max_length = max(max_length, backtrack(i + 1, current + arr[i]))\n        return max_length\n\n    return backtrack(0, \"\")", "passed": false, "score": {"loc": 8, "tokens": 103, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.688060705756904}}, {"code": "def maxLength(arr):\n    def backtrack(start, current):\n        nonlocal max_length\n        max_length = max(max_length, len(current))\n        for i in range(start, len(arr)):\n            if len(current & arr[i]) == 0:\n                backtrack(i + 1, current | arr[i])\n    \n    max_length = 0\n    backtrack(0, set())\n    return max_length", "passed": false, "score": {"loc": 10, "tokens": 80, "cc": 2, "nest": 4, "execution_time": 10.0, "novelty": 0.5360755049180921}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 23579, "entry_point": "minFlips", "best_list": [{"code": "def minFlips(a: int, b: int, c: int) -> int:\n    flips = 0\n    while a or b or c:\n        bit_a, bit_b, bit_c = a & 1, b & 1, c & 1\n        if bit_c == 0:\n            flips += bit_a + bit_b\n        else:\n            flips += 0 if bit_a or bit_b else 1\n        a, b, c = a >> 1, b >> 1, c >> 1\n    return flips", "passed": true, "score": {"loc": 10, "tokens": 92, "cc": 4, "nest": 3, "execution_time": 0.016644, "novelty": 0.5115864077309837}}, {"code": "def minFlips(a, b, c):\n    flips = 0\n    while a or b or c:\n        if c & 1:\n            flips += (a & 1) == 0 and (b & 1) == 0\n        else:\n            flips += (a & 1) + (b & 1)\n        a >>= 1\n        b >>= 1\n        c >>= 1\n    return flips", "passed": true, "score": {"loc": 11, "tokens": 78, "cc": 4, "nest": 3, "execution_time": 0.016626, "novelty": 0.5555777890788263}}, {"code": "def minFlips(a: int, b: int, c: int) -> int:\n    flips = 0\n    while a or b or c:\n        if c & 1:\n            flips += (a & 1) + (b & 1) == 0\n        else:\n            flips += (a & 1) + (b & 1)\n        a >>= 1\n        b >>= 1\n        c >>= 1\n    return flips", "passed": true, "score": {"loc": 11, "tokens": 84, "cc": 3, "nest": 3, "execution_time": 0.016677, "novelty": 0.47176441120434054}}, {"code": "def minFlips(a: int, b: int, c: int) -> int:\n    return sum(x != y != (c & 1) for x, y in zip_longest(format(a, '030b'), format(b, '030b'), format(c, '030b'), fillvalue='0'))", "passed": false, "score": {"loc": 2, "tokens": 74, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7664952068893576}}, {"code": "def minFlips(a: int, b: int, c: int) -> int:\n    flips = 0\n    while a or b or c:\n        bit_a, bit_b, bit_c = a & 1, b & 1, c & 1\n        if bit_c == 0:\n            flips += bit_a + bit_b\n        else:\n            flips += (bit_a == 0) + (bit_b == 0)\n        a, b, c = a >> 1, b >> 1, c >> 1\n    return flips", "passed": false, "score": {"loc": 10, "tokens": 98, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5014363919263174}}, {"code": "def minFlips(a, b, c):\n    return sum([\n        (a | b) & ~c,\n        (a & c) & ~b,\n        (b & c) & ~a\n    ])", "passed": false, "score": {"loc": 6, "tokens": 42, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.8318092187006295}}, {"code": "def minFlips(a: int, b: int, c: int) -> int:\n    flips = 0\n    while a or b or c:\n        bit_a = a & 1\n        bit_b = b & 1\n        bit_c = c & 1\n        if bit_c == 0:\n            flips += bit_a + bit_b\n        else:\n            flips += (bit_a == 0) + (bit_b == 0)\n        a >>= 1\n        b >>= 1\n        c >>= 1\n    return flips", "passed": false, "score": {"loc": 14, "tokens": 91, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.4388355602163152}}], "num_pass": 5, "num_uniq": 4, "num_fail": 5, "fail_uniq": 4}
{"id": 23663, "entry_point": "sumOddLengthSubarrays", "best_list": [{"code": "def sumOddLengthSubarrays(arr):\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        total_sum += ((i + 1) * (n - i) + 1) // 2 * arr[i]\n    return total_sum", "passed": true, "score": {"loc": 6, "tokens": 51, "cc": 1, "nest": 2, "execution_time": 0.016403, "novelty": 0.3887726990981072}}, {"code": "def sumOddLengthSubarrays(arr):\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for end in range(start, n, 2):\n            total_sum += sum(arr[start:end+1])\n    return total_sum", "passed": true, "score": {"loc": 7, "tokens": 51, "cc": 2, "nest": 3, "execution_time": 0.016489, "novelty": 0.2859893728691302}}, {"code": "def sumOddLengthSubarrays(arr):\n    total_sum = 0\n    n = len(arr)\n    for start in range(n):\n        for length in range(1, n - start + 1, 2):\n            total_sum += sum(arr[start:start + length])\n    return total_sum", "passed": true, "score": {"loc": 7, "tokens": 55, "cc": 2, "nest": 3, "execution_time": 0.016466, "novelty": 0.29127522347509716}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 23674, "entry_point": "maximumProduct", "best_list": [{"code": "def maximumProduct(nums):\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])", "passed": true, "score": {"loc": 3, "tokens": 48, "cc": 0, "nest": 1, "execution_time": 0.016471, "novelty": 0.09855618330194593}}, {"code": "def maximumProduct(nums):\n    min1 = min2 = math.inf\n    max1 = max2 = max3 = -math.inf\n    for num in nums:\n        if num < min1:\n            min2, min1 = min1, num\n        elif num < min2:\n            min2 = num\n        \n        if num > max1:\n            max3, max2, max1 = max2, max1, num\n        elif num > max2:\n            max3, max2 = max2, num\n        elif num > max3:\n            max3 = num\n    return max(min1 * min2 * max1, max1 * max2 * max3)", "passed": true, "score": {"loc": 15, "tokens": 99, "cc": 6, "nest": 5, "execution_time": 0.016551, "novelty": 0.8067796610169491}}], "num_pass": 10, "num_uniq": 2, "num_fail": 0, "fail_uniq": 0}
{"id": 23699, "entry_point": "findLUSlength", "best_list": [{"code": "def findLUSlength(a, b):\n    return max(len(a), len(b)) if a != b else -1", "passed": true, "score": {"loc": 2, "tokens": 29, "cc": 0, "nest": 1, "execution_time": 0.016553, "novelty": 0.21720689624316292}}, {"code": "def findLUSlength(s1: str, s2: str) -> int:\n    return max(len(s1), len(s2)) if s1 != s2 else -1", "passed": true, "score": {"loc": 2, "tokens": 36, "cc": 0, "nest": 1, "execution_time": 0.016525, "novelty": 0.260046449999508}}, {"code": "def findLUSlength(a: str, b: str) -> int:\n    return max(len(a), len(b)) if a != b else -1", "passed": true, "score": {"loc": 2, "tokens": 36, "cc": 0, "nest": 1, "execution_time": 0.016683, "novelty": 0.17265223460172363}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 23777, "entry_point": "maxNonOverlapping", "best_list": [{"code": "def maxNonOverlapping(nums, target):\n    prefix_sums = {0: -1}\n    current_sum = max_count = 0\n    for end, num in enumerate(nums):\n        current_sum += num\n        if current_sum - target in prefix_sums:\n            max_count += 1\n            current_sum = 0\n            prefix_sums = {0: end}\n        else:\n            prefix_sums[current_sum] = end\n    return max_count", "passed": true, "score": {"loc": 12, "tokens": 66, "cc": 2, "nest": 3, "execution_time": 0.016649, "novelty": 0.39381436741034515}}, {"code": "def maxNonOverlapping(nums, target):\n    prefix_sum = {0: -1}\n    current_sum = 0\n    max_subarrays = 0\n    last_end = -1\n\n    for i, num in enumerate(nums):\n        current_sum += num\n        if current_sum - target in prefix_sum and prefix_sum[current_sum - target] >= last_end:\n            max_subarrays += 1\n            last_end = i\n        prefix_sum[current_sum] = i\n\n    return max_subarrays", "passed": true, "score": {"loc": 12, "tokens": 72, "cc": 3, "nest": 3, "execution_time": 0.016533, "novelty": 0.4258075682606235}}, {"code": "def maxNonOverlapping(nums, target):\n    prefix_sum = {0: -1}\n    current_sum = 0\n    count = 0\n    last_end = -1\n    \n    for i, num in enumerate(nums):\n        current_sum += num\n        if current_sum - target in prefix_sum and prefix_sum[current_sum - target] >= last_end:\n            count += 1\n            last_end = i\n        prefix_sum[current_sum] = i\n    \n    return count", "passed": true, "score": {"loc": 12, "tokens": 72, "cc": 3, "nest": 3, "execution_time": 0.016647, "novelty": 0.39356542769314595}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 23851, "entry_point": "splitArraySameAverage", "best_list": [{"code": "def splitArraySameAverage(A):\n    from itertools import combinations\n\n    total_sum, n = sum(A), len(A)\n    for i in range(1, n // 2 + 1):\n        if total_sum * i % n == 0:\n            if any(sum(subset) == total_sum * i // n for subset in combinations(A, i)):\n                return True\n    return False", "passed": true, "score": {"loc": 8, "tokens": 78, "cc": 3, "nest": 4, "execution_time": 0.016653, "novelty": 0.6495241167486638}}, {"code": "def splitArraySameAverage(A):\n    from itertools import combinations\n    total_sum = sum(A)\n    n = len(A)\n    for i in range(1, n // 2 + 1):\n        if (total_sum * i) % n == 0:\n            target = total_sum * i // n\n            for comb in combinations(A, i):\n                if sum(comb) == target:\n                    return True\n    return False", "passed": true, "score": {"loc": 11, "tokens": 80, "cc": 4, "nest": 5, "execution_time": 0.016507, "novelty": 0.585721317582611}}, {"code": "def splitArraySameAverage(A):\n    n, total = len(A), sum(A)\n    dp = [set() for _ in range(n + 1)]\n    dp[0].add(0)\n\n    for num in A:\n        for i in range(n, 0, -1):\n            for s in dp[i - 1]:\n                dp[i].add(s + num)\n\n    for i in range(1, n // 2 + 1):\n        if (total * i) % n == 0 and (total * i) // n in dp[i]:\n            return True\n\n    return False", "passed": true, "score": {"loc": 12, "tokens": 128, "cc": 6, "nest": 4, "execution_time": 0.016697, "novelty": 0.6696931263697926}}, {"code": "from typing import List\n\ndef splitArraySameAverage(A: List[int]) -> bool:\n    total_sum = sum(A)\n    n = len(A)\n    \n    def can_split(sumB, lenB):\n        sumC = total_sum - sumB\n        lenC = n - lenB\n        if lenC == 0:\n            return False\n        if sumC / lenC == sumB / lenB:\n            return True\n        return any(can_split(sumB - x, lenB - 1) for x in A if x < sumB and can_split(sumB, lenB))\n    \n    return any(can_split(sumB, lenB) for lenB in range(1, n) for sumB in range(lenB * min(A), lenB * max(A) + 1))", "passed": false, "score": {"loc": 13, "tokens": 137, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.7422952987885691}}, {"code": "from fractions import Fraction\nfrom itertools import combinations\n\ndef splitArraySameAverage(A):\n    n = len(A)\n    total_sum = sum(A)\n    \n    if n == 1:\n        return False\n    \n    for i in range(1, n // 2 + 1):\n        if total_sum * i % n == 0:\n            target = Fraction(total_sum * i, n)\n            seen = set()\n            for comb in combinations(A, i):\n                if Fraction(sum(comb), i) == target:\n                    return True\n    return False", "passed": false, "score": {"loc": 15, "tokens": 102, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.7103297034398826}}, {"code": "from typing import List\n\ndef splitArraySameAverage(A: List[int]) -> bool:\n    n = len(A)\n    if n < 2:\n        return False\n    \n    total_sum = sum(A)\n    target = total_sum / n\n    \n    for i in range(1, n // 2 + 1):\n        if target * i == sum(A[:i]) and target * (n - i) == sum(A[i:n]):\n            return True\n        if target * i == sum(A[:i]) and target * (n - i) == sum(A[i:n]):\n            return True\n    \n    return False", "passed": false, "score": {"loc": 13, "tokens": 131, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.722601215741444}}, {"code": "def splitArraySameAverage(A):\n    n, s = len(A), sum(A)\n    if n == 1: return False\n    target = s / n\n    dp = {0}\n    for a in A:\n        ndp = dp.copy()\n        for dp_s in dp:\n            ndp[dp_s + a] = True\n            if (n - 1) * dp_s + a == target * (n - 1):\n                return True\n        dp = ndp\n    return False", "passed": false, "score": {"loc": 13, "tokens": 89, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.7038395579377577}}, {"code": "def splitArraySameAverage(A):\n    from collections import defaultdict\n    total_sum = sum(A)\n    n = len(A)\n    \n    def is_possible(subset_sum, subset_size):\n        if subset_size == 0 or subset_size == n:\n            return False\n        target = subset_sum * n // total_sum\n        dp = defaultdict(set)\n        dp[0].add(0)\n        for num in A:\n            for size in range(subset_size - 1, 0, -1):\n                for s in dp[size - 1]:\n                    dp[size].add(s + num)\n        return target in dp[subset_size]\n    \n    for i in range(1, n // 2 + 1):\n        if total_sum * i % n == 0 and is_possible(total_sum * i, i):\n            return True\n    return False", "passed": false, "score": {"loc": 19, "tokens": 152, "cc": 8, "nest": 5, "execution_time": 10.0, "novelty": 0.7743511969630192}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 23855, "entry_point": "search", "best_list": [{"code": "def search(nums, target):\n    return next((i for i, x in enumerate(nums) if x == target), -1)", "passed": true, "score": {"loc": 2, "tokens": 32, "cc": 0, "nest": 1, "execution_time": 0.016701, "novelty": 0.7589225129886624}}, {"code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1", "passed": true, "score": {"loc": 17, "tokens": 116, "cc": 5, "nest": 4, "execution_time": 0.016666, "novelty": 0.14804002530254756}}, {"code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1", "passed": true, "score": {"loc": 17, "tokens": 116, "cc": 5, "nest": 5, "execution_time": 0.016573, "novelty": 0.14655152932462823}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 23892, "entry_point": "minSteps", "best_list": [{"code": "def minSteps(s: str, t: str) -> int:\n    return sum([abs(s.count(c) - t.count(c)) for c in set(s)]) // 2", "passed": true, "score": {"loc": 2, "tokens": 47, "cc": 0, "nest": 1, "execution_time": 0.016547, "novelty": 0.6438844058671357}}, {"code": "import collections\n\ndef minSteps(s: str, t: str) -> int:\n    return sum((collections.Counter(s) - collections.Counter(t)).values())", "passed": true, "score": {"loc": 3, "tokens": 40, "cc": 0, "nest": 1, "execution_time": 0.016598, "novelty": 0.5508475690526639}}, {"code": "from collections import Counter\n\ndef minSteps(s: str, t: str) -> int:\n    return sum((Counter(s) - Counter(t)).values()) // 2", "passed": false, "score": {"loc": 3, "tokens": 41, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.487054194522781}}, {"code": "from collections import Counter\n\ndef minSteps(s, t):\n    return sum(abs(a - b) for a, b in zip(Counter(s).values(), Counter(t).values())) // 2", "passed": false, "score": {"loc": 3, "tokens": 50, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6740611917506925}}, {"code": "import collections\n\ndef minSteps(s, t):\n    return sum((collections.Counter(s) & collections.Counter(t)).values())", "passed": false, "score": {"loc": 3, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5775930691555946}}, {"code": "def minSteps(s: str, t: str) -> int:\n    s_count, t_count = [0] * 26, [0] * 26\n    for char in s:\n        s_count[ord(char) - ord('a')] += 1\n    for char in t:\n        t_count[ord(char) - ord('a')] += 1\n    return sum(abs(s_count[i] - t_count[i]) for i in range(26)) // 2", "passed": false, "score": {"loc": 7, "tokens": 100, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.7101294973059924}}, {"code": "def minSteps(s, t):\n    return (sum((collections.Counter(s) - collections.Counter(t)).values()) + 1) // 2", "passed": false, "score": {"loc": 2, "tokens": 38, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6346996945303529}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 8}
{"id": 23900, "entry_point": "consecutiveNumbersSum", "best_list": [{"code": "def consecutiveNumbersSum(N):\n    count = 0\n    for k in range(1, int(N**0.5) + 1):\n        if (N - k * (k - 1) // 2) % k == 0:\n            count += 1\n    return count", "passed": true, "score": {"loc": 6, "tokens": 56, "cc": 2, "nest": 3, "execution_time": 0.016744, "novelty": 0.37189487188581827}}, {"code": "def consecutiveNumbersSum(N):\n    count = 0\n    left = 1\n    current_sum = 0\n    \n    while left * (left - 1) // 2 < N:\n        if (N - left * (left - 1) // 2) % left == 0:\n            count += 1\n        left += 1\n    \n    return count", "passed": true, "score": {"loc": 9, "tokens": 60, "cc": 2, "nest": 3, "execution_time": 0.016543, "novelty": 0.6261411619878807}}, {"code": "def consecutiveNumbersSum(N):\n    count = 0\n    for start in range(1, N + 1):\n        current_sum = 0\n        for end in range(start, N + 1):\n            current_sum += end\n            if current_sum == N:\n                count += 1\n            elif current_sum > N:\n                break\n    return count", "passed": true, "score": {"loc": 11, "tokens": 58, "cc": 4, "nest": 5, "execution_time": 0.016567, "novelty": 0.45978975026061764}}, {"code": "def consecutiveNumbersSum(N):\n    count = 0\n    for start in range(1, int(N ** 0.5) + 1):\n        total = 0\n        for i in range(start, start + int((2 * N - start**2) ** 0.5) + 1):\n            total += i\n            if total == N:\n                count += 1\n                break\n            elif total > N:\n                break\n    return count", "passed": false, "score": {"loc": 12, "tokens": 86, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.5133365394422236}}, {"code": "def consecutiveNumbersSum(N):\n    count = 0\n    for i in range(1, int(N**0.5) + 1):\n        current_sum = 0\n        j = i\n        while current_sum < N:\n            current_sum += j\n            j += 1\n        if current_sum == N:\n            count += 1\n    return count", "passed": false, "score": {"loc": 11, "tokens": 60, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.46869244469547633}}, {"code": "def consecutiveNumbersSum(N):\n    count = 0\n    for k in range(1, N + 1):\n        if (2 * N + k - k * k) % (2 * k) == 0:\n            count += 1\n    return count", "passed": false, "score": {"loc": 6, "tokens": 49, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.4409268643124675}}, {"code": "def consecutiveNumbersSum(n):\n    count = 0\n    for i in range(1, n):\n        total = 0\n        for j in range(i, n):\n            total += j\n            if total == n:\n                count += 1\n                break\n            elif total > n:\n                break\n    return count", "passed": false, "score": {"loc": 12, "tokens": 55, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.4473666787309897}}], "num_pass": 6, "num_uniq": 4, "num_fail": 4, "fail_uniq": 4}
{"id": 23913, "entry_point": "mergeStones", "best_list": [{"code": "def mergeStones(stones, K):\n    if (len(stones) - 1) % (K - 1) != 0:\n        return -1\n    \n    n = len(stones)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + stones[i]\n    \n    dp = [[0] * n for _ in range(n)]\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            for m in range(i, j, K - 1):\n                dp[i][j] = min(dp[i][j], dp[i][m] + dp[m + 1][j])\n            if (j - i) % (K - 1) == 0:\n                dp[i][j] += prefix_sum[j + 1] - prefix_sum[i]\n    \n    return dp[0][n - 1]", "passed": true, "score": {"loc": 17, "tokens": 228, "cc": 6, "nest": 4, "execution_time": 0.016736, "novelty": 0.7972137150109947}}, {"code": "def mergeStones(stones, K):\n    n = len(stones)\n    if (n - 1) % (K - 1):\n        return -1\n    \n    prefix_sum = [0]\n    for stone in stones:\n        prefix_sum.append(prefix_sum[-1] + stone)\n    \n    dp = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 0\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            for m in range(i, j, K - 1):\n                dp[i][j] = min(dp[i][j], dp[i][m] + dp[m + 1][j])\n            if (j - i) % (K - 1) == 0:\n                dp[i][j] += prefix_sum[j + 1] - prefix_sum[i]\n    \n    return dp[0][n - 1]", "passed": true, "score": {"loc": 18, "tokens": 217, "cc": 7, "nest": 4, "execution_time": 0.016728, "novelty": 0.24658143719731063}}, {"code": "def mergeStones(stones, K):\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n\n    prefix_sum = [0]\n    for stone in stones:\n        prefix_sum.append(prefix_sum[-1] + stone)\n\n    dp = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 0\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            for m in range(i, j, K - 1):\n                dp[i][j] = min(dp[i][j], dp[i][m] + dp[m + 1][j])\n            if (length - 1) % (K - 1) == 0:\n                dp[i][j] += prefix_sum[j + 1] - prefix_sum[i]\n\n    return dp[0][n - 1]", "passed": true, "score": {"loc": 18, "tokens": 220, "cc": 7, "nest": 4, "execution_time": 0.016814, "novelty": 0.45582394818557037}}, {"code": "def mergeStones(stones, K):\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    \n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + stones[i]\n    \n    dp = [[float('inf')] * n for _ in range(n)]\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            for m in range(i, j, K - 1):\n                dp[i][j] = min(dp[i][j], dp[i][m] + dp[m + 1][j])\n            if (j - i) % (K - 1) == 0:\n                dp[i][j] += prefix_sum[j + 1] - prefix_sum[i]\n    \n    return dp[0][n - 1]", "passed": false, "score": {"loc": 16, "tokens": 216, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.4597248113828244}}, {"code": "def mergeStones(stones, K):\n    n = len(stones)\n    if (n - 1) % (K - 1) != 0:\n        return -1\n    \n    prefix_sum = [0]\n    for stone in stones:\n        prefix_sum.append(prefix_sum[-1] + stone)\n    \n    dp = [[float('inf')] * n for _ in range(n)]\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            for mid in range(i, j, K - 1):\n                dp[i][j] = min(dp[i][j], dp[i][mid] + dp[mid + 1][j])\n            if (j - i) % (K - 1) == 0:\n                dp[i][j] += prefix_sum[j + 1] - prefix_sum[i]\n    \n    return dp[0][n - 1]", "passed": false, "score": {"loc": 16, "tokens": 203, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.49228234368180934}}], "num_pass": 7, "num_uniq": 6, "num_fail": 3, "fail_uniq": 2}
{"id": 23927, "entry_point": "maximumGap", "best_list": [{"code": "def maximumGap(nums):\n    if len(nums) < 2:\n        return 0\n    nums.sort()\n    return max(nums[i] - nums[i-1] for i in range(1, len(nums)))", "passed": true, "score": {"loc": 5, "tokens": 48, "cc": 1, "nest": 2, "execution_time": 0.016685, "novelty": 0.4628794625069249}}, {"code": "def maximumGap(nums):\n    if len(nums) < 2:\n        return 0\n    \n    nums.sort()\n    max_gap = 0\n    \n    for i in range(1, len(nums)):\n        max_gap = max(max_gap, nums[i] - nums[i - 1])\n    \n    return max_gap", "passed": true, "score": {"loc": 8, "tokens": 57, "cc": 2, "nest": 2, "execution_time": 0.016546, "novelty": 0.5531387229198921}}, {"code": "def maximumGap(nums):\n    if len(nums) < 2:\n        return 0\n    \n    max_num = max(nums)\n    min_num = min(nums)\n    gap = (max_num - min_num) // (len(nums) - 1)\n    if gap == 0:\n        return max_num - min_num\n    \n    buckets = [[] for _ in range(len(nums) + 1)]\n    for num in nums:\n        idx = (num - min_num) // gap\n        buckets[idx].append(num)\n    \n    max_gap = 0\n    prev_max = min_num\n    for bucket in buckets:\n        if bucket:\n            max_gap = max(max_gap, bucket[0] - prev_max)\n            prev_max = max(bucket)\n    \n    return max_gap", "passed": true, "score": {"loc": 19, "tokens": 132, "cc": 5, "nest": 3, "execution_time": 0.016884, "novelty": 0.6981747894531035}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 23947, "entry_point": "threeSumClosest", "best_list": [{"code": "def threeSumClosest(nums, target):\n    nums.sort()\n    closest_sum = float('inf')\n    \n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if abs(current_sum - target) < abs(closest_sum - target):\n                closest_sum = current_sum\n            if current_sum < target:\n                left += 1\n            elif current_sum > target:\n                right -= 1\n            else:\n                return closest_sum\n    \n    return closest_sum", "passed": true, "score": {"loc": 16, "tokens": 111, "cc": 5, "nest": 5, "execution_time": 0.016562, "novelty": 0.10518891392107177}}, {"code": "def threeSumClosest(nums, target):\n    nums.sort()\n    closest_sum = float('inf')\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if abs(target - current_sum) < abs(target - closest_sum):\n                closest_sum = current_sum\n            if current_sum < target:\n                left += 1\n            elif current_sum > target:\n                right -= 1\n            else:\n                return closest_sum\n    return closest_sum", "passed": true, "score": {"loc": 16, "tokens": 111, "cc": 5, "nest": 5, "execution_time": 0.016644, "novelty": 0.1014896519059908}}, {"code": "def threeSumClosest(nums, target):\n    nums.sort()\n    closest_sum = float('inf')\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if abs(current_sum - target) < abs(closest_sum - target):\n                closest_sum = current_sum\n            if current_sum < target:\n                left += 1\n            elif current_sum > target:\n                right -= 1\n            else:\n                return target\n    return closest_sum", "passed": true, "score": {"loc": 16, "tokens": 111, "cc": 5, "nest": 5, "execution_time": 0.016708, "novelty": 0.08294118696985875}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 2401, "entry_point": "robotSim", "best_list": [{"code": "def robotSim(commands, obstacles):\n    x, y, dx, dy, max_dist = 0, 0, 0, 1, 0\n    obstacle_set = set(map(tuple, obstacles))\n    \n    for cmd in commands:\n        if cmd == -2:\n            dx, dy = -dy, dx\n        elif cmd == -1:\n            dx, dy = dy, -dx\n        else:\n            for _ in range(cmd):\n                if (x + dx, y + dy) not in obstacle_set:\n                    x, y = x + dx, y + dy\n                    max_dist = max(max_dist, x * x + y * y)\n                else:\n                    break\n    \n    return max_dist", "passed": true, "score": {"loc": 16, "tokens": 127, "cc": 5, "nest": 6, "execution_time": 0.016627, "novelty": 0.63663312820822}}, {"code": "def robotSim(commands, obstacles):\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    x, y, dx, dy, max_dist = 0, 0, 0, 1, 0\n    obstacles_set = set(map(tuple, obstacles))\n    \n    for cmd in commands:\n        if cmd == -1:\n            dx, dy = -dy, dx\n        elif cmd == -2:\n            dx, dy = dy, -dx\n        else:\n            for _ in range(cmd):\n                nx, ny = x + dx, y + dy\n                if (nx, ny) not in obstacles_set:\n                    x, y = nx, ny\n                    max_dist = max(max_dist, x*x + y*y)\n    \n    return max_dist", "passed": true, "score": {"loc": 16, "tokens": 156, "cc": 5, "nest": 6, "execution_time": 0.016821, "novelty": 0.6454765857689804}}, {"code": "def robotSim(commands, obstacles):\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    obstacle_set = set(map(tuple, obstacles))\n    x, y, d = 0, 0, 0\n    max_dist = 0\n\n    for cmd in commands:\n        if cmd == -2:\n            d = (d - 1) % 4\n        elif cmd == -1:\n            d = (d + 1) % 4\n        else:\n            dx, dy = directions[d]\n            while cmd > 0 and (x + dx, y + dy) not in obstacle_set:\n                x, y = x + dx, y + dy\n                cmd -= 1\n            max_dist = max(max_dist, x * x + y * y)\n\n    return max_dist", "passed": true, "score": {"loc": 17, "tokens": 158, "cc": 5, "nest": 5, "execution_time": 0.01661, "novelty": 0.4944995345310975}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 2404, "entry_point": "isValidSerialization", "best_list": [{"code": "def isValidSerialization(preorder):\n    slots = 1\n    for value in preorder.split(','):\n        if slots == 0:\n            return False\n        slots += 1 if value != '#' else -1\n    return slots == 0", "passed": true, "score": {"loc": 7, "tokens": 48, "cc": 2, "nest": 3, "execution_time": 0.016723, "novelty": 0.27160589187004747}}, {"code": "def isValidSerialization(serialized: str) -> bool:\n    slots = 1\n    for val in serialized.split(','):\n        if slots == 0:\n            return False\n        slots += 1 if val != '#' else -1\n    return slots == 0", "passed": true, "score": {"loc": 7, "tokens": 53, "cc": 2, "nest": 3, "execution_time": 0.01654, "novelty": 0.26340728984248096}}, {"code": "def isValidSerialization(serialized: str) -> bool:\n    slots = 1\n    for value in serialized.split(','):\n        if slots == 0:\n            return False\n        slots += 1 if value != '#' else -1\n    return slots == 0", "passed": true, "score": {"loc": 7, "tokens": 53, "cc": 2, "nest": 3, "execution_time": 0.016542, "novelty": 0.2633324170041974}}, {"code": "def isValidSerialization preorder):\n    slots = 1\n    for value in preorder.split(','):\n        slots -= 1\n        if slots < 0:\n            return False\n        if value != '#':\n            slots += 2\n    return slots == 0", "passed": false, "score": {"loc": 9, "tokens": 48, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.9532873707683527}}, {"code": "def isValidSerialization(self, preorder: str) -> bool:\n    slots = 1\n    for node in preorder.split(','):\n        if not slots:\n            return False\n        slots += 1 if node != '#' else -1\n    return not slots", "passed": false, "score": {"loc": 7, "tokens": 51, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.36365476551838205}}, {"code": "def isValidSerialization(self, preorder: str) -> bool:\n    slots = 1\n    for node in preorder.split(','):\n        slots -= 1\n        if slots < 0:\n            return False\n        slots += 2\n    return slots == 0", "passed": false, "score": {"loc": 8, "tokens": 48, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.4817680575424985}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 2406, "entry_point": "reverseBits", "best_list": [{"code": "def reverseBits(n):\n    return int(f'{n:032b}'[::-1], 2)", "passed": true, "score": {"loc": 2, "tokens": 26, "cc": 0, "nest": 1, "execution_time": 0.01663, "novelty": 0.3319948016954214}}, {"code": "def reverseBits(n):\n    return int(bin(n)[2:].zfill(32)[::-1], 2)", "passed": true, "score": {"loc": 2, "tokens": 31, "cc": 0, "nest": 1, "execution_time": 0.016556, "novelty": 0.18357214279082323}}, {"code": "def reverseBits(n: int) -> int:\n    return int(bin(n)[2:].zfill(32)[::-1], 2)", "passed": true, "score": {"loc": 2, "tokens": 36, "cc": 0, "nest": 1, "execution_time": 0.0166, "novelty": 0.2241662261668651}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 24128, "entry_point": "removeDuplicateLetters", "best_list": [{"code": "def removeDuplicateLetters(s):\n    stack = []\n    last_occurrence = {char: s.rindex(char) for char in set(s)}\n    seen = set()\n    \n    for i, char in enumerate(s):\n        if char not in seen:\n            while stack and char < stack[-1] and i < last_occurrence[stack[-1]]:\n                seen.remove(stack.pop())\n            stack.append(char)\n            seen.add(char)\n    \n    return ''.join(stack)", "passed": true, "score": {"loc": 11, "tokens": 102, "cc": 4, "nest": 4, "execution_time": 0.016787, "novelty": 0.6929109567608297}}, {"code": "def removeDuplicateLetters(s):\n    last_occurrence = {c: s.rindex(c) for c in set(s)}\n    stack = []\n    seen = set()\n\n    for i, c in enumerate(s):\n        if c not in seen:\n            while stack and c < stack[-1] and i < last_occurrence[stack[-1]]:\n                seen.remove(stack.pop())\n            stack.append(c)\n            seen.add(c)\n\n    return ''.join(stack)\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "passed": true, "score": {"loc": 13, "tokens": 115, "cc": 4, "nest": 4, "execution_time": 0.016819, "novelty": 0.6935736190640103}}, {"code": "def removeDuplicateLetters(s):\n    from collections import Counter\n    count = Counter(s)\n    stack = []\n    in_stack = set()\n    \n    for char in s:\n        count[char] -= 1\n        if char in in_stack:\n            continue\n        while stack and stack[-1] > char and count[stack[-1]] > 0:\n            in_stack.remove(stack.pop())\n        stack.append(char)\n        in_stack.add(char)\n    \n    return ''.join(stack)", "passed": true, "score": {"loc": 14, "tokens": 95, "cc": 4, "nest": 3, "execution_time": 0.0165, "novelty": 0.1704356487020272}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 24152, "entry_point": "binaryGap", "best_list": [{"code": "def binaryGap(n):\n    bits = [i for i, bit in enumerate(bin(n)[2:]) if bit == '1']\n    return max((bits[i] - bits[i-1] for i in range(1, len(bits))), default=0)", "passed": true, "score": {"loc": 3, "tokens": 67, "cc": 0, "nest": 1, "execution_time": 0.016521, "novelty": 0.7517508589290338}}, {"code": "def binaryGap(n):\n    binary = bin(n)[2:]\n    ones = [i for i, bit in enumerate(binary) if bit == '1']\n    if len(ones) < 2:\n        return 0\n    return max(ones[i] - ones[i - 1] for i in range(1, len(ones)))", "passed": true, "score": {"loc": 6, "tokens": 74, "cc": 1, "nest": 2, "execution_time": 0.016649, "novelty": 0.7679569290967718}}, {"code": "def binaryGap(n):\n    max_distance = 0\n    last_one_position = -1\n    for i in reversed(range(32)):\n        if n & (1 << i):\n            if last_one_position != -1:\n                max_distance = max(max_distance, last_one_position - i)\n            last_one_position = i\n    return max_distance", "passed": true, "score": {"loc": 9, "tokens": 56, "cc": 3, "nest": 4, "execution_time": 0.016571, "novelty": 0.7012225121071938}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 24180, "entry_point": "simplifyPath", "best_list": [{"code": "def simplifyPath(path):\n    stack = []\n    for part in path.split('/'):\n        if part == '..':\n            if stack:\n                stack.pop()\n        elif part and part != '.':\n            stack.append(part)\n    return '/' + '/'.join(stack)", "passed": true, "score": {"loc": 9, "tokens": 68, "cc": 5, "nest": 4, "execution_time": 0.016593, "novelty": 0.061423162416921584}}, {"code": "def simplifyPath(path: str) -> str:\n    stack = []\n    for token in path.split('/'):\n        if token == '..':\n            if stack:\n                stack.pop()\n        elif token and token != '.':\n            stack.append(token)\n    return '/' + '/'.join(stack)", "passed": true, "score": {"loc": 9, "tokens": 73, "cc": 5, "nest": 4, "execution_time": 0.01664, "novelty": 0.15480785272885678}}, {"code": "def simplifyPath(path: str) -> str:\n    stack = []\n    for part in path.split('/'):\n        if part == '..':\n            if stack:\n                stack.pop()\n        elif part and part != '.':\n            stack.append(part)\n    return '/' + '/'.join(stack)", "passed": true, "score": {"loc": 9, "tokens": 73, "cc": 5, "nest": 4, "execution_time": 0.016666, "novelty": 0.047624823722942855}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 24234, "entry_point": "xorOperation", "best_list": [{"code": "def xorOperation(n, start):\n    result = 0\n    for i in range(n):\n        result ^= start + 2 * i\n    return result", "passed": true, "score": {"loc": 5, "tokens": 29, "cc": 1, "nest": 2, "execution_time": 0.016632, "novelty": 0.48252619500871885}}, {"code": "def xorOperation(n, start):\n    xor_result = 0\n    for i in range(n):\n        xor_result ^= start + 2 * i\n    return xor_result", "passed": true, "score": {"loc": 5, "tokens": 29, "cc": 1, "nest": 2, "execution_time": 0.016695, "novelty": 0.5751979379419369}}, {"code": "def xorOperation(n: int, start: int) -> int:\n    xor_result = 0\n    for i in range(n):\n        xor_result ^= start + 2 * i\n    return xor_result", "passed": true, "score": {"loc": 5, "tokens": 36, "cc": 1, "nest": 2, "execution_time": 0.01659, "novelty": 0.5927714773170498}}, {"code": "def xorOperation(n, start):\n    return reduce(lambda x, y: x ^ y, range(start, start + 2 * n, 2), 0)", "passed": false, "score": {"loc": 2, "tokens": 35, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.4719659909720644}}, {"code": "def xorOperation(n: int, start: int) -> int:\n    return reduce(xor, range(start, start + 2*n, 2))", "passed": false, "score": {"loc": 2, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.4682758323889129}}, {"code": "def xorOperation(n, start):\n    return reduce(lambda x, y: x ^ y, (start + 2*i for i in range(n)))", "passed": false, "score": {"loc": 2, "tokens": 35, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.4527774111514812}}, {"code": "def xorOperation(n, start):\n    return reduce(lambda x, i: x ^ (start + 2 * i), range(n), 0)", "passed": false, "score": {"loc": 2, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.41523076684010096}}, {"code": "def xorOperation(n, start):\n    return reduce(xor, (start + 2*i for i in range(n)))", "passed": false, "score": {"loc": 2, "tokens": 28, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.3844765002748973}}], "num_pass": 4, "num_uniq": 4, "num_fail": 6, "fail_uniq": 5}
{"id": 24283, "entry_point": "numWays", "best_list": [{"code": "MOD = 10**9 + 7\n\ndef numWays(steps: int, arrLen: int) -> int:\n    max_reach = min(steps // 2 + 1, arrLen)\n    dp = [1] + [0] * (max_reach - 1)\n    \n    for _ in range(steps):\n        ndp = [0] * max_reach\n        for i in range(max_reach):\n            ndp[i] = (dp[i] + (dp[i - 1] if i > 0 else 0) + (dp[i + 1] if i < max_reach - 1 else 0)) % MOD\n        dp = ndp\n    \n    return dp[0]", "passed": true, "score": {"loc": 10, "tokens": 127, "cc": 2, "nest": 3, "execution_time": 0.016722, "novelty": 0.5655972503947018}}, {"code": "def numWays(steps: int, arrLen: int) -> int:\n    MOD = 10**9 + 7\n    dp = [0] * min(steps // 2 + 1, arrLen) + [0]\n    dp[0] = 1\n    for _ in range(steps):\n        new_dp = [0] * len(dp)\n        for i in range(len(dp) - 1):\n            new_dp[i] = (dp[i] + dp[i + 1]) % MOD\n            if i > 0:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n        dp = new_dp\n    return dp[0]", "passed": true, "score": {"loc": 12, "tokens": 134, "cc": 3, "nest": 4, "execution_time": 0.016844, "novelty": 0.6337073969616692}}, {"code": "def numWays(steps, arrLen):\n    MOD = 10**9 + 7\n    arrLen = min(steps // 2 + 1, arrLen)\n    dp = [0] * arrLen\n    dp[0] = 1\n    for _ in range(steps):\n        new_dp = [0] * arrLen\n        for i in range(arrLen):\n            new_dp[i] = dp[i]\n            if i > 0:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n            if i < arrLen - 1:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    return dp[0]", "passed": true, "score": {"loc": 15, "tokens": 134, "cc": 4, "nest": 4, "execution_time": 0.016685, "novelty": 0.5915990193722839}}, {"code": "MOD = 10**9 + 7\n\ndef numWays(steps: int, arrLen: int) -> int:\n    max_pos = min(steps // 2, arrLen - 1)\n    dp = [0] * (max_pos + 2)\n    dp[1] = 1\n    \n    for _ in range(steps):\n        new_dp = [0] * (max_pos + 2)\n        for i in range(1, max_pos + 1):\n            new_dp[i] = (dp[i - 1] + dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return dp[1]", "passed": false, "score": {"loc": 11, "tokens": 119, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6132942200953151}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 24365, "entry_point": "findGoodStrings", "best_list": [{"code": "from functools import lru_cache\nfrom typing import Callable\n\ndef findGoodStrings(n: int, s1: str, s2: str, evil: str) -> int:\n    mod = 10**9 + 7\n    m = len(evil)\n\n    @lru_cache(None)\n    def dp(i: int, is_lo: bool, is_hi: bool, j: int) -> int:\n        if j == m:\n            return 0\n        if i == n:\n            return 1\n        lo = ord(s1[i]) if is_lo else ord('a')\n        hi = ord(s2[i]) if is_hi else ord('z')\n        res = 0\n        for c in range(lo, hi + 1):\n            if evil[j] == chr(c):\n                res += dp(i + 1, is_lo and c == lo, is_hi and c == hi, j + 1)\n            else:\n                idx = j\n                while idx > 0 and evil[idx] != chr(c):\n                    idx = evil.find(evil[:idx], idx - 1)\n                res += dp(i + 1, is_lo and c == lo, is_hi and c == hi, idx)\n        return res % mod\n\n    return dp(0, True, True, 0)", "passed": true, "score": {"loc": 24, "tokens": 256, "cc": 10, "nest": 5, "execution_time": 0.018142, "novelty": 0.8231832260470112}}, {"code": "def findGoodStrings(n, s1, s2, evil):\n    MOD = 10**9 + 7\n    \n    def z_function(s):\n        z = [0] * len(s)\n        l, r = 0, 0\n        for i in range(1, len(s)):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n            while i + z[i] < len(s) and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n            if i + z[i] - 1 > r:\n                l, r = i, i + z[i] - 1\n        return z\n    \n    def count_good_strings(s, evil):\n        z = z_function(evil)\n        dp = [[0] * (len(evil) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            dp[i][0] = sum(dp[i-1]) % MOD\n            for j in range(1, min(i, len(evil)) + 1):\n                if s[i-1] == evil[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = dp[i-1][0] - dp[i-z[j]][j] + dp[i-z[j]-1][0]\n                    if dp[i][j] < 0:\n                        dp[i][j] += MOD\n        \n        return sum(dp[-1]) % MOD\n    \n    count_s1 = count_good_strings(s1, evil)\n    count_s2 = count_good_strings(s2, evil)\n    \n    if s1 < s2:\n        return (count_s2 - count_s1 + MOD) % MOD\n    else:\n        return count_s2", "passed": false, "score": {"loc": 33, "tokens": 403, "cc": 10, "nest": 6, "execution_time": 10.0, "novelty": 0.7678313195066262}}, {"code": "MOD = 10**9 + 7\n\ndef findGoodStrings(n, s1, s2, evil):\n    def z_function(s):\n        z = [0] * len(s)\n        l, r = 0, 0\n        for i in range(1, len(s)):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n            while i + z[i] < len(s) and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n            if i + z[i] - 1 > r:\n                l, r = i, i + z[i] - 1\n        return z\n\n    def count_less_than(s, evil):\n        m = len(evil)\n        z = z_function(evil)\n        dp = [[0] * (m + 1) for _ in range(2)]\n        dp[0][0] = 1\n        for i, char in enumerate(s):\n            for j in range(m + 1):\n                if j == 0:\n                    dp[1][j] = (dp[0][j] * 26) % MOD\n                else:\n                    dp[1][j] = (dp[0][j] * 25 + dp[1][j - 1]) % MOD\n            for j in range(m, 0, -1):\n                if s[i] < evil[j - 1]:\n                    dp[1][j] = (dp[1][j] - dp[0][j - 1]) % MOD\n                    if dp[1][j] < 0:\n                        dp[1][j] += MOD\n            dp[0], dp[1] = dp[1], [0] * (m + 1)\n        return dp[0][0]\n\n    return (count_less_than(s2, evil) - count_less_than(s1, evil) - (evil in s1) + MOD) % MOD", "passed": false, "score": {"loc": 32, "tokens": 412, "cc": 11, "nest": 6, "execution_time": 10.0, "novelty": 0.8757814398501359}}, {"code": "def findGoodStrings(n, s1, s2, evil):\n    MOD = 10**9 + 7\n\n    def z_function(s):\n        z = [0] * len(s)\n        l, r = 0, 0\n        for i in range(1, len(s)):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n            while i + z[i] < len(s) and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n            if i + z[i] - 1 > r:\n                l, r = i, i + z[i] - 1\n        return z\n\n    def helper(s, evil, z):\n        @lru_cache(None)\n        def dp(i, j, lo, hi):\n            if j == len(evil):\n                return 0\n            if i == len(s):\n                return 1\n            cmin = ord(s[i]) if lo else ord('a')\n            cmax = ord(s[i]) if hi else ord('z')\n            res = 0\n            for c in range(cmin, cmax + 1):\n                if evil[j] == chr(c):\n                    res += dp(i + 1, j + 1, lo and c == cmin, hi and c == cmax)\n                else:\n                    res += dp(i + 1, j, lo and c == cmin, hi and c == cmax)\n            res %= MOD\n            return res\n\n        return dp(0, 0, True, True)\n\n    z = z_function(evil)\n    return (helper(s2, evil, z) - helper(s1, evil, z) + MOD) % MOD", "passed": false, "score": {"loc": 33, "tokens": 362, "cc": 13, "nest": 5, "execution_time": 10.0, "novelty": 0.7488855148234843}}, {"code": "from functools import lru_cache\n\ndef findGoodStrings(n, s1, s2, evil):\n    MOD = 10**9 + 7\n    e_len = len(evil)\n\n    @lru_cache(None)\n    def count(s, i, j):\n        if j < 0:\n            return 1\n        if i == 0:\n            return sum(count(s, 0, j - ord(c) + 97) for c in 'abcdefghijklmnopqrstuvwxyz') % MOD\n        res = 0\n        for c in 'abcdefghijklmnopqrstuvwxyz':\n            if ord(c) >= ord(s[i - 1]):\n                res = (res + count(s, i - 1, j - (ord(c) - ord(s[i - 1])) if j >= ord(c) - ord(s[i - 1]) else -1)) % MOD\n        return res\n\n    @lru_cache(None)\n    def has_evil(s, i, j):\n        if j < 0:\n            return False\n        if i == 0:\n            return has_evil(s, 0, j - ord(s[i - 1]) + 97) or evil[j] in s\n        if evil[j] == s[i - 1]:\n            return has_evil(s, i - 1, j - 1)\n        return has_evil(s, i - 1, e_len - 1)\n\n    def count_good(s):\n        return count(s, len(s), e_len - 1)\n\n    def count_evil(s):\n        return has_evil(s, len(s), e_len - 1)\n\n    return (count_good(s2) - count_good(s1) + MOD + count_good(s1) - count_evil(s1)) % MOD", "passed": false, "score": {"loc": 29, "tokens": 332, "cc": 8, "nest": 4, "execution_time": 10.0, "novelty": 0.8510136150532172}}, {"code": "def findGoodStrings(n: int, s1: str, s2: str, evil: str) -> int:\n    mod = 10**9 + 7\n\n    def count_up_to(s: str) -> int:\n        dp = [0] * (len(evil) + 1)\n        for char in s:\n            for i in range(len(evil), 0, -1):\n                if evil[i-1] == char:\n                    dp[i] = dp[i-1]\n                    break\n            dp[0] += 1\n        return dp[0]\n\n    def count_less_than(s: str) -> int:\n        dp = [0] * (len(evil) + 1)\n        for i, char in enumerate(s):\n            dp[0] += 26 ** (len(s) - i - 1)\n            for j in range(len(evil), 0, -1):\n                if evil[j-1] == char:\n                    dp[j] = dp[j-1]\n                    break\n            if dp[j] == 0:\n                return dp[0]\n        return dp[0]\n\n    def count_good_strings(left: int, right: int) -> int:\n        return (count_less_than(s2) - count_less_than(s1) + count_up_to(s2) - count_up_to(s1) + mod) % mod\n\n    return count_good_strings(0, n-1)", "passed": false, "score": {"loc": 25, "tokens": 274, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.7977453633645342}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 24390, "entry_point": "reverseWords", "best_list": [{"code": "def reverseWords(s):\n    return ' '.join(word[::-1] for word in s.split())", "passed": true, "score": {"loc": 2, "tokens": 28, "cc": 0, "nest": 1, "execution_time": 0.016462, "novelty": 0.02504382669671934}}, {"code": "def reverseWords(s: str) -> str:\n    return ' '.join(word[::-1] for word in s.split())", "passed": true, "score": {"loc": 2, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016613, "novelty": 0.037565740045078844}}], "num_pass": 10, "num_uniq": 2, "num_fail": 0, "fail_uniq": 0}
{"id": 24417, "entry_point": "is_leap", "best_list": [{"code": "def is_leap(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)", "passed": true, "score": {"loc": 2, "tokens": 29, "cc": 2, "nest": 1, "execution_time": 0.016558, "novelty": 0.1575032332125721}}, {"code": "def is_leap(year):\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)", "passed": true, "score": {"loc": 2, "tokens": 31, "cc": 2, "nest": 1, "execution_time": 0.016642, "novelty": 0.14069886647513963}}, {"code": "def is_leap(year):\n    leap_conditions = [year % 400 == 0, year % 100 == 0, year % 4 == 0]\n    return leap_conditions[0] or (not leap_conditions[1] and leap_conditions[2])", "passed": true, "score": {"loc": 3, "tokens": 48, "cc": 2, "nest": 1, "execution_time": 0.016632, "novelty": 0.5511931152190843}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 24452, "entry_point": "longestDupSubstring", "best_list": [{"code": "def longestDupSubstring(S):\n    n = len(S)\n    left, right = 0, n\n    while left < right:\n        mid = (left + right + 1) // 2\n        if find_dup(S, mid) != -1:\n            left = mid\n        else:\n            right = mid - 1\n    start = find_dup(S, left)\n    return S[start:start + left] if start != -1 else \"\"\n\ndef find_dup(S, length):\n    seen = set()\n    for i in range(len(S) - length + 1):\n        substring = S[i:i + length]\n        if substring in seen:\n            return i\n        seen.add(substring)\n    return -1", "passed": true, "score": {"loc": 19, "tokens": 138, "cc": 4, "nest": 3, "execution_time": 0.016799, "novelty": 0.6997499437225929}}, {"code": "def longestDupSubstring(S):\n    n = len(S)\n    left, right = 0, n - 1\n    result = \"\"\n\n    while left < right:\n        mid = (left + right + 1) // 2\n        found = False\n        seen = set()\n        for i in range(n - mid + 1):\n            substring = S[i:i + mid]\n            if substring in seen:\n                found = True\n                result = substring\n                break\n            seen.add(substring)\n        if found:\n            left = mid\n        else:\n            right = mid - 1\n\n    return result", "passed": true, "score": {"loc": 20, "tokens": 105, "cc": 4, "nest": 4, "execution_time": 0.016606, "novelty": 0.5821078544996034}}, {"code": "def longestDupSubstring(S: str) -> str:\n    n = len(S)\n    left, right = 0, n\n    result = \"\"\n    \n    while left < right:\n        mid = (left + right) // 2\n        seen = set()\n        found = False\n        \n        for i in range(n - mid + 1):\n            substring = S[i:i + mid]\n            if substring in seen:\n                result = substring\n                found = True\n                break\n            seen.add(substring)\n        \n        if found:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return result", "passed": true, "score": {"loc": 20, "tokens": 106, "cc": 4, "nest": 4, "execution_time": 0.016805, "novelty": 0.5759264815237972}}, {"code": "def longestDupSubstring(S):\n    n = len(S)\n    ans = \"\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            if S[i:j] in S[j:]:\n                ans = max(ans, S[i:j], key=len)\n    return ans", "passed": false, "score": {"loc": 8, "tokens": 69, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.731788698135178}}, {"code": "def longestDupSubstring(S):\n    def binary_search(left, right):\n        while left < right:\n            mid = (left + right + 1) // 2\n            if has_duplicate(S, mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left\n\n    def has_duplicate(S, length):\n        seen = set()\n        for i in range(len(S) - length + 1):\n            substring = S[i:i + length]\n            if substring in seen:\n                return True\n            seen.add(substring)\n        return False\n\n    if len(S) < 2:\n        return \"\"\n    return S[binary_search(0, len(S) - 1)]", "passed": false, "score": {"loc": 20, "tokens": 130, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.7844662998713474}}, {"code": "def longestDupSubstring(S):\n    n = len(S)\n    left, right = 0, n - 1\n    result = \"\"\n    \n    while left <= right:\n        mid = (left + right) // 2\n        substring = \"\"\n        found = False\n        \n        for i in range(n - mid + 1):\n            sub = S[i:i+mid]\n            if sub not in substring:\n                substring += sub\n            else:\n                result = sub\n                found = True\n                break\n        \n        if found:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result", "passed": false, "score": {"loc": 21, "tokens": 106, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.6158122258976555}}, {"code": "def longestDupSubstring(S: str) -> str:\n    n = len(S)\n    substrings = sorted(S[i:j] for i in range(n) for j in range(i + 1, n + 1))\n    longest = \"\"\n    for i in range(1, len(substrings)):\n        if substrings[i] == substrings[i - 1]:\n            longest = substrings[i]\n    return longest", "passed": false, "score": {"loc": 8, "tokens": 87, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7634953444224476}}, {"code": "def longestDupSubstring(S: str) -> str:\n    n = len(S)\n    def binarySearch(left, right):\n        while left < right:\n            mid = (left + right + 1) // 2\n            if hasDuplicate(S, mid):\n                left = mid\n            else:\n                right = mid - 1\n        return left\n\n    def hasDuplicate(s, length):\n        seen = set()\n        for i in range(len(s) - length + 1):\n            substring = s[i:i + length]\n            if substring in seen:\n                return True\n            seen.add(substring)\n        return False\n\n    length = binarySearch(0, n - 1)\n    return S[:length]\n\n# Unit tests\nassert longestDupSubstring(\"banana\") == \"ana\"\nassert longestDupSubstring(\"abcd\") == \"\"\nassert longestDupSubstring(\"pineapple\") == \"app\"\nassert longestDupSubstring(\"mississippi\") == \"issi\"\nassert longestDupSubstring(\"a\") == \"\"\nassert longestDupSubstring(\"aa\") == \"a\"", "passed": false, "score": {"loc": 27, "tokens": 204, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.7634483862605851}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 2460, "entry_point": "validMountainArray", "best_list": [{"code": "def validMountainArray(A):\n    if len(A) < 3:\n        return False\n    i = 0\n    while i + 1 < len(A) and A[i] < A[i + 1]:\n        i += 1\n    if i == 0 or i + 1 == len(A):\n        return False\n    while i + 1 < len(A) and A[i] > A[i + 1]:\n        i += 1\n    return i + 1 == len(A)", "passed": true, "score": {"loc": 11, "tokens": 99, "cc": 7, "nest": 2, "execution_time": 0.016708, "novelty": 0.29187400331848057}}, {"code": "def validMountainArray(A):\n    n = len(A)\n    if n < 3:\n        return False\n    i = 0\n    while i + 1 < n and A[i] < A[i + 1]:\n        i += 1\n    if i == 0 or i == n - 1:\n        return False\n    while i + 1 < n and A[i] > A[i + 1]:\n        i += 1\n    return i == n - 1", "passed": true, "score": {"loc": 12, "tokens": 90, "cc": 7, "nest": 2, "execution_time": 0.016526, "novelty": 0.06582450511336546}}, {"code": "def validMountainArray(A):\n    if len(A) < 3:\n        return False\n    \n    i = 0\n    \n    # Walk up\n    while i + 1 < len(A) and A[i] < A[i + 1]:\n        i += 1\n    \n    # Peak can't be the first or last\n    if i == 0 or i == len(A) - 1:\n        return False\n    \n    # Walk down\n    while i + 1 < len(A) and A[i] > A[i + 1]:\n        i += 1\n    \n    return i == len(A) - 1", "passed": true, "score": {"loc": 14, "tokens": 115, "cc": 7, "nest": 2, "execution_time": 0.016635, "novelty": 0.1386580412431383}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 24533, "entry_point": "maxPerformance", "best_list": [{"code": "from heapq import heappush, heappop\n\ndef maxPerformance(n, speed, efficiency, k):\n    MOD = 10**9 + 7\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    heap = []\n    total_speed = 0\n    max_performance = 0\n    \n    for eff, spd in engineers:\n        if len(heap) == k:\n            total_speed -= heappop(heap)\n        heappush(heap, spd)\n        total_speed += spd\n        max_performance = max(max_performance, total_speed * eff)\n    \n    return max_performance % MOD", "passed": true, "score": {"loc": 14, "tokens": 98, "cc": 2, "nest": 3, "execution_time": 0.016598, "novelty": 0.31599079640165584}}, {"code": "from typing import List\nfrom heapq import heappush, heappop\n\ndef maxPerformance(n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n    MOD = 10**9 + 7\n    heap = []\n    total_speed = 0\n    max_performance = 0\n    \n    for e, s in sorted(zip(efficiency, speed), reverse=True):\n        heappush(heap, s)\n        total_speed += s\n        if len(heap) > k:\n            total_speed -= heappop(heap)\n        max_performance = max(max_performance, total_speed * e)\n    \n    return max_performance % MOD", "passed": true, "score": {"loc": 14, "tokens": 115, "cc": 2, "nest": 3, "execution_time": 0.018019, "novelty": 0.3664856109990381}}, {"code": "from heapq import heappush, heappop\nfrom typing import List\n\ndef maxPerformance(n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n    MOD = 10**9 + 7\n    pq = []\n    spd_sum = 0\n    best_perf = 0\n    \n    for eff, spd in sorted(zip(efficiency, speed), reverse=True):\n        spd_sum += spd\n        heappush(pq, spd)\n        if len(pq) > k:\n            spd_sum -= heappop(pq)\n        best_perf = max(best_perf, spd_sum * eff)\n    \n    return best_perf % MOD", "passed": true, "score": {"loc": 14, "tokens": 115, "cc": 2, "nest": 3, "execution_time": 0.018182, "novelty": 0.4079662936767764}}, {"code": "def maxPerformance(n, speed, efficiency, k):\n    MOD = 10**9 + 7\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    speed_sum = 0\n    heap = []\n    best_performance = 0\n    \n    for eff, spd in engineers:\n        speed_sum += spd\n        heapq.heappush(heap, spd)\n        if len(heap) > k:\n            speed_sum -= heapq.heappop(heap)\n        best_performance = max(best_performance, speed_sum * eff)\n    \n    return best_performance % MOD", "passed": false, "score": {"loc": 13, "tokens": 95, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.36580215230467417}}, {"code": "def maxPerformance(n, speed, efficiency, k):\n    MOD = 10**9 + 7\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    heap = []\n    total_speed = 0\n    max_perf = 0\n\n    for e, s in engineers:\n        if len(heap) == k:\n            total_speed -= heapq.heappop(heap)\n        heapq.heappush(heap, s)\n        total_speed += s\n        max_perf = max(max_perf, total_speed * e)\n\n    return max_perf % MOD", "passed": false, "score": {"loc": 13, "tokens": 96, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.31151591781507293}}, {"code": "from typing import List\n\ndef maxPerformance(n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n    MOD = 10**9 + 7\n    engineers = sorted(zip(efficiency, speed), reverse=True)\n    max_performance = curr_speed = 0\n    heap = []\n    \n    for eff, spd in engineers:\n        if len(heap) == k:\n            curr_speed -= heapq.heappop(heap)\n        heapq.heappush(heap, spd)\n        curr_speed += spd\n        max_performance = max(max_performance, curr_speed * eff)\n    \n    return max_performance % MOD", "passed": false, "score": {"loc": 13, "tokens": 116, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.3706322442035046}}, {"code": "def maxPerformance(n, speed, efficiency, k):\n    MOD = 10**9 + 7\n    workers = sorted(zip(efficiency, speed), reverse=True)\n    total_speed = 0\n    min_heap = []\n    max_performance = 0\n    \n    for eff, spd in workers:\n        if len(min_heap) == k:\n            total_speed -= heapq.heappop(min_heap)\n        heapq.heappush(min_heap, spd)\n        total_speed += spd\n        max_performance = max(max_performance, total_speed * eff)\n    \n    return max_performance % MOD", "passed": false, "score": {"loc": 13, "tokens": 96, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.3548850647045543}}, {"code": "def maxPerformance(n, speed, efficiency, k):\n    MOD = 10**9 + 7\n    heap = []\n    total_speed = 0\n    max_perf = 0\n\n    for e, s in sorted(zip(efficiency, speed), reverse=True):\n        heapq.heappush(heap, s)\n        total_speed += s\n        if len(heap) > k:\n            total_speed -= heapq.heappop(heap)\n        max_perf = max(max_perf, total_speed * e)\n\n    return max_perf % MOD", "passed": false, "score": {"loc": 12, "tokens": 92, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.30360004639481175}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 24600, "entry_point": "numFriendRequests", "best_list": [{"code": "def numFriendRequests(ages):\n    def valid_request(a, b):\n        return b > 0.5 * a + 7 and b <= a\n\n    count = 0\n    for i in range(len(ages)):\n        for j in range(len(ages)):\n            if i != j and valid_request(ages[i], ages[j]):\n                count += 1\n    return count", "passed": true, "score": {"loc": 9, "tokens": 79, "cc": 5, "nest": 4, "execution_time": 0.016657, "novelty": 0.8178285790419505}}, {"code": "def numFriendRequests(ages):\n    count = 0\n    age_counts = [0] * 121\n    for age in ages:\n        age_counts[age] += 1\n    for age in range(1, 121):\n        total = 0\n        for other_age in range(age // 2 + 8, age + 1):\n            total += age_counts[other_age]\n        count += age_counts[age] * total - age_counts[age]\n    return count", "passed": true, "score": {"loc": 11, "tokens": 81, "cc": 3, "nest": 3, "execution_time": 0.016767, "novelty": 0.6108674484828713}}, {"code": "def numFriendRequests(ages):\n    count = [0] * 121\n    for age in ages:\n        count[age] += 1\n    \n    total_requests = 0\n    cumulative_count = [0] * 121\n    for i in range(1, 121):\n        cumulative_count[i] = cumulative_count[i - 1] + count[i]\n    \n    for age in ages:\n        lower_bound = age // 2 + 8\n        upper_bound = age\n        total_requests += max(0, cumulative_count[upper_bound] - cumulative_count[lower_bound - 1] - 1)\n    \n    return total_requests", "passed": true, "score": {"loc": 13, "tokens": 100, "cc": 3, "nest": 2, "execution_time": 0.016797, "novelty": 0.7096306171166773}}, {"code": "def numFriendRequests(ages):\n    age_counts = [0] * 121\n    for age in ages:\n        age_counts[age] += 1\n    \n    total_requests = 0\n    for age, count in enumerate(age_counts):\n        if count == 0:\n            continue\n        upper_bound = age // 2 + 8\n        for other_age, other_count in enumerate(age_counts):\n            if other_age <= upper_bound or other_age > age:\n                total_requests += count * other_count - (count * (count - 1) // 2 if age == other_age else 0)\n    \n    return total_requests", "passed": false, "score": {"loc": 13, "tokens": 101, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.7587235662458466}}, {"code": "def numFriendRequests(ages):\n    count = 0\n    age_counts = [0] * 121\n    for age in ages:\n        age_counts[age] += 1\n    for age in range(1, 121):\n        for other_age in range(0.5 * age + 8, age):\n            count += age_counts[other_age]\n    return count", "passed": false, "score": {"loc": 9, "tokens": 63, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5839523619097555}}, {"code": "def numFriendRequests(ages):\n    count = 0\n    age_counts = [0] * 121\n    for age in ages:\n        age_counts[age] += 1\n    \n    for age in range(1, 121):\n        for other_age in range(age // 2 + 8, age + 1):\n            count += age_counts[other_age]\n        if age > 100:\n            count -= age_counts[age]\n    \n    return count", "passed": false, "score": {"loc": 11, "tokens": 76, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.61885883661194}}, {"code": "def numFriendRequests(ages):\n    count = 0\n    ages.sort()\n    age_counts = {}\n    for age in ages:\n        age_counts[age] = age_counts.get(age, 0) + 1\n    for age in ages:\n        lower_bound = age // 2 + 8\n        upper_bound = age\n        count += sum(age_counts[a] for a in range(lower_bound, upper_bound + 1) if a != age)\n    return count", "passed": false, "score": {"loc": 11, "tokens": 82, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.7513669971265515}}, {"code": "def numFriendRequests(ages):\n    ages.sort()\n    requests = 0\n    j = 0\n    for i, age in enumerate(ages):\n        while j < i and not (ages[j] <= 0.5 * age + 7 or ages[j] > age):\n            j += 1\n        requests += i - j\n    return requests", "passed": false, "score": {"loc": 9, "tokens": 68, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7267922826173154}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 24657, "entry_point": "numTrees", "best_list": [{"code": "def numTrees(n):\n    if n <= 1:\n        return 1\n    return sum(numTrees(i) * numTrees(n - i - 1) for i in range(n))", "passed": true, "score": {"loc": 4, "tokens": 38, "cc": 1, "nest": 2, "execution_time": 0.016544, "novelty": 0.7018796638426368}}, {"code": "def numTrees(n):\n    if n == 0:\n        return 1\n    return sum(numTrees(i-1) * numTrees(n-i) for i in range(1, n+1))", "passed": true, "score": {"loc": 4, "tokens": 42, "cc": 1, "nest": 2, "execution_time": 0.016589, "novelty": 0.7132544249670483}}, {"code": "def numTrees(n):\n    memo = [0] * (n + 1)\n    memo[0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            memo[i] += memo[j - 1] * memo[i - j]\n    return memo[n]", "passed": true, "score": {"loc": 7, "tokens": 71, "cc": 2, "nest": 3, "execution_time": 0.016585, "novelty": 0.24445832340097118}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 24721, "entry_point": "largestRectangleArea", "best_list": [{"code": "def largestRectangleArea(heights):\n    def helper(left, right):\n        if left > right:\n            return 0\n        min_index = left\n        for i in range(left, right + 1):\n            if heights[i] < heights[min_index]:\n                min_index = i\n        return max(heights[min_index] * (right - left + 1), helper(left, min_index - 1), helper(min_index + 1, right))\n    return helper(0, len(heights) - 1)", "passed": true, "score": {"loc": 10, "tokens": 96, "cc": 3, "nest": 4, "execution_time": 0.016592, "novelty": 0.830031678649757}}, {"code": "def largestRectangleArea(heights):\n    stack, max_area = [], 0\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] > h:\n            j, h2 = stack.pop()\n            max_area = max(max_area, h2 * (i - j))\n            start = j\n        stack.append((start, h))\n    for i, h in stack:\n        max_area = max(max_area, h * (len(heights) - i))\n    return max_area", "passed": true, "score": {"loc": 12, "tokens": 103, "cc": 4, "nest": 3, "execution_time": 0.016572, "novelty": 0.5084299002115138}}, {"code": "def largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] > h:\n            j, h2 = stack.pop()\n            max_area = max(max_area, h2 * (i - j))\n            start = j\n        stack.append((start, h))\n    for j, h2 in stack:\n        max_area = max(max_area, h2 * (len(heights) - j))\n    return max_area", "passed": true, "score": {"loc": 13, "tokens": 102, "cc": 4, "nest": 3, "execution_time": 0.016436, "novelty": 0.4780675887979777}}, {"code": "def largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights + [0]):\n        while stack and h < heights[stack[-1]]:\n            h_index = stack.pop()\n            width = i - stack[-1] - 1 if stack else i\n            max_area = max(max_area, h * width)\n        stack.append(i)\n    return max_area", "passed": false, "score": {"loc": 10, "tokens": 81, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5310589318852859}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 24825, "entry_point": "singleNumber", "best_list": [{"code": "def singleNumber(nums):\n    return 2 * sum(set(nums)) - sum(nums)", "passed": true, "score": {"loc": 2, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 0.016404, "novelty": 0.12427184466019425}}, {"code": "def singleNumber(nums):\n    return sum(nums) - 2 * sum(set(nums))", "passed": false, "score": {"loc": 2, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.13462783171521042}}], "num_pass": 6, "num_uniq": 1, "num_fail": 4, "fail_uniq": 1}
{"id": 24842, "entry_point": "validateStackSequences", "best_list": [{"code": "def validateStackSequences(pushed, popped):\n    stack = []\n    for x in pushed:\n        stack.append(x)\n        while stack and stack[-1] == popped[0]:\n            stack.pop()\n            popped.pop(0)\n    return not stack", "passed": true, "score": {"loc": 8, "tokens": 52, "cc": 3, "nest": 3, "execution_time": 0.016729, "novelty": 0.16752800826482972}}, {"code": "def validateStackSequences(pushed, popped):\n    stack = []\n    j = 0\n    for x in pushed:\n        stack.append(x)\n        while stack and stack[-1] == popped[j]:\n            stack.pop()\n            j += 1\n    return not stack", "passed": true, "score": {"loc": 9, "tokens": 53, "cc": 3, "nest": 3, "execution_time": 0.016549, "novelty": 0.08873616339701451}}, {"code": "def validateStackSequences(pushed, popped):\n    stack = []\n    i = 0\n    for x in pushed:\n        stack.append(x)\n        while stack and stack[-1] == popped[i]:\n            stack.pop()\n            i += 1\n    return not stack", "passed": true, "score": {"loc": 9, "tokens": 53, "cc": 3, "nest": 3, "execution_time": 0.016592, "novelty": 0.08840859642010435}}, {"code": "def validateStackSequences(pushed, popped):\n    stack = []\n    for push, pop in zip(pushed, popped):\n        stack.append(push)\n        while stack and stack[-1] == pop:\n            stack.pop()\n    return not stack", "passed": false, "score": {"loc": 7, "tokens": 50, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5790158079613679}}], "num_pass": 9, "num_uniq": 5, "num_fail": 1, "fail_uniq": 1}
{"id": 24882, "entry_point": "maxVowels", "best_list": [{"code": "def maxVowels(s, k):\n    vowels = set(\"aeiou\")\n    return max(sum(1 for char in s[i:i+k] if char in vowels) for i in range(len(s) - k + 1))", "passed": true, "score": {"loc": 3, "tokens": 53, "cc": 0, "nest": 1, "execution_time": 0.016648, "novelty": 0.6568567577286045}}, {"code": "def maxVowels(s: str, k: int) -> int:\n    vowels = \"aeiou\"\n    return max(sum(1 for char in s[i:i+k] if char in vowels) for i in range(len(s) - k + 1))", "passed": true, "score": {"loc": 3, "tokens": 57, "cc": 0, "nest": 1, "execution_time": 0.016581, "novelty": 0.5332508236035274}}, {"code": "def maxVowels(s, k):\n    vowels = set('aeiou')\n    count = sum(1 for char in s[:k] if char in vowels)\n    max_count = count\n    for i in range(k, len(s)):\n        count += (1 if s[i] in vowels else 0) - (1 if s[i - k] in vowels else 0)\n        max_count = max(max_count, count)\n    return max_count", "passed": true, "score": {"loc": 8, "tokens": 90, "cc": 1, "nest": 2, "execution_time": 0.016668, "novelty": 0.6029108160905572}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 24896, "entry_point": "isMonotonic", "best_list": [{"code": "def isMonotonic(A):\n    return A == sorted(A) or A == sorted(A, reverse=True)", "passed": true, "score": {"loc": 2, "tokens": 26, "cc": 1, "nest": 1, "execution_time": 0.016598, "novelty": 0.6065716156951304}}, {"code": "def isMonotonic(A):\n    return all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or all(A[i] >= A[i + 1] for i in range(len(A) - 1))", "passed": true, "score": {"loc": 2, "tokens": 62, "cc": 1, "nest": 1, "execution_time": 0.016735, "novelty": 0.51425083061695}}, {"code": "def isMonotonic(A):\n    increasing = decreasing = True\n    for i in range(1, len(A)):\n        if A[i] < A[i - 1]:\n            increasing = False\n        if A[i] > A[i - 1]:\n            decreasing = False\n    return increasing or decreasing", "passed": true, "score": {"loc": 8, "tokens": 60, "cc": 4, "nest": 3, "execution_time": 0.016358, "novelty": 0.5940957894973551}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 24929, "entry_point": "numOfMinutes", "best_list": [{"code": "def numOfMinutes(n: int, headID: int, manager: list[int], informTime: list[int]) -> int:\n    def dfs(i: int) -> int:\n        return informTime[i] + max((dfs(j) for j in range(n) if manager[j] == i), default=0)\n    return dfs(headID)", "passed": true, "score": {"loc": 4, "tokens": 79, "cc": 0, "nest": 2, "execution_time": 0.016734, "novelty": 0.6703830016031471}}, {"code": "def numOfMinutes(n, headID, manager, informTime):\n    def dfs(i):\n        if manager[i] == -1:\n            return informTime[i]\n        return informTime[i] + dfs(manager[i])\n    \n    return max(dfs(i) for i in range(n))", "passed": true, "score": {"loc": 6, "tokens": 61, "cc": 1, "nest": 3, "execution_time": 0.016608, "novelty": 0.6981286336783257}}, {"code": "def numOfMinutes(n, headID, manager, informTime):\n    def dfs(employee):\n        if manager[employee] == -1:\n            return 0\n        manager[employee] = dfs(manager[employee])\n        return manager[employee] + informTime[employee]\n    \n    return max(dfs(i) for i in range(n))", "passed": true, "score": {"loc": 7, "tokens": 67, "cc": 1, "nest": 3, "execution_time": 0.016619, "novelty": 0.721078657727092}}, {"code": "def numOfMinutes(n, headID, manager, informTime):\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for i, m in enumerate(manager):\n        graph[m].append(i)\n    \n    def dfs(node):\n        return informTime[node] + max(dfs(sub) for sub in graph[node], default=0)\n    \n    return dfs(headID)", "passed": false, "score": {"loc": 8, "tokens": 76, "cc": 1000000000, "nest": 1000000000, "execution_time": 10.0, "novelty": 0.9568312886557362}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 24950, "entry_point": "minMoves", "best_list": [{"code": "def minMoves(nums):\n    return sum(nums) - len(nums) * min(nums)", "passed": true, "score": {"loc": 2, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 0.016477, "novelty": 0.19260759312760378}}, {"code": "def minMoves(nums):\n    min_num = min(nums)\n    return sum(num - min_num for num in nums)", "passed": true, "score": {"loc": 3, "tokens": 23, "cc": 0, "nest": 1, "execution_time": 0.016425, "novelty": 0.5331331843276468}}, {"code": "def minMoves(nums):\n    min_val = min(nums)\n    return sum(num - min_val for num in nums)", "passed": true, "score": {"loc": 3, "tokens": 23, "cc": 0, "nest": 1, "execution_time": 0.016653, "novelty": 0.5575326644777903}}, {"code": "def minMoves(nums):\n    return (len(nums) - 1) * (max(nums) - min(nums))", "passed": false, "score": {"loc": 2, "tokens": 27, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.5261359143265234}}], "num_pass": 9, "num_uniq": 4, "num_fail": 1, "fail_uniq": 1}
{"id": 258, "entry_point": "bitwiseComplement", "best_list": [{"code": "def bitwiseComplement(N):\n    return N ^ (2**N.bit_length() - 1)", "passed": true, "score": {"loc": 2, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 0.016681, "novelty": 0.6053861755877972}}, {"code": "def bitwiseComplement(N):\n    return int(''.join('0' if bit == '1' else '1' for bit in bin(N)[2:]), 2)", "passed": true, "score": {"loc": 2, "tokens": 43, "cc": 0, "nest": 1, "execution_time": 0.01645, "novelty": 0.5711567779361578}}, {"code": "def bitwiseComplement(N):\n    return int(''.join('1' if bit == '0' else '0' for bit in bin(N)[2:]), 2)", "passed": true, "score": {"loc": 2, "tokens": 43, "cc": 0, "nest": 1, "execution_time": 0.016596, "novelty": 0.6623644753710807}}, {"code": "def bitwiseComplement(N):\n    mask = 0\n    while N > 0:\n        mask = (mask << 1) | 1\n        N >>= 1\n    return ~N & mask", "passed": false, "score": {"loc": 6, "tokens": 34, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.5009519333460979}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 25053, "entry_point": "validateBinaryTreeNodes", "best_list": [{"code": "def validateBinaryTreeNodes(n, leftChild, rightChild):\n    indegree = [0] * n\n    for i in range(n):\n        if leftChild[i] != -1:\n            indegree[leftChild[i]] += 1\n        if rightChild[i] != -1:\n            indegree[rightChild[i]] += 1\n    root = [i for i in range(n) if indegree[i] == 0]\n    return len(root) == 1", "passed": true, "score": {"loc": 9, "tokens": 93, "cc": 3, "nest": 3, "execution_time": 0.01663, "novelty": 0.547932644259592}}, {"code": "def validateBinaryTreeNodes(n, leftChild, rightChild):\n    indegree = [0] * n\n    for i in range(n):\n        if leftChild[i] != -1:\n            indegree[leftChild[i]] += 1\n        if rightChild[i] != -1:\n            indegree[rightChild[i]] += 1\n    \n    root_count = 0\n    for i in range(n):\n        if indegree[i] == 0:\n            root_count += 1\n    \n    return root_count == 1", "passed": true, "score": {"loc": 12, "tokens": 94, "cc": 5, "nest": 3, "execution_time": 0.016508, "novelty": 0.534932243459105}}, {"code": "def validateBinaryTreeNodes(n, leftChild, rightChild):\n    def has_one_root_and_no_cycles():\n        parent = [-1] * n\n        for i in range(n):\n            for child in [leftChild[i], rightChild[i]]:\n                if child != -1:\n                    if parent[child] != -1:\n                        return False\n                    parent[child] = i\n        root_count = sum(1 for p in parent if p == -1)\n        return root_count == 1\n\n    return has_one_root_and_no_cycles()", "passed": true, "score": {"loc": 12, "tokens": 96, "cc": 4, "nest": 6, "execution_time": 0.016694, "novelty": 0.7093228506534113}}, {"code": "def validateBinaryTreeNodes(n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n    def dfs(node, parent):\n        if node == -1:\n            return True\n        if node in seen:\n            return False\n        seen.add(node)\n        return dfs(leftChild[node], node) and dfs(rightChild[node], node)\n    \n    seen = set()\n    root = -1\n    for i in range(n):\n        if leftChild[i] != -1:\n            if leftChild[i] in seen:\n                return False\n            if root != -1:\n                return False\n            root = leftChild[i]\n        if rightChild[i] != -1:\n            if rightChild[i] in seen:\n                return False\n            if root != -1 and root != leftChild[i]:\n                return False\n            root = rightChild[i]\n    \n    return root != -1 and dfs(root, -1) and len(seen) == n", "passed": false, "score": {"loc": 24, "tokens": 192, "cc": 12, "nest": 4, "execution_time": 10.0, "novelty": 0.728552398963873}}, {"code": "def validateBinaryTreeNodes(n, leftChild, rightChild):\n    def dfs(node, visited, stack):\n        if node == -1:\n            return True\n        if node in visited:\n            return False\n        visited.add(node)\n        stack.append(node)\n        return dfs(leftChild[node], visited, stack) and dfs(rightChild[node], visited, stack)\n\n    visited = set()\n    stack = []\n    root = -1\n    for i in range(n):\n        if i not in visited:\n            if root != -1:\n                return False\n            root = i\n\n    if not dfs(root, visited, stack):\n        return False\n\n    return len(visited) == n", "passed": false, "score": {"loc": 20, "tokens": 132, "cc": 7, "nest": 4, "execution_time": 10.0, "novelty": 0.7354623712276205}}, {"code": "def validateBinaryTreeNodes(n, leftChild, rightChild):\n    def has_no_cycle(node, parent):\n        if node == -1:\n            return True\n        if node in visited:\n            return False\n        visited.add(node)\n        return has_no_cycle(leftChild[node], node) and has_no_cycle(rightChild[node], node)\n    \n    visited = set()\n    root = -1\n    \n    for i in range(n):\n        if leftChild[i] != -1 and leftChild[i] == root or rightChild[i] != -1 and rightChild[i] == root:\n            return False\n        if leftChild[i] != -1:\n            root = leftChild[i]\n        elif rightChild[i] != -1:\n            root = rightChild[i]\n        if root == -1:\n            return False\n    \n    return has_no_cycle(root, -1) and len(visited) == n", "passed": false, "score": {"loc": 20, "tokens": 171, "cc": 12, "nest": 4, "execution_time": 10.0, "novelty": 0.721744177967622}}, {"code": "def validateBinaryTreeNodes(n, leftChild, rightChild):\n    seen = set()\n    stack = [0]\n    \n    while stack:\n        node = stack.pop()\n        if node == -1:\n            continue\n        if node in seen:\n            return False\n        seen.add(node)\n        stack.extend([rightChild[node], leftChild[node]])\n    \n    return len(seen) == n and -1 not in leftChild and -1 not in rightChild", "passed": false, "score": {"loc": 12, "tokens": 87, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7569464989984932}}], "num_pass": 6, "num_uniq": 6, "num_fail": 4, "fail_uniq": 4}
{"id": 25064, "entry_point": "fractionToDecimal", "best_list": [{"code": "def fractionToDecimal(numerator: int, denominator: int) -> str:\n    # Handle sign of the result\n    sign = '-' if numerator * denominator < 0 else ''\n    numerator, denominator = abs(numerator), abs(denominator)\n    \n    # Integer part\n    integer_part = numerator // denominator\n    \n    # Fractional part\n    fractional_part = []\n    remainder = numerator % denominator\n    seen_remainders = {}\n    \n    while remainder:\n        if remainder in seen_remainders:\n            start = seen_remainders[remainder]\n            non_repeating = ''.join(str(x) for x in fractional_part[:start])\n            repeating = ''.join(str(x) for x in fractional_part[start:])\n            return sign + str(integer_part) + '.' + non_repeating + '(' + repeating + ')'\n        \n        seen_remainders[remainder] = len(fractional_part)\n        remainder *= 10\n        fractional_part.append(remainder // denominator)\n        remainder %= denominator\n    \n    return sign + str(integer_part) + '.' + ''.join(map(str, fractional_part)) if fractional_part else ''", "passed": true, "score": {"loc": 21, "tokens": 205, "cc": 2, "nest": 3, "execution_time": 0.01666, "novelty": 0.7320168892166843}}, {"code": "def fractionToDecimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    sign = \"-\" if (numerator < 0) ^ (denominator < 0) else \"\"\n    numerator, denominator = abs(numerator), abs(denominator)\n    integer_part = numerator // denominator\n    remainder = numerator % denominator\n    fractional_part = []\n    remainders = {}\n    i = 0\n\n    while remainder != 0:\n        if remainder in remainders:\n            start = remainders[remainder]\n            fractional_part.insert(start, \"(\")\n            fractional_part.append(\")\")\n            break\n        remainders[remainder] = i\n        remainder *= 10\n        digit = remainder // denominator\n        fractional_part.append(str(digit))\n        remainder %= denominator\n        i += 1\n\n    return sign + str(integer_part) + (\".\" + \"\".join(fractional_part) if fractional_part else \"\")", "passed": true, "score": {"loc": 23, "tokens": 168, "cc": 3, "nest": 3, "execution_time": 0.016531, "novelty": 0.5410957073712264}}, {"code": "def fractionToDecimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    result = []\n    if (numerator < 0) ^ (denominator < 0):\n        result.append('-')\n    numerator, denominator = abs(numerator), abs(denominator)\n    result.append(str(numerator // denominator))\n    numerator %= denominator\n    if numerator == 0:\n        return ''.join(result)\n    result.append('.')\n    seen = {}\n    while numerator != 0:\n        if numerator in seen:\n            result.insert(seen[numerator], '(')\n            result.append(')')\n            break\n        seen[numerator] = len(result)\n        numerator *= 10\n        result.append(str(numerator // denominator))\n        numerator %= denominator\n    return ''.join(result)", "passed": true, "score": {"loc": 23, "tokens": 168, "cc": 5, "nest": 3, "execution_time": 0.016581, "novelty": 0.4509197195456154}}, {"code": "def fractionToDecimal(numerator, denominator):\n    quotient, remainder = divmod(abs(numerator), abs(denominator))\n    sign = '-' if (numerator < 0) ^ (denominator < 0) else ''\n    if remainder == 0:\n        return sign + str(quotient)\n    \n    decimals, seen = [], {}\n    while remainder != 0:\n        if remainder in seen:\n            start = seen[remainder]\n            non_repeating = ''.join(map(str, decimals[:start]))\n            repeating = ''.join(map(str, decimals[start:]))\n            return sign + non_repeating + '(' + repeating + ')'\n        seen[remainder] = len(decimals)\n        quotient, remainder = divmod(remainder * 10, abs(denominator))\n        decimals.append(quotient)\n    \n    return sign + ''.join(map(str, decimals))", "passed": false, "score": {"loc": 16, "tokens": 178, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.8076158588475568}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 25093, "entry_point": "minJumps", "best_list": [{"code": "def minJumps(arr):\n    from collections import defaultdict, deque\n    n = len(arr)\n    if n == 1:\n        return 0\n    graph = defaultdict(list)\n    for i, x in enumerate(arr):\n        graph[x].append(i)\n    \n    visited = [False] * n\n    queue = deque([0])\n    visited[0] = True\n    steps = 0\n    \n    while queue:\n        for _ in range(len(queue)):\n            i = queue.popleft()\n            if i == n - 1:\n                return steps\n            for j in [i - 1, i + 1] + graph[arr[i]]:\n                if 0 <= j < n and not visited[j]:\n                    visited[j] = True\n                    queue.append(j)\n            graph[arr[i]].clear()  # Prevent revisiting\n        \n        steps += 1\n    \n    return -1", "passed": true, "score": {"loc": 24, "tokens": 174, "cc": 8, "nest": 5, "execution_time": 0.016667, "novelty": 0.650755328301569}}, {"code": "def minJumps(arr):\n    from collections import defaultdict, deque\n\n    n = len(arr)\n    if n == 1:\n        return 0\n\n    graph = defaultdict(list)\n    for i, num in enumerate(arr):\n        graph[num].append(i)\n\n    visited = [False] * n\n    visited[0] = True\n    queue = deque([0])\n    steps = 0\n\n    while queue:\n        for _ in range(len(queue)):\n            i = queue.popleft()\n            if i == n - 1:\n                return steps\n\n            for j in [i - 1, i + 1] + graph[arr[i]]:\n                if 0 <= j < n and not visited[j]:\n                    visited[j] = True\n                    queue.append(j)\n\n            graph[arr[i]] = []  # Avoid revisiting same values\n\n        steps += 1\n\n    return -1", "passed": true, "score": {"loc": 24, "tokens": 175, "cc": 8, "nest": 5, "execution_time": 0.0169, "novelty": 0.6428271199443547}}, {"code": "from collections import defaultdict, deque\n\ndef minJumps(arr):\n    if not arr or len(arr) == 1:\n        return 0\n    \n    n = len(arr)\n    graph = defaultdict(list)\n    \n    for i, num in enumerate(arr):\n        graph[num].append(i)\n    \n    queue = deque([0])\n    visited = {0}\n    step = 0\n    \n    while queue:\n        for _ in range(len(queue)):\n            current = queue.popleft()\n            \n            if current == n - 1:\n                return step\n            \n            for neighbor in [current - 1, current + 1] + graph[arr[current]]:\n                if 0 <= neighbor < n and neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n            \n            # Clear the list to avoid revisiting\n            graph[arr[current]].clear()\n        \n        step += 1\n    \n    return -1", "passed": true, "score": {"loc": 24, "tokens": 175, "cc": 9, "nest": 5, "execution_time": 0.016644, "novelty": 0.8520714284149813}}, {"code": "def minJumps(arr):\n    n = len(arr)\n    if n == 1:\n        return 0\n    \n    target = n - 1\n    jumps = [float('inf')] * n\n    jumps[0] = 0\n    \n    seen = set()\n    q = [0]\n    \n    while q:\n        i = q.pop(0)\n        if i in seen:\n            continue\n        seen.add(i)\n        \n        if i == target:\n            break\n        \n        if i > 0 and jumps[i - 1] > jumps[i] + 1:\n            jumps[i - 1] = jumps[i] + 1\n            q.append(i - 1)\n        \n        if i < n - 1 and jumps[i + 1] > jumps[i] + 1:\n            jumps[i + 1] = jumps[i] + 1\n            q.append(i + 1)\n        \n        if arr[i] in seen_vals:\n            for j in seen_vals[arr[i]]:\n                if jumps[j] > jumps[i] + 1:\n                    jumps[j] = jumps[i] + 1\n                    q.append(j)\n            seen_vals[arr[i]].clear()\n    \n    return jumps[target]", "passed": false, "score": {"loc": 29, "tokens": 230, "cc": 11, "nest": 5, "execution_time": 10.0, "novelty": 0.8082267001302966}}, {"code": "def minJumps(arr):\n    from collections import defaultdict, deque\n    \n    n = len(arr)\n    if n == 1:\n        return 0\n    \n    index_map = defaultdict(list)\n    for i, val in enumerate(arr):\n        index_map[val].append(i)\n    \n    queue = deque([(0, 0)])\n    visited = {0}\n    while queue:\n        current_index, steps = queue.popleft()\n        if current_index == n - 1:\n            return steps\n        \n        next_indices = [current_index + 1, current_index - 1]\n        for j in index_map[arr[current_index]]:\n            if j not in visited and 0 <= j < n:\n                next_indices.append(j)\n        \n        for next_index in next_indices:\n            if next_index not in visited:\n                visited.add(next_index)\n                queue.append((next_index, steps + 1))\n        \n        index_map[arr[current_index]] = []\n    \n    return -1", "passed": false, "score": {"loc": 24, "tokens": 173, "cc": 9, "nest": 4, "execution_time": 10.0, "novelty": 0.6292037026947741}}, {"code": "from collections import deque\n\ndef minJumps(arr):\n    n = len(arr)\n    if n == 1:\n        return 0\n    \n    graph = {}\n    for i in range(n):\n        if arr[i] not in graph:\n            graph[arr[i]] = []\n        graph[arr[i]].append(i)\n    \n    visited = [False] * n\n    visited[0] = True\n    queue = deque([0])\n    steps = 0\n    \n    while queue:\n        for _ in range(len(queue)):\n            curr = queue.popleft()\n            if curr == n - 1:\n                return steps\n            \n            for next_step in [curr - 1, curr + 1]:\n                if 0 <= next_step < n and not visited[next_step]:\n                    visited[next_step] = True\n                    queue.append(next_step)\n            \n            if arr[curr] in graph:\n                for next_step in graph[arr[curr]]:\n                    if not visited[next_step]:\n                        visited[next_step] = True\n                        queue.append(next_step)\n                del graph[arr[curr]]\n    \n    return -1", "passed": false, "score": {"loc": 30, "tokens": 210, "cc": 12, "nest": 6, "execution_time": 10.0, "novelty": 0.7973773684301942}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 25106, "entry_point": "largestSumAfterKNegations", "best_list": [{"code": "def largestSumAfterKNegations(A, K):\n    for _ in range(K):\n        A[A.index(min(A))] *= -1\n    return sum(A)", "passed": true, "score": {"loc": 4, "tokens": 37, "cc": 1, "nest": 2, "execution_time": 0.016631, "novelty": 0.3295145641210818}}, {"code": "def largestSumAfterKNegations(A, K):\n    for _ in range(K):\n        min_index = A.index(min(A))\n        A[min_index] = -A[min_index]\n    return sum(A)", "passed": true, "score": {"loc": 5, "tokens": 42, "cc": 1, "nest": 2, "execution_time": 0.016657, "novelty": 0.4287394095501198}}, {"code": "def largestSumAfterKNegations(A, K):\n    A.sort()\n    for _ in range(K):\n        A[0] = -A[0]\n        A.sort()\n    return sum(A)", "passed": true, "score": {"loc": 6, "tokens": 41, "cc": 1, "nest": 2, "execution_time": 0.016679, "novelty": 0.5652921549540382}}, {"code": "def largestSumAfterKNegations(A, K):\n    A.sort()\n    for i in range(K):\n        if A[i] < 0:\n            A[i] = -A[i]\n        else:\n            break\n    if K % 2 == 1:\n        A.sort()\n        A[0] = -A[0]\n    return sum(A)", "passed": false, "score": {"loc": 11, "tokens": 70, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6781577649141148}}, {"code": "def largestSumAfterKNegations(A, K):\n    for _ in range(K):\n        A.append(min(A) * -1)\n    return sum(A)", "passed": false, "score": {"loc": 4, "tokens": 33, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.41456539479426546}}], "num_pass": 7, "num_uniq": 4, "num_fail": 3, "fail_uniq": 2}
{"id": 25127, "entry_point": "canMeasureWater", "best_list": [{"code": "def canMeasureWater(x, y, z):\n    if z == 0:\n        return True\n    if x + y < z:\n        return False\n    return z % math.gcd(x, y) == 0", "passed": true, "score": {"loc": 6, "tokens": 41, "cc": 2, "nest": 2, "execution_time": 0.016556, "novelty": 0.26046950606286745}}, {"code": "def canMeasureWater(x: int, y: int, z: int) -> bool:\n    if z == 0:\n        return True\n    if x + y < z:\n        return False\n    return z % math.gcd(x, y) == 0", "passed": true, "score": {"loc": 6, "tokens": 50, "cc": 2, "nest": 2, "execution_time": 0.016639, "novelty": 0.3178823916611624}}, {"code": "def canMeasureWater(x, y, z):\n    if z > x + y:\n        return False\n    if z == 0:\n        return True\n    return z % gcd(x, y) == 0\n\nfrom math import gcd", "passed": true, "score": {"loc": 7, "tokens": 43, "cc": 2, "nest": 2, "execution_time": 0.016628, "novelty": 0.41145783806503977}}, {"code": "def canMeasureWater(x, y, z):\n    if z == 0:\n        return True\n    if x + y < z:\n        return False\n    return z % gcd(x, y) == 0", "passed": false, "score": {"loc": 6, "tokens": 39, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.25353078060218737}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 25132, "entry_point": "myPow", "best_list": [{"code": "def myPow(x, n):\n    return x ** n", "passed": true, "score": {"loc": 2, "tokens": 13, "cc": 0, "nest": 1, "execution_time": 0.016664, "novelty": 0.5038113973129021}}, {"code": "def myPow(x, n):\n    return x ** n\n\ndef _equivalent(lhs, rhs):\n    return abs(lhs - rhs) < 1e-9", "passed": true, "score": {"loc": 4, "tokens": 32, "cc": 0, "nest": 1, "execution_time": 0.016651, "novelty": 0.6170711309888783}}, {"code": "def myPow(x, n):\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    while n > 0:\n        if n % 2 == 1:\n            result *= x\n        x *= x\n        n //= 2\n    return result", "passed": true, "score": {"loc": 11, "tokens": 53, "cc": 3, "nest": 3, "execution_time": 0.016689, "novelty": 0.4889067191591513}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 25192, "entry_point": "soupServings", "best_list": [{"code": "def soupServings(N):\n    if N > 4800: return 1.0  # For large N, the probability approaches 1\n    \n    dp = [[0] * 200 for _ in range(200)]\n    dp[0][0] = 0.5\n    \n    for i in range(1, 200):\n        dp[0][i] = 1.0\n        dp[i][0] = 0.0\n    \n    for i in range(1, 200):\n        for j in range(1, 200):\n            dp[i][j] = 0.25 * (dp[max(0, i-4)][j] + dp[max(0, i-3)][max(0, j-1)] + dp[max(0, i-2)][max(0, j-2)] + dp[max(0, i-1)][max(0, j-3)])\n    \n    return dp[N // 25][N // 25]\n\ndef _equivalent(lhs, rhs, tolerance=1e-6):\n    return abs(lhs - rhs) < tolerance", "passed": true, "score": {"loc": 13, "tokens": 234, "cc": 4, "nest": 3, "execution_time": 0.04527, "novelty": 0.7458763533147985}}, {"code": "from functools import lru_cache\n\n@lru_cache(None)\ndef soupServings(N: int) -> float:\n    if N > 4800:\n        return 1.0\n    return (soupServings(N - 4) + soupServings(N - 3) + soupServings(N - 2) + soupServings(N - 1)) / 4.0", "passed": false, "score": {"loc": 6, "tokens": 63, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.5103386999136215}}, {"code": "from functools import lru_cache\n\n@lru_cache(None)\ndef soupServings(N):\n    if N >= 5000:\n        return 1.0\n    return (\n        soupServings(N - 100) / 4 +\n        soupServings(N - 75) / 4 +\n        soupServings(N - 50) / 4 +\n        soupServings(N - 25) / 4\n    )", "passed": false, "score": {"loc": 11, "tokens": 63, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.5775364854111376}}, {"code": "def soupServings(N):\n    if N > 4800:\n        return 1.0\n    N = (N + 24) // 25\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 0.5\n    for i in range(1, N + 1):\n        dp[i][0] = 1.0\n        dp[0][i] = 0.0\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            dp[i][j] = (dp[max(i - 4, 0)][j] + dp[max(i - 3, 0)][max(j - 1, 0)] + \n                        dp[max(i - 2, 0)][max(j - 2, 0)] + dp[max(i - 1, 0)][max(j - 3, 0)]) / 4.0\n    return dp[N][N]", "passed": false, "score": {"loc": 14, "tokens": 218, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7488746355407754}}, {"code": "@lru_cache(None)\ndef soupServings(N):\n    if N >= 4800:\n        return 1.0\n    def helper(a, b):\n        if a <= 0 and b <= 0:\n            return 0.5\n        if a <= 0:\n            return 1.0\n        if b <= 0:\n            return 0.0\n        return 0.25 * (helper(a - 4, b) + helper(a - 3, b - 1) + helper(a - 2, b - 2) + helper(a - 1, b - 3))\n    return helper(N, N)", "passed": false, "score": {"loc": 13, "tokens": 119, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.5668781707646446}}, {"code": "def soupServings(N):\n    if N > 4800:\n        return 1.0\n    memo = {}\n    def helper(A, B):\n        if (A, B) in memo:\n            return memo[(A, B)]\n        if A <= 0 and B <= 0:\n            return 0.5\n        if A <= 0:\n            return 1.0\n        if B <= 0:\n            return 0.0\n        prob = 0.25 * (helper(A - 4, B) + helper(A - 3, B - 1) + helper(A - 2, B - 2) + helper(A - 1, B - 3))\n        memo[(A, B)] = prob\n        return prob\n    return helper(N, N)", "passed": false, "score": {"loc": 17, "tokens": 148, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.6388839655417796}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 25250, "entry_point": "strWithout3a3b", "best_list": [{"code": "def strWithout3a3b(A, B):\n    if A > B:\n        return \"aab\" + strWithout3a3b(A - 2, B - 1)\n    elif B > A:\n        return \"bba\" + strWithout3a3b(A - 1, B - 2)\n    elif A > 0:\n        return \"ab\" + strWithout3a3b(A - 1, B - 1)\n    else:\n        return \"\"", "passed": true, "score": {"loc": 9, "tokens": 73, "cc": 3, "nest": 4, "execution_time": 0.016712, "novelty": 0.7155417761395187}}, {"code": "def strWithout3a3b(A, B):\n    result = []\n    while A > 0 or B > 0:\n        if A > B and A > 1:\n            result.append('a')\n            result.append('a')\n            A -= 2\n        elif B > A and B > 1:\n            result.append('b')\n            result.append('b')\n            B -= 2\n        else:\n            if A > 0:\n                result.append('a')\n                A -= 1\n            if B > 0:\n                result.append('b')\n                B -= 1\n    return ''.join(result)", "passed": true, "score": {"loc": 19, "tokens": 123, "cc": 8, "nest": 5, "execution_time": 0.016631, "novelty": 0.3621178011232138}}, {"code": "def strWithout3a3b(A, B):\n    result = []\n    while A > 0 or B > 0:\n        if A >= B and A > 1:\n            result.append('a')\n            result.append('a')\n            A -= 2\n        elif B >= A and B > 1:\n            result.append('b')\n            result.append('b')\n            B -= 2\n        else:\n            if A > 0:\n                result.append('a')\n                A -= 1\n            if B > 0:\n                result.append('b')\n                B -= 1\n    return ''.join(result)", "passed": true, "score": {"loc": 19, "tokens": 125, "cc": 8, "nest": 5, "execution_time": 0.016603, "novelty": 0.3642373398133749}}, {"code": "def strWithout3a3b(A, B):\n    result = []\n    while A > 0 or B > 0:\n        if A > B:\n            if A > 1:\n                result.append('a')\n                A -= 1\n            if B > 0:\n                result.append('b')\n                B -= 1\n        else:\n            if B > 1:\n                result.append('b')\n                B -= 1\n            if A > 0:\n                result.append('a')\n                A -= 1\n    return ''.join(result)", "passed": false, "score": {"loc": 18, "tokens": 104, "cc": 7, "nest": 4, "execution_time": 10.0, "novelty": 0.34864039595133745}}, {"code": "def strWithout3a3b(A, B):\n    result = []\n    while A or B:\n        if A > B:\n            if len(result) >= 2 and result[-2:] == ['a', 'a']:\n                result.append('b')\n                B -= 1\n            else:\n                result.append('a')\n                A -= 1\n        elif B > A:\n            if len(result) >= 2 and result[-2:] == ['b', 'b']:\n                result.append('a')\n                A -= 1\n            else:\n                result.append('b')\n                B -= 1\n        else:\n            if A > 0:\n                result.append('a')\n                A -= 1\n            if B > 0:\n                result.append('b')\n                B -= 1\n    return ''.join(result)", "passed": false, "score": {"loc": 25, "tokens": 177, "cc": 10, "nest": 5, "execution_time": 10.0, "novelty": 0.5701435151539397}}, {"code": "def strWithout3a3b(A, B):\n    def _equivalent(lhs, rhs):\n        return lhs == rhs\n\n    result = []\n    while A > 0 or B > 0:\n        if A >= B:\n            if A > 1:\n                result.append('a')\n                result.append('a')\n                A -= 2\n            else:\n                result.append('a')\n                A -= 1\n            if B > 0:\n                result.append('b')\n                B -= 1\n        else:\n            if B > 1:\n                result.append('b')\n                result.append('b')\n                B -= 2\n            else:\n                result.append('b')\n                B -= 1\n            if A > 0:\n                result.append('a')\n                A -= 1\n    return ''.join(result)\n\n# Test cases\nassert _equivalent(strWithout3a3b(1, 2), \"abb\")\nassert _equivalent(strWithout3a3b(4, 1), \"aabaa\")\nassert _equivalent(strWithout3a3b(0, 0), \"\")\nassert _equivalent(strWithout3a3b(2, 2), \"abab\")\nassert _equivalent(strWithout3a3b(5, 3), \"aababaa\")\nassert _equivalent(strWithout3a3b(3, 5), \"bbbabaa\")\nassert _equivalent(strWithout3a3b(1, 0), \"a\")\nassert _equivalent(strWithout3a3b(0, 1), \"b\")\nassert _equivalent(strWithout3a3b(2, 0), \"aa\")\nassert _equivalent(strWithout3a3b(0, 2), \"bb\")", "passed": false, "score": {"loc": 39, "tokens": 304, "cc": 7, "nest": 4, "execution_time": 10.0, "novelty": 0.5473784930629433}}], "num_pass": 7, "num_uniq": 6, "num_fail": 3, "fail_uniq": 3}
{"id": 25283, "entry_point": "maxSizeSlices", "best_list": [{"code": "def maxSizeSlices(slices):\n    n = len(slices)\n    k = n // 3\n    \n    def maxSum(arr, k):\n        dp = [[0] * (k + 1) for _ in range(len(arr) + 1)]\n        for i in range(1, len(arr) + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j], (dp[i - 2][j - 1] if i > 1 else 0) + arr[i - 1])\n        return dp[-1][-1]\n    \n    return max(maxSum(slices[1:], k), maxSum(slices[:-1], k))", "passed": true, "score": {"loc": 10, "tokens": 161, "cc": 2, "nest": 4, "execution_time": 0.016665, "novelty": 0.6213099521288246}}, {"code": "def maxSizeSlices(slices):\n    n = len(slices)\n    k = n // 3\n\n    def maxSlicesHelper(slices):\n        n = len(slices)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j], (dp[i - 2][j - 1] if i >= 2 else 0) + slices[i - 1])\n        return dp[n][k]\n\n    return max(maxSlicesHelper(slices[1:]), maxSlicesHelper(slices[:-1]))", "passed": true, "score": {"loc": 11, "tokens": 154, "cc": 2, "nest": 4, "execution_time": 0.017125, "novelty": 0.5291453291306613}}, {"code": "def maxSizeSlices(slices):\n    n = len(slices)\n    k = n // 3\n    \n    @lru_cache(None)\n    def dp(i, j, m):\n        if m == 0:\n            return 0\n        if j - i < m:\n            return float('-inf')\n        return max(dp(i + 1, j, m), dp(i + 2, j, m - 1) + slices[i])\n    \n    return max(dp(1, n - 1, k), dp(0, n - 2, k))", "passed": false, "score": {"loc": 11, "tokens": 113, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6684840789489412}}, {"code": "def maxSizeSlices(slices):\n    n = len(slices)\n    k = n // 3\n\n    def helper(s):\n        dp = [0] * (k + 1)\n        for i in range(n - 1):\n            dp[1] = max(dp[1], dp[0] + s[i])\n            for j in range(2, k + 1):\n                dp[j] = max(dp[j], dp[j - 1], (dp[j - 2] if i > 1 else 0) + s[i])\n        return dp[k]\n\n    return max(helper(slices[1:]), helper(slices[:-1]))", "passed": false, "score": {"loc": 11, "tokens": 145, "cc": 2, "nest": 4, "execution_time": 10.0, "novelty": 0.571020611035945}}, {"code": "def maxSizeSlices(slices):\n    n = len(slices)\n    def dfs(start, end, k):\n        if k == 0:\n            return 0\n        if end - start + 1 < k:\n            return 0\n        return max(dfs(start + 1, end, k), dfs(start, end - 1, k - 1) + slices[end])\n    return dfs(1, n - 2, n // 3)", "passed": false, "score": {"loc": 9, "tokens": 87, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7023376248645172}}, {"code": "def maxSizeSlices(slices):\n    def max_slice(arr):\n        n = len(arr)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for length in range(2, n + 1, 2):\n            for start in range(n - length + 1):\n                end = start + length\n                dp[start][end] = max(arr[start] + dp[start + 2][end], dp[start + 1][end - 1])\n        return dp[0][n]\n\n    n = len(slices)\n    return max(max_slice(slices[1:n]), max_slice(slices[0:n-1]))", "passed": false, "score": {"loc": 11, "tokens": 147, "cc": 2, "nest": 4, "execution_time": 10.0, "novelty": 0.6954409275646696}}, {"code": "def maxSizeSlices(slices):\n    n = len(slices)\n    k = n // 3\n    \n    def maxSlicesLinear(arr):\n        n = len(arr)\n        dp = [0] * (k + 1)\n        for i in range(n):\n            for j in range(k, 0, -1):\n                dp[j] = max(dp[j], dp[j - 1] + arr[i])\n        return dp[k]\n    \n    return max(maxSlicesLinear(slices[:n-1]), maxSlicesLinear(slices[1:]))", "passed": false, "score": {"loc": 11, "tokens": 114, "cc": 2, "nest": 4, "execution_time": 10.0, "novelty": 0.6602455249482884}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 8}
{"id": 25332, "entry_point": "maxSubArray", "best_list": [{"code": "def maxSubArray(nums):\n    max_current = max_global = nums[0]\n    for num in nums[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n    return max_global", "passed": true, "score": {"loc": 7, "tokens": 43, "cc": 2, "nest": 3, "execution_time": 0.016803, "novelty": 0.0}}], "num_pass": 10, "num_uniq": 1, "num_fail": 0, "fail_uniq": 0}
{"id": 25391, "entry_point": "kConcatenationMaxSum", "best_list": [{"code": "def kConcatenationMaxSum(arr, k):\n    MOD = 10**9 + 7\n    n = len(arr)\n    max_sum = 0\n    current_sum = 0\n    \n    for i in range(n * min(2, k)):\n        current_sum = max(0, current_sum + arr[i % n])\n        max_sum = max(max_sum, current_sum)\n    \n    if k == 1:\n        return max_sum % MOD\n    \n    total_sum = sum(arr)\n    if total_sum > 0:\n        max_sum = max(max_sum, (k - 2) * total_sum + max_sum)\n    \n    return max_sum % MOD", "passed": true, "score": {"loc": 14, "tokens": 107, "cc": 3, "nest": 2, "execution_time": 0.016725, "novelty": 0.6727119336408522}}, {"code": "def kConcatenationMaxSum(arr, k):\n    MOD = 10**9 + 7\n    n = len(arr)\n    max_sum = 0\n    current_sum = 0\n    max_prefix_sum = 0\n    prefix_sum = 0\n    \n    for _ in range(k):\n        for num in arr:\n            current_sum = max(num, current_sum + num)\n            max_sum = max(max_sum, current_sum)\n            prefix_sum += num\n            max_prefix_sum = max(max_prefix_sum, prefix_sum)\n    \n    if k >= 2:\n        max_sum = max(max_sum, prefix_sum * (k - 2) + max_sum - max_prefix_sum)\n    \n    return max_sum % MOD", "passed": true, "score": {"loc": 16, "tokens": 105, "cc": 3, "nest": 3, "execution_time": 0.016674, "novelty": 0.686072488245984}}, {"code": "def kConcatenationMaxSum(arr, k):\n    MOD = 10**9 + 7\n    max_sum = current_sum = 0\n    arr_sum = sum(arr)\n    \n    for i in range(k * 2):\n        current_sum = max(0, current_sum + arr[i % len(arr)])\n        max_sum = max(max_sum, current_sum)\n    \n    if k > 1 and arr_sum > 0:\n        max_sum = max(max_sum, (k - 2) * arr_sum + max_sum)\n    \n    return max_sum % MOD", "passed": false, "score": {"loc": 10, "tokens": 92, "cc": 3, "nest": 2, "execution_time": 10.0, "novelty": 0.6503508099203666}}, {"code": "def kConcatenationMaxSum(arr, k):\n    MOD = 10**9 + 7\n    max_sum = curr_sum = 0\n    max_prefix_sum = curr_prefix_sum = 0\n    min_suffix_sum = curr_suffix_sum = 0\n\n    for _ in range(2 if k > 1 else 1):\n        for num in arr:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n\n            curr_prefix_sum = max(0, curr_prefix_sum + num)\n            max_prefix_sum = max(max_prefix_sum, curr_prefix_sum)\n\n            curr_suffix_sum = min(0, curr_suffix_sum + num)\n            min_suffix_sum = min(min_suffix_sum, curr_suffix_sum)\n\n    if k == 1:\n        return max_sum % MOD\n\n    total_sum = sum(arr)\n    if total_sum <= 0:\n        return max(max_sum, 0) % MOD\n\n    return (max_sum + total_sum * (k - 2) - min_suffix_sum + max_prefix_sum) % MOD", "passed": false, "score": {"loc": 19, "tokens": 153, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7197888074893102}}, {"code": "def kConcatenationMaxSum(arr, k):\n    max_subarray_sum = float('-inf')\n    current_sum = 0\n    total_sum = 0\n\n    for _ in range(k):\n        for num in arr:\n            current_sum = max(0, current_sum + num)\n            max_subarray_sum = max(max_subarray_sum, current_sum)\n            total_sum += num\n\n    if k > 1 and total_sum > 0:\n        max_subarray_sum = max(max_subarray_sum, total_sum * (k - 2) + max_subarray_sum)\n\n    return max_subarray_sum % (10**9 + 7)", "passed": false, "score": {"loc": 12, "tokens": 94, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.6537154555738166}}, {"code": "def kConcatenationMaxSum(arr, k):\n    max_current = max_global = arr[0]\n    for x in arr * (k + 1)[:-1]:\n        max_current = max(x, max_current + x)\n        max_global = max(max_global, max_current)\n    return max_global % (10**9 + 7)", "passed": false, "score": {"loc": 6, "tokens": 61, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.6707418254255044}}, {"code": "def kConcatenationMaxSum(arr, k):\n    MOD = 10**9 + 7\n    max_current = max_global = arr[0]\n    for x in arr[1:]:\n        max_current = max(x, max_current + x)\n        max_global = max(max_global, max_current)\n    \n    total_sum = sum(arr)\n    if total_sum <= 0:\n        return max_global % MOD\n    \n    if k == 1:\n        return max_global % MOD\n    \n    max_prefix = max_suffix = 0\n    prefix_sum = 0\n    for x in arr:\n        prefix_sum += x\n        max_prefix = max(max_prefix, prefix_sum)\n    \n    suffix_sum = 0\n    for x in reversed(arr):\n        suffix_sum += x\n        max_suffix = max(max_suffix, suffix_sum)\n    \n    return (max_global + max_prefix + max_suffix + (k - 2) * total_sum) % MOD", "passed": false, "score": {"loc": 21, "tokens": 143, "cc": 5, "nest": 2, "execution_time": 10.0, "novelty": 0.7482038440180401}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 8}
{"id": 25392, "entry_point": "isSubsequence", "best_list": [{"code": "def isSubsequence(s, t):\n    s_iter = iter(t)\n    return all(c in s_iter for c in s)", "passed": true, "score": {"loc": 3, "tokens": 25, "cc": 0, "nest": 1, "execution_time": 0.016349, "novelty": 0.4227517704245687}}, {"code": "def isSubsequence(s, t):\n    it = iter(t)\n    return all(c in it for c in s)", "passed": true, "score": {"loc": 3, "tokens": 25, "cc": 0, "nest": 1, "execution_time": 0.016397, "novelty": 0.05248269896203872}}, {"code": "def isSubsequence(s, t):\n    it = iter(t)\n    return all(char in it for char in s)", "passed": true, "score": {"loc": 3, "tokens": 25, "cc": 0, "nest": 1, "execution_time": 0.016638, "novelty": 0.16237458581090014}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 25394, "entry_point": "largestComponentSize", "best_list": [{"code": "def largestComponentSize(A):\n    from collections import defaultdict\n    from math import gcd\n\n    n = len(A)\n    parent = list(range(n))\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        parent[find(x)] = find(y)\n\n    factors = defaultdict(list)\n    for i, a in enumerate(A):\n        for f in range(2, int(a**0.5) + 1):\n            if a % f == 0:\n                factors[f].append(i)\n                factors[a // f].append(i)\n        factors[a].append(i)\n\n    for factor in factors.values():\n        for i in range(1, len(factor)):\n            union(factor[0], factor[i])\n\n    size = [0] * n\n    for i in range(n):\n        size[find(i)] += 1\n\n    return max(size)", "passed": true, "score": {"loc": 25, "tokens": 219, "cc": 7, "nest": 4, "execution_time": 0.016963, "novelty": 0.6245102706196785}}, {"code": "def largestComponentSize(A):\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n            size[rootY] += size[rootX]\n\n    n = len(A)\n    parent = list(range(n))\n    size = [1] * n\n\n    factor_to_index = {}\n    for i, num in enumerate(A):\n        for f in range(2, int(num**0.5) + 1):\n            if num % f == 0:\n                if f in factor_to_index:\n                    union(i, factor_to_index[f])\n                factor_to_index[f] = i\n                if num // f != f:\n                    if num // f in factor_to_index:\n                        union(i, factor_to_index[num // f])\n                    factor_to_index[num // f] = i\n\n    return max(size)", "passed": true, "score": {"loc": 26, "tokens": 207, "cc": 8, "nest": 6, "execution_time": 0.016682, "novelty": 0.5868290374013094}}, {"code": "def largestComponentSize(A):\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n            size[rootY] += size[rootX]\n\n    n = len(A)\n    parent = list(range(n))\n    size = [1] * n\n    factor_to_index = {}\n\n    for i, num in enumerate(A):\n        for j in range(2, int(num ** 0.5) + 1):\n            if num % j == 0:\n                if j not in factor_to_index:\n                    factor_to_index[j] = i\n                union(i, factor_to_index[j])\n                if num // j != j:\n                    if num // j not in factor_to_index:\n                        factor_to_index[num // j] = i\n                    union(i, factor_to_index[num // j])\n        if num not in factor_to_index:\n            factor_to_index[num] = i\n\n    return max(size)", "passed": true, "score": {"loc": 28, "tokens": 221, "cc": 9, "nest": 6, "execution_time": 0.016869, "novelty": 0.6001115902590655}}, {"code": "def largestComponentSize(A):\n    from collections import defaultdict\n    import math\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        parent[find(y)] = find(x)\n\n    n = len(A)\n    parent = list(range(n))\n    factor_to_node = defaultdict(list)\n\n    for i, a in enumerate(A):\n        for f in range(2, int(math.sqrt(a)) + 1):\n            if a % f == 0:\n                factor_to_node[f].append(i)\n                factor_to_node[a // f].append(i)\n\n    for factors in factor_to_node.values():\n        for i in range(1, len(factors)):\n            union(factors[0], factors[i])\n\n    return max(len(list(group)) for _, group in itertools.groupby(sorted(find(i) for i in range(n))))", "passed": false, "score": {"loc": 21, "tokens": 213, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.6695314609339322}}, {"code": "from collections import defaultdict\n\ndef largestComponentSize(A):\n    max_val = max(A)\n    primes = [True] * (max_val + 1)\n    for i in range(2, int(max_val**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, max_val + 1, i):\n                primes[j] = False\n    \n    prime_to_nodes = defaultdict(set)\n    for num in A:\n        for i in range(2, num + 1):\n            if num % i == 0 and primes[i]:\n                prime_to_nodes[i].add(num)\n                break\n    \n    parent = list(range(len(A) + 1))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    for group in prime_to_nodes.values():\n        for i in range(1, len(group)):\n            union(group[0], group[i])\n    \n    size = [0] * (len(A) + 1)\n    for node in range(1, len(A) + 1):\n        parent_node = find(node)\n        size[parent_node] += 1\n    \n    return max(size)", "passed": false, "score": {"loc": 32, "tokens": 280, "cc": 12, "nest": 4, "execution_time": 10.0, "novelty": 0.7885082531596608}}, {"code": "from collections import defaultdict\nfrom math import sqrt\n\ndef largestComponentSize(A):\n    def union(x, y):\n        px, py = find(x), find(y)\n        if px != py:\n            parent[px] = py\n            size[py] += size[px]\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    n = len(A)\n    parent = list(range(n))\n    size = [1] * n\n    factor_to_node = defaultdict(list)\n\n    for i, num in enumerate(A):\n        for f in range(2, int(sqrt(num)) + 1):\n            if num % f == 0:\n                factor_to_node[f].append(i)\n                factor_to_node[num // f].append(i)\n\n    for nodes in factor_to_node.values():\n        for i in range(1, len(nodes)):\n            union(nodes[0], nodes[i])\n\n    return max(size)\n\n# Unit tests\ndef _equivalent(lhs, rhs):\n    return lhs == rhs\n\n# Example tests\nassert _equivalent(largestComponentSize([4, 6, 15, 35]), 4)\nassert _equivalent(largestComponentSize([20, 50, 9, 63]), 2)\nassert _equivalent(largestComponentSize([2, 3, 6, 7, 4, 12, 21, 39]), 8)", "passed": false, "score": {"loc": 32, "tokens": 294, "cc": 7, "nest": 4, "execution_time": 10.0, "novelty": 0.8158223366999084}}, {"code": "from collections import defaultdict\nfrom math import isqrt\n\ndef largestComponentSize(A):\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.append(i)\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    factor_to_nodes = defaultdict(set)\n    for node in A:\n        for factor in prime_factors(node):\n            factor_to_nodes[factor].add(node)\n\n    max_size = 0\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return 0\n        visited.add(node)\n        size = 1\n        for neighbor in factor_to_nodes[node]:\n            size += dfs(neighbor)\n        return size\n\n    for node in A:\n        if node not in visited:\n            max_size = max(max_size, dfs(node))\n\n    return max_size", "passed": false, "score": {"loc": 33, "tokens": 169, "cc": 9, "nest": 4, "execution_time": 10.0, "novelty": 0.7980313588085519}}, {"code": "def largestComponentSize(A):\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n            size[rootY] += size[rootX]\n    \n    max_val = max(A)\n    parent = list(range(max_val + 1))\n    size = [1] * (max_val + 1)\n    \n    for num in A:\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                union(num, i)\n                union(num, num // i)\n    \n    return max(size)", "passed": false, "score": {"loc": 20, "tokens": 161, "cc": 5, "nest": 4, "execution_time": 10.0, "novelty": 0.5656581190027796}}], "num_pass": 5, "num_uniq": 5, "num_fail": 5, "fail_uniq": 5}
{"id": 25404, "entry_point": "distinctEchoSubstrings", "best_list": [{"code": "def distinctEchoSubstrings(text):\n    n = len(text)\n    substrings = set()\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if text[i:j] == text[j:2*j-i]:\n                substrings.add(text[i:j])\n                \n    return len(substrings)", "passed": true, "score": {"loc": 8, "tokens": 73, "cc": 3, "nest": 4, "execution_time": 0.016668, "novelty": 0.2501274184907927}}, {"code": "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    distinct_substrings = set()\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if 2 * j - i <= n and text[i:j] == text[j:2 * j - i]:\n                distinct_substrings.add(text[i:j])\n    \n    return len(distinct_substrings)", "passed": true, "score": {"loc": 8, "tokens": 87, "cc": 4, "nest": 4, "execution_time": 0.016417, "novelty": 0.28633794965028336}}, {"code": "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    distinct_substrings = set()\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if 2 * (j - i) + i <= n and text[i:j] == text[j:2 * (j - i) + i]:\n                distinct_substrings.add(text[i:2 * (j - i) + i])\n    \n    return len(distinct_substrings)", "passed": true, "score": {"loc": 8, "tokens": 103, "cc": 4, "nest": 4, "execution_time": 0.016683, "novelty": 0.3708161254522617}}, {"code": "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    result = set()\n    \n    for length in range(1, n // 2 + 1):\n        for i in range(n - length * 2 + 1):\n            if text[i:i + length] == text[i + length:i + length * 2]:\n                dp[i][i + length * 2] = dp[i + 1][i + length * 2 - 1] + 1\n                if dp[i][i + length * 2] == length:\n                    result.add(text[i:i + length * 2])\n    \n    return len(result)", "passed": false, "score": {"loc": 11, "tokens": 162, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.7735663096397701}}, {"code": "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    result = set()\n    for i in range(n):\n        for j in range(i + 1, (n + 1) // 2):\n            if text[i:i + j] == text[i + j:i + 2 * j]:\n                result.add(text[i:i + j])\n    return len(result)", "passed": false, "score": {"loc": 8, "tokens": 91, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.20688984203477245}}, {"code": "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    distinct_substrings = set()\n    \n    for i in range(n):\n        for j in range(i + 1, n // 2 + 1):\n            if text[i:i + j] == text[i + j:i + 2 * j]:\n                distinct_substrings.add(text[i:i + j])\n    \n    return len(distinct_substrings)", "passed": false, "score": {"loc": 8, "tokens": 89, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.20707350167620986}}, {"code": "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    count = set()\n    for i in range(n):\n        for j in range(i + 1, n // 2 + 1):\n            if text[i:i + j] == text[i + j:i + 2 * j]:\n                count.add(text[i:i + j])\n    return len(count)", "passed": false, "score": {"loc": 8, "tokens": 89, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.20073420838194156}}, {"code": "def distinctEchoSubstrings(text: str) -> int:\n    n = len(text)\n    distinct_substrings = set()\n    \n    for i in range(n):\n        for j in range(i + 1, (n + 1) // 2):\n            if text[i:i + j] == text[i + j:i + 2 * j]:\n                distinct_substrings.add(text[i:i + j])\n                \n    return len(distinct_substrings)", "passed": false, "score": {"loc": 8, "tokens": 91, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.2136422241713224}}], "num_pass": 4, "num_uniq": 4, "num_fail": 6, "fail_uniq": 6}
{"id": 2559, "entry_point": "queryString", "best_list": [{"code": "def queryString(S, N):\n    return all(bin(x)[2:] in S for x in range(1, N + 1))", "passed": true, "score": {"loc": 2, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016444, "novelty": 0.43904216533344453}}, {"code": "def queryString(S, N):\n    return all(bin(X)[2:] in S for X in range(1, N + 1))", "passed": true, "score": {"loc": 2, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.016535, "novelty": 0.43395165183171613}}, {"code": "def queryString(S, N):\n    return all(f\"{i:b}\" in S for i in range(1, N + 1))", "passed": true, "score": {"loc": 2, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.017605, "novelty": 0.5025582921009133}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 2569, "entry_point": "coinChange", "best_list": [{"code": "def coinChange(coins, amount):\n    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for x in range(coin, amount + 1):\n            dp[x] = min(dp[x], dp[x - coin] + 1)\n    \n    return dp[amount] if dp[amount] != amount + 1 else -1", "passed": true, "score": {"loc": 7, "tokens": 83, "cc": 2, "nest": 3, "execution_time": 0.016657, "novelty": 0.09031257251018565}}, {"code": "def coinChange(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for x in range(coin, amount + 1):\n            dp[x] = min(dp[x], dp[x - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1", "passed": true, "score": {"loc": 7, "tokens": 89, "cc": 2, "nest": 3, "execution_time": 0.016679, "novelty": 0.1396794807023669}}, {"code": "def coinChange(coins, amount):\n    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if i - coin >= 0:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] <= amount else -1", "passed": true, "score": {"loc": 8, "tokens": 89, "cc": 3, "nest": 4, "execution_time": 0.016576, "novelty": 0.49301825134000676}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 2575, "entry_point": "subarraysWithKDistinct", "best_list": [{"code": "def subarraysWithKDistinct(A, K):\n    def atMost(K):\n        count = [0] * (len(A) + 1)\n        i = res = 0\n        for j, num in enumerate(A):\n            if count[num] == 0:\n                K -= 1\n            count[num] += 1\n            while K < 0:\n                count[A[i]] -= 1\n                if count[A[i]] == 0:\n                    K += 1\n                i += 1\n            res += j - i + 1\n        return res\n\n    return atMost(K) - atMost(K - 1)", "passed": true, "score": {"loc": 16, "tokens": 120, "cc": 4, "nest": 5, "execution_time": 0.016699, "novelty": 0.6920915066706781}}, {"code": "def subarraysWithKDistinct(A, K):\n    def atMost(K):\n        count = 0\n        left = 0\n        frequency = {}\n        for right, num in enumerate(A):\n            if num not in frequency:\n                frequency[num] = 0\n            frequency[num] += 1\n            while len(frequency) > K:\n                frequency[A[left]] -= 1\n                if frequency[A[left]] == 0:\n                    del frequency[A[left]]\n                left += 1\n            count += right - left + 1\n        return count\n    \n    return atMost(K) - atMost(K - 1)", "passed": true, "score": {"loc": 17, "tokens": 117, "cc": 4, "nest": 5, "execution_time": 0.016663, "novelty": 0.5435068861836133}}, {"code": "def subarraysWithKDistinct(A, K):\n    def atMostKDistinct(k):\n        count = 0\n        left = 0\n        char_count = {}\n        for right in range(len(A)):\n            if A[right] not in char_count:\n                char_count[A[right]] = 0\n            char_count[A[right]] += 1\n            while len(char_count) > k:\n                char_count[A[left]] -= 1\n                if char_count[A[left]] == 0:\n                    del char_count[A[left]]\n                left += 1\n            count += right - left + 1\n        return count\n\n    return atMostKDistinct(K) - atMostKDistinct(K - 1)", "passed": true, "score": {"loc": 17, "tokens": 127, "cc": 4, "nest": 5, "execution_time": 0.016531, "novelty": 0.47663681029483274}}, {"code": "from collections import Counter\n\ndef subarraysWithKDistinct(A, K):\n    count = Counter()\n    left = 0\n    result = 0\n    for right in range(len(A)):\n        if count[A[right]] == 0:\n            K -= 1\n        count[A[right]] += 1\n        while K < 0:\n            count[A[left]] -= 1\n            if count[A[left]] == 0:\n                K += 1\n            left += 1\n        result += right - left + 1\n    return result\n\ndef subarraysWithKDistinct(A, K):\n    return subarraysWithKDistinct(A, K) - subarraysWithKDistinct(A, K - 1)", "passed": false, "score": {"loc": 18, "tokens": 129, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.8322158167898388}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 2588, "entry_point": "majorityElement", "best_list": [{"code": "def majorityElement(nums):\n    nums.sort()\n    return nums[len(nums) // 2]", "passed": true, "score": {"loc": 3, "tokens": 22, "cc": 0, "nest": 1, "execution_time": 0.016653, "novelty": 0.7326980283529567}}, {"code": "from collections import Counter\n\ndef majorityElement(nums):\n    return Counter(nums).most_common(1)[0][0]", "passed": true, "score": {"loc": 3, "tokens": 26, "cc": 0, "nest": 1, "execution_time": 0.016734, "novelty": 0.7370616134113444}}, {"code": "def majorityElement(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)", "passed": true, "score": {"loc": 6, "tokens": 29, "cc": 2, "nest": 3, "execution_time": 0.016612, "novelty": 0.5915865123822854}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 2606, "entry_point": "lengthOfLastWord", "best_list": [{"code": "def lengthOfLastWord(s):\n    return len(s.strip().split(' ')[-1]) if s.strip() else 0", "passed": true, "score": {"loc": 2, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.01661, "novelty": 0.5626470004672464}}, {"code": "def lengthOfLastWord(s):\n    s = s.strip()\n    words = s.split(' ')\n    return len(words[-1]) if words else 0", "passed": true, "score": {"loc": 4, "tokens": 35, "cc": 0, "nest": 1, "execution_time": 0.016641, "novelty": 0.5162925720731422}}, {"code": "def lengthOfLastWord(s):\n    s = s.strip()\n    if not s:\n        return 0\n    return len(s.split(' ')[-1])", "passed": true, "score": {"loc": 5, "tokens": 34, "cc": 1, "nest": 2, "execution_time": 0.016605, "novelty": 0.5416754138143433}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 2627, "entry_point": "findTheLongestSubstring", "best_list": [{"code": "def findTheLongestSubstring(s):\n    vowels = 'aeiou'\n    mask = 0\n    max_length = 0\n    seen = {0: -1}\n    \n    for i, char in enumerate(s):\n        if char in vowels:\n            mask ^= 1 << (vowels.index(char))\n        if mask in seen:\n            max_length = max(max_length, i - seen[mask])\n        else:\n            seen[mask] = i\n    \n    return max_length", "passed": true, "score": {"loc": 13, "tokens": 82, "cc": 3, "nest": 3, "execution_time": 0.016542, "novelty": 0.42836783924260224}}, {"code": "def findTheLongestSubstring(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    parity_map = {0: -1}\n    mask = 0\n    max_length = 0\n\n    for i, char in enumerate(s):\n        if char in vowels:\n            mask ^= 1 << (ord(char) - ord('a'))\n        if mask in parity_map:\n            max_length = max(max_length, i - parity_map[mask])\n        else:\n            parity_map[mask] = i\n\n    return max_length", "passed": true, "score": {"loc": 13, "tokens": 110, "cc": 3, "nest": 3, "execution_time": 0.016647, "novelty": 0.4875927228807132}}, {"code": "def findTheLongestSubstring(s):\n    vowels = 'aeiou'\n    bit_map = {c: 1 << i for i, c in enumerate(vowels)}\n    seen = {0: -1}\n    mask = 0\n    max_length = 0\n\n    for i, char in enumerate(s):\n        if char in bit_map:\n            mask ^= bit_map[char]\n        if mask in seen:\n            max_length = max(max_length, i - seen[mask])\n        else:\n            seen[mask] = i\n\n    return max_length", "passed": true, "score": {"loc": 14, "tokens": 94, "cc": 3, "nest": 3, "execution_time": 0.016665, "novelty": 0.6367028167949969}}, {"code": "def findTheLongestSubstring(s):\n    counts = [0] * 32\n    counts[0] = -1\n    mask = 0\n    result = 0\n\n    for i, char in enumerate(s):\n        if char in \"aeiou\":\n            mask ^= 1 << (ord(char) - ord('a'))\n        if counts[mask] != -1:\n            result = max(result, i - counts[mask])\n        else:\n            counts[mask] = i\n\n    return result", "passed": false, "score": {"loc": 13, "tokens": 95, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.5051335179085951}}, {"code": "def findTheLongestSubstring(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = [0] * 32\n    count[0] = -1\n    result = 0\n    current = 0\n\n    for i, char in enumerate(s):\n        if char in vowels:\n            current ^= 1 << (ord(char) - ord('a'))\n        if current in count:\n            result = max(result, i - count[current])\n        else:\n            count[current] = i\n\n    return result", "passed": false, "score": {"loc": 14, "tokens": 116, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.4607564261515926}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 2680, "entry_point": "stoneGame", "best_list": [{"code": "def stoneGame(piles):\n    return True", "passed": true, "score": {"loc": 2, "tokens": 8, "cc": 0, "nest": 1, "execution_time": 0.016483, "novelty": 0.258730914635522}}, {"code": "def stoneGame(piles):\n    def canAlexWin(piles):\n        return sum(piles[::2]) > sum(piles[1::2])\n    return canAlexWin(piles)", "passed": true, "score": {"loc": 4, "tokens": 38, "cc": 0, "nest": 2, "execution_time": 0.016535, "novelty": 0.7342042740153212}}, {"code": "def stoneGame(piles):\n    def helper(left, right, turn):\n        if left > right:\n            return 0\n        if (right - left) % 2 == 0:\n            return max(helper(left + 1, right, not turn), helper(left, right - 1, not turn))\n        else:\n            return piles[left] + min(helper(left + 1, right, not turn), helper(left, right - 1, not turn))\n    \n    return helper(0, len(piles) - 1, True) > sum(piles) // 2", "passed": true, "score": {"loc": 9, "tokens": 118, "cc": 2, "nest": 3, "execution_time": 0.016619, "novelty": 0.8605415993678415}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 2702, "entry_point": "divide", "best_list": [{"code": "def divide(dividend, divisor):\n    if dividend == -2147483648 and divisor == -1:\n        return 2147483647\n    sign = -1 if (dividend < 0) != (divisor < 0) else 1\n    dividend, divisor = abs(dividend), abs(divisor)\n    quotient = 0\n    for i in range(31, -1, -1):\n        if (dividend >> i) - divisor >= 0:\n            dividend -= divisor << i\n            quotient += 1 << i\n    return sign * quotient", "passed": true, "score": {"loc": 11, "tokens": 103, "cc": 4, "nest": 3, "execution_time": 0.016755, "novelty": 0.3691725073539084}}, {"code": "def divide(dividend: int, divisor: int) -> int:\n    INT_MIN = -2**31\n    INT_MAX = 2**31 - 1\n    \n    if dividend == INT_MIN and divisor == -1:\n        return INT_MAX\n    \n    sign = -1 if (dividend < 0) ^ (divisor < 0) else 1\n    dividend, divisor = abs(dividend), abs(divisor)\n    quotient = 0\n    \n    for power in range(31, -1, -1):\n        if (dividend >> power) - divisor >= 0:\n            quotient += 1 << power\n            dividend -= divisor << power\n    \n    return sign * quotient", "passed": true, "score": {"loc": 13, "tokens": 123, "cc": 4, "nest": 3, "execution_time": 0.016679, "novelty": 0.30957178220229686}}, {"code": "def divide(dividend: int, divisor: int) -> int:\n    if dividend == -2**31 and divisor == -1:\n        return 2**31 - 1\n    sign = -1 if (dividend < 0) ^ (divisor < 0) else 1\n    dividend, divisor = abs(dividend), abs(divisor)\n    quotient = 0\n    while dividend >= divisor:\n        temp, i = divisor, 1\n        while dividend >= temp:\n            dividend -= temp\n            quotient += i\n            temp <<= 1\n            i <<= 1\n    return sign * quotient", "passed": true, "score": {"loc": 14, "tokens": 113, "cc": 4, "nest": 3, "execution_time": 0.016703, "novelty": 0.4248057700360103}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 2742, "entry_point": "reverse", "best_list": [{"code": "def reverse(x):\n    sign = [1, -1][x < 0]\n    rst = sign * int(str(abs(x))[::-1])\n    return rst if -(2**31)-1 < rst < 2**31 else 0", "passed": true, "score": {"loc": 4, "tokens": 60, "cc": 0, "nest": 1, "execution_time": 0.016931, "novelty": 0.2246226574907726}}, {"code": "def reverse(x):\n    sign = [-1, 1][x >= 0]\n    rst = sign * int(str(abs(x))[::-1])\n    return rst if -(2**31)-1 < rst < 2**31 else 0", "passed": true, "score": {"loc": 4, "tokens": 61, "cc": 0, "nest": 1, "execution_time": 0.016435, "novelty": 0.23208208016062892}}, {"code": "def reverse(x):\n    result = 0\n    while x != 0:\n        digit = x % 10\n        result = result * 10 + digit\n        if result < -2**31 or result > 2**31 - 1:\n            return 0\n        x //= 10\n    return result", "passed": true, "score": {"loc": 9, "tokens": 54, "cc": 3, "nest": 3, "execution_time": 0.016445, "novelty": 0.5914531107607423}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 2752, "entry_point": "checkIfExist", "best_list": [{"code": "def checkIfExist(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num * 2)\n        seen.add(num / 2)\n    return False", "passed": true, "score": {"loc": 8, "tokens": 41, "cc": 2, "nest": 3, "execution_time": 0.016681, "novelty": 0.0889680321212527}}, {"code": "def checkIfExist(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num * 2)\n        seen.add(num // 2 if num % 2 == 0 else None)\n    return False", "passed": true, "score": {"loc": 8, "tokens": 51, "cc": 2, "nest": 3, "execution_time": 0.016757, "novelty": 0.11257242081186325}}, {"code": "def checkIfExist(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num * 2)\n        if num % 2 == 0:\n            seen.add(num // 2)\n    return False", "passed": true, "score": {"loc": 9, "tokens": 50, "cc": 3, "nest": 3, "execution_time": 0.016609, "novelty": 0.03785484091674163}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 2819, "entry_point": "getRow", "best_list": [{"code": "from math import comb\n\ndef getRow(k: int) -> list[int]:\n    return [comb(k, i) for i in range(k + 1)]", "passed": true, "score": {"loc": 3, "tokens": 36, "cc": 0, "nest": 1, "execution_time": 0.016733, "novelty": 0.7049779196049926}}, {"code": "def getRow(k):\n    row = [1] * (k + 1)\n    for i in range(1, k // 2 + 1):\n        row[i] = row[k - i] = (row[i - 1] * (k - i + 1)) // i\n    return row", "passed": true, "score": {"loc": 5, "tokens": 65, "cc": 1, "nest": 2, "execution_time": 0.016703, "novelty": 0.3779244009406022}}, {"code": "def getRow(k):\n    row = [1] * (k + 1)\n    for i in range(1, k + 1):\n        for j in range(i - 1, 0, -1):\n            row[j] += row[j - 1]\n    return row", "passed": true, "score": {"loc": 6, "tokens": 58, "cc": 2, "nest": 3, "execution_time": 0.016593, "novelty": 0.27121431462825596}}, {"code": "def getRow(k):\n    row = [1] * (k + 1)\n    for i in range(1, k + 1):\n        for j in range(i, 0, -1):\n            row[j] += row[j - 1]\n    return row", "passed": false, "score": {"loc": 6, "tokens": 56, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.2631665528886623}}, {"code": "def getRow(i):\n    row = [1] * (i + 1)\n    for j in range(1, i):\n        row[j] = (row[j] * (i - j + 1)) // j\n    return row", "passed": false, "score": {"loc": 5, "tokens": 51, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.3962587170643793}}], "num_pass": 5, "num_uniq": 4, "num_fail": 5, "fail_uniq": 2}
{"id": 2826, "entry_point": "maxArea", "best_list": [{"code": "def maxArea(h, w, horizontalCuts, verticalCuts):\n    horizontalCuts = [0] + sorted(horizontalCuts) + [h]\n    verticalCuts = [0] + sorted(verticalCuts) + [w]\n    max_h = max(horizontalCuts[i] - horizontalCuts[i-1] for i in range(1, len(horizontalCuts)))\n    max_w = max(verticalCuts[i] - verticalCuts[i-1] for i in range(1, len(verticalCuts)))\n    return (max_h * max_w) % (10**9 + 7)", "passed": true, "score": {"loc": 6, "tokens": 111, "cc": 0, "nest": 1, "execution_time": 0.016633, "novelty": 0.5788364609716783}}, {"code": "def maxArea(h, w, horizontalCuts, verticalCuts):\n    MOD = 10**9 + 7\n    horizontalCuts.sort()\n    verticalCuts.sort()\n    \n    max_horizontal_cut = max(horizontalCuts[i] - horizontalCuts[i - 1] for i in range(1, len(horizontalCuts))) or h - horizontalCuts[-1]\n    max_vertical_cut = max(verticalCuts[i] - verticalCuts[i - 1] for i in range(1, len(verticalCuts))) or w - verticalCuts[-1]\n    \n    return (max_horizontal_cut * max_vertical_cut) % MOD", "passed": true, "score": {"loc": 7, "tokens": 110, "cc": 2, "nest": 1, "execution_time": 0.016744, "novelty": 0.8659768945093977}}, {"code": "def maxArea(h, w, horizontalCuts, verticalCuts):\n    horizontalCuts.sort()\n    verticalCuts.sort()\n    max_h = max(horizontalCuts[i] - horizontalCuts[i-1] for i in range(1, len(horizontalCuts)))\n    max_h = max(max_h, h - horizontalCuts[-1])\n    max_v = max(verticalCuts[i] - verticalCuts[i-1] for i in range(1, len(verticalCuts)))\n    max_v = max(max_v, w - verticalCuts[-1])\n    return (max_h * max_v) % (10**9 + 7)", "passed": true, "score": {"loc": 8, "tokens": 121, "cc": 0, "nest": 1, "execution_time": 0.016686, "novelty": 0.5578461545142246}}, {"code": "def maxArea(h, w, horizontalCuts, verticalCuts):\n    max_h = max(horizontalCuts[1:] - horizontalCuts[:-1])\n    max_h = max(max_h, h - horizontalCuts[-1])\n    max_h = max(max_h, horizontalCuts[0])\n\n    max_v = max(verticalCuts[1:] - verticalCuts[:-1])\n    max_v = max(max_v, w - verticalCuts[-1])\n    max_v = max(max_v, verticalCuts[0])\n\n    return (max_h * max_v) % (10**9 + 7)", "passed": false, "score": {"loc": 8, "tokens": 111, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6550266329625193}}, {"code": "def maxArea(h, w, horizontalCuts, verticalCuts):\n    max_h = max(horizontalCuts) - min(horizontalCuts)\n    max_w = max(verticalCuts) - min(verticalCuts)\n    return (max_h * max_w) % (10**9 + 7)", "passed": false, "score": {"loc": 4, "tokens": 49, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6065759932466435}}, {"code": "def maxArea(h, w, horizontalCuts, verticalCuts):\n    def max_v(max_v, w, prev_v):\n        return max(max_v, w - prev_v)\n\n    horizontalCuts.sort()\n    verticalCuts.sort()\n\n    max_h = max_v(0, h, 0)\n    max_h = max_v(max_h, h, horizontalCuts[0])\n    for i in range(1, len(horizontalCuts)):\n        max_h = max_v(max_h, h, horizontalCuts[i] - horizontalCuts[i-1])\n    max_h = max_v(max_h, h, h - horizontalCuts[-1])\n\n    max_w = max_v(0, w, 0)\n    max_w = max_v(max_w, w, verticalCuts[0])\n    for i in range(1, len(verticalCuts)):\n        max_w = max_v(max_w, w, verticalCuts[i] - verticalCuts[i-1])\n    max_w = max_v(max_w, w, w - verticalCuts[-1])\n\n    return (max_h * max_w) % (10**9 + 7)", "passed": false, "score": {"loc": 16, "tokens": 200, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.7780899571520131}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 2839, "entry_point": "minSumOfLengths", "best_list": [{"code": "def minSumOfLengths(arr, target):\n    n = len(arr)\n    min_len = float('inf')\n    result = float('inf')\n    min_len_prefix = [float('inf')] * n\n    \n    # Find the minimum length sub-array with sum equal to target\n    left, current_sum = 0, 0\n    for right in range(n):\n        current_sum += arr[right]\n        while current_sum >= target:\n            if current_sum == target:\n                length = right - left + 1\n                min_len = min(min_len, length)\n                min_len_prefix[right] = min(min_len_prefix[right], length)\n                if left > 0:\n                    min_len_prefix[right] = min(min_len_prefix[right], min_len_prefix[left - 1])\n            current_sum -= arr[left]\n            left += 1\n    \n    # Find the minimum sum of lengths of two non-overlapping sub-arrays\n    for i in range(n):\n        if min_len_prefix[i] < float('inf'):\n            result = min(result, min_len_prefix[i] + min_len)\n    \n    return result if result != float('inf') else -1", "passed": true, "score": {"loc": 23, "tokens": 217, "cc": 6, "nest": 5, "execution_time": 0.016737, "novelty": 0.7276520363569674}}, {"code": "def minSumOfLengths(arr, target):\n    def min_length_subarray(arr, target):\n        window_start = 0\n        window_sum = 0\n        min_length = float('inf')\n        for window_end in range(len(arr)):\n            window_sum += arr[window_end]\n            while window_sum >= target:\n                min_length = min(min_length, window_end - window_start + 1)\n                window_sum -= arr[window_start]\n                window_start += 1\n        return min_length if min_length != float('inf') else -1\n\n    n = len(arr)\n    min_lengths = [float('inf')] * n\n    min_length = float('inf')\n    for i in range(n):\n        length = min_length_subarray(arr[i:], target)\n        if length != -1:\n            min_lengths[i] = length\n            min_length = min(min_length, length)\n\n    min_sum = float('inf')\n    for i in range(n - 1):\n        if min_lengths[i] != float('inf') and min_lengths[i + 1] != float('inf'):\n            min_sum = min(min_sum, min_lengths[i] + min_lengths[i + 1])\n    return min_sum if min_sum != float('inf') else -1", "passed": true, "score": {"loc": 25, "tokens": 239, "cc": 7, "nest": 4, "execution_time": 0.016852, "novelty": 0.8174058583599447}}, {"code": "def minSumOfLengths(arr, target):\n    def min_subarray_length(arr, target):\n        length = float('inf')\n        start = 0\n        current_sum = 0\n        for end, num in enumerate(arr):\n            current_sum += num\n            while current_sum >= target:\n                if current_sum == target:\n                    length = min(length, end - start + 1)\n                current_sum -= arr[start]\n                start += 1\n        return length if length != float('inf') else -1\n\n    n = len(arr)\n    min_lengths = [float('inf')] * n\n    min_sum = float('inf')\n    current_min = float('inf')\n\n    for i in range(n):\n        current_min = min(current_min, min_subarray_length(arr[:i+1], target))\n        if current_min != float('inf'):\n            min_lengths[i] = current_min\n\n    for i in range(n-1, -1, -1):\n        if min_lengths[i] != float('inf'):\n            min_sum = min(min_sum, min_lengths[i] + min_subarray_length(arr[i:], target))\n\n    return min_sum if min_sum != float('inf') else -1", "passed": true, "score": {"loc": 25, "tokens": 239, "cc": 7, "nest": 5, "execution_time": 0.016925, "novelty": 0.787472368132402}}, {"code": "def minSumOfLengths(arr, target):\n    def min_length_subarray(nums, t):\n        result, i, current_sum = float('inf'), 0, 0\n        for j, num in enumerate(nums):\n            current_sum += num\n            while current_sum >= t:\n                if current_sum == t:\n                    result = min(result, j - i + 1)\n                current_sum -= nums[i]\n                i += 1\n        return result if result != float('inf') else -1\n\n    n = len(arr)\n    if min_length_subarray(arr, target) == -1:\n        return -1\n\n    min_lengths = [float('inf')] * n\n    j = 0\n    current_sum = 0\n    for i, num in enumerate(arr):\n        current_sum += num\n        while current_sum >= target:\n            if current_sum == target:\n                min_lengths[i] = i - j + 1\n            current_sum -= arr[j]\n            j += 1\n\n    min_length = float('inf')\n    for i in range(1, n):\n        if min_lengths[i-1] != float('inf') and min_lengths[i] != float('inf'):\n            min_length = min(min_length, min_lengths[i-1] + min_lengths[i])\n\n    return min_length if min_length != float('inf') else -1", "passed": false, "score": {"loc": 29, "tokens": 262, "cc": 10, "nest": 5, "execution_time": 10.0, "novelty": 0.804386885464621}}, {"code": "def minSumOfLengths(arr, target):\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    min_len = float('inf')\n    best_end = -1\n    result = float('inf')\n    \n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n        if prefix_sum[i + 1] - target in prefix_sum[:i + 1]:\n            start = prefix_sum[:i + 1].index(prefix_sum[i + 1] - target)\n            if start <= best_end:\n                min_len = min(min_len, i - start + 1)\n            result = min(result, min_len + i - start + 1)\n            best_end = i\n    \n    return result if result < float('inf') else -1", "passed": false, "score": {"loc": 15, "tokens": 157, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7587883784683651}}, {"code": "def minSumOfLengths(arr, target):\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n    \n    min_length = [float('inf')] * (n + 1)\n    min_sum = float('inf')\n    \n    for i in range(1, n + 1):\n        if prefix_sum[i] - target in prefix_sum:\n            j = prefix_sum.index(prefix_sum[i] - target)\n            min_length[i] = min_length[j] if min_length[j] != float('inf') else i - j\n            min_sum = min(min_sum, min_length[j] + i - j)\n    \n    return min_sum if min_sum != float('inf') else -1", "passed": false, "score": {"loc": 13, "tokens": 164, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6991888278504228}}, {"code": "def minSumOfLengths(arr, target):\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n    \n    min_length = float('inf')\n    min_lengths = [float('inf')] * n\n    min_sum = float('inf')\n    \n    for i in range(n):\n        if prefix_sum[i + 1] - target in prefix_sum[:i + 1]:\n            j = prefix_sum[:i + 1].index(prefix_sum[i + 1] - target)\n            if j < i:\n                min_lengths[j] = min(min_lengths[j], i - j)\n                min_sum = min(min_sum, min_lengths[j] + (i - j))\n    \n    return min_sum if min_sum != float('inf') else -1", "passed": false, "score": {"loc": 15, "tokens": 177, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.6977669844637282}}, {"code": "def minSumOfLengths(arr, target):\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n    \n    subarray_lengths = [-1] * n\n    min_length = float('inf')\n    min_length_at = -1\n    \n    for i in range(n):\n        if prefix_sum[i + 1] - prefix_sum[i] == target:\n            subarray_lengths[i] = 1\n        else:\n            if min_length_at != -1:\n                subarray_lengths[i] = min_length\n            if prefix_sum[i + 1] - target in prefix_sum[:i + 1]:\n                index = prefix_sum[:i + 1].index(prefix_sum[i + 1] - target)\n                subarray_lengths[i] = min(subarray_lengths[i], i - index + 1)\n                if subarray_lengths[index] != -1:\n                    min_length = min(min_length, i - index + 1 + subarray_lengths[index])\n                min_length_at = index\n    \n    if min_length == float('inf'):\n        return -1\n    return min_length\n\ndef _equivalent(_lhs, _rhs):\n    return _lhs == _rhs", "passed": false, "score": {"loc": 25, "tokens": 230, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.8576459413237779}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 2870, "entry_point": "carFleet", "best_list": [{"code": "def carFleet(target, position, speed):\n    cars = sorted(zip(position, speed), reverse=True)\n    fleets = []\n    for pos, sp in cars:\n        if not fleets or (target - pos) / sp > (target - fleets[-1][0]) / fleets[-1][1]:\n            fleets.append((pos, sp))\n    return len(fleets)", "passed": true, "score": {"loc": 7, "tokens": 85, "cc": 3, "nest": 3, "execution_time": 0.016509, "novelty": 0.6298126212055577}}, {"code": "def carFleet(target, position, speed):\n    cars = sorted(zip(position, speed), reverse=True)\n    fleets = 0\n    max_time = 0\n    \n    for pos, spd in cars:\n        time = (target - pos) / spd\n        if time > max_time:\n            fleets += 1\n            max_time = time\n    \n    return fleets", "passed": true, "score": {"loc": 10, "tokens": 61, "cc": 2, "nest": 3, "execution_time": 0.016494, "novelty": 0.12337317841846385}}, {"code": "def carFleet(target, position, speed):\n    cars = sorted(zip(position, speed), reverse=True)\n    fleets = 0\n    max_time = 0\n    \n    for pos, sp in cars:\n        time = (target - pos) / sp\n        if time > max_time:\n            fleets += 1\n            max_time = time\n    \n    return fleets", "passed": true, "score": {"loc": 10, "tokens": 61, "cc": 2, "nest": 3, "execution_time": 0.016547, "novelty": 0.12282937972838304}}], "num_pass": 10, "num_uniq": 7, "num_fail": 0, "fail_uniq": 0}
{"id": 2888, "entry_point": "canBeEqual", "best_list": [{"code": "def canBeEqual(target, arr):\n    return sorted(target) == sorted(arr)", "passed": true, "score": {"loc": 2, "tokens": 19, "cc": 0, "nest": 1, "execution_time": 0.016665, "novelty": 0.0}}], "num_pass": 10, "num_uniq": 1, "num_fail": 0, "fail_uniq": 0}
{"id": 2910, "entry_point": "grayCode", "best_list": [{"code": "def grayCode(n):\n    return [i ^ (i >> 1) for i in range(1 << n)]", "passed": true, "score": {"loc": 2, "tokens": 27, "cc": 0, "nest": 1, "execution_time": 0.016619, "novelty": 0.3536388917560187}}, {"code": "def grayCode(n: int) -> list[int]:\n    result = [0]\n    for i in range(n):\n        for j in range(len(result) - 1, -1, -1):\n            result.append(result[j] | (1 << i))\n    return result", "passed": true, "score": {"loc": 6, "tokens": 64, "cc": 2, "nest": 3, "execution_time": 0.016736, "novelty": 0.7191281945409654}}, {"code": "def grayCode(n):\n    if n == 0:\n        return [0]\n    \n    def backtrack(path, used):\n        if len(path) == 1 << n:\n            result.append(path[:])\n            return\n        for i in range(n):\n            if (path[-1] >> i) & 1 == 1:\n                if i not in used:\n                    used.add(i)\n                    path.append(path[-1] ^ (1 << i))\n                    backtrack(path, used)\n                    path.pop()\n                    used.remove(i)\n            else:\n                if i not in used:\n                    used.add(i)\n                    path.append(path[-1] | (1 << i))\n                    backtrack(path, used)\n                    path.pop()\n                    used.remove(i)\n    \n    result = []\n    backtrack([0], set())\n    return result", "passed": false, "score": {"loc": 25, "tokens": 181, "cc": 6, "nest": 5, "execution_time": 10.0, "novelty": 0.8220484748099701}}, {"code": "def grayCode(n):\n    return list(map(int, map(''.join, map(lambda x: format(x, f'0{n}b'), range(1 << n)))))", "passed": false, "score": {"loc": 2, "tokens": 50, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6179910639580618}}, {"code": "def grayCode(n):\n    def backtrack(path):\n        if len(path) == 1 << n:\n            result.append(path)\n            return\n        for bit in [0, 1]:\n            if not path or path[-1] ^ bit not in visited:\n                visited.add(path[-1] ^ bit)\n                backtrack(path + [path[-1] ^ bit])\n                visited.remove(path[-1] ^ bit)\n    \n    result = []\n    visited = {0}\n    backtrack([0])\n    return result[0]", "passed": false, "score": {"loc": 14, "tokens": 113, "cc": 4, "nest": 4, "execution_time": 10.0, "novelty": 0.7819038142694347}}], "num_pass": 7, "num_uniq": 2, "num_fail": 3, "fail_uniq": 3}
{"id": 2921, "entry_point": "countCharacters", "best_list": [{"code": "from collections import Counter\n\ndef countCharacters(words, chars):\n    char_count = Counter(chars)\n    return sum(len(word) for word in words if not Counter(word) - char_count)", "passed": true, "score": {"loc": 4, "tokens": 38, "cc": 0, "nest": 1, "execution_time": 0.016681, "novelty": 0.3627934415326425}}, {"code": "def countCharacters(words, chars):\n    from collections import Counter\n    char_count = Counter(chars)\n    return sum(len(word) for word in words if not Counter(word) - char_count)", "passed": true, "score": {"loc": 4, "tokens": 38, "cc": 0, "nest": 1, "execution_time": 0.016789, "novelty": 0.3091015586528988}}, {"code": "def countCharacters(words, chars):\n    from collections import Counter\n    \n    char_count = Counter(chars)\n    total_length = 0\n    \n    for word in words:\n        word_count = Counter(word)\n        if all(word_count[char] <= char_count[char] for char in word_count):\n            total_length += len(word)\n    \n    return total_length", "passed": true, "score": {"loc": 9, "tokens": 60, "cc": 2, "nest": 3, "execution_time": 0.016721, "novelty": 0.6762751800897503}}, {"code": "def countCharacters(words, chars):\n    def canForm(word, char_count):\n        return all(word.count(char) <= char_count[char] for char in word)\n\n    char_count = collections.Counter(chars)\n    return sum(len(word) for word in words if canForm(word, char_count))", "passed": false, "score": {"loc": 5, "tokens": 63, "cc": 0, "nest": 2, "execution_time": 10.0, "novelty": 0.793017591711055}}, {"code": "def countCharacters(words, chars):\n    from collections import Counter\n    char_count = Counter(chars)\n    return sum(len(word) for word in words if Counter(word) <= char_count)", "passed": false, "score": {"loc": 4, "tokens": 38, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.46977418494085077}}, {"code": "def countCharacters(words, chars):\n    def canBeFormed(word, charCount):\n        wordCount = Counter(word)\n        for char in wordCount:\n            if wordCount[char] > charCount[char]:\n                return False\n        return True\n\n    charCount = Counter(chars)\n    return sum(len(word) for word in words if canBeFormed(word, charCount))", "passed": false, "score": {"loc": 9, "tokens": 67, "cc": 2, "nest": 4, "execution_time": 10.0, "novelty": 0.7813850311077256}}, {"code": "def countCharacters(words, chars):\n    char_count = {}\n    for char in chars:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    total_length = 0\n    for word in words:\n        word_count = {}\n        for char in word:\n            word_count[char] = word_count.get(char, 0) + 1\n        if all(word_count[char] <= char_count[char] for char in word_count):\n            total_length += len(word)\n    \n    return total_length", "passed": false, "score": {"loc": 12, "tokens": 92, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.7361635284252892}}], "num_pass": 6, "num_uniq": 3, "num_fail": 4, "fail_uniq": 4}
{"id": 2922, "entry_point": "maxProfit", "best_list": [{"code": "def maxProfit(prices):\n    return sum(max(b - a, 0) for a, b in zip(prices, prices[1:]))", "passed": true, "score": {"loc": 2, "tokens": 33, "cc": 0, "nest": 1, "execution_time": 0.01665, "novelty": 0.39694742829641017}}, {"code": "def maxProfit(prices):\n    return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, len(prices)))", "passed": true, "score": {"loc": 2, "tokens": 38, "cc": 0, "nest": 1, "execution_time": 0.016588, "novelty": 0.5147503990280577}}, {"code": "def maxProfit(prices):\n    def _helper(prices):\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, len(prices)))\n    \n    return _helper(prices)", "passed": true, "score": {"loc": 4, "tokens": 49, "cc": 0, "nest": 2, "execution_time": 0.016638, "novelty": 0.8248894571194926}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 2966, "entry_point": "nthPersonGetsNthSeat", "best_list": [{"code": "def nthPersonGetsNthSeat(n):\n    return 1.0 if n == 1 else 0.5", "passed": true, "score": {"loc": 2, "tokens": 19, "cc": 0, "nest": 1, "execution_time": 0.0165, "novelty": 0.08441437155145459}}, {"code": "def nthPersonGetsNthSeat(n: int) -> float:\n    return 1.0 if n == 1 else 0.5", "passed": true, "score": {"loc": 2, "tokens": 24, "cc": 0, "nest": 1, "execution_time": 0.016696, "novelty": 0.10223277587796098}}, {"code": "def nthPersonGetsNthSeat(n):\n    return 1.0 if n == 1 else (0.5 if n == 2 else 0.0)", "passed": true, "score": {"loc": 2, "tokens": 30, "cc": 0, "nest": 1, "execution_time": 0.01657, "novelty": 0.20734218894317902}}, {"code": "def nthPersonGetsNthSeat(n):\n    return 0.5", "passed": false, "score": {"loc": 2, "tokens": 10, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.27598292818436976}}], "num_pass": 9, "num_uniq": 3, "num_fail": 1, "fail_uniq": 1}
{"id": 2991, "entry_point": "canCross", "best_list": [{"code": "def canCross(stones):\n    stone_set = set(stones)\n    jumps = {s: set() for s in stones}\n    jumps[0].add(1)\n\n    for stone in stones:\n        for jump in jumps[stone]:\n            for step in [jump - 1, jump, jump + 1]:\n                if step > 0 and stone + step in stone_set:\n                    jumps[stone + step].add(step)\n\n    return bool(jumps[stones[-1]])", "passed": true, "score": {"loc": 10, "tokens": 96, "cc": 5, "nest": 5, "execution_time": 0.016615, "novelty": 0.2836952501349369}}, {"code": "def canCross(stones):\n    stone_set = set(stones)\n    jumps = {stone: set() for stone in stones}\n    jumps[0].add(1)\n\n    for stone in stones:\n        for k in jumps[stone]:\n            for step in range(k - 1, k + 2):\n                if step > 0 and stone + step in stone_set:\n                    jumps[stone + step].add(step)\n\n    return len(jumps[stones[-1]]) > 0", "passed": true, "score": {"loc": 10, "tokens": 97, "cc": 5, "nest": 5, "execution_time": 0.016761, "novelty": 0.571572414013254}}, {"code": "def canCross(stones):\n    stone_set = set(stones)\n    jump_table = {stone: set() for stone in stones}\n    jump_table[0].add(0)\n\n    for stone in stones:\n        for jump in jump_table[stone]:\n            for next_jump in (jump - 1, jump, jump + 1):\n                if next_jump > 0 and stone + next_jump in stone_set:\n                    jump_table[stone + next_jump].add(next_jump)\n\n    return len(jump_table[stones[-1]]) > 0", "passed": true, "score": {"loc": 10, "tokens": 98, "cc": 5, "nest": 5, "execution_time": 0.016642, "novelty": 0.31519083338319587}}, {"code": "def canCross(stones):\n    stone_set = set(stones)\n    dp = {}\n\n    def can_jump(i, k):\n        if (i, k) in dp:\n            return dp[(i, k)]\n        if i == stones[-1]:\n            return True\n        if i not in stone_set:\n            return False\n        dp[(i, k)] = (k > 0 and can_jump(i + k, k - 1)) or (can_jump(i + k, k)) or (k > 1 and can_jump(i + k, k + 1))\n        return dp[(i, k)]\n\n    return can_jump(0, 0)", "passed": false, "score": {"loc": 13, "tokens": 131, "cc": 6, "nest": 3, "execution_time": 10.0, "novelty": 0.775993201410969}}, {"code": "def canCross(stones):\n    if stones[1] != 1:\n        return False\n    \n    stone_set = set(stones)\n    dp = [set() for _ in stones]\n    dp[0].add(0)\n    \n    for i in range(1, len(stones)):\n        for k in dp[i]:\n            if k > 0 and stones[i] + k in stone_set:\n                dp[stones[i] + k].add(k)\n            if k + 1 > 0 and stones[i] + k + 1 in stone_set:\n                dp[stones[i] + k + 1].add(k + 1)\n            if k - 1 > 0 and stones[i] + k - 1 in stone_set:\n                dp[stones[i] + k - 1].add(k - 1)\n    \n    return len(dp[-1]) > 0", "passed": false, "score": {"loc": 15, "tokens": 175, "cc": 9, "nest": 4, "execution_time": 10.0, "novelty": 0.8740953425148281}}], "num_pass": 8, "num_uniq": 8, "num_fail": 2, "fail_uniq": 2}
{"id": 3003, "entry_point": "subsetsWithDup", "best_list": [{"code": "def subsetsWithDup(nums):\n    nums.sort()\n    result = [[]]\n    for num in nums:\n        result += [subset + [num] for subset in result if subset + [num] not in result]\n    return result", "passed": true, "score": {"loc": 6, "tokens": 47, "cc": 1, "nest": 2, "execution_time": 0.016656, "novelty": 0.7121063672106682}}, {"code": "def subsetsWithDup(nums):\n    nums.sort()\n    res = [[]]\n    for num in nums:\n        res += [item + [num] for item in res if item + [num] not in res]\n    return res\n\ndef _equivalent(lhs, rhs):\n    return sorted(lhs) == sorted(rhs)", "passed": true, "score": {"loc": 8, "tokens": 66, "cc": 1, "nest": 2, "execution_time": 0.016618, "novelty": 0.6433767170962919}}, {"code": "def subsetsWithDup(nums):\n    result = set()\n    nums.sort()\n    def backtrack(start, path):\n        result.add(tuple(path))\n        for i in range(start, len(nums)):\n            backtrack(i + 1, path + [nums[i]])\n    backtrack(0, [])\n    return [list(subset) for subset in result]", "passed": true, "score": {"loc": 9, "tokens": 79, "cc": 1, "nest": 3, "execution_time": 0.016779, "novelty": 0.6890327004085882}}, {"code": "def subsetsWithDup(nums):\n    from collections import Counter\n    count = Counter(nums)\n    result = [[]]\n\n    for num in count:\n        for i in range(len(result)):\n            result.append(result[i] + [num] * count[num])\n\n    return result", "passed": false, "score": {"loc": 8, "tokens": 58, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7307710898790469}}, {"code": "def subsetsWithDup(nums):\n    nums.sort()\n    result = [[]]\n    start = 0\n    for i in range(len(nums)):\n        if i > 0 and nums[i] == nums[i - 1]:\n            start = len(result) - start\n        end = len(result)\n        for j in range(start, end):\n            result.append(result[j] + [nums[i]])\n    return result", "passed": false, "score": {"loc": 11, "tokens": 91, "cc": 4, "nest": 3, "execution_time": 10.0, "novelty": 0.6797622149867846}}], "num_pass": 8, "num_uniq": 7, "num_fail": 2, "fail_uniq": 2}
{"id": 3094, "entry_point": "maxValueAfterReverse", "best_list": [{"code": "def maxValueAfterReverse(nums):\n    n = len(nums)\n    total = sum(abs(nums[i] - nums[i+1]) for i in range(n-1))\n    max_gain = 0\n    \n    for i in range(n-1):\n        max_gain = max(max_gain, abs(nums[0] - nums[i+1]) - abs(nums[i] - nums[i+1]))\n        max_gain = max(max_gain, abs(nums[-1] - nums[i]) - abs(nums[i] - nums[i+1]))\n    \n    for i in range(1, n-1):\n        max_gain = max(max_gain, abs(nums[i] - nums[0]) - abs(nums[i+1] - nums[0]))\n        max_gain = max(max_gain, abs(nums[i] - nums[-1]) - abs(nums[i-1] - nums[-1]))\n    \n    return total + max_gain", "passed": true, "score": {"loc": 11, "tokens": 210, "cc": 2, "nest": 2, "execution_time": 0.016627, "novelty": 0.47589140201524094}}, {"code": "def maxValueAfterReverse(nums):\n    n = len(nums)\n    if n <= 2:\n        return 0\n    \n    current_value = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    max_diff = 0\n    \n    for i in range(n - 1):\n        max_diff = max(max_diff, \n                       abs(nums[0] - nums[i + 1]) - abs(nums[i] - nums[i + 1]),\n                       abs(nums[n - 1] - nums[i]) - abs(nums[i] - nums[i + 1]),\n                       abs(nums[i] - nums[0]) - abs(nums[i + 1] - nums[i]),\n                       abs(nums[i] - nums[n - 1]) - abs(nums[i + 1] - nums[i]))\n    \n    return current_value + max_diff", "passed": true, "score": {"loc": 13, "tokens": 189, "cc": 2, "nest": 2, "execution_time": 0.016605, "novelty": 0.49025111944400745}}, {"code": "def maxValueAfterReverse(nums):\n    n = len(nums)\n    current_value = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    max_value = current_value\n    \n    for i in range(n - 1):\n        max_value = max(max_value, current_value - abs(nums[i] - nums[i + 1]) + abs(nums[0] - nums[i + 1]), \n                       current_value - abs(nums[i] - nums[i + 1]) + abs(nums[i] - nums[0]))\n    \n    for i in range(1, n):\n        max_value = max(max_value, current_value - abs(nums[i - 1] - nums[i]) + abs(nums[0] - nums[i]),\n                       current_value - abs(nums[i - 1] - nums[i]) + abs(nums[i - 1] - nums[-1]))\n    \n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if i == 0:\n                max_value = max(max_value, current_value - abs(nums[i] - nums[i + 1]) + abs(nums[j] - nums[i + 1]))\n            elif j == n - 1:\n                max_value = max(max_value, current_value - abs(nums[i] - nums[i + 1]) + abs(nums[i] - nums[j]))\n            else:\n                max_value = max(max_value, current_value - abs(nums[i] - nums[i + 1]) + abs(nums[i] - nums[j]) + \n                               abs(nums[i + 1] - nums[j]) - abs(nums[i] - nums[j]))\n    \n    return max_value", "passed": true, "score": {"loc": 20, "tokens": 378, "cc": 6, "nest": 5, "execution_time": 0.016761, "novelty": 0.7010658482815237}}, {"code": "def maxValueAfterReverse(nums):\n    n = len(nums)\n    if n <= 2:\n        return sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    \n    max_diff = 0\n    current_diff = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    \n    for i in range(n - 1):\n        max_diff = max(max_diff, abs(nums[0] - nums[i + 1]) - abs(nums[i] - nums[i + 1]))\n        max_diff = max(max_diff, abs(nums[-1] - nums[i]) - abs(nums[i] - nums[i + 1]))\n    \n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if i == 0:\n                max_diff = max(max_diff, current_diff - abs(nums[i] - nums[j]) + abs(nums[j] - nums[j + 1]) + abs(nums[i] - nums[j + 1]))\n            elif j == n - 1:\n                max_diff = max(max_diff, current_diff - abs(nums[i] - nums[j]) + abs(nums[i - 1] - nums[j - 1]) + abs(nums[j - 1] - nums[i]))\n            else:\n                max_diff = max(max_diff, current_diff - abs(nums[i] - nums[j]) + abs(nums[j] - nums[j + 1]) + abs(nums[i - 1] - nums[j - 1]))\n    \n    return current_diff + max_diff", "passed": false, "score": {"loc": 18, "tokens": 356, "cc": 6, "nest": 5, "execution_time": 10.0, "novelty": 0.6989498205609139}}, {"code": "def maxValueAfterReverse(nums):\n    n = len(nums)\n    if n == 1:\n        return 0\n    \n    current_value = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    max_value = current_value\n    \n    # Check reversing the entire array\n    max_value = max(max_value, 2 * sum(nums) - current_value)\n    \n    # Check reversing subarrays ending at each position\n    for i in range(n - 1):\n        max_value = max(max_value, current_value - abs(nums[i] - nums[i + 1]) + abs(nums[0] - nums[i + 1]))\n        max_value = max(max_value, current_value - abs(nums[i] - nums[i + 1]) + abs(nums[i] - nums[0]))\n    \n    # Check reversing subarrays starting at each position\n    for i in range(1, n):\n        max_value = max(max_value, current_value - abs(nums[i] - nums[i - 1]) + abs(nums[i] - nums[-1]))\n        max_value = max(max_value, current_value - abs(nums[i] - nums[i - 1]) + abs(nums[-1] - nums[i - 1]))\n    \n    return max_value", "passed": false, "score": {"loc": 17, "tokens": 260, "cc": 3, "nest": 2, "execution_time": 10.0, "novelty": 0.7096074621734113}}, {"code": "def maxValueAfterReverse(nums):\n    n = len(nums)\n    current_sum = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    max_gain = 0\n\n    for i in range(n - 1):\n        max_gain = max(max_gain, abs(nums[0] - nums[i + 1]) - abs(nums[i] - nums[i + 1]))\n        max_gain = max(max_gain, abs(nums[n - 1] - nums[i]) - abs(nums[i] - nums[i + 1]))\n\n    for i in range(1, n):\n        max_gain = max(max_gain, abs(nums[i - 1] - nums[n - 1]) - abs(nums[i] - nums[i - 1]))\n\n    return current_sum + max_gain", "passed": false, "score": {"loc": 10, "tokens": 177, "cc": 2, "nest": 2, "execution_time": 10.0, "novelty": 0.48269535383920814}}, {"code": "def maxValueAfterReverse(nums):\n    n = len(nums)\n    original_sum = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    max_gain = 0\n\n    for i in range(n - 1):\n        max_gain = max(max_gain, 2 * abs(nums[i] - nums[n - 1]) - abs(nums[i] - nums[i + 1]),\n                       2 * abs(nums[0] - nums[i + 1]) - abs(nums[i] - nums[i + 1]))\n\n    return original_sum + max_gain", "passed": false, "score": {"loc": 8, "tokens": 127, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.5305697712977515}}, {"code": "def maxValueAfterReverse(nums):\n    n = len(nums)\n    current_value = sum(abs(nums[i] - nums[i + 1]) for i in range(n - 1))\n    max_increase = 0\n\n    for i in range(n - 1):\n        max_increase = max(max_increase, abs(nums[0] - nums[i + 1]) - abs(nums[i] - nums[i + 1]))\n        max_increase = max(max_increase, abs(nums[n - 1] - nums[i]) - abs(nums[i] - nums[i + 1]))\n        if i > 0:\n            max_increase = max(max_increase, abs(nums[i - 1] - nums[n - 1]) - abs(nums[i - 1] - nums[i]) + abs(nums[i] - nums[n - 1]) - abs(nums[i] - nums[i + 1]))\n\n    return current_value + max_increase", "passed": false, "score": {"loc": 10, "tokens": 202, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.4952604791093659}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 3099, "entry_point": "countNegatives", "best_list": [{"code": "def countNegatives(grid):\n    return sum(row.count(x) for row in grid for x in range(-1, -101, -1))", "passed": true, "score": {"loc": 2, "tokens": 34, "cc": 0, "nest": 1, "execution_time": 0.016623, "novelty": 0.7139785097930462}}, {"code": "def countNegatives(grid):\n    count = 0\n    for row in grid:\n        count += sum(1 for x in row if x < 0)\n    return count", "passed": true, "score": {"loc": 5, "tokens": 31, "cc": 1, "nest": 2, "execution_time": 0.016573, "novelty": 0.5895338935708436}}, {"code": "def countNegatives(grid):\n    count = 0\n    for row in grid:\n        for num in row:\n            if num < 0:\n                count += 1\n    return count", "passed": true, "score": {"loc": 7, "tokens": 30, "cc": 3, "nest": 4, "execution_time": 0.016555, "novelty": 0.3952395222423366}}, {"code": "def countNegatives(grid):\n    return sum(row.count(-1) for row in grid)", "passed": false, "score": {"loc": 2, "tokens": 21, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6791392782056773}}, {"code": "def countNegatives(grid):\n    m, n = len(grid), len(grid[0])\n    count = 0\n    for i in range(m):\n        j = 0\n        while j < n and grid[i][j] >= 0:\n            j += 1\n        count += n - j\n    return count", "passed": false, "score": {"loc": 9, "tokens": 64, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6885818634676504}}, {"code": "def countNegatives(grid):\n    count = 0\n    rows, cols = len(grid), len(grid[0])\n    row, col = 0, cols - 1\n    while row < rows and col >= 0:\n        if grid[row][col] < 0:\n            count += rows - row\n            col -= 1\n        else:\n            row += 1\n    return count", "passed": false, "score": {"loc": 11, "tokens": 73, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6895287040908282}}, {"code": "def countNegatives(grid):\n    m, n = len(grid), len(grid[0])\n    count = 0\n    for i in range(m):\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if grid[i][mid] < 0:\n                right = mid\n            else:\n                left = mid + 1\n        count += n - left\n    return count", "passed": false, "score": {"loc": 13, "tokens": 84, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7256190059073202}}], "num_pass": 6, "num_uniq": 3, "num_fail": 4, "fail_uniq": 4}
{"id": 3112, "entry_point": "subarraySum", "best_list": [{"code": "def subarraySum(nums, k):\n    count, total = 0, 0\n    seen = {0: 1}\n    for num in nums:\n        total += num\n        if total - k in seen:\n            count += seen[total - k]\n        seen[total] = seen.get(total, 0) + 1\n    return count", "passed": true, "score": {"loc": 9, "tokens": 64, "cc": 2, "nest": 3, "execution_time": 0.016592, "novelty": 0.16443425056206606}}, {"code": "def subarraySum(nums, k):\n    count, current_sum = 0, 0\n    prefix_sum_count = {0: 1}\n    for num in nums:\n        current_sum += num\n        if current_sum - k in prefix_sum_count:\n            count += prefix_sum_count[current_sum - k]\n        prefix_sum_count[current_sum] = prefix_sum_count.get(current_sum, 0) + 1\n    return count", "passed": true, "score": {"loc": 9, "tokens": 64, "cc": 2, "nest": 3, "execution_time": 0.016733, "novelty": 0.3246562803343097}}, {"code": "def subarraySum(nums, k):\n    count, cumulative_sum = 0, 0\n    sum_counts = {0: 1}\n    \n    for num in nums:\n        cumulative_sum += num\n        if cumulative_sum - k in sum_counts:\n            count += sum_counts[cumulative_sum - k]\n        sum_counts[cumulative_sum] = sum_counts.get(cumulative_sum, 0) + 1\n    \n    return count", "passed": true, "score": {"loc": 9, "tokens": 64, "cc": 2, "nest": 3, "execution_time": 0.016741, "novelty": 0.23169850155917382}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 3156, "entry_point": "maximumSum", "best_list": [{"code": "def maximumSum(arr):\n    n = len(arr)\n    max_sum = float('-inf')\n    dp = [[0] * 2 for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = max(arr[i], dp[i-1][0] + arr[i])\n        dp[i][1] = max(dp[i-1][0], dp[i-1][1] + arr[i])\n        max_sum = max(max_sum, dp[i][0], dp[i][1])\n    \n    return max_sum", "passed": true, "score": {"loc": 9, "tokens": 134, "cc": 1, "nest": 2, "execution_time": 0.016562, "novelty": 0.7336391621102576}}, {"code": "def maximumSum(arr):\n    n = len(arr)\n    if n == 1:\n        return arr[0]\n    \n    dp = [[0, 0] for _ in range(n)]\n    dp[0][0] = arr[0]\n    dp[0][1] = arr[0]\n    \n    for i in range(1, n):\n        dp[i][0] = max(arr[i], dp[i - 1][0] + arr[i])\n        dp[i][1] = max(dp[i - 1][0], dp[i - 1][1] + arr[i])\n    \n    return max(max(dp[i]) for i in range(n))", "passed": true, "score": {"loc": 11, "tokens": 156, "cc": 2, "nest": 2, "execution_time": 0.016717, "novelty": 0.613071348986334}}, {"code": "def maximumSum(arr):\n    n = len(arr)\n    dp = [[0, 0] for _ in range(n)]\n    dp[0][0] = arr[0]\n    dp[0][1] = arr[0]\n    max_sum = arr[0]\n    \n    for i in range(1, n):\n        dp[i][0] = max(dp[i-1][0] + arr[i], arr[i])\n        dp[i][1] = max(dp[i-1][0], dp[i-1][1] + arr[i])\n        max_sum = max(max_sum, dp[i][0], dp[i][1])\n    \n    return max_sum", "passed": true, "score": {"loc": 11, "tokens": 157, "cc": 1, "nest": 2, "execution_time": 0.016568, "novelty": 0.613474065867013}}, {"code": "def maximumSum(arr):\n    n = len(arr)\n    if n == 1:\n        return arr[0]\n    \n    max_sum = arr[0]\n    current_sum = arr[0]\n    \n    for i in range(1, n):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    \n    without_deletion = max_sum\n    \n    current_sum = arr[0]\n    max_sum = arr[0]\n    \n    for i in range(1, n):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    \n    without_deletion = max(without_deletion, max_sum)\n    \n    current_sum = arr[0]\n    max_sum = arr[0]\n    \n    for i in range(1, n):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    \n    without_deletion = max(without_deletion, max_sum)\n    \n    return without_deletion", "passed": false, "score": {"loc": 23, "tokens": 182, "cc": 4, "nest": 2, "execution_time": 10.0, "novelty": 0.6346419215715995}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 3226, "entry_point": "bagOfTokensScore", "best_list": [{"code": "def bagOfTokensScore(tokens, P):\n    tokens.sort()\n    left, right = 0, len(tokens) - 1\n    score, max_score = 0, 0\n    \n    while left <= right:\n        if P >= tokens[left]:\n            P -= tokens[left]\n            score += 1\n            left += 1\n            max_score = max(max_score, score)\n        elif score > 0:\n            P += tokens[right]\n            score -= 1\n            right -= 1\n        else:\n            break\n    \n    return max_score", "passed": true, "score": {"loc": 17, "tokens": 95, "cc": 3, "nest": 4, "execution_time": 0.016645, "novelty": 0.17691350345128753}}, {"code": "def bagOfTokensScore(tokens, P):\n    tokens.sort()\n    points = 0\n    max_points = 0\n    left, right = 0, len(tokens) - 1\n    \n    while left <= right:\n        if P >= tokens[left]:\n            P -= tokens[left]\n            points += 1\n            left += 1\n            max_points = max(max_points, points)\n        elif points > 0:\n            P += tokens[right]\n            points -= 1\n            right -= 1\n        else:\n            break\n    \n    return max_points", "passed": true, "score": {"loc": 18, "tokens": 94, "cc": 3, "nest": 4, "execution_time": 0.016585, "novelty": 0.07981998799610701}}, {"code": "def bagOfTokensScore(tokens, P):\n    tokens.sort()\n    points = 0\n    max_points = 0\n    i, j = 0, len(tokens) - 1\n    \n    while i <= j:\n        if P >= tokens[i]:\n            P -= tokens[i]\n            points += 1\n            max_points = max(max_points, points)\n            i += 1\n        elif points > 0:\n            P += tokens[j]\n            points -= 1\n            j -= 1\n        else:\n            break\n    \n    return max_points", "passed": true, "score": {"loc": 18, "tokens": 94, "cc": 3, "nest": 4, "execution_time": 0.01662, "novelty": 0.08031214843176315}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 3243, "entry_point": "numSquares", "best_list": [{"code": "def numSquares(n):\n    dp = {0: 0}\n    for i in range(1, n + 1):\n        dp[i] = min(dp[i - j * j] + 1 for j in range(1, int(i**0.5) + 1))\n    return dp[n]", "passed": true, "score": {"loc": 5, "tokens": 67, "cc": 1, "nest": 2, "execution_time": 0.016663, "novelty": 0.618093073399871}}, {"code": "def numSquares(n: int) -> int:\n    dp = {0: 0}\n    for i in range(1, n + 1):\n        dp[i] = min(dp[i - j * j] + 1 for j in range(1, int(i**0.5) + 1))\n    return dp[n]", "passed": true, "score": {"loc": 5, "tokens": 72, "cc": 1, "nest": 2, "execution_time": 0.016693, "novelty": 0.6221545541241875}}, {"code": "def numSquares(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n    return dp[n]", "passed": true, "score": {"loc": 9, "tokens": 83, "cc": 2, "nest": 3, "execution_time": 0.016538, "novelty": 0.23119358950932578}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 3304, "entry_point": "minSubarray", "best_list": [{"code": "def minSubarray(nums, p):\n    target = sum(nums) % p\n    if target == 0:\n        return 0\n    \n    prefix_sum = 0\n    min_len = float('inf')\n    seen = {0: -1}\n    \n    for i, num in enumerate(nums):\n        prefix_sum = (prefix_sum + num) % p\n        if (prefix_sum - target) % p in seen:\n            min_len = min(min_len, i - seen[(prefix_sum - target) % p])\n        seen[prefix_sum] = i\n    \n    return min_len if min_len < len(nums) else -1", "passed": true, "score": {"loc": 13, "tokens": 110, "cc": 3, "nest": 3, "execution_time": 0.016814, "novelty": 0.31958655673950753}}, {"code": "def minSubarray(nums, p):\n    target = sum(nums) % p\n    if target == 0:\n        return 0\n    \n    prefix_sum = 0\n    min_length = float('inf')\n    seen = {0: -1}\n    \n    for i, num in enumerate(nums):\n        prefix_sum = (prefix_sum + num) % p\n        needed = (prefix_sum - target) % p\n        if needed in seen:\n            min_length = min(min_length, i - seen[needed])\n        seen[prefix_sum] = i\n    \n    return min_length if min_length < len(nums) else -1", "passed": true, "score": {"loc": 14, "tokens": 107, "cc": 3, "nest": 3, "execution_time": 0.01654, "novelty": 0.2442397550076526}}, {"code": "def minSubarray(nums, p):\n    target = sum(nums) % p\n    if target == 0:\n        return 0\n    \n    prefix_sum_mod = {0: -1}\n    current_sum_mod = 0\n    min_length = float('inf')\n    \n    for i, num in enumerate(nums):\n        current_sum_mod = (current_sum_mod + num) % p\n        required_mod = (current_sum_mod - target) % p\n        if required_mod in prefix_sum_mod:\n            min_length = min(min_length, i - prefix_sum_mod[required_mod])\n        prefix_sum_mod[current_sum_mod] = i\n    \n    return min_length if min_length < len(nums) else -1", "passed": true, "score": {"loc": 14, "tokens": 107, "cc": 3, "nest": 3, "execution_time": 0.016642, "novelty": 0.5915978986136634}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 3394, "entry_point": "isScramble", "best_list": [{"code": "def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if sorted(s1) != sorted(s2):\n        return False\n    for i in range(1, len(s1)):\n        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n           (isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i])):\n            return True\n    return False", "passed": true, "score": {"loc": 10, "tokens": 122, "cc": 7, "nest": 3, "execution_time": 0.016765, "novelty": 0.30771341854181844}}, {"code": "def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2) or sorted(s1) != sorted(s2):\n        return False\n    for i in range(1, len(s1)):\n        if isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:]) or \\\n           isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i]):\n            return True\n    return False", "passed": true, "score": {"loc": 10, "tokens": 129, "cc": 8, "nest": 3, "execution_time": 0.016527, "novelty": 0.5249556025428771}}, {"code": "def isScramble(s1: str, s2: str) -> bool:\n    if len(s1) != len(s2):\n        return False\n    if s1 == s2:\n        return True\n    if sorted(s1) != sorted(s2):\n        return False\n    n = len(s1)\n    for i in range(1, n):\n        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n           (isScramble(s1[:i], s2[n-i:]) and isScramble(s1[i:], s2[:n-i])):\n            return True\n    return False", "passed": true, "score": {"loc": 13, "tokens": 141, "cc": 8, "nest": 3, "execution_time": 0.016799, "novelty": 0.6539638724704693}}, {"code": "def isScramble(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    if s1 == s2:\n        return True\n    count = [0] * 26\n    for i in range(len(s1)):\n        count[ord(s1[i]) - ord('a')] += 1\n        count[ord(s2[i]) - ord('a')] -= 1\n        if count[i] != 0:\n            return False\n    for i in range(1, len(s1)):\n        if isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:]):\n            return True\n        if isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i]):\n            return True\n    return False", "passed": false, "score": {"loc": 17, "tokens": 182, "cc": 9, "nest": 3, "execution_time": 10.0, "novelty": 0.779164052769464}}, {"code": "def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2):\n        return False\n    count = [0] * 26\n    for i in range(len(s1)):\n        count[ord(s1[i]) - ord('a')] += 1\n        count[ord(s2[i]) - ord('a')] -= 1\n        if count[i] != 0:\n            return False\n    for i in range(1, len(s1)):\n        if isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:]) or \\\n           isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i]):\n            return True\n    return False", "passed": false, "score": {"loc": 16, "tokens": 187, "cc": 9, "nest": 3, "execution_time": 10.0, "novelty": 0.5756046750382109}}, {"code": "def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2):\n        return False\n\n    count = [0] * 26\n    for i in range(len(s1)):\n        count[ord(s1[i]) - ord('a')] += 1\n        count[ord(s2[i]) - ord('a')] -= 1\n\n    if any(count):\n        return False\n\n    n = len(s1)\n    for i in range(1, n):\n        if isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:]) or \\\n           isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i]):\n            return True\n    return False", "passed": false, "score": {"loc": 17, "tokens": 187, "cc": 9, "nest": 3, "execution_time": 10.0, "novelty": 0.6022166647497715}}, {"code": "def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2):\n        return False\n    count = [0] * 26\n    for i in range(len(s1)):\n        count[ord(s1[i]) - ord('a')] += 1\n        count[ord(s2[i]) - ord('a')] -= 1\n    if any(count):\n        return False\n    for i in range(1, len(s1)):\n        if isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:]) or \\\n           isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i]):\n            return True\n    return False", "passed": false, "score": {"loc": 16, "tokens": 184, "cc": 9, "nest": 3, "execution_time": 10.0, "novelty": 0.5991776706020662}}], "num_pass": 6, "num_uniq": 5, "num_fail": 4, "fail_uniq": 4}
{"id": 3459, "entry_point": "canCompleteCircuit", "best_list": [{"code": "def canCompleteCircuit(gas, cost):\n    total_gas = current_gas = start = 0\n    for i in range(len(gas)):\n        total_gas += gas[i] - cost[i]\n        current_gas += gas[i] - cost[i]\n        if current_gas < 0:\n            start = i + 1\n            current_gas = 0\n    return start if total_gas >= 0 else -1", "passed": true, "score": {"loc": 9, "tokens": 73, "cc": 2, "nest": 3, "execution_time": 0.016701, "novelty": 0.27651769832675166}}, {"code": "def canCompleteCircuit(gas, cost):\n    total_tank, curr_tank = 0, 0\n    start_station = 0\n    \n    for i in range(len(gas)):\n        total_tank += gas[i] - cost[i]\n        curr_tank += gas[i] - cost[i]\n        \n        if curr_tank < 0:\n            start_station = i + 1\n            curr_tank = 0\n    \n    return start_station if total_tank >= 0 else -1", "passed": true, "score": {"loc": 10, "tokens": 76, "cc": 2, "nest": 3, "execution_time": 0.016549, "novelty": 0.3102298576293614}}, {"code": "def canCompleteCircuit(gas, cost):\n    total_gas, current_gas = 0, 0\n    start = 0\n    \n    for i in range(len(gas)):\n        total_gas += gas[i] - cost[i]\n        current_gas += gas[i] - cost[i]\n        \n        if current_gas < 0:\n            start = i + 1\n            current_gas = 0\n    \n    return start if total_gas >= 0 else -1", "passed": true, "score": {"loc": 10, "tokens": 76, "cc": 2, "nest": 3, "execution_time": 0.016556, "novelty": 0.2741376212318456}}], "num_pass": 10, "num_uniq": 9, "num_fail": 0, "fail_uniq": 0}
{"id": 379, "entry_point": "tribonacci", "best_list": [{"code": "def tribonacci(n):\n    a, b, c = 0, 1, 1\n    for _ in range(n):\n        a, b, c = b, c, a + b + c\n    return a", "passed": true, "score": {"loc": 5, "tokens": 42, "cc": 1, "nest": 2, "execution_time": 0.01662, "novelty": 0.2159660190305417}}, {"code": "def tribonacci(n: int) -> int:\n    a, b, c = 0, 1, 1\n    for _ in range(n):\n        a, b, c = b, c, a + b + c\n    return a", "passed": true, "score": {"loc": 5, "tokens": 47, "cc": 1, "nest": 2, "execution_time": 0.016591, "novelty": 0.2243614829866346}}, {"code": "def tribonacci(n):\n    trib = {0: 0, 1: 1, 2: 1}\n    for i in range(3, n + 1):\n        trib[i] = trib[i - 1] + trib[i - 2] + trib[i - 3]\n    return trib[n]", "passed": true, "score": {"loc": 5, "tokens": 63, "cc": 1, "nest": 2, "execution_time": 0.016598, "novelty": 0.6090333713931455}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 388, "entry_point": "sumFourDivisors", "best_list": [{"code": "def sumFourDivisors(nums):\n    return sum(sum(d for d in range(1, n + 1) if n % d == 0 and len([d for d in range(1, n + 1) if n % d == 0]) == 4) for n in nums)", "passed": true, "score": {"loc": 2, "tokens": 64, "cc": 1, "nest": 1, "execution_time": 0.016647, "novelty": 0.6582064252547821}}, {"code": "def sumFourDivisors(nums):\n    def hasFourDivisors(n):\n        count = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                count += 1\n                if i * i != n:\n                    count += 1\n                if count > 4:\n                    return False\n        return count == 4\n\n    return sum(sum(i for i in range(1, n + 1) if n % i == 0) for n in nums if hasFourDivisors(n))", "passed": true, "score": {"loc": 12, "tokens": 106, "cc": 4, "nest": 5, "execution_time": 0.016759, "novelty": 0.442655500881449}}, {"code": "def sumFourDivisors(nums):\n    def count_divisors(n):\n        count = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                count += 2 if i != n // i else 1\n                if count > 4:\n                    return 0\n        return count if count == 4 else 0\n    \n    total = 0\n    for num in nums:\n        if count_divisors(num) == 4:\n            total += sum(divisor for divisor in range(1, num + 1) if num % divisor == 0)\n    return total", "passed": true, "score": {"loc": 14, "tokens": 117, "cc": 5, "nest": 5, "execution_time": 0.016661, "novelty": 0.5092740474229154}}, {"code": "def sumFourDivisors(nums):\n    def count_divisors(n):\n        count, i = 0, 1\n        for i in reversed(range(1, int(n**0.5) + 1)):\n            if n % i == 0:\n                count += 1\n                if i != n // i:\n                    count += 1\n            if count > 4:\n                return 0\n        return count\n\n    return sum(sum(range(1, n + 1)) if count_divisors(n) == 4 else 0 for n in reversed(nums))", "passed": false, "score": {"loc": 12, "tokens": 108, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.6760755281817648}}, {"code": "def sumFourDivisors(nums):\n    def has_four_divisors(n):\n        divisors = []\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return len(divisors) == 4\n    \n    return sum(n for n in nums if has_four_divisors(n))", "passed": false, "score": {"loc": 10, "tokens": 90, "cc": 3, "nest": 5, "execution_time": 10.0, "novelty": 0.5369958329811892}}, {"code": "def sumFourDivisors(nums):\n    def count_divisors(n):\n        if n <= 3:\n            return 0\n        count = 2  # 1 and n are divisors\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                count += 1\n                if i != n // i:\n                    count += 1\n                if count > 4:\n                    return 0\n        return count\n\n    return sum(n for n in nums if count_divisors(n) == 4)", "passed": false, "score": {"loc": 14, "tokens": 100, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.442457923803554}}, {"code": "def sumFourDivisors(nums):\n    def hasExactlyFourDivisors(n):\n        count = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                count += 1\n                if i != n // i:\n                    count += 1\n                if count > 4:\n                    return False\n        return count == 4\n\n    return sum(n for n in nums if hasExactlyFourDivisors(n))", "passed": false, "score": {"loc": 12, "tokens": 86, "cc": 4, "nest": 5, "execution_time": 10.0, "novelty": 0.36405533705549864}}, {"code": "def sumFourDivisors(nums):\n    def hasFourDivisors(n):\n        divisors = [1, n]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.extend([i, n // i])\n                if len(divisors) > 4:\n                    return False\n        return len(divisors) == 4\n\n    return sum(filter(hasFourDivisors, nums))", "passed": false, "score": {"loc": 10, "tokens": 88, "cc": 3, "nest": 5, "execution_time": 10.0, "novelty": 0.5145098437707862}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 392, "entry_point": "reorderSpaces", "best_list": [{"code": "def reorderSpaces(text):\n    words = text.split()\n    spaces = text.count(' ')\n    if len(words) == 1:\n        return words[0] + ' ' * spaces\n    sep_spaces, extra_spaces = divmod(spaces, len(words) - 1)\n    return (' ' * sep_spaces).join(words) + ' ' * extra_spaces", "passed": true, "score": {"loc": 7, "tokens": 73, "cc": 1, "nest": 2, "execution_time": 0.016601, "novelty": 0.1762139225853664}}, {"code": "def reorderSpaces(text):\n    words = text.split()\n    spaces = text.count(' ')\n    if len(words) == 1:\n        return words[0] + ' ' * spaces\n    between, extra = divmod(spaces, len(words) - 1)\n    return (' ' * between).join(words) + ' ' * extra", "passed": true, "score": {"loc": 7, "tokens": 73, "cc": 1, "nest": 2, "execution_time": 0.016619, "novelty": 0.17866200184636216}}, {"code": "def reorderSpaces(text):\n    spaces = text.count(' ')\n    words = text.split()\n    \n    if len(words) == 1:\n        return words[0] + ' ' * spaces\n    \n    between, end = divmod(spaces, len(words) - 1)\n    return (' ' * between).join(words) + ' ' * end", "passed": true, "score": {"loc": 7, "tokens": 73, "cc": 1, "nest": 2, "execution_time": 0.016631, "novelty": 0.22123853294950369}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 3576, "entry_point": "numSub", "best_list": [{"code": "def numSub(s: str) -> int:\n    MOD = 10**9 + 7\n    count, result = 0, 0\n    for char in s:\n        if char == '1':\n            count += 1\n            result = (result + count) % MOD\n        else:\n            count = 0\n    return result", "passed": true, "score": {"loc": 10, "tokens": 59, "cc": 2, "nest": 3, "execution_time": 0.016758, "novelty": 0.32851071706336643}}, {"code": "def numSub(s):\n    MOD = 10**9 + 7\n    count = 0\n    result = 0\n    for char in s:\n        if char == '1':\n            count += 1\n            result = (result + count) % MOD\n        else:\n            count = 0\n    return result", "passed": true, "score": {"loc": 11, "tokens": 53, "cc": 2, "nest": 3, "execution_time": 0.01647, "novelty": 0.3272151377118031}}, {"code": "def numSub(s: str) -> int:\n    MOD = 10**9 + 7\n    result = 0\n    count = 0\n    \n    for char in s:\n        if char == '1':\n            count += 1\n            result = (result + count) % MOD\n        else:\n            count = 0\n    \n    return result", "passed": true, "score": {"loc": 11, "tokens": 58, "cc": 2, "nest": 3, "execution_time": 0.016623, "novelty": 0.30711255804490245}}, {"code": "def numSub(s: str) -> int:\n    return sum((len(group) * (len(group) + 1)) // 2 for group in s.split('0')) % (10**9 + 7)", "passed": false, "score": {"loc": 2, "tokens": 53, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.6557991532709881}}], "num_pass": 9, "num_uniq": 6, "num_fail": 1, "fail_uniq": 1}
{"id": 3588, "entry_point": "findLongestWord", "best_list": [{"code": "def findLongestWord(s, d):\n    def is_subsequence(word):\n        it = iter(s)\n        return all(char in it for char in word)\n    \n    filtered = [word for word in d if is_subsequence(word)]\n    return max(filtered or [''], key=lambda x: (len(x), x))", "passed": true, "score": {"loc": 6, "tokens": 69, "cc": 1, "nest": 2, "execution_time": 0.016745, "novelty": 0.47660427008513273}}, {"code": "def findLongestWord(s, d):\n    def is_subsequence(word):\n        it = iter(s)\n        return all(char in it for char in word)\n    \n    candidates = sorted((word for word in d if is_subsequence(word)), key=lambda x: (-len(x), x))\n    return candidates[0] if candidates else \"\"", "passed": true, "score": {"loc": 6, "tokens": 73, "cc": 0, "nest": 2, "execution_time": 0.016591, "novelty": 0.39517596889477646}}, {"code": "def findLongestWord(s: str, d: list[str]) -> str:\n    def is_subsequence(word: str) -> bool:\n        it = iter(s)\n        return all(char in it for char in word)\n    \n    filtered = filter(is_subsequence, d)\n    return max(filtered, key=lambda x: (len(x), x), default='')", "passed": true, "score": {"loc": 6, "tokens": 78, "cc": 0, "nest": 2, "execution_time": 0.016724, "novelty": 0.7593661842040977}}, {"code": "def findLongestWord(s: str, d: List[str]) -> str:\n    def is_subsequence(word):\n        it = iter(s)\n        return all(char in it for char in word)\n\n    sorted_d = sorted(d, key=lambda x: (-len(x), x))\n    for word in sorted_d:\n        if is_subsequence(word):\n            return word\n    return \"\"", "passed": false, "score": {"loc": 9, "tokens": 78, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5790075230716123}}], "num_pass": 9, "num_uniq": 8, "num_fail": 1, "fail_uniq": 1}
{"id": 3612, "entry_point": "hIndex", "best_list": [{"code": "def hIndex(citations):\n    citations.sort(reverse=True)\n    h = 0\n    for i, c in enumerate(citations):\n        if c >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h", "passed": true, "score": {"loc": 9, "tokens": 45, "cc": 2, "nest": 3, "execution_time": 0.016459, "novelty": 0.49253617631587}}, {"code": "def hIndex(citations):\n    citations.sort(reverse=True)\n    h = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h", "passed": true, "score": {"loc": 9, "tokens": 45, "cc": 2, "nest": 3, "execution_time": 0.016575, "novelty": 0.495074792433678}}, {"code": "def hIndex(citations):\n    count = [0] * (len(citations) + 1)\n    for c in citations:\n        count[min(c, len(citations))] += 1\n    total = 0\n    for i in range(len(count) - 1, -1, -1):\n        total += count[i]\n        if total >= i:\n            return i", "passed": true, "score": {"loc": 9, "tokens": 77, "cc": 3, "nest": 3, "execution_time": 0.016536, "novelty": 0.6103339037822098}}, {"code": "def hIndex(citations):\n    from collections import Counter\n    count = Counter(citations)\n    n = len(citations)\n    for h in range(n, 0, -1):\n        if sum(count[i] for i in range(h, n + 1)) >= h:\n            return h\n    return 0", "passed": false, "score": {"loc": 8, "tokens": 62, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.656125218547552}}], "num_pass": 9, "num_uniq": 7, "num_fail": 1, "fail_uniq": 1}
{"id": 3614, "entry_point": "arrangeCoins", "best_list": [{"code": "def arrangeCoins(n):\n    return int((n * 2 + 0.25)**0.5 - 0.5)", "passed": true, "score": {"loc": 2, "tokens": 28, "cc": 0, "nest": 1, "execution_time": 0.016638, "novelty": 0.5125271230784667}}, {"code": "def arrangeCoins(n):\n    return int((2 * n + 0.25) ** 0.5 - 0.5)", "passed": true, "score": {"loc": 2, "tokens": 28, "cc": 0, "nest": 1, "execution_time": 0.016646, "novelty": 0.5210686512691047}}, {"code": "def arrangeCoins(n):\n    k = 0\n    while n >= k + 1:\n        n -= k + 1\n        k += 1\n    return k", "passed": true, "score": {"loc": 6, "tokens": 29, "cc": 1, "nest": 2, "execution_time": 0.016588, "novelty": 0.630987648530008}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 3678, "entry_point": "lengthOfLongestSubstring", "best_list": [{"code": "def lengthOfLongestSubstring(s):\n    char_map = {}\n    max_length = 0\n    start = 0\n\n    for end, char in enumerate(s):\n        if char in char_map and char_map[char] >= start:\n            start = char_map[char] + 1\n        char_map[char] = end\n        max_length = max(max_length, end - start + 1)\n\n    return max_length", "passed": true, "score": {"loc": 10, "tokens": 67, "cc": 3, "nest": 3, "execution_time": 0.016536, "novelty": 0.3174478372462437}}, {"code": "def lengthOfLongestSubstring(s):\n    char_index_map = {}\n    start = 0\n    max_length = 0\n    \n    for end, char in enumerate(s):\n        if char in char_index_map and char_index_map[char] >= start:\n            start = char_index_map[char] + 1\n        char_index_map[char] = end\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length", "passed": true, "score": {"loc": 10, "tokens": 67, "cc": 3, "nest": 3, "execution_time": 0.016632, "novelty": 0.4723196394253768}}, {"code": "def lengthOfLongestSubstring(s):\n    char_index = {}\n    max_length = 0\n    start = 0\n    \n    for end, char in enumerate(s):\n        if char in char_index and char_index[char] >= start:\n            start = char_index[char] + 1\n        char_index[char] = end\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length", "passed": true, "score": {"loc": 10, "tokens": 67, "cc": 3, "nest": 3, "execution_time": 0.01675, "novelty": 0.3142207171337732}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 3757, "entry_point": "minSetSize", "best_list": [{"code": "def minSetSize(arr):\n    from collections import Counter\n    count = Counter(arr)\n    sorted_counts = sorted(count.values(), reverse=True)\n    target = len(arr) // 2\n    removed = 0\n    for i, freq in enumerate(sorted_counts):\n        removed += freq\n        if removed >= target:\n            return i + 1", "passed": true, "score": {"loc": 10, "tokens": 66, "cc": 2, "nest": 3, "execution_time": 0.016668, "novelty": 0.470964367614206}}, {"code": "from collections import Counter\n\ndef minSetSize(arr):\n    count = Counter(arr)\n    sorted_count = sorted(count.values(), reverse=True)\n    total = 0\n    result = 0\n    for freq in sorted_count:\n        total += freq\n        result += 1\n        if total >= len(arr) // 2:\n            return result", "passed": true, "score": {"loc": 11, "tokens": 63, "cc": 2, "nest": 3, "execution_time": 0.016527, "novelty": 0.3990602976483263}}, {"code": "from collections import Counter\n\ndef minSetSize(arr):\n    count = Counter(arr)\n    total = len(arr)\n    target = total // 2\n    removed = 0\n    result = 0\n    \n    for _, freq in count.most_common():\n        removed += freq\n        result += 1\n        if removed >= target:\n            return result", "passed": true, "score": {"loc": 12, "tokens": 61, "cc": 2, "nest": 3, "execution_time": 0.016668, "novelty": 0.4107944928199535}}, {"code": "def minSetSize(arr):\n    count = sorted(Counter(arr).values(), reverse=True)\n    target = len(arr) // 2\n    for i, x in enumerate(accumulate(count)):\n        if x >= target:\n            return i + 1", "passed": false, "score": {"loc": 6, "tokens": 55, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.45909100923720614}}, {"code": "def minSetSize(arr):\n    count = sorted(Counter(arr).values(), reverse=True)\n    removed = 0\n    for i, freq in enumerate(count):\n        removed += freq\n        if removed >= len(arr) // 2:\n            return i + 1", "passed": false, "score": {"loc": 7, "tokens": 56, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.4800249020705416}}, {"code": "def minSetSize(arr):\n    freq = sorted(Counter(arr).values(), reverse=True)\n    total = len(arr)\n    removed = 0\n    for i, count in enumerate(freq):\n        removed += count\n        if removed >= total // 2:\n            return i + 1", "passed": false, "score": {"loc": 8, "tokens": 59, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5071129389177682}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 3777, "entry_point": "findIntegers", "best_list": [{"code": "def findIntegers(n):\n    a, b = 0, 1\n    for _ in range(n.bit_length()):\n        a, b = b, a + b\n    return a + (n < 2)", "passed": true, "score": {"loc": 5, "tokens": 42, "cc": 1, "nest": 2, "execution_time": 0.016748, "novelty": 0.6671427457741479}}, {"code": "def findIntegers(n):\n    def fib(n):\n        a, b = 1, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return a\n\n    n += 1\n    res, p = 0, 1\n    while n:\n        if n & 1:\n            res += p\n        if res >= p:\n            return p\n        n >>= 1\n        p <<= 1\n    return p", "passed": true, "score": {"loc": 16, "tokens": 81, "cc": 4, "nest": 3, "execution_time": 0.016702, "novelty": 0.7443473957772297}}, {"code": "def findIntegers(n):\n    def fib(n):\n        a, b = 0, 1\n        for _ in range(n + 1):\n            a, b = b, a + b\n        return a\n\n    binary_n = bin(n)[2:]\n    length = len(binary_n)\n    count = fib(length)\n    prefix = 1\n\n    for i in range(length - 2, -1, -1):\n        if binary_n[i] == '1' and binary_n[i + 1] == '1':\n            break\n        if binary_n[i] == '1':\n            prefix = fib(i + 2)\n        count -= prefix\n\n    return count", "passed": false, "score": {"loc": 17, "tokens": 130, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.7580438735578405}}, {"code": "def findIntegers(n: int) -> int:\n    if n == 0:\n        return 1\n    bin_n = bin(n)[2:]\n    length = len(bin_n)\n    fib = [0] * (length + 1)\n    fib[0], fib[1] = 1, 2\n    for i in range(2, length + 1):\n        fib[i] = fib[i - 1] + fib[i - 2]\n    res = fib[length] - (bin_n[length - 1] == bin_n[length - 2])\n    for i in range(length - 2, -1, -1):\n        if bin_n[i] == '1' and bin_n[i + 1] == '1':\n            break\n        elif bin_n[i] == '0' and bin_n[i + 1] == '0':\n            res -= fib[i]\n    return res", "passed": false, "score": {"loc": 16, "tokens": 184, "cc": 7, "nest": 4, "execution_time": 10.0, "novelty": 0.8870270545662342}}, {"code": "def findIntegers(n):\n    dp = [0, 1] + [0] * n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]", "passed": false, "score": {"loc": 5, "tokens": 54, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.6832249725675466}}, {"code": "def findIntegers(n):\n    dp = [0, 1]\n    for i in range(2, 32):\n        dp.append(dp[i - 1] + dp[i - 2])\n    a, b = 1, 1\n    for i in range(30, -1, -1):\n        if n & (1 << i):\n            a, b = a + b, a\n        if (n & (1 << i)) and (n & (1 << (i - 1))):\n            break\n    return a", "passed": false, "score": {"loc": 11, "tokens": 111, "cc": 5, "nest": 3, "execution_time": 10.0, "novelty": 0.6528709473078549}}, {"code": "def findIntegers(n):\n    dp = [0, 1]\n    for i in range(2, n + 1):\n        dp.append(dp[i - 1] + dp[i - 2])\n    return dp[n]", "passed": false, "score": {"loc": 5, "tokens": 48, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.6333683343700209}}], "num_pass": 2, "num_uniq": 2, "num_fail": 8, "fail_uniq": 8}
{"id": 3952, "entry_point": "subarrayBitwiseORs", "best_list": [{"code": "from functools import reduce\nfrom operator import or_\n\ndef subarrayBitwiseORs(A):\n    return len({reduce(or_, A[i:j]) for i in range(len(A)) for j in range(i+1, len(A)+1)})", "passed": true, "score": {"loc": 4, "tokens": 57, "cc": 0, "nest": 1, "execution_time": 0.016707, "novelty": 0.6753533297730605}}, {"code": "def subarrayBitwiseORs(A):\n    s, r = {0}, set()\n    for x in A:\n        s = {x | y for y in s} | {x}\n        r |= s\n    return len(r)", "passed": true, "score": {"loc": 6, "tokens": 46, "cc": 1, "nest": 2, "execution_time": 0.016748, "novelty": 0.6364195854491188}}, {"code": "def subarrayBitwiseORs(A):\n    ors = set()\n    current = 0\n    for num in A:\n        current |= num\n        ors |= {current}\n    return len(ors)", "passed": true, "score": {"loc": 7, "tokens": 34, "cc": 1, "nest": 2, "execution_time": 0.016414, "novelty": 0.51332632424571}}, {"code": "def subarrayBitwiseORs(A):\n    unique_results = set()\n    current_or = 0\n    for num in A:\n        current_or |= num\n        unique_results.add(current_or)\n        prefix_or = 0\n        for prev_or in reversed(unique_results):\n            prefix_or |= prev_or\n            unique_results.add(prefix_or)\n    return len(unique_results)", "passed": false, "score": {"loc": 11, "tokens": 55, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.5956855044635005}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 410, "entry_point": "numTilePossibilities", "best_list": [{"code": "import itertools\n\ndef numTilePossibilities(tiles):\n    return sum(len(set(itertools.permutations(tiles, r))) for r in range(1, len(tiles) + 1))", "passed": true, "score": {"loc": 3, "tokens": 40, "cc": 0, "nest": 1, "execution_time": 0.016625, "novelty": 0.6341047081497015}}, {"code": "def numTilePossibilities(tiles):\n    from itertools import permutations\n\n    result = set()\n    for r in range(1, len(tiles) + 1):\n        for perm in permutations(tiles, r):\n            result.add(''.join(perm))\n    return len(result)", "passed": true, "score": {"loc": 7, "tokens": 57, "cc": 2, "nest": 3, "execution_time": 0.016594, "novelty": 0.3907441470894699}}, {"code": "def numTilePossibilities(tiles):\n    from itertools import permutations\n\n    unique_tiles = set()\n    for r in range(1, len(tiles) + 1):\n        for perm in permutations(tiles, r):\n            unique_tiles.add(''.join(perm))\n    return len(unique_tiles)", "passed": true, "score": {"loc": 7, "tokens": 57, "cc": 2, "nest": 3, "execution_time": 0.0166, "novelty": 0.5082780246572148}}, {"code": "from collections import Counter\nfrom itertools import permutations\n\ndef numTilePossibilities(tiles):\n    def generate(tiles):\n        if not tiles:\n            yield \"\"\n        for i in range(len(tiles)):\n            for perm in generate(tiles[:i] + tiles[i+1:]):\n                yield tiles[i] + perm\n\n    return len(set(generate(tiles))) - 1\n\n# Unit tests to satisfy:\nassert numTilePossibilities(\"AAB\") == 8\nassert numTilePossibilities(\"AAABBC\") == 188\nassert numTilePossibilities(\"V\") == 1", "passed": false, "score": {"loc": 14, "tokens": 114, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.8008678487051638}}, {"code": "from itertools import permutations\n\ndef numTilePossibilities(tiles):\n    return len(set(''.join(p) for p in permutations(tiles)))", "passed": false, "score": {"loc": 3, "tokens": 31, "cc": 0, "nest": 1, "execution_time": 10.0, "novelty": 0.7437835548854632}}], "num_pass": 8, "num_uniq": 7, "num_fail": 2, "fail_uniq": 2}
{"id": 436, "entry_point": "trailingZeroes", "best_list": [{"code": "def trailingZeroes(n):\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count", "passed": true, "score": {"loc": 6, "tokens": 26, "cc": 1, "nest": 2, "execution_time": 0.016435, "novelty": 0.072940959092334}}, {"code": "def trailingZeroes(n: int) -> int:\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count", "passed": true, "score": {"loc": 6, "tokens": 31, "cc": 1, "nest": 2, "execution_time": 0.016479, "novelty": 0.12093376651839871}}, {"code": "def trailingZeroes(n):\n    count = 0\n    for i in range(5, n + 1, 5):\n        while i % 5 == 0:\n            count += 1\n            i //= 5\n    return count", "passed": true, "score": {"loc": 7, "tokens": 42, "cc": 2, "nest": 3, "execution_time": 0.016512, "novelty": 0.5733154239595721}}], "num_pass": 10, "num_uniq": 3, "num_fail": 0, "fail_uniq": 0}
{"id": 4080, "entry_point": "longestArithSeqLength", "best_list": [{"code": "def longestArithSeqLength(A):\n    n = len(A)\n    dp = [{} for _ in range(n)]\n    max_length = 0\n    \n    for i in range(n):\n        for j in range(i):\n            diff = A[i] - A[j]\n            dp[i][diff] = dp[j].get(diff, 1) + 1\n            max_length = max(max_length, dp[i][diff])\n    \n    return max_length", "passed": true, "score": {"loc": 10, "tokens": 92, "cc": 2, "nest": 3, "execution_time": 0.016607, "novelty": 0.14212462351124122}}, {"code": "def longestArithSeqLength(A):\n    n = len(A)\n    dp = [{} for _ in range(n)]\n    max_length = 2\n\n    for i in range(n):\n        for j in range(i):\n            diff = A[i] - A[j]\n            dp[i][diff] = dp[j].get(diff, 1) + 1\n            max_length = max(max_length, dp[i][diff])\n\n    return max_length", "passed": true, "score": {"loc": 10, "tokens": 92, "cc": 2, "nest": 3, "execution_time": 0.016648, "novelty": 0.14239885041922962}}, {"code": "def longestArithSeqLength(A):\n    n = len(A)\n    dp = [{} for _ in range(n)]\n    max_len = 0\n    \n    for i in range(1, n):\n        for j in range(i):\n            diff = A[i] - A[j]\n            dp[i][diff] = dp[j].get(diff, 1) + 1\n            max_len = max(max_len, dp[i][diff])\n    \n    return max_len", "passed": true, "score": {"loc": 10, "tokens": 94, "cc": 2, "nest": 3, "execution_time": 0.016585, "novelty": 0.154176570747789}}, {"code": "def longestArithSeqLength(A):\n    from collections import defaultdict\n\n    n = len(A)\n    dp = [defaultdict(lambda: 2) for _ in range(n)]\n\n    max_length = 2\n\n    for i in range(n):\n        for j in range(i):\n            diff = A[i] - A[j]\n            dp[i][diff] = dp[j][diff] + 1\n            max_length = max(max_length, dp[i][diff])\n\n    return max_length", "passed": false, "score": {"loc": 11, "tokens": 96, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.502573509761527}}, {"code": "def longestArithSeqLength(A):\n    from collections import defaultdict\n    \n    n = len(A)\n    dp = [defaultdict(lambda: 2) for _ in range(n)]\n    longest = 2\n    \n    for i in range(1, n):\n        for j in range(i):\n            diff = A[i] - A[j]\n            dp[i][diff] = dp[j][diff] + 1\n            longest = max(longest, dp[i][diff])\n    \n    return longest", "passed": false, "score": {"loc": 11, "tokens": 98, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.505659574247111}}], "num_pass": 8, "num_uniq": 6, "num_fail": 2, "fail_uniq": 2}
{"id": 4101, "entry_point": "validPalindrome", "best_list": [{"code": "def validPalindrome(s: str) -> bool:\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return s[i:j] == s[i:j][::-1] or s[i+1:j+1] == s[i+1:j+1][::-1]\n        i += 1\n        j -= 1\n    return True", "passed": true, "score": {"loc": 8, "tokens": 100, "cc": 3, "nest": 3, "execution_time": 0.016733, "novelty": 0.5007035225626724}}, {"code": "def validPalindrome(s):\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            # Check if skipping either the left or the right character results in a palindrome\n            return s[left:right] == s[left:right][::-1] or s[left+1:right+1] == s[left+1:right+1][::-1]\n        left += 1\n        right -= 1\n    \n    return True", "passed": true, "score": {"loc": 9, "tokens": 110, "cc": 3, "nest": 3, "execution_time": 0.016656, "novelty": 0.6488141640784745}}, {"code": "def validPalindrome(s: str) -> bool:\n    def check_palindrome(subs: str, skip_one: bool) -> bool:\n        left, right = 0, len(subs) - 1\n        while left < right:\n            if subs[left] != subs[right]:\n                if skip_one:\n                    return check_palindrome(subs[left:right], False) or check_palindrome(subs[left+1:right+1], False)\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    return check_palindrome(s, True)", "passed": true, "score": {"loc": 12, "tokens": 105, "cc": 4, "nest": 5, "execution_time": 0.016994, "novelty": 0.6476879175207695}}], "num_pass": 10, "num_uniq": 8, "num_fail": 0, "fail_uniq": 0}
{"id": 4165, "entry_point": "movesToMakeZigzag", "best_list": [{"code": "def movesToMakeZigzag(nums):\n    n = len(nums)\n    def cost(arr):\n        return sum(max(0, arr[i] - arr[i-1] + 1) for i in range(1, n)) + sum(max(0, arr[i] - arr[i+1] + 1) for i in range(n-1)) - max(0, arr[0] - arr[1] + 1) - max(0, arr[-1] - arr[-2] + 1)\n    return min(cost(nums[1:] + nums[:1]), cost(nums[:-1] + nums[-1:]))", "passed": true, "score": {"loc": 5, "tokens": 151, "cc": 0, "nest": 2, "execution_time": 0.016556, "novelty": 0.8219747266796386}}, {"code": "def movesToMakeZigzag(nums):\n    n = len(nums)\n    def moves(index):\n        left = nums[index - 1] if index > 0 else float('inf')\n        right = nums[index + 1] if index < n - 1 else float('inf')\n        return max(0, nums[index] - min(left, right) + 1)\n    return min(sum(moves(i) for i in range(0, n, 2)), sum(moves(i) for i in range(1, n, 2)))", "passed": true, "score": {"loc": 7, "tokens": 118, "cc": 0, "nest": 2, "execution_time": 0.016613, "novelty": 0.7971480527012184}}, {"code": "def movesToMakeZigzag(nums):\n    def transform(arr, cond):\n        moves = 0\n        for i in range(len(arr)):\n            if (i % 2 == 0) == cond:\n                left = arr[i - 1] if i > 0 else float('inf')\n                right = arr[i + 1] if i < len(arr) - 1 else float('inf')\n                if arr[i] >= min(left, right):\n                    moves += arr[i] - min(left, right) + 1\n        return moves\n\n    return min(transform(nums, True), transform(nums, False))", "passed": true, "score": {"loc": 11, "tokens": 133, "cc": 3, "nest": 5, "execution_time": 0.016507, "novelty": 0.7478040124072118}}, {"code": "def movesToMakeZigzag(nums):\n    def count_moves(arr):\n        moves = 0\n        for i in range(len(arr)):\n            if i % 2 == 0:\n                if i + 1 < len(arr) and arr[i] <= arr[i + 1]:\n                    moves += arr[i + 1] - arr[i] + 1\n                    arr[i + 1] = arr[i] - 1\n                if i - 1 >= 0 and arr[i] <= arr[i - 1]:\n                    moves += arr[i - 1] - arr[i] + 1\n                    arr[i - 1] = arr[i] - 1\n            else:\n                if i + 1 < len(arr) and arr[i] >= arr[i + 1]:\n                    moves += arr[i] - arr[i + 1] + 1\n                    arr[i + 1] = arr[i] - 1\n                if i - 1 >= 0 and arr[i] >= arr[i - 1]:\n                    moves += arr[i] - arr[i - 1] + 1\n                    arr[i - 1] = arr[i] - 1\n        return moves\n\n    return min(count_moves(nums), count_moves(nums[::-1]))", "passed": false, "score": {"loc": 20, "tokens": 261, "cc": 10, "nest": 5, "execution_time": 10.0, "novelty": 0.8038543254261259}}, {"code": "def movesToMakeZigzag(nums):\n    def adjust_to_zigzag(arr, start):\n        moves = 0\n        for i in range(start, len(arr) - 1, 2):\n            min_adj = min(arr[i - 1], arr[i + 1]) if i > 0 and i < len(arr) - 1 else float('inf')\n            if arr[i] >= min_adj:\n                moves += arr[i] - min_adj + 1\n                arr[i] = min_adj - 1\n        return moves\n\n    return min(adjust_to_zigzag(nums.copy(), 0), adjust_to_zigzag(nums.copy(), 1))", "passed": false, "score": {"loc": 10, "tokens": 127, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.7385349979185661}}, {"code": "def movesToMakeZigzag(nums):\n    def count_moves(target):\n        return sum(max(0, num - target - 1) for num in nums)\n\n    if not nums:\n        return 0\n\n    n = len(nums)\n    return min(count_moves(nums[0] - 1) + count_moves(nums[1::2] - 1) + count_moves(nums[2::2] - 1),\n              count_moves(nums[1] - 1) + count_moves(nums[::2] - 1))", "passed": false, "score": {"loc": 8, "tokens": 103, "cc": 1, "nest": 2, "execution_time": 10.0, "novelty": 0.7775443882018112}}, {"code": "def movesToMakeZigzag(nums):\n    def transform_to_zigzag(arr, compare):\n        moves = 0\n        for i in range(len(arr)):\n            if i % 2 == 0 and not compare(arr[i], arr[i + 1]):\n                moves += arr[i] - arr[i + 1] + 1\n            elif i % 2 == 1 and not compare(arr[i], arr[i - 1]):\n                moves += arr[i] - arr[i - 1] + 1\n        return moves\n\n    def greater_than(a, b):\n        return a > b\n\n    def less_than(a, b):\n        return a < b\n\n    return min(transform_to_zigzag(nums, greater_than), transform_to_zigzag(nums, less_than))", "passed": false, "score": {"loc": 14, "tokens": 151, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.6852165113161992}}, {"code": "def movesToMakeZigzag(nums):\n    def transform(array, adjust):\n        return [array[i] - adjust[i] for i in range(len(array))]\n\n    def count_moves(array):\n        return sum(max(0, array[i] - min(array[i - 1] if i > 0 else float('inf'), array[i + 1] if i < len(array) - 1 else float('inf'))) for i in range(len(array)))\n\n    adjust_even = [1] * len(nums)\n    adjust_odd = [1] * len(nums)\n    adjust_even[1::2] = [0] * (len(nums) // 2)\n    adjust_odd[0::2] = [0] * (len(nums) // 2)\n\n    return min(count_moves(transform(nums, adjust_even)), count_moves(transform(nums, adjust_odd)))", "passed": false, "score": {"loc": 10, "tokens": 194, "cc": 0, "nest": 2, "execution_time": 10.0, "novelty": 0.8091302105754992}}], "num_pass": 4, "num_uniq": 4, "num_fail": 6, "fail_uniq": 6}
{"id": 4173, "entry_point": "isSelfCrossing", "best_list": [{"code": "def isSelfCrossing(x):\n    if len(x) < 4:\n        return False\n    for i in range(3, len(x)):\n        if (i >= 3 and x[i] >= x[i-2]) or (i >= 4 and x[i-1] == x[i-3] and x[i] + x[i-4] >= x[i-2]) or (i >= 5 and x[i-2] > x[i-4] and x[i-1] > x[i-3] and x[i] + x[i-4] >= x[i-2] and x[i-1] + x[i-5] >= x[i-3]):\n            return True\n    return False", "passed": true, "score": {"loc": 7, "tokens": 173, "cc": 7, "nest": 3, "execution_time": 0.016486, "novelty": 0.48932292653627507}}, {"code": "def isSelfCrossing(x):\n    x = x + [0] * 3  # Pad the array to avoid index out of range\n    for i in range(3, len(x)):\n        if x[i] >= x[i-2] and x[i-1] <= x[i-3]:\n            return True\n        if i >= 4 and x[i-1] == x[i-3] and x[i] + x[i-4] >= x[i-2]:\n            return True\n        if i >= 5 and x[i-2] > x[i-4] and x[i-1] < x[i-3] and x[i] + x[i-4] >= x[i-2] and x[i-5] + x[i-1] >= x[i-3]:\n            return True\n    return False", "passed": true, "score": {"loc": 10, "tokens": 192, "cc": 7, "nest": 3, "execution_time": 0.016607, "novelty": 0.5454841776231805}}, {"code": "def isSelfCrossing(x):\n    x = [0] + x\n    for i in range(4, len(x)):\n        if x[i] >= x[i-2] and x[i-1] <= x[i-3]:  # Case 1\n            return True\n        if i >= 5 and x[i-3] >= x[i-5] and x[i-2] == x[i-4] and x[i-1] >= x[i-3] - x[i-5]:  # Case 2\n            return True\n        if i >= 6 and x[i-2] > x[i-4] and x[i-3] >= x[i-5] and x[i-1] >= x[i-3] - x[i-5] and x[i-4] >= x[i-6] and x[i-5] >= x[i-7]:  # Case 4\n            return True\n    return False", "passed": true, "score": {"loc": 10, "tokens": 217, "cc": 7, "nest": 3, "execution_time": 0.016733, "novelty": 0.5487273695658892}}, {"code": "def isSelfCrossing(x):\n    return any(x[i] >= x[i-2] and x[i-4] >= x[i-6] for i in range(5, len(x))) if len(x) >= 6 else False", "passed": false, "score": {"loc": 2, "tokens": 59, "cc": 1, "nest": 1, "execution_time": 10.0, "novelty": 0.6179992098626865}}, {"code": "def isSelfCrossing(x):\n    return is_self_crossing() if len(x) >= 6 else False\n\ndef is_self_crossing():\n    x = self.x\n    x += [0, 0, 0, 0]  # Pad the array to handle edge cases\n    for i in range(3, len(x)):\n        if x[i] >= x[i - 2] and x[i - 1] <= x[i - 3]:\n            return True\n        if i >= 4 and x[i - 1] == x[i - 3] and x[i] + x[i - 4] >= x[i - 2]:\n            return True\n        if i >= 5 and x[i - 2] >= x[i - 4] and x[i - 3] > x[i - 5] and x[i] + x[i - 4] >= x[i - 2] and x[i - 1] >= x[i - 3] and x[i - 1] - x[i - 3] <= x[i - 5]:\n            return True\n    return False", "passed": false, "score": {"loc": 13, "tokens": 233, "cc": 7, "nest": 3, "execution_time": 10.0, "novelty": 0.5626680668582084}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 2}
{"id": 4178, "entry_point": "canReorderDoubled", "best_list": [{"code": "def canReorderDoubled(A):\n    A.sort(key=abs)\n    count = {}\n    for x in A:\n        if x // 2 in count and count[x // 2] > 0:\n            count[x // 2] -= 1\n        else:\n            count[2 * x] = count.get(2 * x, 0) + 1\n    return all(v == 0 for v in count.values())", "passed": true, "score": {"loc": 9, "tokens": 88, "cc": 3, "nest": 3, "execution_time": 0.016451, "novelty": 0.6922206950550464}}, {"code": "def canReorderDoubled(A):\n    from collections import Counter\n    count = Counter(A)\n    for x in sorted(A, key=abs):\n        if count[x] > 0:\n            if count[2 * x] > 0:\n                count[x] -= 1\n                count[2 * x] -= 1\n            else:\n                return False\n    return True", "passed": true, "score": {"loc": 11, "tokens": 68, "cc": 3, "nest": 4, "execution_time": 0.016529, "novelty": 0.4018189590112652}}, {"code": "def canReorderDoubled(A):\n    from collections import Counter\n    count = Counter(A)\n    for num in sorted(A, key=abs):\n        if count[num] > 0:\n            if count[2 * num] > 0:\n                count[num] -= 1\n                count[2 * num] -= 1\n            else:\n                return False\n    return True", "passed": true, "score": {"loc": 11, "tokens": 68, "cc": 3, "nest": 4, "execution_time": 0.016561, "novelty": 0.4126418616009716}}, {"code": "def canReorderDoubled(A):\n    A.sort()\n    count = 0\n    for num in A:\n        if count == len(A) // 2:\n            return True\n        if num == 0:\n            count += 1\n        elif num > 0 and num * 2 in A:\n            A.remove(num * 2)\n            count += 1\n        elif num < 0 and num // 2 in A:\n            A.remove(num // 2)\n            count += 1\n    return False", "passed": false, "score": {"loc": 15, "tokens": 93, "cc": 7, "nest": 5, "execution_time": 10.0, "novelty": 0.7273797470104786}}, {"code": "def canReorderDoubled(A):\n    A.sort(key=abs)\n    count = {}\n    for x in A:\n        if x // 2 in count and count[x // 2] > 0:\n            count[x // 2] -= 1\n        else:\n            count[x] = count.get(x, 0) + 1\n    return all(v == 0 for v in count.values())", "passed": false, "score": {"loc": 9, "tokens": 84, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.6881753219617212}}, {"code": "def canReorderDoubled(A):\n    count = collections.Counter(A)\n    for x in sorted(A, key=abs):\n        if count[x] == 0:\n            continue\n        count[x] -= 1\n        if count[2 * x] == 0:\n            return False\n        count[2 * x] -= 1\n    return True", "passed": false, "score": {"loc": 10, "tokens": 67, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.44789635732790667}}], "num_pass": 7, "num_uniq": 6, "num_fail": 3, "fail_uniq": 3}
{"id": 4212, "entry_point": "findMinStep", "best_list": [{"code": "def findMinStep(board, hand):\n    from collections import Counter\n    \n    def dfs(board, hand):\n        if not board:\n            return 0\n        if not hand:\n            return float('inf')\n        res = float('inf')\n        for i, c in enumerate(board):\n            if i == 0 or board[i-1] != c:\n                need = 3 - (2 if board[i-1] == c else 0)\n                if hand[c] >= need:\n                    new_hand = hand.copy()\n                    new_hand[c] -= need\n                    new_board = board[:i] + board[i+1:]\n                    res = min(res, dfs(new_board, new_hand))\n        return res\n    \n    hand_count = Counter(hand)\n    res = dfs(board, hand_count)\n    return res if res != float('inf') else -1", "passed": true, "score": {"loc": 20, "tokens": 172, "cc": 6, "nest": 5, "execution_time": 0.016792, "novelty": 0.6581006433581236}}, {"code": "def findMinStep(board, hand):\n    from collections import Counter\n    \n    def dfs(board, hand):\n        if not board:\n            return 0\n        if not hand:\n            return float('inf')\n        \n        res = float('inf')\n        for i in range(len(board) + 1):\n            for color, cnt in hand.items():\n                if cnt == 0:\n                    continue\n                new_hand = hand.copy()\n                new_hand[color] -= 1\n                new_board = board[:i] + color + board[i:]\n                new_board = ''.join(new_board.split(color * 3))\n                res = min(res, 3 - cnt + dfs(new_board, new_hand))\n        return res\n    \n    hand_count = Counter(hand)\n    res = dfs(board, hand_count)\n    return res if res < float('inf') else -1", "passed": true, "score": {"loc": 21, "tokens": 168, "cc": 5, "nest": 5, "execution_time": 0.434958, "novelty": 0.6580201881875094}}, {"code": "from collections import defaultdict, deque\n\ndef findMinStep(board, hand):\n    def remove_triplets(s):\n        stack = []\n        for c in s:\n            if stack and stack[-1][0] == c and stack[-1][1] == 2:\n                stack.pop()\n            else:\n                stack.append((c, stack[-1][1] + 1 if stack and stack[-1][0] == c else 1))\n        return ''.join(c * n for c, n in stack)\n\n    def dfs(board, hand):\n        if not board:\n            return 0\n        if not hand:\n            return float('inf')\n        board = remove_triplets(board)\n        min_steps = float('inf')\n        for i, c in enumerate(board):\n            if c == hand[0]:\n                min_steps = min(min_steps, dfs(board[:i] + board[i+1:], hand[1:]) + (2 - (i > 0 and board[i-1] == c) - (i < len(board) - 1 and board[i+1] == c)))\n        return min_steps\n\n    hand_count = defaultdict(int)\n    for c in hand:\n        hand_count[c] += 1\n    result = dfs(board, ''.join(hand_count[c] * c for c in \"RYBGW\"))\n    return result if result < float('inf') else -1", "passed": true, "score": {"loc": 26, "tokens": 301, "cc": 11, "nest": 4, "execution_time": 0.017705, "novelty": 0.826627540234635}}, {"code": "from collections import Counter\n\ndef findMinStep(board, hand):\n    def remove_triplets(board):\n        stack = []\n        for ball in board:\n            if not stack or stack[-1][0] != ball:\n                stack.append((ball, 1))\n            else:\n                stack[-1][1] += 1\n        result = []\n        for ball, count in stack:\n            if count < 3:\n                result.append(ball * count)\n        return ''.join(result)\n\n    def dfs(board, hand):\n        if not board:\n            return 0\n        if tuple(hand) in memo:\n            return memo[tuple(hand)]\n        min_steps = float('inf')\n        for i in range(len(board)):\n            for ball, count in hand.items():\n                if i == 0 or board[i - 1] != ball:\n                    if count >= (3 - (i > 0 and board[i - 1] == ball)):\n                        new_hand = hand.copy()\n                        new_hand[ball] -= 3 - (i > 0 and board[i - 1] == ball)\n                        new_board = board[:i] + (ball * (3 - (i > 0 and board[i - 1] == ball))) + board[i:]\n                        new_board = remove_triplets(new_board)\n                        min_steps = min(min_steps, dfs(new_board, new_hand))\n        memo[tuple(hand)] = min_steps if min_steps != float('inf') else -1\n        return min_steps\n\n    memo = {}\n    hand_count = Counter(hand)\n    return dfs(board, hand_count)", "passed": false, "score": {"loc": 34, "tokens": 325, "cc": 15, "nest": 6, "execution_time": 10.0, "novelty": 0.7400913124312531}}, {"code": "from collections import Counter\n\ndef findMinStep(board, hand):\n    hand_count = Counter(hand)\n    min_steps = float('inf')\n    \n    def dfs(board, hand_count):\n        nonlocal min_steps\n        if not board:\n            return 0\n        \n        for i in range(len(board) + 1):\n            for color in hand_count:\n                if hand_count[color] == 0:\n                    continue\n                hand_count[color] -= 1\n                next_board = board[:i] + color + board[i:]\n                next_hand_count = hand_count.copy()\n                cleaned = False\n                while True:\n                    next_board = next_board.replace(color * 3, \"\")\n                    if next_board == board:\n                        break\n                    board, cleaned = next_board, True\n                if cleaned:\n                    min_steps = min(min_steps, dfs(next_board, next_hand_count))\n                hand_count[color] += 1\n    \n    dfs(board, hand_count)\n    return min_steps if min_steps != float('inf') else -1", "passed": false, "score": {"loc": 26, "tokens": 176, "cc": 7, "nest": 6, "execution_time": 10.0, "novelty": 0.7571350649669342}}, {"code": "def findMinStep(board, hand):\n    from collections import Counter\n    \n    def removeConsecutive(b):\n        while True:\n            i = 0\n            while i < len(b):\n                j = i + 1\n                while j < len(b) and b[j] == b[i]:\n                    j += 1\n                if j - i >= 3:\n                    b = b[:i] + b[j:]\n                    break\n            else:\n                break\n        return b\n    \n    def dfs(b, h):\n        if not b:\n            return 0\n        if not h:\n            return float('inf')\n        if (b, h) in memo:\n            return memo[(b, h)]\n        \n        ans = float('inf')\n        for i, c in enumerate(b):\n            if h[c] > 0:\n                new_b = removeConsecutive(b[:i] + c + b[i:])\n                new_h = h.copy()\n                new_h[c] -= 1\n                ans = min(ans, dfs(new_b, new_h))\n        \n        memo[(b, h)] = ans\n        return ans\n    \n    memo = {}\n    h = Counter(hand)\n    res = dfs(board, h)\n    return res if res != float('inf') else -1", "passed": false, "score": {"loc": 35, "tokens": 246, "cc": 10, "nest": 5, "execution_time": 10.0, "novelty": 0.7541057017857766}}, {"code": "from collections import Counter\n\ndef findMinStep(board, hand):\n    def dfs(board, hand):\n        if not board:\n            return 0\n        if not hand:\n            return float('inf')\n        \n        res = float('inf')\n        for i, c in enumerate(board):\n            if i > 0 and board[i] == board[i - 1]:\n                continue\n            need = 3 - (board[i - 1] == board[i] == c) * 2\n            if hand[c] >= need:\n                new_hand = hand.copy()\n                new_hand[c] -= need\n                res = min(res, 1 + dfs(board[:i] + board[i + 1:], new_hand))\n        return res if res != float('inf') else -1\n    \n    hand_count = Counter(hand)\n    return dfs(board, hand_count)", "passed": false, "score": {"loc": 19, "tokens": 175, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.6555927323655288}}, {"code": "def findMinStep(board, hand):\n    from collections import Counter\n    \n    def remove_triples(s):\n        i = 0\n        while i < len(s):\n            if i + 2 < len(s) and s[i] == s[i + 1] == s[i + 2]:\n                s = s[:i] + s[i + 3:]\n                i = max(0, i - 1)\n            else:\n                i += 1\n        return s\n    \n    def dfs(board, hand):\n        if not board:\n            return 0\n        if not hand:\n            return float('inf')\n        res = float('inf')\n        count = Counter(hand)\n        for i in range(len(board) + 1):\n            for color in count:\n                if count[color] > (2 - (i > 0 and board[i - 1] == color) - (i < len(board) and board[i] == color)):\n                    continue\n                new_hand = hand[:i] + color + hand[i:]\n                count[color] -= 1\n                new_board = remove_triples(board[:i] + color + board[i:])\n                res = min(res, 3 - count[color] + dfs(new_board, new_hand))\n                count[color] += 1\n        return res\n    \n    res = dfs(board, hand)\n    return res if res < float('inf') else -1", "passed": false, "score": {"loc": 30, "tokens": 285, "cc": 10, "nest": 5, "execution_time": 10.0, "novelty": 0.737414631761823}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
{"id": 4387, "entry_point": "normalize", "best_list": [{"code": "def normalize(nested_list, growing_value=0):\n    def helper(sub_list, depth, size):\n        if depth == 1:\n            return [item if isinstance(item, list) else [item] * size for item in sub_list] + [growing_value] * (size - len(sub_list))\n        return [[helper(item, depth - 1, size) if isinstance(item, list) else [helper([item], depth - 1, size)] * size for item in sub_list] + [growing_value] * (size - len(sub_list))]\n    \n    def get_max_size(sub_list):\n        max_size = 0\n        for item in sub_list:\n            if isinstance(item, list):\n                max_size = max(max_size, get_max_size(item))\n            else:\n                max_size = max(max_size, 1)\n        return max_size\n    \n    depth = get_max_size(nested_list)\n    size = max(len(nested_list), get_max_size(nested_list))\n    return helper(nested_list, depth, size)", "passed": true, "score": {"loc": 16, "tokens": 190, "cc": 3, "nest": 4, "execution_time": 0.016763, "novelty": 0.8411903727526524}}, {"code": "def normalize(nested_list, growing_value=0):\n    def get_dimension(lst):\n        return 1 + (max(map(get_dimension, lst)) if isinstance(lst, list) else 0)\n\n    def get_size(lst):\n        return max(map(get_size, lst)) if isinstance(lst, list) else 1\n\n    def hypercube(size):\n        if size == 1:\n            return [growing_value]\n        return [[hypercube(size - 1)] * size]\n\n    def pad(lst, target_size):\n        if isinstance(lst, list):\n            return [pad(x, target_size) for x in lst] + ([hypercube(target_size)] * (target_size - len(lst)))\n        return [lst] + ([hypercube(target_size)] * (target_size - 1))\n\n    target_dimension = get_dimension(nested_list)\n    target_size = get_size(nested_list)\n\n    def normalize_recursive(lst, dim):\n        if dim == 1:\n            return pad(lst, target_size)\n        return [normalize_recursive(x, dim - 1) for x in lst] + ([hypercube(target_size)] * (target_size - len(lst)))\n\n    return normalize_recursive(nested_list, target_dimension)", "passed": false, "score": {"loc": 20, "tokens": 232, "cc": 3, "nest": 3, "execution_time": 10.0, "novelty": 0.8051467604284026}}, {"code": "def normalize(nested_list, growing_value=0):\n    def is_basic_element(x):\n        return not isinstance(x, list)\n\n    def max_dimension(lst):\n        return 1 + max(max_dimension(x) for x in lst if isinstance(x, list)) if lst else 0\n\n    def max_size(lst):\n        return max(len(lst), max(max_size(x) for x in lst if isinstance(x, list))) if lst else 0\n\n    def pad_with_growing_value(lst, size, growing_value):\n        while len(lst) < size:\n            lst.append(growing_value)\n        return lst\n\n    def make_hypercube(lst, dimension, size, growing_value):\n        if is_basic_element(lst):\n            return pad_with_growing_value([lst] * size, size, growing_value)\n        else:\n            new_size = max(max_size(lst), size)\n            new_dimension = max_dimension(lst)\n            return [\n                make_hypercube(x, new_dimension, new_size, growing_value) for x in lst\n            ]\n\n    dimension = max_dimension(nested_list)\n    size = max_size(nested_list)\n    return make_hypercube(nested_list, dimension, size, growing_value)", "passed": false, "score": {"loc": 23, "tokens": 208, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7931026327995279}}, {"code": "def normalize(nested_list, growing_value=0):\n    def is_hypercube(lst):\n        if not lst:\n            return True, 0\n        size = len(lst)\n        is_cube, dim = is_hypercube(lst[0])\n        if not is_cube:\n            return False, 0\n        return all(len(item) == size and is_hypercube(item)[0] for item in lst), dim + 1\n\n    def pad(lst, size, growing_value):\n        if not lst:\n            return [growing_value] * size\n        if isinstance(lst[0], list):\n            return [pad(item, size, growing_value) for item in lst]\n        return lst + [growing_value] * (size - len(lst))\n\n    def expand(lst, growing_value):\n        if isinstance(lst[0], list):\n            return [expand(item, growing_value) for item in lst]\n        return [lst] * 5\n\n    is_cube, dim = is_hypercube(nested_list)\n    size = len(nested_list) if is_cube else len(nested_list[0])\n    padded = pad(nested_list, size, growing_value)\n    if dim > 1:\n        return [expand(item, growing_value) for item in padded]\n    return padded", "passed": false, "score": {"loc": 25, "tokens": 229, "cc": 7, "nest": 3, "execution_time": 10.0, "novelty": 0.8413152392609132}}, {"code": "def normalize(nested_list, growing_value=0):\n    def get_size(lst):\n        return max(map(get_size, lst), default=0) + 1\n\n    def fill_to_size(lst, size, growing_value):\n        return [fill_to_size(x, size, growing_value) if isinstance(x, list) else growing_value for _ in range(size)]\n\n    max_size = get_size(nested_list)\n    return fill_to_size(nested_list, max_size, growing_value)", "passed": false, "score": {"loc": 7, "tokens": 84, "cc": 0, "nest": 2, "execution_time": 10.0, "novelty": 0.7089204740721129}}, {"code": "def normalize(nested_list, growing_value=0):\n    def hypercube(size, dim):\n        return [[hypercube(size, dim - 1)] * size for _ in range(size)] if dim > 1 else [growing_value] * size\n\n    def get_max_size(nested_list):\n        return max(get_max_size(item) if isinstance(item, list) else 0 for item in nested_list) + 1\n\n    def fill_hypercube(nested_list, size, dim):\n        if dim == 1:\n            return nested_list + [growing_value] * (size - len(nested_list))\n        return [fill_hypercube(item, size, dim - 1) if isinstance(item, list) else hypercube(size, dim - 1) for item in nested_list]\n\n    max_size = get_max_size(nested_list)\n    return fill_hypercube(nested_list, max_size, get_max_size(nested_list))", "passed": false, "score": {"loc": 11, "tokens": 161, "cc": 1, "nest": 3, "execution_time": 10.0, "novelty": 0.7977366445467399}}], "num_pass": 1, "num_uniq": 1, "num_fail": 9, "fail_uniq": 9}
{"id": 4460, "entry_point": "getMaxLen", "best_list": [{"code": "def getMaxLen(nums):\n    pos, neg, res = 0, 0, 0\n    for num in nums:\n        if num == 0:\n            pos, neg = 0, 0\n        elif num > 0:\n            pos, neg = pos + 1, (neg + 1) if neg > 0 else 0\n        else:\n            pos, neg = (neg + 1) if neg > 0 else 0, pos + 1\n        res = max(res, pos)\n    return res", "passed": true, "score": {"loc": 11, "tokens": 90, "cc": 3, "nest": 4, "execution_time": 0.016728, "novelty": 0.43039229475978835}}, {"code": "def getMaxLen(nums):\n    pos, neg = 0, 0\n    max_len = 0\n    for num in nums:\n        if num == 0:\n            pos, neg = 0, 0\n        elif num > 0:\n            pos, neg = pos + 1, neg + 1 if neg > 0 else 0\n        else:\n            pos, neg = neg + 1 if neg > 0 else 0, pos + 1\n        max_len = max(max_len, pos)\n    return max_len", "passed": true, "score": {"loc": 12, "tokens": 85, "cc": 3, "nest": 4, "execution_time": 0.016787, "novelty": 0.42323872757791714}}, {"code": "def getMaxLen(nums):\n    max_len = 0\n    current_positive = 0\n    current_negative = 0\n    \n    for num in nums:\n        if num > 0:\n            current_positive += 1\n            current_negative = current_negative + 1 if current_negative > 0 else 0\n        elif num < 0:\n            current_positive, current_negative = current_negative + 1 if current_negative > 0 else 1, current_positive + 1\n        else:\n            current_positive = 0\n            current_negative = 0\n        max_len = max(max_len, current_positive)\n    \n    return max_len", "passed": true, "score": {"loc": 15, "tokens": 80, "cc": 3, "nest": 4, "execution_time": 0.016526, "novelty": 0.5214532179603135}}, {"code": "def getMaxLen(nums):\n    max_len = 0\n    pos_len = 0\n    neg_len = 0\n    \n    for num in nums:\n        if num == 0:\n            pos_len, neg_len = 0, 0\n        elif num > 0:\n            pos_len += 1\n            neg_len += 1 if neg_len > 0 else 0\n        else:\n            pos_len, neg_len = neg_len + 1 if neg_len > 0 else 0, pos_len + 1\n    \n    return max_len", "passed": false, "score": {"loc": 13, "tokens": 73, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.4293959592274573}}, {"code": "def getMaxLen(nums):\n    max_len = 0\n    last_zero = -1\n    last_neg = -1\n    pos_len = 0\n    neg_len = 0\n    \n    for i, num in enumerate(nums):\n        if num == 0:\n            last_zero = i\n            pos_len = 0\n            neg_len = 0\n        elif num > 0:\n            pos_len += 1\n            neg_len = neg_len + 1 if neg_len != 0 else 0\n        else:\n            pos_len, neg_len = neg_len + 1 if neg_len != 0 else 0, pos_len + 1\n            if last_neg != -1:\n                max_len = max(max_len, i - last_neg)\n            else:\n                max_len = max(max_len, i - last_zero)\n        last_neg = i if num < 0 else last_neg\n    \n    if neg_len != 0:\n        max_len = max(max_len, len(nums) - 1 - last_neg)\n    \n    return max_len", "passed": false, "score": {"loc": 24, "tokens": 150, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.5649856745955449}}, {"code": "def getMaxLen(nums):\n    max_len = 0\n    current_positive = 0\n    current_negative = 0\n    \n    for num in nums:\n        if num == 0:\n            current_positive = 0\n            current_negative = 0\n        elif num > 0:\n            current_positive += 1\n            current_negative = current_negative + 1 if current_negative > 0 else 0\n        else:\n            current_positive, current_negative = current_negative + 1 if current_negative > 0 else 0, current_positive + 1\n    \n    return max_len", "passed": false, "score": {"loc": 14, "tokens": 73, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.4453484115269455}}], "num_pass": 7, "num_uniq": 7, "num_fail": 3, "fail_uniq": 3}
{"id": 4491, "entry_point": "maxScoreWords", "best_list": [{"code": "def maxScoreWords(words, letters, score):\n    from collections import Counter\n    letter_count = Counter(letters)\n    score_dict = {chr(i + ord('a')): score[i] for i in range(26)}\n    \n    def can_use_word(word_count):\n        return all(letter_count[letter] >= word_count[letter] for letter in word_count)\n    \n    def dfs(start, current_score, current_count):\n        if start == len(words):\n            return current_score\n        max_score = dfs(start + 1, current_score, current_count)\n        word_count = Counter(words[start])\n        if can_use_word(word_count):\n            new_count = current_count + word_count\n            if all(new_count[letter] <= letter_count[letter] for letter in new_count):\n                max_score = max(max_score, dfs(start + 1, current_score + sum(score_dict[letter] * word_count[letter] for letter in word_count), new_count))\n        return max_score\n    \n    return dfs(0, 0, Counter())", "passed": true, "score": {"loc": 17, "tokens": 190, "cc": 3, "nest": 4, "execution_time": 0.016935, "novelty": 0.7191591208637462}}, {"code": "def maxScoreWords(words, letters, score):\n    def score_word(word):\n        return sum(score[ord(c) - ord('a')] for c in word)\n    \n    def can_form(word, letter_count):\n        return all(letter_count[ord(c) - ord('a')] >= word.count(c) for c in word)\n    \n    def dfs(index, current_score, letter_count):\n        if index == len(words):\n            return current_score\n        \n        max_score = dfs(index + 1, current_score, letter_count)\n        if can_form(words[index], letter_count):\n            new_letter_count = letter_count[:]\n            for c in words[index]:\n                new_letter_count[ord(c) - ord('a')] -= 1\n            max_score = max(max_score, dfs(index + 1, current_score + score_word(words[index]), new_letter_count))\n        return max_score\n    \n    from collections import Counter\n    letter_count = Counter(letters)\n    return dfs(0, 0, letter_count)", "passed": true, "score": {"loc": 18, "tokens": 197, "cc": 3, "nest": 4, "execution_time": 0.016869, "novelty": 0.6960190437135256}}, {"code": "from collections import Counter\n\ndef maxScoreWords(words, letters, score):\n    def can_form(word, letter_count):\n        return all(letter_count[char] >= word[char] for char in word)\n\n    def get_word_score(word):\n        return sum(score[ord(char) - ord('a')] for char in word)\n\n    letter_count = Counter(letters)\n    max_score = 0\n\n    def backtrack(start, current_score, used_letters):\n        nonlocal max_score\n        if start == len(words):\n            max_score = max(max_score, current_score)\n            return\n\n        # Include the current word\n        word = Counter(words[start])\n        if can_form(word, used_letters):\n            new_score = current_score + get_word_score(words[start])\n            new_used_letters = used_letters + word\n            backtrack(start + 1, new_score, new_used_letters)\n\n        # Exclude the current word\n        backtrack(start + 1, current_score, used_letters)\n\n    backtrack(0, 0, Counter())\n    return max_score", "passed": true, "score": {"loc": 23, "tokens": 182, "cc": 2, "nest": 3, "execution_time": 0.016943, "novelty": 0.7141315771633716}}, {"code": "def maxScoreWords(words, letters, score, index=0, used_count=None):\n    if used_count is None:\n        used_count = [0] * 26\n    \n    if index == len(words):\n        return 0\n    \n    word = words[index]\n    word_score = sum(score[ord(char) - ord('a')] for char in word)\n    can_use = True\n    \n    for char in word:\n        if used_count[ord(char) - ord('a')] + word.count(char) > letters.count(char):\n            can_use = False\n            break\n    \n    include = 0\n    exclude = 0\n    \n    if can_use:\n        for char in word:\n            used_count[ord(char) - ord('a')] += word.count(char)\n        include = word_score + maxScoreWords(words, letters, score, index + 1, used_count)\n        for char in word:\n            used_count[ord(char) - ord('a')] -= word.count(char)\n    \n    exclude = maxScoreWords(words, letters, score, index + 1, used_count)\n    \n    return max(include, exclude)", "passed": false, "score": {"loc": 22, "tokens": 216, "cc": 7, "nest": 3, "execution_time": 10.0, "novelty": 0.8536090299601524}}, {"code": "from collections import Counter\n\ndef maxScoreWords(words, letters, score):\n    letter_count = Counter(letters)\n    word_scores = [sum(score[ord(c) - ord('a')] for c in word) for word in words]\n    \n    def backtrack(index, current_score, current_count):\n        if index == len(words):\n            return current_score\n        max_score = current_score\n        if all(current_count[char] + word_count[char] <= letter_count[char] for char, word_count in Counter(words[index]).items()):\n            current_count += Counter(words[index])\n            max_score = max(max_score, backtrack(index + 1, current_score + word_scores[index], current_count))\n            current_count -= Counter(words[index])\n        max_score = max(max_score, backtrack(index + 1, current_score, current_count))\n        return max_score\n    \n    return backtrack(0, 0, Counter())", "passed": false, "score": {"loc": 15, "tokens": 181, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6743839816052495}}, {"code": "def maxScoreWords(words, letters, score):\n    letter_count = [letters.count(chr(97 + i)) for i in range(26)]\n    word_scores = [sum(score[ord(w) - ord('a')] for w in word) for word in words]\n\n    def dfs(index, current_score, current_letter_count):\n        if index == len(words):\n            return current_score\n        max_score = current_score\n        for i in range(1, len(words[index]) + 1):\n            if all(current_letter_count[ord(words[index][j]) - ord('a')] + 1 <= letter_count[ord(words[index][j]) - ord('a')] for j in range(i)):\n                for j in range(i):\n                    current_letter_count[ord(words[index][j]) - ord('a')] += 1\n                max_score = max(max_score, dfs(index + 1, current_score + word_scores[index], current_letter_count))\n                for j in range(i):\n                    current_letter_count[ord(words[index][j]) - ord('a')] -= 1\n        max_score = max(max_score, dfs(index + 1, current_score, current_letter_count))\n        return max_score\n\n    return dfs(0, 0, [0] * 26)", "passed": false, "score": {"loc": 17, "tokens": 275, "cc": 5, "nest": 5, "execution_time": 10.0, "novelty": 0.782694092026288}}, {"code": "def maxScoreWords(words, letters, score):\n    from collections import Counter\n    \n    letter_count = Counter(letters)\n    word_scores = [sum(score[ord(w) - ord('a')] for w in word) for word in words]\n    \n    def dfs(index, current_score, remaining_letters):\n        if index == len(words):\n            return current_score\n        max_score = dfs(index + 1, current_score, remaining_letters)\n        word = words[index]\n        word_count = Counter(word)\n        if all(remaining_letters[char] >= word_count[char] for char in word_count):\n            new_letters = remaining_letters - word_count\n            max_score = max(max_score, dfs(index + 1, current_score + word_scores[index], new_letters))\n        return max_score\n    \n    return dfs(0, 0, letter_count)", "passed": false, "score": {"loc": 15, "tokens": 151, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.6312696366690791}}, {"code": "def maxScoreWords(words, letters, score):\n    n = len(words)\n    letter_count = [0] * 26\n    for letter in letters:\n        letter_count[ord(letter) - ord('a')] += 1\n    \n    def can_form(word, letter_count):\n        for letter in word:\n            if letter_count[ord(letter) - ord('a')] == 0:\n                return False\n            letter_count[ord(letter) - ord('a')] -= 1\n        return True\n    \n    def restore_letter_count(word, letter_count):\n        for letter in word:\n            letter_count[ord(letter) - ord('a')] += 1\n    \n    def backtrack(index, current_score, letter_count):\n        if index == n:\n            return current_score\n        \n        max_score = backtrack(index + 1, current_score, letter_count)\n        if can_form(words[index], letter_count):\n            current_score += sum(score[ord(letter) - ord('a')] for letter in words[index])\n            letter_count = restore_letter_count(words[index], letter_count)\n            max_score = max(max_score, backtrack(index + 1, current_score, letter_count))\n        \n        return max_score\n    \n    return backtrack(0, 0, letter_count)", "passed": false, "score": {"loc": 24, "tokens": 235, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.6882779601370217}}], "num_pass": 4, "num_uniq": 4, "num_fail": 6, "fail_uniq": 6}
{"id": 4551, "entry_point": "kLengthApart", "best_list": [{"code": "def kLengthApart(nums, k):\n    prev = -k - 1\n    for i, num in enumerate(nums):\n        if num == 1:\n            if i - prev - 1 < k:\n                return False\n            prev = i\n    return True", "passed": true, "score": {"loc": 8, "tokens": 46, "cc": 3, "nest": 4, "execution_time": 0.01653, "novelty": 0.129341577459678}}, {"code": "def kLengthApart(nums, k):\n    prev_one = -k - 1\n    for i, num in enumerate(nums):\n        if num == 1:\n            if i - prev_one - 1 < k:\n                return False\n            prev_one = i\n    return True", "passed": true, "score": {"loc": 8, "tokens": 46, "cc": 3, "nest": 4, "execution_time": 0.016689, "novelty": 0.264600156321968}}, {"code": "def kLengthApart(nums, k):\n    prev = None\n    for i, num in enumerate(nums):\n        if num == 1:\n            if prev is not None and i - prev - 1 < k:\n                return False\n            prev = i\n    return True", "passed": true, "score": {"loc": 8, "tokens": 48, "cc": 4, "nest": 4, "execution_time": 0.016617, "novelty": 0.26810256137143784}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 4556, "entry_point": "uniquePathsWithObstacles", "best_list": [{"code": "def uniquePathsWithObstacles(obstacleGrid):\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    dp = [0] * n\n    dp[0] = 1 if obstacleGrid[0][0] == 0 else 0\n    \n    for i in range(m):\n        for j in range(n):\n            if obstacleGrid[i][j] == 1:\n                dp[j] = 0\n            elif j > 0:\n                dp[j] += dp[j - 1]\n    \n    return dp[n - 1]", "passed": true, "score": {"loc": 11, "tokens": 106, "cc": 4, "nest": 5, "execution_time": 0.016758, "novelty": 0.6005490487765708}}, {"code": "def uniquePathsWithObstacles(obstacleGrid):\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if obstacleGrid[i][j] == 1:\n                dp[i][j] = 0\n            elif i == 0 and j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[m-1][n-1]", "passed": true, "score": {"loc": 12, "tokens": 136, "cc": 5, "nest": 5, "execution_time": 0.016749, "novelty": 0.246187997471923}}, {"code": "def uniquePathsWithObstacles(obstacleGrid):\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if obstacleGrid[i][j] == 1:\n                dp[i][j] = 0\n            elif i == 0 and j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (dp[i-1][j] if i > 0 else 0) + (dp[i][j-1] if j > 0 else 0)\n    \n    return dp[m-1][n-1]", "passed": true, "score": {"loc": 12, "tokens": 152, "cc": 5, "nest": 5, "execution_time": 0.016652, "novelty": 0.3709804704268177}}], "num_pass": 10, "num_uniq": 6, "num_fail": 0, "fail_uniq": 0}
{"id": 4616, "entry_point": "countAndSay", "best_list": [{"code": "def countAndSay(n):\n    result = \"1\"\n    for _ in range(1, n):\n        result = ''.join(str(len(list(group))) + digit for digit, group in groupby(result))\n    return result", "passed": true, "score": {"loc": 5, "tokens": 52, "cc": 1, "nest": 2, "execution_time": 0.016623, "novelty": 0.58606271028539}}, {"code": "def countAndSay(n):\n    result = \"1\"\n    for _ in range(n - 1):\n        result = ''.join(str(len(list(group))) + digit for digit, group in itertools.groupby(result))\n    return result", "passed": true, "score": {"loc": 5, "tokens": 54, "cc": 1, "nest": 2, "execution_time": 0.016795, "novelty": 0.6490785307775662}}, {"code": "def countAndSay(n):\n    result = \"1\"\n    for _ in range(1, n):\n        result = \"\".join([str(len(list(g))) + k for k, g in itertools.groupby(result)])\n    return result", "passed": true, "score": {"loc": 5, "tokens": 56, "cc": 1, "nest": 2, "execution_time": 0.016782, "novelty": 0.5656682139729632}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 4763, "entry_point": "findMaximumXOR", "best_list": [{"code": "def findMaximumXOR(nums):\n    mask = 0\n    max_xor = 0\n    for i in range(31, -1, -1):\n        mask |= 1 << i\n        prefixes = {num & mask for num in nums}\n        potential_max = max_xor | (1 << i)\n        for prefix in prefixes:\n            if potential_max ^ prefix in prefixes:\n                max_xor = potential_max\n                break\n    return max_xor", "passed": true, "score": {"loc": 12, "tokens": 72, "cc": 3, "nest": 4, "execution_time": 0.016444, "novelty": 0.21142872335489826}}, {"code": "def findMaximumXOR(nums):\n    mask = 0\n    result = 0\n    for i in range(31, -1, -1):\n        mask |= 1 << i\n        prefixes = {num & mask for num in nums}\n        potential = result | (1 << i)\n        for prefix in prefixes:\n            if potential ^ prefix in prefixes:\n                result = potential\n                break\n    return result", "passed": true, "score": {"loc": 12, "tokens": 72, "cc": 3, "nest": 4, "execution_time": 0.016597, "novelty": 0.06961672117488282}}, {"code": "def findMaximumXOR(nums):\n    max_xor = 0\n    mask = 0\n    for i in range(31, -1, -1):\n        mask |= 1 << i\n        prefixes = {num & mask for num in nums}\n        target = max_xor | (1 << i)\n        for prefix in prefixes:\n            if target ^ prefix in prefixes:\n                max_xor = target\n                break\n    return max_xor", "passed": true, "score": {"loc": 12, "tokens": 72, "cc": 3, "nest": 4, "execution_time": 0.016682, "novelty": 0.026062579752397008}}], "num_pass": 10, "num_uniq": 5, "num_fail": 0, "fail_uniq": 0}
{"id": 4795, "entry_point": "maxProbability", "best_list": [{"code": "import heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = [[] for _ in range(n)]\n    for (a, b), p in zip(edges, succProb):\n        graph[a].append((b, p))\n        graph[b].append((a, p))\n    \n    max_prob = [0.0] * n\n    max_prob[start] = 1.0\n    heap = [(-1.0, start)]\n    \n    while heap:\n        current_prob, current_node = heapq.heappop(heap)\n        current_prob = -current_prob\n        \n        if current_node == end:\n            return current_prob\n        \n        for neighbor, prob in graph[current_node]:\n            if current_prob * prob > max_prob[neighbor]:\n                max_prob[neighbor] = current_prob * prob\n                heapq.heappush(heap, (-current_prob * prob, neighbor))\n    \n    return 0.0", "passed": true, "score": {"loc": 19, "tokens": 172, "cc": 5, "nest": 4, "execution_time": 0.016893, "novelty": 0.4198731966084458}}, {"code": "from heapq import heappop, heappush\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = [[] for _ in range(n)]\n    for (a, b), p in zip(edges, succProb):\n        graph[a].append((b, p))\n        graph[b].append((a, p))\n    \n    pq = [(-1, start)]\n    visited = set()\n    \n    while pq:\n        prob, node = heappop(pq)\n        prob = -prob\n        if node == end:\n            return prob\n        if node in visited:\n            continue\n        visited.add(node)\n        for neighbor, edge_prob in graph[node]:\n            if neighbor not in visited:\n                heappush(pq, (-(prob * edge_prob), neighbor))\n    \n    return 0", "passed": true, "score": {"loc": 20, "tokens": 158, "cc": 6, "nest": 4, "execution_time": 0.016737, "novelty": 0.5231438923760838}}, {"code": "def maxProbability(n, edges, succProb, start, end):\n    import heapq\n\n    graph = {i: {} for i in range(n)}\n    for (a, b), p in zip(edges, succProb):\n        graph[a][b] = p\n        graph[b][a] = p\n\n    max_prob = [0] * n\n    max_prob[start] = 1\n    pq = [(-1, start)]\n\n    while pq:\n        prob, node = heapq.heappop(pq)\n        prob = -prob\n        if node == end:\n            return prob\n        for neighbor, edge_prob in graph[node].items():\n            new_prob = prob * edge_prob\n            if new_prob > max_prob[neighbor]:\n                max_prob[neighbor] = new_prob\n                heapq.heappush(pq, (-new_prob, neighbor))\n\n    return 0", "passed": true, "score": {"loc": 20, "tokens": 161, "cc": 5, "nest": 4, "execution_time": 0.016838, "novelty": 0.519787097851175}}, {"code": "from collections import defaultdict\nimport heapq\n\ndef maxProbability(n, edges, succProb, start, end):\n    graph = defaultdict(list)\n    for i, (a, b) in enumerate(edges):\n        graph[a].append((b, succProb[i]))\n        graph[b].append((a, succProb[i]))\n    \n    pq = [(-1, start)]\n    visited = set()\n    \n    while pq:\n        prob, node = heapq.heappop(pq)\n        prob = -prob\n        \n        if node == end:\n            return prob\n        \n        if node in visited:\n            continue\n        \n        visited.add(node)\n        \n        for neighbor, edge_prob in graph[node]:\n            if neighbor not in visited:\n                heapq.heappush(pq, (-prob * edge_prob, neighbor))\n    \n    return 0", "passed": false, "score": {"loc": 21, "tokens": 157, "cc": 6, "nest": 4, "execution_time": 10.0, "novelty": 0.5865427587513901}}], "num_pass": 9, "num_uniq": 9, "num_fail": 1, "fail_uniq": 1}
{"id": 4847, "entry_point": "removeDuplicates", "best_list": [{"code": "def removeDuplicates(s):\n    stack = []\n    for char in s:\n        if stack and stack[-1] == char:\n            stack.pop()\n        else:\n            stack.append(char)\n    return ''.join(stack)", "passed": true, "score": {"loc": 8, "tokens": 48, "cc": 3, "nest": 3, "execution_time": 0.016593, "novelty": 0.020846686393981684}}, {"code": "def removeDuplicates(S):\n    stack = []\n    for char in S:\n        if stack and stack[-1] == char:\n            stack.pop()\n        else:\n            stack.append(char)\n    return ''.join(stack)", "passed": true, "score": {"loc": 8, "tokens": 48, "cc": 3, "nest": 3, "execution_time": 0.016867, "novelty": 0.01947663370582886}}, {"code": "def removeDuplicates(S: str) -> str:\n    stack = []\n    for char in S:\n        if stack and stack[-1] == char:\n            stack.pop()\n        else:\n            stack.append(char)\n    return ''.join(stack)", "passed": true, "score": {"loc": 8, "tokens": 53, "cc": 3, "nest": 3, "execution_time": 0.016629, "novelty": 0.0475927504345095}}], "num_pass": 10, "num_uniq": 4, "num_fail": 0, "fail_uniq": 0}
{"id": 4919, "entry_point": "minOperationsMaxProfit", "best_list": [{"code": "def minOperationsMaxProfit(customers, boardingCost, runningCost):\n    profit = 0\n    max_profit = 0\n    max_profit_rotation = -1\n    waiting_customers = 0\n    current_rotation = 0\n\n    while waiting_customers > 0 or any(customers):\n        if customers:\n            waiting_customers += customers.pop(0)\n        boarded = min(4, waiting_customers)\n        waiting_customers -= boarded\n        profit += boarded * boardingCost - runningCost\n        current_rotation += 1\n\n        if profit > max_profit:\n            max_profit = profit\n            max_profit_rotation = current_rotation\n\n    return max_profit_rotation", "passed": true, "score": {"loc": 17, "tokens": 85, "cc": 4, "nest": 3, "execution_time": 0.016574, "novelty": 0.7388178691433276}}, {"code": "def minOperationsMaxProfit(customers, boardingCost, runningCost):\n    max_profit = current_profit = 0\n    max_profit_operations = current_operations = 0\n    waiting_customers = 0\n\n    for i, customers_arriving in enumerate(customers):\n        waiting_customers += customers_arriving\n        boarded_customers = min(4, waiting_customers)\n        waiting_customers -= boarded_customers\n        current_profit += boarded_customers * boardingCost - runningCost\n        current_operations += 1\n\n        if current_profit > max_profit:\n            max_profit = current_profit\n            max_profit_operations = current_operations\n\n    while waiting_customers > 0:\n        boarded_customers = min(4, waiting_customers)\n        waiting_customers -= boarded_customers\n        current_profit += boarded_customers * boardingCost - runningCost\n        current_operations += 1\n\n        if current_profit > max_profit:\n            max_profit = current_profit\n            max_profit_operations = current_operations\n\n    return max_profit_operations if max_profit > 0 else -1", "passed": true, "score": {"loc": 22, "tokens": 121, "cc": 4, "nest": 3, "execution_time": 0.016583, "novelty": 0.5384329253189987}}, {"code": "def minOperationsMaxProfit(customers, boardingCost, runningCost):\n    max_profit = current_profit = 0\n    rotations = 0\n    max_profit_rotations = -1\n    waiting = 0\n\n    for i, new_customers in enumerate(customers):\n        waiting += new_customers\n        boarding = min(4, waiting)\n        waiting -= boarding\n        current_profit += boarding * boardingCost - runningCost\n        rotations += 1\n\n        if current_profit > max_profit:\n            max_profit = current_profit\n            max_profit_rotations = rotations\n\n    while waiting > 0:\n        boarding = min(4, waiting)\n        waiting -= boarding\n        current_profit += boarding * boardingCost - runningCost\n        rotations += 1\n\n        if current_profit > max_profit:\n            max_profit = current_profit\n            max_profit_rotations = rotations\n\n    return max_profit_rotations", "passed": true, "score": {"loc": 23, "tokens": 116, "cc": 4, "nest": 3, "execution_time": 0.016725, "novelty": 0.5008866171407642}}], "num_pass": 10, "num_uniq": 10, "num_fail": 0, "fail_uniq": 0}
{"id": 4961, "entry_point": "minDeletionSize", "best_list": [{"code": "def minDeletionSize(A):\n    n, m = len(A), len(A[0])\n    dp = [1] * m\n    for j in range(m):\n        for i in range(j):\n            if all(A[k][i] <= A[k][j] for k in range(n)):\n                dp[j] = max(dp[j], dp[i] + 1)\n    return m - max(dp)", "passed": true, "score": {"loc": 8, "tokens": 99, "cc": 3, "nest": 4, "execution_time": 0.016529, "novelty": 0.32787990592646865}}, {"code": "def minDeletionSize(A):\n    m, n = len(A), len(A[0])\n    dp = [1] * n\n    for j in range(1, n):\n        for i in range(j):\n            if all(A[k][i] <= A[k][j] for k in range(m)):\n                dp[j] = max(dp[j], dp[i] + 1)\n    return n - max(dp)", "passed": true, "score": {"loc": 8, "tokens": 101, "cc": 3, "nest": 4, "execution_time": 0.016561, "novelty": 0.35754017828748064}}, {"code": "def minDeletionSize(A):\n    n = len(A)\n    m = len(A[0])\n    dp = [1] * m\n    for j in range(1, m):\n        for i in range(j):\n            if all(A[k][i] <= A[k][j] for k in range(n)):\n                dp[j] = max(dp[j], dp[i] + 1)\n    return m - max(dp)\n\ndef _equivalent(lhs, rhs):\n    return lhs == rhs", "passed": true, "score": {"loc": 11, "tokens": 113, "cc": 3, "nest": 4, "execution_time": 0.016652, "novelty": 0.386319049289674}}, {"code": "def minDeletionSize(A):\n    n = len(A)\n    m = len(A[0])\n    dp = list(range(m))\n    for i in range(1, n):\n        new_dp = list(dp)\n        j = m - 2\n        while j >= 0:\n            if all(A[i][j] <= A[k][j] for k in range(n)):\n                new_dp[j] = min(new_dp[j], dp[k])\n            j -= 1\n        dp = new_dp\n    return m - max(dp)", "passed": false, "score": {"loc": 13, "tokens": 116, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5852383403382595}}, {"code": "def minDeletionSize(A):\n    n, m = len(A), len(A[0])\n    dp = list(range(m))\n    for j in range(1, m):\n        ndp = list(range(m))\n        for i in range(n):\n            if all(A[i][dp[k]] <= A[i][j] for k in range(j)):\n                ndp[j] = min(ndp[j], dp[k])\n        dp = ndp\n    return m - min(dp)", "passed": false, "score": {"loc": 10, "tokens": 116, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.6353791850067104}}, {"code": "def minDeletionSize(A):\n    n = len(A)\n    m = len(A[0])\n    \n    @lru_cache(None)\n    def dp(i, prev):\n        if i == m:\n            return 0\n        delete = dp(i + 1, prev) + 1\n        keep = float('inf')\n        if all(A[j][i] >= A[j][prev] for j in range(n)):\n            keep = dp(i + 1, i)\n        return min(delete, keep)\n    \n    return dp(0, 0)", "passed": false, "score": {"loc": 13, "tokens": 114, "cc": 2, "nest": 3, "execution_time": 10.0, "novelty": 0.7483450975034427}}, {"code": "def minDeletionSize(A):\n    n, m = len(A), len(A[0])\n    dp = [0] * m\n    for j in range(1, m):\n        dp[j] = dp[j - 1] + 1\n        for i in range(n):\n            if all(A[i][k] <= A[i][j] for k in range(j)):\n                dp[j] = max(dp[j], dp[i] + 1)\n    return m - max(dp)", "passed": false, "score": {"loc": 9, "tokens": 114, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.36846065130499417}}, {"code": "def minDeletionSize(A):\n    n = len(A)\n    m = len(A[0])\n    dp = [i for i in range(m)]\n    for i in range(1, m):\n        prev_dp = dp[:]\n        for j in range(i):\n            if all(A[k][j] <= A[k][i] for k in range(n)):\n                dp[i] = min(dp[i], prev_dp[j])\n        dp[i] += 1\n    return dp[-1]", "passed": false, "score": {"loc": 11, "tokens": 115, "cc": 3, "nest": 4, "execution_time": 10.0, "novelty": 0.5825088659762494}}], "num_pass": 3, "num_uniq": 3, "num_fail": 7, "fail_uniq": 7}
